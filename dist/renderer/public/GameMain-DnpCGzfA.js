import { c as createLucideIcon, j as jsxRuntimeExports, r as reactExports, D as DEFAULT_TRACK_TYPE_ID, u as useMainStore, T as TooltipProvider, a as useTranslation, b as DropdownMenu, d as Tooltip$2, e as TooltipTrigger, f as DropdownMenuTrigger, g as cn, h as TooltipContent, i as DropdownMenuContent, k as DropdownMenuItem, l as useTimeConfig, m as useSettings, n as formatClockTime, o as DEBUG_MODE, p as TimeOfDayIndicator, q as commonjsGlobal, s as getDefaultExportFromCjs, t as clsx, R as React, v as useDirection, w as useControllableState, x as createContextScope, y as useId$1, P as Primitive, z as createRovingFocusGroupScope, A as Root$2, I as Item, B as composeEventHandlers, C as Presence, E as useMoney, F as useFinancialHistory, G as useTransitCost, H as Dialog, J as DialogContent, K as DialogHeader, L as DialogTitle, M as Card, N as CardHeader, O as CardTitle, Q as CardContent, S as Button, U as CardDescription, V as formatCurrency, W as telemetry, X as useComposedRefs, Y as useCallbackRef, Z as useLayoutEffect2, _ as clamp$2, $ as newspaperService, a0 as SubwayButton, a1 as tweetService, a2 as Twitter, a3 as useGamePerformanceMetrics, a4 as DEBUG_TIMES, a5 as toast, a6 as cities, a7 as useNavigate, a8 as BackButton, a9 as formatRelativeTime, aa as getSavedGames, ab as toastWithMusic, ac as importSaveFromFile, ad as indexedDBHelper, ae as exportSaveToFile, af as deleteSave, ag as saveGame, ah as loadGame, ai as Input$1, aj as FileUp, ak as Settings, al as BigLogo, am as MS_PER_UPDATE, an as X$1, ao as TooltipPortal, ap as getTrainType, aq as Select, ar as SelectTrigger, as as SelectValue, at as SelectContent, au as TRAIN_TYPES, av as SelectItem, aw as TriangleAlert, ax as getElevationInfo, ay as getAllElevationTypes, az as RULES, aA as formatElevationRange, aB as ChevronRight, aC as useConstructionCosts, aD as getElevationDisplayName, aE as LoaderCircle, aF as DialogDescription, aG as DialogFooter, aH as ChevronUp, aI as ChevronDown, aJ as useStations, aK as useRoutes, aL as getWalkingTimeAndDistanceBetweenPoints, aM as PATHFINDING_RULES, aN as Briefcase, aO as MODE_COLORS, aP as formatTimeHHMM, aQ as Label$1, aR as Root$3, aS as Portal$1, aT as Overlay, aU as Content$1, aV as composeRefs, aW as createPopperScope, aX as Root2$2, aY as Anchor, aZ as Portal$2, a_ as hideOthers, a$ as ReactRemoveScroll, b0 as createSlot, b1 as useFocusGuards, b2 as FocusScope, b3 as DismissableLayer, b4 as Content$2, b5 as Arrow, b6 as Check, b7 as formatMinutes$1, b8 as Color$1, b9 as ROUTE_COLORS, ba as generateRoute, bb as MAX_ROUTE_NAME_LENGTH, bc as useDemandData, bd as formatDistance$1, be as formatTime$1, bf as getDrivingTimeMultiplier, bg as getTimeOfDay, bh as usePreviewRoute, bi as convertToRaptorFormat, bj as useStationGroups, bk as useAllStationTrainPopMovements, bl as getHoursByDemandLevel, bm as DEFAULT_TRAIN_TYPE_ID, bn as getMaxCarsNeededByTypeWithUpdate, bo as useTrains, bp as getIdealTrainCountByTime, bq as isScheduleComplete, br as getMaxTrainsNeededWithCarsUpdate, bs as getTrainCost, bt as getHourDemandLevel, bu as getTrainOperatingSchedule, bv as useSignals, bw as SIGNAL_TYPES, bx as getFilePath, by as findRouteSplitIndices, bz as useTracks, bA as usePrevious, bB as useSize, bC as LAYER_CONFIG, bD as useWarnings, bE as ModeToggle, bF as React$1, bG as useFloating$1, bH as isElement, bI as getComputedStyle$1, bJ as useTrackGroups, bK as offset, bL as flip, bM as shift, bN as arrow, bO as now, bP as CardFooter, bQ as autoUpdate, bR as start, bS as PolySynth, bT as Synth, bU as Frequency, bV as useCityCode, bW as generateNodeFeatures, bX as COORD_PRECISION, bY as Marker, bZ as usePreviewTracks, b_ as useBuildingDetector, b$ as validateBuildingCollision, c0 as calculateBuildingDemolitionCost, c1 as useLayersToShow, c2 as useDebugOffsetLines, c3 as DEMAND_COLORS, c4 as useHoveredPoint, c5 as useInterlinedFeatureCollection, c6 as COLORS, c7 as useTheme, c8 as usePlatformMapItems, c9 as usePopMovementGeojson, ca as useRoadsGeojson, cb as useRouteFeatureCollection, cc as MIN_TRACK_BASE_PIXEL_WIDTH, cd as useSignalsGeojson, ce as useTrackElevationsGeojson, cf as usePreviewTrackElevationsGeojson, cg as usePreviewTracksGeojsonFeatures, ch as useTracksGeojsonFeatures, ci as THREE_D_MODE, cj as useTrackSpeedsGeojson, ck as usePreviewTrackSpeedsGeojson, cl as useTrackTypesGeojson, cm as usePreviewTrackTypesGeojson, cn as useTrainWindowsGeojson, co as Source, cp as Layer$2, cq as useMap, cr as BUILDING_FOUNDATION_DEPTHS, cs as MODE_COLORS$1, ct as TRACK_ELEVATIONS, cu as _0x24b10a, cv as useStNodes, cw as getBearing, cx as useTrackSpeedPointsGeojson, cy as reverseBearing, cz as distance$1, cA as _0x134c1a, cB as getLineLength, cC as nearestPointOnLine, cD as roundCoordinates, cE as centroid, cF as lineString, cG as v4, cH as getLineMidpoint, cI as getTrackElevationAtPoint, cJ as getDistanceBetweenPoints, cK as _0x44416e, cL as bbox, cM as lineIntersect, cN as getTrackBaseWidthFromLanes, cO as booleanOverlap, cP as point$3, cQ as bearing, cR as lineSlice, cS as PIXEL_SNAP_THRESHOLD, cT as roundCoordinate, cU as useCrowdVolume, cV as generativeMusic, cW as WARNING_CONSTS, cX as debugHelpers, cY as useNodeFeatures, cZ as useIntersectionsGeojson, c_ as useStartPoint, c$ as useTrainTest, d0 as useTrainWindowCoordsTest, d1 as useTrackGraphGeojson, d2 as useTrackSpatialIndex, d3 as LoadingScreen, d4 as Map$3, d5 as ArrowsGeojsonLayer, d6 as useSearchParams, d7 as SettingsProvider, d8 as Toaster } from "./index-Cen67UD7.js";
import { a as maplibregl } from "./maplibre-gl-DBtjkim_.js";
function _mergeNamespaces(n, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e = m2[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k2 in e) {
        if (k2 !== "default" && !(k2 in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k2);
          if (d) {
            Object.defineProperty(n, k2, d.get ? d : {
              enumerable: true,
              get: () => e[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ArrowDown = createLucideIcon("ArrowDown", [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ArrowRight = createLucideIcon("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ArrowUpDown = createLucideIcon("ArrowUpDown", [
  ["path", { d: "m21 16-4 4-4-4", key: "f6ql7i" }],
  ["path", { d: "M17 20V4", key: "1ejh1v" }],
  ["path", { d: "m3 8 4-4 4 4", key: "11wl7u" }],
  ["path", { d: "M7 4v16", key: "1glfcx" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Banknote = createLucideIcon("Banknote", [
  ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2", key: "9lu3g6" }],
  ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }],
  ["path", { d: "M6 12h.01M18 12h.01", key: "113zkx" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bug = createLucideIcon("Bug", [
  ["path", { d: "m8 2 1.88 1.88", key: "fmnt4t" }],
  ["path", { d: "M14.12 3.88 16 2", key: "qol33r" }],
  ["path", { d: "M9 7.13v-1a3.003 3.003 0 1 1 6 0v1", key: "d7y7pr" }],
  [
    "path",
    {
      d: "M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6",
      key: "xs1cw7"
    }
  ],
  ["path", { d: "M12 20v-9", key: "1qisl0" }],
  ["path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5", key: "32zzws" }],
  ["path", { d: "M6 13H2", key: "82j7cp" }],
  ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4", key: "4p0ekp" }],
  ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4", key: "18gb23" }],
  ["path", { d: "M22 13h-4", key: "1jl80f" }],
  ["path", { d: "M17.2 17c2.1.1 3.8 1.9 3.8 4", key: "k3fwyw" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Building2 = createLucideIcon("Building2", [
  ["path", { d: "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z", key: "1b4qmf" }],
  ["path", { d: "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2", key: "i71pzd" }],
  ["path", { d: "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2", key: "10jefs" }],
  ["path", { d: "M10 6h4", key: "1itunk" }],
  ["path", { d: "M10 10h4", key: "tcdvrf" }],
  ["path", { d: "M10 14h4", key: "kelpxr" }],
  ["path", { d: "M10 18h4", key: "1ulq68" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CalendarClock = createLucideIcon("CalendarClock", [
  ["path", { d: "M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5", key: "1osxxc" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M3 10h5", key: "r794hk" }],
  ["path", { d: "M17.5 17.5 16 16.3V14", key: "akvzfd" }],
  ["circle", { cx: "16", cy: "16", r: "6", key: "qoo3c4" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Car = createLucideIcon("Car", [
  [
    "path",
    {
      d: "M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2",
      key: "5owen"
    }
  ],
  ["circle", { cx: "7", cy: "17", r: "2", key: "u2ysq9" }],
  ["path", { d: "M9 17h6", key: "r8uit2" }],
  ["circle", { cx: "17", cy: "17", r: "2", key: "axvx0g" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChartBar = createLucideIcon("ChartBar", [
  ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }],
  ["path", { d: "M7 16h8", key: "srdodz" }],
  ["path", { d: "M7 11h12", key: "127s9w" }],
  ["path", { d: "M7 6h3", key: "w9rmul" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChartNoAxesColumnIncreasing = createLucideIcon("ChartNoAxesColumnIncreasing", [
  ["line", { x1: "12", x2: "12", y1: "20", y2: "10", key: "1vz5eb" }],
  ["line", { x1: "18", x2: "18", y1: "20", y2: "4", key: "cun8e5" }],
  ["line", { x1: "6", x2: "6", y1: "20", y2: "16", key: "hq0ia6" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronLeft = createLucideIcon("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronsUpDown = createLucideIcon("ChevronsUpDown", [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CircleChevronDown = createLucideIcon("CircleChevronDown", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m16 10-4 4-4-4", key: "894hmk" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Clock$1 = createLucideIcon("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Compass = createLucideIcon("Compass", [
  [
    "path",
    {
      d: "m16.24 7.76-1.804 5.411a2 2 0 0 1-1.265 1.265L7.76 16.24l1.804-5.411a2 2 0 0 1 1.265-1.265z",
      key: "9ktpf1"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CornerUpRight = createLucideIcon("CornerUpRight", [
  ["polyline", { points: "15 14 20 9 15 4", key: "1tbx3s" }],
  ["path", { d: "M4 20v-7a4 4 0 0 1 4-4h12", key: "1lu4f8" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Crosshair = createLucideIcon("Crosshair", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "22", x2: "18", y1: "12", y2: "12", key: "l9bcsi" }],
  ["line", { x1: "6", x2: "2", y1: "12", y2: "12", key: "13hhkx" }],
  ["line", { x1: "12", x2: "12", y1: "6", y2: "2", key: "10w3f3" }],
  ["line", { x1: "12", x2: "12", y1: "22", y2: "18", key: "15g9kq" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const DollarSign = createLucideIcon("DollarSign", [
  ["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }],
  ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Download = createLucideIcon("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FileDown = createLucideIcon("FileDown", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M12 18v-6", key: "17g6i2" }],
  ["path", { d: "m9 15 3 3 3-3", key: "1npd3o" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GitPullRequest = createLucideIcon("GitPullRequest", [
  ["circle", { cx: "18", cy: "18", r: "3", key: "1xkwt0" }],
  ["circle", { cx: "6", cy: "6", r: "3", key: "1lh9wr" }],
  ["path", { d: "M13 6h3a2 2 0 0 1 2 2v7", key: "1yeb86" }],
  ["line", { x1: "6", x2: "6", y1: "9", y2: "21", key: "rroup" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GraduationCap = createLucideIcon("GraduationCap", [
  [
    "path",
    {
      d: "M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0z",
      key: "j76jl0"
    }
  ],
  ["path", { d: "M22 10v6", key: "1lu8f3" }],
  ["path", { d: "M6 12.5V16a6 3 0 0 0 12 0v-3.5", key: "1r8lef" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Hammer = createLucideIcon("Hammer", [
  ["path", { d: "m15 12-8.373 8.373a1 1 0 1 1-3-3L12 9", key: "eefl8a" }],
  ["path", { d: "m18 15 4-4", key: "16gjal" }],
  [
    "path",
    {
      d: "m21.5 11.5-1.914-1.914A2 2 0 0 1 19 8.172V7l-2.26-2.26a6 6 0 0 0-4.202-1.756L9 2.96l.92.82A6.18 6.18 0 0 1 12 8.4V10l2 2h1.172a2 2 0 0 1 1.414.586L18.5 14.5",
      key: "b7pghm"
    }
  ]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const House = createLucideIcon("House", [
  ["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }],
  [
    "path",
    {
      d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
      key: "1d0kgt"
    }
  ]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MapPin = createLucideIcon("MapPin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Map$2 = createLucideIcon("Map", [
  [
    "path",
    {
      d: "M14.106 5.553a2 2 0 0 0 1.788 0l3.659-1.83A1 1 0 0 1 21 4.619v12.764a1 1 0 0 1-.553.894l-4.553 2.277a2 2 0 0 1-1.788 0l-4.212-2.106a2 2 0 0 0-1.788 0l-3.659 1.83A1 1 0 0 1 3 19.381V6.618a1 1 0 0 1 .553-.894l4.553-2.277a2 2 0 0 1 1.788 0z",
      key: "169xi5"
    }
  ],
  ["path", { d: "M15 5.764v15", key: "1pn4in" }],
  ["path", { d: "M9 3.236v15", key: "1uimfh" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Menu$1 = createLucideIcon("Menu", [
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
  ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
  ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Minus = createLucideIcon("Minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Navigation = createLucideIcon("Navigation", [
  ["polygon", { points: "3 11 22 2 13 21 11 13 3 11", key: "1ltx0t" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pause = createLucideIcon("Pause", [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pencil = createLucideIcon("Pencil", [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ],
  ["path", { d: "m15 5 4 4", key: "1mk7zo" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pin = createLucideIcon("Pin", [
  ["path", { d: "M12 17v5", key: "bb1du9" }],
  [
    "path",
    {
      d: "M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H8a2 2 0 0 0 0 4 1 1 0 0 1 1 1z",
      key: "1nkz8b"
    }
  ]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Plane = createLucideIcon("Plane", [
  [
    "path",
    {
      d: "M17.8 19.2 16 11l3.5-3.5C21 6 21.5 4 21 3c-1-.5-3 0-4.5 1.5L13 8 4.8 6.2c-.5-.1-.9.1-1.1.5l-.3.5c-.2.5-.1 1 .3 1.3L9 12l-2 3H4l-1 1 3 2 2 3 1-1v-3l3-2 3.5 5.3c.3.4.8.5 1.3.3l.5-.2c.4-.3.6-.7.5-1.2z",
      key: "1v9wt8"
    }
  ]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Play = createLucideIcon("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Redo2 = createLucideIcon("Redo2", [
  ["path", { d: "m15 14 5-5-5-5", key: "12vg1m" }],
  ["path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13", key: "6uklza" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RefreshCcw = createLucideIcon("RefreshCcw", [
  ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
  ["path", { d: "M16 16h5v5", key: "ccwih5" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RotateCw = createLucideIcon("RotateCw", [
  ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8", key: "1p45f6" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Route = createLucideIcon("Route", [
  ["circle", { cx: "6", cy: "19", r: "3", key: "1kj8tv" }],
  ["path", { d: "M9 19h8.5a3.5 3.5 0 0 0 0-7h-11a3.5 3.5 0 0 1 0-7H15", key: "1d8sl" }],
  ["circle", { cx: "18", cy: "5", r: "3", key: "gq8acd" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Scissors = createLucideIcon("Scissors", [
  ["circle", { cx: "6", cy: "6", r: "3", key: "1lh9wr" }],
  ["path", { d: "M8.12 8.12 12 12", key: "1alkpv" }],
  ["path", { d: "M20 4 8.12 15.88", key: "xgtan2" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["path", { d: "M14.8 14.8 20 20", key: "ptml3r" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ShoppingCart = createLucideIcon("ShoppingCart", [
  ["circle", { cx: "8", cy: "21", r: "1", key: "jimo8o" }],
  ["circle", { cx: "19", cy: "21", r: "1", key: "13723u" }],
  [
    "path",
    {
      d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
      key: "9zh506"
    }
  ]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Square = createLucideIcon("Square", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TrainFrontTunnel = createLucideIcon("TrainFrontTunnel", [
  ["path", { d: "M2 22V12a10 10 0 1 1 20 0v10", key: "o0fyp0" }],
  ["path", { d: "M15 6.8v1.4a3 2.8 0 1 1-6 0V6.8", key: "m8q3n9" }],
  ["path", { d: "M10 15h.01", key: "44in9x" }],
  ["path", { d: "M14 15h.01", key: "5mohn5" }],
  ["path", { d: "M10 19a4 4 0 0 1-4-4v-3a6 6 0 1 1 12 0v3a4 4 0 0 1-4 4Z", key: "hckbmu" }],
  ["path", { d: "m9 19-2 3", key: "iij7hm" }],
  ["path", { d: "m15 19 2 3", key: "npx8sa" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TrainTrack = createLucideIcon("TrainTrack", [
  ["path", { d: "M2 17 17 2", key: "18b09t" }],
  ["path", { d: "m2 14 8 8", key: "1gv9hu" }],
  ["path", { d: "m5 11 8 8", key: "189pqp" }],
  ["path", { d: "m8 8 8 8", key: "1imecy" }],
  ["path", { d: "m11 5 8 8", key: "ummqn6" }],
  ["path", { d: "m14 2 8 8", key: "1vk7dn" }],
  ["path", { d: "M7 22 22 7", key: "15mb1i" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TramFront = createLucideIcon("TramFront", [
  ["rect", { width: "16", height: "16", x: "4", y: "3", rx: "2", key: "1wxw4b" }],
  ["path", { d: "M4 11h16", key: "mpoxn0" }],
  ["path", { d: "M12 3v8", key: "1h2ygw" }],
  ["path", { d: "m8 19-2 3", key: "13i0xs" }],
  ["path", { d: "m18 22-2-3", key: "1p0ohu" }],
  ["path", { d: "M8 15h.01", key: "a7atzg" }],
  ["path", { d: "M16 15h.01", key: "rnfrdf" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash2 = createLucideIcon("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash = createLucideIcon("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Triangle = createLucideIcon("Triangle", [
  [
    "path",
    { d: "M13.73 4a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z", key: "14u9p9" }
  ]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Undo2 = createLucideIcon("Undo2", [
  ["path", { d: "M9 14 4 9l5-5", key: "102s5s" }],
  ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11", key: "f3b9sd" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UsersRound = createLucideIcon("UsersRound", [
  ["path", { d: "M18 21a8 8 0 0 0-16 0", key: "3ypg7q" }],
  ["circle", { cx: "10", cy: "8", r: "5", key: "o932ke" }],
  ["path", { d: "M22 20c0-3.37-2-6.5-4-8a5 5 0 0 0-.45-8.3", key: "10s06x" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Users = createLucideIcon("Users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Volume2 = createLucideIcon("Volume2", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
  ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VolumeOff = createLucideIcon("VolumeOff", [
  ["path", { d: "M16 9a5 5 0 0 1 .95 2.293", key: "1fgyg8" }],
  ["path", { d: "M19.364 5.636a9 9 0 0 1 1.889 9.96", key: "l3zxae" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  [
    "path",
    {
      d: "m7 7-.587.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298V11",
      key: "1gbwow"
    }
  ],
  ["path", { d: "M9.828 4.172A.686.686 0 0 1 11 4.657v.686", key: "s2je0y" }]
]);
/**
 * @license lucide-react v0.437.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wrench = createLucideIcon("Wrench", [
  [
    "path",
    {
      d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z",
      key: "cbrjhi"
    }
  ]
]);
const CityContext = reactExports.createContext(void 0);
function CityProvider({ children, cityCode }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CityContext.Provider, { value: { cityCode }, children });
}
function useCity() {
  const context = reactExports.useContext(CityContext);
  if (!context) {
    throw new Error("useCity must be used within a CityProvider");
  }
  return context;
}
const getActionCategories = () => [
  {
    labelKey: "navigation.construction",
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Wrench, { className: "w-full h-full" }),
    navigationStateToAdd: {
      type: "construction",
      itemId: null,
      view: null
    }
  },
  {
    labelKey: "navigation.routes",
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GitPullRequest, { className: "w-full h-full" }),
    navigationStateToAdd: {
      type: "routes-list",
      itemId: null,
      view: null
    }
  },
  {
    labelKey: "navigation.statistics",
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartBar, { className: "w-full h-full" }),
    navigationStateToAdd: null,
    subCategories: [
      {
        labelKey: "navigation.demandStats",
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-full h-full" }),
        navigationStateToAdd: {
          type: "demand-stats",
          itemId: null,
          view: "homes"
        }
      },
      {
        labelKey: "navigation.routeRidership",
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { className: "w-full h-full" }),
        navigationStateToAdd: {
          type: "route-ridership",
          itemId: null,
          view: "homes"
        }
      },
      {
        labelKey: "navigation.stationRidership",
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { className: "w-full h-full" }),
        navigationStateToAdd: {
          type: "station-ridership",
          itemId: null,
          view: "groups"
          // Default to groups view
        }
      }
    ]
  },
  {
    labelKey: "navigation.journeyPlanner",
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CornerUpRight, { className: "w-full h-full" }),
    navigationStateToAdd: {
      type: "journey-planner",
      itemId: null,
      view: null
    }
  }
];
const actionCategories = getActionCategories();
const _0x3b9c1b = _0x4238;
function _0x4238(_0x4ff29b, _0x1bbcf4) {
  const _0x20e29c = _0x59a9();
  return _0x4238 = function(_0x551d022, _0x3c28d82) {
    _0x551d022 = _0x551d022 - 442;
    let _0x1f0b18 = _0x20e29c[_0x551d022];
    return _0x1f0b18;
  }, _0x4238(_0x4ff29b, _0x1bbcf4);
}
(function(_0x495d09, _0x391d76) {
  const _0x24f44b = _0x4238, _0x5489fd = _0x495d09();
  while (!![]) {
    try {
      const _0x29228c = -parseInt(_0x24f44b(481)) / 1 * (-parseInt(_0x24f44b(445)) / 2) + -parseInt(_0x24f44b(484)) / 3 * (parseInt(_0x24f44b(474)) / 4) + -parseInt(_0x24f44b(461)) / 5 * (parseInt(_0x24f44b(469)) / 6) + -parseInt(_0x24f44b(459)) / 7 + parseInt(_0x24f44b(476)) / 8 * (parseInt(_0x24f44b(450)) / 9) + parseInt(_0x24f44b(475)) / 10 + -parseInt(_0x24f44b(458)) / 11 * (-parseInt(_0x24f44b(477)) / 12);
      if (_0x29228c === _0x391d76) break;
      else _0x5489fd["push"](_0x5489fd["shift"]());
    } catch (_0x3ee8a0) {
      _0x5489fd["push"](_0x5489fd["shift"]());
    }
  }
})(_0x59a9, 873978);
const _0x3c28d8 = /* @__PURE__ */ (function() {
  let _0x29b074 = !![];
  return function(_0x5624b2, _0x26bd8d) {
    const _0x242752 = _0x29b074 ? function() {
      const _0x4fa0f1 = _0x4238;
      if (_0x26bd8d) {
        const _0x5c72de = _0x26bd8d[_0x4fa0f1(464)](_0x5624b2, arguments);
        return _0x26bd8d = null, _0x5c72de;
      }
    } : function() {
    };
    return _0x29b074 = ![], _0x242752;
  };
})(), _0x551d02 = _0x3c28d8(void 0, function() {
  const _0x217af2 = _0x4238;
  let _0x13b5fb;
  try {
    const _0x3ace60 = Function(_0x217af2(451) + _0x217af2(467) + ");");
    _0x13b5fb = _0x3ace60();
  } catch (_0x2f816a) {
    _0x13b5fb = window;
  }
  const _0x4dc1d4 = _0x13b5fb["console"] = _0x13b5fb[_0x217af2(444)] || {}, _0x24fb22 = [_0x217af2(452), "warn", _0x217af2(466), _0x217af2(457), _0x217af2(471), _0x217af2(465), _0x217af2(485)];
  for (let _0x3fceb1 = 0; _0x3fceb1 < _0x24fb22[_0x217af2(453)]; _0x3fceb1++) {
    const _0x2c068e = _0x3c28d8[_0x217af2(478)]["prototype"]["bind"](_0x3c28d8), _0x3d1e4d = _0x24fb22[_0x3fceb1], _0x271f87 = _0x4dc1d4[_0x3d1e4d] || _0x2c068e;
    _0x2c068e[_0x217af2(480)] = _0x3c28d8[_0x217af2(462)](_0x3c28d8), _0x2c068e[_0x217af2(468)] = _0x271f87[_0x217af2(468)][_0x217af2(462)](_0x271f87), _0x4dc1d4[_0x3d1e4d] = _0x2c068e;
  }
});
_0x551d02();
function _0x59a9() {
  const _0x11ca51 = ["bind", "select-journey-location", "apply", "table", "info", '{}.constructor("return this")( )', "toString", "35166LKNTRX", "draw-quad-tracks", "exception", "draw-line-track", "Select journey location", "268uMUDMG", "4357040KLgNes", "11095168WLvYTR", "12TegDLW", "constructor", "Splits all the tracks in a track group if the centerline is clicked. If a single track is clicked it only splits that track.", "__proto__", "29Byuhpi", "Single track station", "crosshair", "12114dlNFSR", "trace", "Delete tracks", "none", "Parallel track station", "Draw route by track", "console", "37608CJuLhK", "draw-parallel-tracks", "Click on the map to select a location for journey planning.", "draw-quad-station", "Quad track station", "9ANoRWf", "return (function() ", "log", "length", "None", "draw-parallel-station", "delete-track-group", "error", "8868233fGBQtM", "10801924uaDWid", "create-scissors-crossover", "415XQjSjo"];
  _0x59a9 = function() {
    return _0x11ca51;
  };
  return _0x59a9();
}
const SELECT_NONE_SNAPPING_CONFIG = { "singleTrackCenterlines": ![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": ![], "parallelTrackCenterlineNodes": ![], "quadTrackCenterlines": ![], "quadTrackCenterlineNodes": ![], "stationNodes": ![], "stationCenterlines": ![], "tracks": ![] };
const userActions = [{ "label": _0x3b9c1b(454), "value": _0x3b9c1b(487), "snappingConfig": SELECT_NONE_SNAPPING_CONFIG }, { "label": "Single track", "value": "draw-single-track", "snappingConfig": { "singleTrackCenterlines": !![], "singleTrackCenterlineNodes": !![], "parallelTrackCenterlines": ![], "parallelTrackCenterlineNodes": ![], "quadTrackCenterlines": ![], "quadTrackCenterlineNodes": ![], "stationNodes": !![], "stationCenterlines": ![], "tracks": !![] }, "customCursor": "crosshair", "ignoreClick": !![] }, { "label": _0x3b9c1b(482), "value": "draw-single-station", "snappingConfig": { "singleTrackCenterlines": ![], "singleTrackCenterlineNodes": !![], "parallelTrackCenterlines": ![], "parallelTrackCenterlineNodes": ![], "quadTrackCenterlines": ![], "quadTrackCenterlineNodes": ![], "stationNodes": ![], "stationCenterlines": ![], "tracks": ![] }, "customCursor": "crosshair", "ignoreClick": !![] }, { "label": "Parallel tracks", "value": _0x3b9c1b(446), "snappingConfig": { "singleTrackCenterlines": ![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": !![], "parallelTrackCenterlineNodes": !![], "quadTrackCenterlines": ![], "quadTrackCenterlineNodes": !![], "stationNodes": !![], "stationCenterlines": ![], "tracks": ![] }, "customCursor": _0x3b9c1b(483), "ignoreClick": !![] }, { "label": _0x3b9c1b(442), "value": _0x3b9c1b(455), "snappingConfig": { "singleTrackCenterlines": ![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": ![], "parallelTrackCenterlineNodes": !![], "quadTrackCenterlines": ![], "quadTrackCenterlineNodes": !![], "stationNodes": ![], "stationCenterlines": ![], "tracks": ![] }, "customCursor": "crosshair", "ignoreClick": !![] }, { "label": "Quad tracks", "value": _0x3b9c1b(470), "snappingConfig": { "singleTrackCenterlines": ![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": ![], "parallelTrackCenterlineNodes": ![], "quadTrackCenterlines": !![], "quadTrackCenterlineNodes": !![], "stationNodes": !![], "stationCenterlines": ![], "tracks": ![] }, "customCursor": _0x3b9c1b(483), "ignoreClick": !![] }, { "label": _0x3b9c1b(449), "value": _0x3b9c1b(448), "snappingConfig": { "singleTrackCenterlines": ![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": ![], "parallelTrackCenterlineNodes": ![], "quadTrackCenterlines": ![], "quadTrackCenterlineNodes": !![], "stationNodes": ![], "stationCenterlines": ![], "tracks": ![] }, "customCursor": _0x3b9c1b(483), "ignoreClick": !![] }, { "label": "Split track", "value": "split-track", "snappingConfig": { "singleTrackCenterlines": !![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": !![], "parallelTrackCenterlineNodes": ![], "quadTrackCenterlines": !![], "quadTrackCenterlineNodes": ![], "stationNodes": ![], "stationCenterlines": ![], "tracks": !![] }, "description": _0x3b9c1b(479), "customCursor": _0x3b9c1b(483), "ignoreClick": !![] }, { "label": "Place scissors crossover", "value": _0x3b9c1b(460), "snappingConfig": { "singleTrackCenterlines": ![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": ![], "parallelTrackCenterlineNodes": !![], "quadTrackCenterlines": ![], "quadTrackCenterlineNodes": !![], "stationNodes": ![], "stationCenterlines": ![], "tracks": ![] }, "description": "Click on a parallel track to create a scissors crossover between the two tracks. For quad tracks, creates crossover between the middle two tracks.", "customCursor": _0x3b9c1b(483), "ignoreClick": !![] }, { "label": _0x3b9c1b(486), "value": _0x3b9c1b(456), "snappingConfig": { "singleTrackCenterlines": !![], "singleTrackCenterlineNodes": ![], "parallelTrackCenterlines": !![], "parallelTrackCenterlineNodes": ![], "quadTrackCenterlines": !![], "quadTrackCenterlineNodes": ![], "stationNodes": ![], "stationCenterlines": !![], "tracks": ![] }, "customCursor": "crosshair", "ignoreClick": !![] }, { "label": _0x3b9c1b(443), "value": _0x3b9c1b(472), "snappingConfig": SELECT_NONE_SNAPPING_CONFIG, "description": "Click on station track nodes to create a route that connects them using existing tracks.", "ignoreClick": !![] }, { "label": _0x3b9c1b(473), "value": _0x3b9c1b(463), "snappingConfig": SELECT_NONE_SNAPPING_CONFIG, "description": _0x3b9c1b(447), "customCursor": _0x3b9c1b(483), "ignoreClick": !![] }];
const MAX_NAVIGATION_HISTORY = 20;
const navigationCloseCallbacks = {};
function triggerNavigationCloseCallbacks(state) {
  const callbacks = navigationCloseCallbacks[state.type];
  if (callbacks) {
    callbacks.forEach((callback) => callback(state));
  }
}
const initialState$1 = {
  isDebugInfoOpen: false,
  isLayersPanelOpen: false,
  selectedActionCategory: null,
  navigationHistory: [],
  currentNavigationIndex: 0,
  userAction: "none",
  demandMapMode: "all",
  isEscapeMenuOpen: false,
  selectedTrackType: DEFAULT_TRACK_TYPE_ID,
  followingTrainId: null,
  isDemandStatsPinned: false,
  pinnedDemandStatsView: "homes"
};
function uiReducer(state, action) {
  switch (action.type) {
    case "TOGGLE_DEBUG_INFO":
      return {
        ...state,
        isDebugInfoOpen: !state.isDebugInfoOpen
      };
    case "TOGGLE_LAYERS_PANEL":
      return {
        ...state,
        isLayersPanelOpen: !state.isLayersPanelOpen
      };
    case "SET_SELECTED_ACTION_CATEGORY":
      return {
        ...state,
        selectedActionCategory: action.payload,
        // Clear the navigation history when a new action category is selected
        navigationHistory: [],
        currentNavigationIndex: 0,
        userAction: "none"
      };
    case "NAVIGATE": {
      if (action.payload === "back") {
        const newIndex2 = state.currentNavigationIndex - 1;
        return {
          ...state,
          currentNavigationIndex: newIndex2,
          navigationHistory: state.navigationHistory.slice(0, newIndex2 + 1)
        };
      }
      const newIndex = state.currentNavigationIndex + 1;
      return {
        ...state,
        currentNavigationIndex: newIndex,
        navigationHistory: state.navigationHistory.slice(0, newIndex + 1)
      };
    }
    case "PUSH_NAVIGATION_STATE": {
      const currentState = state.navigationHistory[state.currentNavigationIndex];
      if (action.payload.state === currentState) {
        return state;
      }
      if (action.payload.options && action.payload.options.clearHistory) {
        return {
          ...state,
          navigationHistory: [action.payload.state],
          currentNavigationIndex: 0
        };
      }
      const replaceLastItemInHistory = currentState && action.payload.state.type === currentState.type && action.payload.state.itemId === currentState.itemId || action.payload.options && action.payload.options.ignoreLastItemIfSameType && action.payload.state?.type === currentState?.type;
      if (replaceLastItemInHistory) {
        return {
          ...state,
          navigationHistory: [
            // The navigation history without the current item
            ...state.navigationHistory.slice(0, state.currentNavigationIndex),
            action.payload.state
          ],
          currentNavigationIndex: state.currentNavigationIndex
        };
      }
      const newNavigationHistory = [...state.navigationHistory, action.payload.state];
      if (newNavigationHistory.length > MAX_NAVIGATION_HISTORY) {
        newNavigationHistory.shift();
      }
      return {
        ...state,
        navigationHistory: newNavigationHistory,
        currentNavigationIndex: newNavigationHistory.length - 1
      };
    }
    case "SET_USER_ACTION":
      return {
        ...state,
        userAction: action.payload
      };
    case "SET_DEMAND_MAP_MODE":
      return {
        ...state,
        demandMapMode: action.payload
      };
    case "CLEAR_NAVIGATION_HISTORY":
      return {
        ...state,
        selectedActionCategory: null,
        navigationHistory: [],
        currentNavigationIndex: 0,
        userAction: "none"
      };
    case "TOGGLE_ESCAPE_MENU":
      return {
        ...state,
        isEscapeMenuOpen: !state.isEscapeMenuOpen
      };
    case "SET_SELECTED_TRACK_TYPE":
      return {
        ...state,
        selectedTrackType: action.payload
      };
    case "SET_FOLLOWING_TRAIN_ID":
      return {
        ...state,
        followingTrainId: action.payload
      };
    case "TOGGLE_DEMAND_STATS_PINNED":
      return {
        ...state,
        isDemandStatsPinned: !state.isDemandStatsPinned
      };
    case "SET_PINNED_DEMAND_STATS_VIEW":
      return {
        ...state,
        pinnedDemandStatsView: action.payload
      };
    default:
      return state;
  }
}
const UiContext = reactExports.createContext(void 0);
const UiProvider = ({ children }) => {
  const [state, dispatch] = reactExports.useReducer(uiReducer, initialState$1);
  const prevNavigationStateRef = reactExports.useRef(null);
  const currentNavigationState = state.navigationHistory[state.currentNavigationIndex] ?? null;
  const selectedRouteId = currentNavigationState?.type === "route-details" ? currentNavigationState.itemId : null;
  const selectedTrainId = currentNavigationState?.type === "train-details" ? currentNavigationState.itemId : null;
  const selectedSignalId = currentNavigationState?.type === "signal-details" ? currentNavigationState.itemId : null;
  const selectedPopMovementIds = currentNavigationState?.type === "pop-movement" ? currentNavigationState.itemId : null;
  const canNavigateBack = state.currentNavigationIndex > 0;
  const handleSetSelectedActionCategory = (actionCategory) => {
    if (actionCategory === state.selectedActionCategory) {
      dispatch({ type: "CLEAR_NAVIGATION_HISTORY" });
      return;
    }
    dispatch({ type: "SET_SELECTED_ACTION_CATEGORY", payload: actionCategory });
    if (!actionCategory) return;
    if (actionCategory.navigationStateToAdd) {
      dispatch({
        type: "PUSH_NAVIGATION_STATE",
        payload: { state: actionCategory.navigationStateToAdd }
      });
    }
  };
  const userActionObj = userActions.find((action) => action.value === state.userAction) ?? null;
  if (!userActionObj) {
    throw new Error(`User action not found: ${state.userAction}`);
  }
  reactExports.useEffect(() => {
    const prevState = prevNavigationStateRef.current;
    const currentState = currentNavigationState;
    if (prevState && (!currentState || prevState.type !== currentState.type || prevState.itemId !== currentState.itemId)) {
      triggerNavigationCloseCallbacks(prevState);
      if (prevState.type === "train-details" && state.followingTrainId) {
        dispatch({ type: "SET_FOLLOWING_TRAIN_ID", payload: null });
      }
    }
    prevNavigationStateRef.current = currentState;
  }, [currentNavigationState, state.followingTrainId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    UiContext.Provider,
    {
      value: {
        isDebugInfoOpen: state.isDebugInfoOpen,
        toggleDebugInfoOpen: () => dispatch({ type: "TOGGLE_DEBUG_INFO" }),
        isLayersPanelOpen: state.isLayersPanelOpen,
        toggleLayersPanel: () => dispatch({ type: "TOGGLE_LAYERS_PANEL" }),
        selectedActionCategory: state.selectedActionCategory,
        handleSetSelectedActionCategory,
        navigationHistory: state.navigationHistory,
        navigate: (direction) => dispatch({ type: "NAVIGATE", payload: direction }),
        currentNavigationState,
        pushNavigationState: (state2, options) => dispatch({ type: "PUSH_NAVIGATION_STATE", payload: { state: state2, options } }),
        clearNavigationHistory: () => dispatch({ type: "CLEAR_NAVIGATION_HISTORY" }),
        selectedRouteId,
        selectedTrainId,
        selectedSignalId,
        selectedPopMovementIds,
        canNavigateBack,
        userAction: state.userAction,
        setUserAction: (userAction) => dispatch({ type: "SET_USER_ACTION", payload: userAction }),
        userActionObj,
        demandMapMode: state.demandMapMode,
        setDemandMapMode: (mode) => dispatch({ type: "SET_DEMAND_MAP_MODE", payload: mode }),
        isEscapeMenuOpen: state.isEscapeMenuOpen,
        toggleEscapeMenu: () => dispatch({ type: "TOGGLE_ESCAPE_MENU" }),
        selectedTrackType: state.selectedTrackType,
        setSelectedTrackType: (trackType) => dispatch({ type: "SET_SELECTED_TRACK_TYPE", payload: trackType }),
        followingTrainId: state.followingTrainId,
        setFollowingTrainId: (trainId) => dispatch({ type: "SET_FOLLOWING_TRAIN_ID", payload: trainId }),
        isDemandStatsPinned: state.isDemandStatsPinned,
        toggleDemandStatsPinned: () => dispatch({ type: "TOGGLE_DEMAND_STATS_PINNED" }),
        pinnedDemandStatsView: state.pinnedDemandStatsView,
        setPinnedDemandStatsView: (view) => dispatch({ type: "SET_PINNED_DEMAND_STATS_VIEW", payload: view })
      },
      children
    }
  );
};
const useUi = () => {
  const context = reactExports.useContext(UiContext);
  if (!context) {
    throw new Error("useUi must be used within a UiProvider");
  }
  return context;
};
const KeyboardShortcutsContext = reactExports.createContext(void 0);
function KeyboardShortcutsProvider({ children }) {
  const [triggeredActionCategoryIndex, setTriggeredActionCategoryIndex] = reactExports.useState(null);
  const { togglePause, updateTimeSpeed, clearPreview } = useMainStore();
  const { handleSetSelectedActionCategory, clearNavigationHistory } = useUi();
  reactExports.useEffect(() => {
    const pressedKeys = /* @__PURE__ */ new Set();
    const handleMenuShortcut = (_event, data) => {
      if (data.type === "action-category") {
        const index2 = data.index;
        let category = actionCategories[index2];
        if (index2 === 2 && category.subCategories && category.subCategories.length > 0) {
          category = category.subCategories[0];
        }
        if (category) {
          clearNavigationHistory();
          clearPreview();
          setTimeout(() => {
            handleSetSelectedActionCategory(category);
          }, 0);
        }
      } else if (data.type === "toggle-pause") {
        togglePause();
      } else if (data.type === "time-speed") {
        updateTimeSpeed(data.speed);
      }
    };
    if (window.electron?.ipcRenderer) {
      window.electron.ipcRenderer.on("menu-shortcut", handleMenuShortcut);
    }
    function handleKeyDown(e) {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }
      if ((e.metaKey || e.ctrlKey) && ["Digit1", "Digit2", "Digit3", "Digit4"].includes(e.code)) {
        const keyCombo = `Cmd+${e.code}`;
        if (!pressedKeys.has(keyCombo)) {
          e.preventDefault();
          pressedKeys.add(keyCombo);
          const index2 = parseInt(e.code.slice(5)) - 1;
          let category = actionCategories[index2];
          if (index2 === 2 && category.subCategories && category.subCategories.length > 0) {
            category = category.subCategories[0];
          }
          if (category) {
            clearNavigationHistory();
            clearPreview();
            setTimeout(() => {
              handleSetSelectedActionCategory(category);
            }, 0);
          }
          setTriggeredActionCategoryIndex(index2);
        }
        return;
      }
      if (e.code === "Space" && !pressedKeys.has("Space")) {
        e.preventDefault();
        pressedKeys.add("Space");
        togglePause();
        return;
      }
      if (["Digit1", "Digit2", "Digit3", "Digit4"].includes(e.code) && !e.metaKey && !e.ctrlKey) {
        if (!pressedKeys.has(e.code)) {
          e.preventDefault();
          pressedKeys.add(e.code);
          switch (e.code) {
            case "Digit1":
              updateTimeSpeed("slow");
              break;
            case "Digit2":
              updateTimeSpeed("normal");
              break;
            case "Digit3":
              updateTimeSpeed("fast");
              break;
            case "Digit4":
              updateTimeSpeed("ultrafast");
              break;
          }
        }
      }
    }
    function handleKeyUp(e) {
      if (["Digit1", "Digit2", "Digit3", "Digit4"].includes(e.code)) {
        pressedKeys.delete(`Cmd+${e.code}`);
        pressedKeys.delete(e.code);
      } else {
        pressedKeys.delete(e.code);
      }
    }
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      if (window.electron?.ipcRenderer) {
        window.electron.ipcRenderer.removeListener("menu-shortcut", handleMenuShortcut);
      }
    };
  }, [togglePause, updateTimeSpeed, handleSetSelectedActionCategory, clearNavigationHistory, clearPreview]);
  const clearTriggeredActionCategory = () => {
    setTriggeredActionCategoryIndex(null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardShortcutsContext.Provider, { value: { triggeredActionCategoryIndex, clearTriggeredActionCategory }, children });
}
function useKeyboardShortcutsContext() {
  const context = reactExports.useContext(KeyboardShortcutsContext);
  if (context === void 0) {
    throw new Error("useKeyboardShortcutsContext must be used within a KeyboardShortcutsProvider");
  }
  return context;
}
const isMac = typeof navigator !== "undefined" && navigator.platform.toUpperCase().indexOf("MAC") >= 0;
const modifierSymbol = isMac ? "⌘" : "Ctrl";
function ActionCategorySelector() {
  const { triggeredActionCategoryIndex } = useKeyboardShortcutsContext();
  const { handleSetSelectedActionCategory, clearNavigationHistory } = useUi();
  const { clearPreview } = useMainStore();
  const lastTriggeredRef = reactExports.useRef(null);
  const actionCategories2 = getActionCategories();
  reactExports.useEffect(() => {
    if (triggeredActionCategoryIndex !== null && triggeredActionCategoryIndex !== lastTriggeredRef.current) {
      lastTriggeredRef.current = triggeredActionCategoryIndex;
      const category = actionCategories2[triggeredActionCategoryIndex];
      if (category) {
        clearNavigationHistory();
        clearPreview();
        setTimeout(() => {
          handleSetSelectedActionCategory(category);
        }, 0);
      }
    }
  }, [triggeredActionCategoryIndex, handleSetSelectedActionCategory, clearPreview, clearNavigationHistory]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-14 p-1.5 bg-primary-foreground/30 backdrop-blur-sm flex items-center gap-2 pointer-events-auto", children: actionCategories2.map((actionCategory, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ActionCategoryButton,
    {
      actionCategory,
      shortcutNumber: index2 + 1
    },
    actionCategory.labelKey
  )) }) });
}
function ActionCategoryButton({
  actionCategory,
  shortcutNumber
}) {
  const { t } = useTranslation("game");
  const { selectedActionCategory, handleSetSelectedActionCategory } = useUi();
  const { clearPreview } = useMainStore();
  const isSelected = selectedActionCategory && selectedActionCategory.labelKey === actionCategory.labelKey;
  const label = t(actionCategory.labelKey);
  const tooltipKey = `${actionCategory.labelKey}Tooltip`;
  const handleClick2 = (category) => {
    if (isSelected) {
      handleSetSelectedActionCategory(null);
      clearPreview();
      return;
    }
    handleSetSelectedActionCategory(category);
    clearPreview();
  };
  if (actionCategory.subCategories) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: cn(
              "aspect-square h-full rounded-full bg-primary-foreground/20 p-2 border-2 border-primary/15 cursor-pointer text-primary stroke-[1px] shadow-md ring-0",
              isSelected ? "bg-blue-300 hover:bg-blue-300 dark:bg-blue-500 dark:hover:bg-blue-500" : "hover:bg-primary-foreground/30"
            ),
            "data-tutorial": actionCategory.labelKey === "navigation.construction" ? "construction-button" : actionCategory.labelKey === "navigation.statistics" ? "statistics-button" : void 0,
            children: actionCategory.icon
          }
        ) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipContent, { className: "mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-fit", children: t(tooltipKey, label) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground mt-1", children: [
            modifierSymbol,
            "+",
            shortcutNumber
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuContent, { align: "start", className: "w-48 mb-1.5", children: actionCategory.subCategories.map((subCategory) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DropdownMenuItem,
        {
          className: "flex items-center gap-2",
          onClick: () => handleClick2(subCategory),
          "data-tutorial": subCategory.labelKey === "navigation.demandStats" ? "demand-stats-button" : void 0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-4 h-4", children: subCategory.icon }),
            t(subCategory.labelKey)
          ]
        },
        subCategory.labelKey
      )) })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: cn(
          "aspect-square h-full rounded-full bg-primary-foreground/20 p-2 border-2 border-primary/15 cursor-pointer text-primary stroke-[1px] shadow-md ring-0",
          isSelected ? "bg-blue-300 hover:bg-blue-300 dark:bg-blue-500 dark:hover:bg-blue-500" : "hover:bg-primary-foreground/30"
        ),
        onClick: () => handleClick2(actionCategory),
        "data-tutorial": actionCategory.labelKey === "navigation.construction" ? "construction-button" : actionCategory.labelKey === "navigation.routes" ? "routes-button" : actionCategory.labelKey === "navigation.statistics" ? "statistics-button" : void 0,
        children: actionCategory.icon
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipContent, { className: "mb-2 max-w-64", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-fit", children: t(tooltipKey, label) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground mt-1", children: [
        modifierSymbol,
        "+",
        shortcutNumber
      ] })
    ] })
  ] });
}
function Clock() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(BottomBarItemWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PlayPauseButton, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TimeDisplay, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TimeSpeedControls, {})
  ] });
}
function TimeDisplay() {
  const { t } = useTranslation("game");
  const timeConfig = useTimeConfig();
  const { use24HourTime } = useSettings();
  const formattedTime = formatClockTime(timeConfig.elapsedSeconds, use24HourTime);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "whitespace-nowrap flex justify-between text-sm items-center",
        use24HourTime ? "w-40" : "w-48"
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium", children: [
          t("clock.day"),
          " ",
          formattedTime.days
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-mono", title: DEBUG_MODE ? `${timeConfig.elapsedSeconds} seconds` : void 0, children: [
            formattedTime.hours,
            ":",
            formattedTime.minutes,
            ":",
            formattedTime.seconds,
            formattedTime.period && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 text-xs", children: formattedTime.period })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TimeOfDayIndicator, {})
        ] })
      ]
    }
  );
}
function PlayPauseButton() {
  const timeConfig = useTimeConfig();
  const { togglePause } = useMainStore();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "flex items-center justify-center hover:cursor-pointer h-full w-9 hover:bg-primary/10 p-1.5 border-r border-primary/15",
      onClick: togglePause,
      "data-tutorial": "play-button",
      children: timeConfig.paused ? /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { className: "h-full stroke-0 fill-primary" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Pause, { className: "h-full stroke-0 fill-primary" })
    }
  );
}
function TimeSpeedControls() {
  const timeConfig = useTimeConfig();
  const { updateTimeSpeed } = useMainStore();
  function handleTimeSpeedChange() {
    let nextSpeed;
    if (timeConfig.timeSpeed === "slow") nextSpeed = "normal";
    else if (timeConfig.timeSpeed === "normal") nextSpeed = "fast";
    else if (timeConfig.timeSpeed === "fast") nextSpeed = "ultrafast";
    else if (timeConfig.timeSpeed === "ultrafast") nextSpeed = "slow";
    if (!nextSpeed) return;
    updateTimeSpeed(nextSpeed);
  }
  const isSlow = timeConfig.timeSpeed === "slow";
  const isNormal = timeConfig.timeSpeed === "normal";
  const isFast = timeConfig.timeSpeed === "fast";
  const isUltrafast = timeConfig.timeSpeed === "ultrafast";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex items-center justify-center py-2 h-full cursor-pointer hover:bg-primary/10 px-1 border-l border-primary/15",
      onClick: handleTimeSpeedChange,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Play,
          {
            className: cn(
              "h-full stroke-0 fill-primary opacity-50",
              (isSlow || isNormal || isFast || isUltrafast) && "opacity-100"
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Play,
          {
            className: cn(
              "h-full stroke-0 fill-primary -ml-2 opacity-50",
              (isNormal || isFast || isUltrafast) && "opacity-100"
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Play,
          {
            className: cn(
              "h-full stroke-0 fill-primary -ml-2 opacity-50",
              (isFast || isUltrafast) && "opacity-100"
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { className: cn("h-full stroke-0 fill-primary -ml-2 opacity-50", isUltrafast && "opacity-100") })
      ]
    }
  );
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray2 = Array.isArray;
  isArray_1 = isArray2;
  return isArray_1;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol2 = root.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey) return _isKey;
  hasRequired_isKey = 1;
  var isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object2) {
    if (isArray2(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  _isKey = isKey;
  return _isKey;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  isObject_1 = isObject2;
  return isObject_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject2 = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction2;
  return isFunction_1;
}
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData) return _coreJsData;
  hasRequired_coreJsData = 1;
  var root = require_root();
  var coreJsData = root["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked) return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = (function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  })();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource) return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative) return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction2 = requireIsFunction(), isMasked = require_isMasked(), isObject2 = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue) return _getValue;
  hasRequired_getValue = 1;
  function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  _getValue = getValue2;
  return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative) return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue2 = require_getValue();
  function getNative(object2, key) {
    var value = getValue2(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative = getNative;
  return _getNative;
}
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate) return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear) return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear;
  return _hashClear;
}
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete) return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete;
  return _hashDelete;
}
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet) return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  _hashGet = hashGet;
  return _hashGet;
}
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas) return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  _hashHas = hashHas;
  return _hashHas;
}
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet) return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  _hashSet = hashSet;
  return _hashSet;
}
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash) return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear) return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq;
  return eq_1;
}
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf) return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq = requireEq();
  function assocIndexOf(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete) return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet) return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas) return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet) return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache) return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root = require_root();
  var Map2 = getNative(root, "Map");
  _Map = Map2;
  return _Map;
}
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear) return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable) return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable;
  return _isKeyable;
}
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData) return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  _getMapData = getMapData;
  return _getMapData;
}
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet) return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas) return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet) return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache) return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize) return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize3(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize3.Cache || MapCache)();
    return memoized;
  }
  memoize3.Cache = MapCache;
  memoize_1 = memoize3;
  return memoize_1;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped) return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize3 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize3(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath) return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName, function(match, number2, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array2, iteratee) {
    var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
    while (++index2 < length) {
      result[index2] = iteratee(array2[index2], index2, array2);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray2(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString2(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString2;
  return toString_1;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath) return _castPath;
  hasRequired_castPath = 1;
  var isArray2 = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString2 = requireToString();
  function castPath(value, object2) {
    if (isArray2(value)) {
      return value;
    }
    return isKey(value, object2) ? [value] : stringToPath(toString2(value));
  }
  _castPath = castPath;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey) return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet) return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object2, path) {
    path = castPath(path, object2);
    var index2 = 0, length = path.length;
    while (object2 != null && index2 < length) {
      object2 = object2[toKey(path[index2++])];
    }
    return index2 && index2 == length ? object2 : void 0;
  }
  _baseGet = baseGet;
  return _baseGet;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet();
  function get2(object2, path, defaultValue) {
    var result = object2 == null ? void 0 : baseGet(object2, path);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get2;
  return get_1;
}
var getExports = requireGet();
const get = /* @__PURE__ */ getDefaultExportFromCjs(getExports);
var isNil_1;
var hasRequiredIsNil;
function requireIsNil() {
  if (hasRequiredIsNil) return isNil_1;
  hasRequiredIsNil = 1;
  function isNil2(value) {
    return value == null;
  }
  isNil_1 = isNil2;
  return isNil_1;
}
var isNilExports = requireIsNil();
const isNil = /* @__PURE__ */ getDefaultExportFromCjs(isNilExports);
var isString_1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString) return isString_1;
  hasRequiredIsString = 1;
  var baseGetTag = require_baseGetTag(), isArray2 = requireIsArray(), isObjectLike = requireIsObjectLike();
  var stringTag = "[object String]";
  function isString2(value) {
    return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  isString_1 = isString2;
  return isString_1;
}
var isStringExports = requireIsString();
const isString = /* @__PURE__ */ getDefaultExportFromCjs(isStringExports);
var isFunctionExports = requireIsFunction();
const isFunction$2 = /* @__PURE__ */ getDefaultExportFromCjs(isFunctionExports);
var isObjectExports = requireIsObject();
const isObject$2 = /* @__PURE__ */ getDefaultExportFromCjs(isObjectExports);
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k2 = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u2;
  u2 = Symbol.for("react.module.reference");
  function v(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var r = a2.$$typeof;
      switch (r) {
        case b:
          switch (a2 = a2.type, a2) {
            case d:
            case f:
            case e:
            case m2:
            case n:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case h:
                case l:
                case q:
                case p2:
                case g:
                  return a2;
                default:
                  return r;
              }
          }
        case c2:
          return r;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = g;
  reactIs_production_min.Element = b;
  reactIs_production_min.ForwardRef = l;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p2;
  reactIs_production_min.Portal = c2;
  reactIs_production_min.Profiler = f;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m2;
  reactIs_production_min.SuspenseList = n;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a2) {
    return v(a2) === h;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return v(a2) === g;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return v(a2) === l;
  };
  reactIs_production_min.isFragment = function(a2) {
    return v(a2) === d;
  };
  reactIs_production_min.isLazy = function(a2) {
    return v(a2) === q;
  };
  reactIs_production_min.isMemo = function(a2) {
    return v(a2) === p2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return v(a2) === c2;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return v(a2) === f;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return v(a2) === e;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return v(a2) === m2;
  };
  reactIs_production_min.isSuspenseList = function(a2) {
    return v(a2) === n;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f || a2 === e || a2 === m2 || a2 === n || a2 === t || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === l || a2.$$typeof === u2 || void 0 !== a2.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v;
  return reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = requireReactIs_production_min();
  }
  return reactIs.exports;
}
var reactIsExports = requireReactIs();
var isNumber_1;
var hasRequiredIsNumber;
function requireIsNumber() {
  if (hasRequiredIsNumber) return isNumber_1;
  hasRequiredIsNumber = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var numberTag = "[object Number]";
  function isNumber3(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
  }
  isNumber_1 = isNumber3;
  return isNumber_1;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  var isNumber3 = requireIsNumber();
  function isNaN2(value) {
    return isNumber3(value) && value != +value;
  }
  _isNaN = isNaN2;
  return _isNaN;
}
var _isNaNExports = require_isNaN();
const isNan = /* @__PURE__ */ getDefaultExportFromCjs(_isNaNExports);
var isNumberExports = requireIsNumber();
const isNumber$1 = /* @__PURE__ */ getDefaultExportFromCjs(isNumberExports);
var mathSign = function mathSign2(value) {
  if (value === 0) {
    return 0;
  }
  if (value > 0) {
    return 1;
  }
  return -1;
};
var isPercent = function isPercent2(value) {
  return isString(value) && value.indexOf("%") === value.length - 1;
};
var isNumber = function isNumber2(value) {
  return isNumber$1(value) && !isNan(value);
};
var isNullish = function isNullish2(value) {
  return isNil(value);
};
var isNumOrStr = function isNumOrStr2(value) {
  return isNumber(value) || isString(value);
};
var idCounter = 0;
var uniqueId = function uniqueId2(prefix2) {
  var id = ++idCounter;
  return "".concat(prefix2 || "").concat(id);
};
var getPercentValue = function getPercentValue2(percent, totalValue) {
  var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var validate2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (!isNumber(percent) && !isString(percent)) {
    return defaultValue;
  }
  var value;
  if (isPercent(percent)) {
    var index2 = percent.indexOf("%");
    value = totalValue * parseFloat(percent.slice(0, index2)) / 100;
  } else {
    value = +percent;
  }
  if (isNan(value)) {
    value = defaultValue;
  }
  if (validate2 && value > totalValue) {
    value = totalValue;
  }
  return value;
};
var getAnyElementOfObject = function getAnyElementOfObject2(obj) {
  if (!obj) {
    return null;
  }
  var keys2 = Object.keys(obj);
  if (keys2 && keys2.length) {
    return obj[keys2[0]];
  }
  return null;
};
var hasDuplicate = function hasDuplicate2(ary) {
  if (!Array.isArray(ary)) {
    return false;
  }
  var len = ary.length;
  var cache2 = {};
  for (var i = 0; i < len; i++) {
    if (!cache2[ary[i]]) {
      cache2[ary[i]] = true;
    } else {
      return true;
    }
  }
  return false;
};
var interpolateNumber$2 = function interpolateNumber(numberA, numberB) {
  if (isNumber(numberA) && isNumber(numberB)) {
    return function(t) {
      return numberA + t * (numberB - numberA);
    };
  }
  return function() {
    return numberB;
  };
};
function findEntryInArray(ary, specifiedKey, specifiedValue) {
  if (!ary || !ary.length) {
    return null;
  }
  return ary.find(function(entry) {
    return entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : get(entry, specifiedKey)) === specifiedValue;
  });
}
var compareValues = function compareValues2(a2, b) {
  if (isNumber(a2) && isNumber(b)) {
    return a2 - b;
  }
  if (isString(a2) && isString(b)) {
    return a2.localeCompare(b);
  }
  if (a2 instanceof Date && b instanceof Date) {
    return a2.getTime() - b.getTime();
  }
  return String(a2).localeCompare(String(b));
};
function shallowEqual(a2, b) {
  for (var key in a2) {
    if ({}.hasOwnProperty.call(a2, key) && (!{}.hasOwnProperty.call(b, key) || a2[key] !== b[key])) {
      return false;
    }
  }
  for (var _key in b) {
    if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a2, _key)) {
      return false;
    }
  }
  return true;
}
function _typeof$I(o) {
  "@babel/helpers - typeof";
  return _typeof$I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$I(o);
}
var SVGContainerPropKeys = ["viewBox", "children"];
var SVGElementPropKeys = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
];
var PolyElementKeys = ["points", "pathLength"];
var FilteredElementKeyMap = {
  svg: SVGContainerPropKeys,
  polygon: PolyElementKeys,
  polyline: PolyElementKeys
};
var EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
var adaptEventHandlers = function adaptEventHandlers2(props, newHandler) {
  if (!props || typeof props === "function" || typeof props === "boolean") {
    return null;
  }
  var inputProps = props;
  if (/* @__PURE__ */ reactExports.isValidElement(props)) {
    inputProps = props.props;
  }
  if (!isObject$2(inputProps)) {
    return null;
  }
  var out = {};
  Object.keys(inputProps).forEach(function(key) {
    if (EventKeys.includes(key)) {
      out[key] = newHandler || function(e) {
        return inputProps[key](inputProps, e);
      };
    }
  });
  return out;
};
var getEventHandlerOfChild = function getEventHandlerOfChild2(originalHandler, data, index2) {
  return function(e) {
    originalHandler(data, index2, e);
    return null;
  };
};
var adaptEventsOfChild = function adaptEventsOfChild2(props, data, index2) {
  if (!isObject$2(props) || _typeof$I(props) !== "object") {
    return null;
  }
  var out = null;
  Object.keys(props).forEach(function(key) {
    var item = props[key];
    if (EventKeys.includes(key) && typeof item === "function") {
      if (!out) out = {};
      out[key] = getEventHandlerOfChild(item, data, index2);
    }
  });
  return out;
};
var _excluded$h = ["children"], _excluded2$6 = ["children"];
function _objectWithoutProperties$h(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$h(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$h(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _typeof$H(o) {
  "@babel/helpers - typeof";
  return _typeof$H = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$H(o);
}
var REACT_BROWSER_EVENT_MAP = {
  click: "onClick",
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  mouseout: "onMouseOut",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  touchcancel: "onTouchCancel",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchstart: "onTouchStart",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick"
};
var getDisplayName = function getDisplayName2(Comp) {
  if (typeof Comp === "string") {
    return Comp;
  }
  if (!Comp) {
    return "";
  }
  return Comp.displayName || Comp.name || "Component";
};
var lastChildren = null;
var lastResult = null;
var toArray = function toArray2(children) {
  if (children === lastChildren && Array.isArray(lastResult)) {
    return lastResult;
  }
  var result = [];
  reactExports.Children.forEach(children, function(child) {
    if (isNil(child)) return;
    if (reactIsExports.isFragment(child)) {
      result = result.concat(toArray2(child.props.children));
    } else {
      result.push(child);
    }
  });
  lastResult = result;
  lastChildren = children;
  return result;
};
function findAllByType(children, type) {
  var result = [];
  var types = [];
  if (Array.isArray(type)) {
    types = type.map(function(t) {
      return getDisplayName(t);
    });
  } else {
    types = [getDisplayName(type)];
  }
  toArray(children).forEach(function(child) {
    var childType = get(child, "type.displayName") || get(child, "type.name");
    if (types.indexOf(childType) !== -1) {
      result.push(child);
    }
  });
  return result;
}
function findChildByType(children, type) {
  var result = findAllByType(children, type);
  return result && result[0];
}
var validateWidthHeight = function validateWidthHeight2(el) {
  if (!el || !el.props) {
    return false;
  }
  var _el$props = el.props, width = _el$props.width, height = _el$props.height;
  if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0) {
    return false;
  }
  return true;
};
var SVG_TAGS = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"];
var isSvgElement = function isSvgElement2(child) {
  return child && child.type && isString(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
};
var hasClipDot = function hasClipDot2(dot2) {
  return dot2 && _typeof$H(dot2) === "object" && "clipDot" in dot2;
};
var isValidSpreadableProp = function isValidSpreadableProp2(property, key, includeEvents, svgElementType) {
  var _FilteredElementKeyMa;
  var matchingElementTypeKeys = (_FilteredElementKeyMa = FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];
  return key.startsWith("data-") || !isFunction$2(property) && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);
};
var filterProps = function filterProps2(props, includeEvents, svgElementType) {
  if (!props || typeof props === "function" || typeof props === "boolean") {
    return null;
  }
  var inputProps = props;
  if (/* @__PURE__ */ reactExports.isValidElement(props)) {
    inputProps = props.props;
  }
  if (!isObject$2(inputProps)) {
    return null;
  }
  var out = {};
  Object.keys(inputProps).forEach(function(key) {
    var _inputProps;
    if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {
      out[key] = inputProps[key];
    }
  });
  return out;
};
var isChildrenEqual = function isChildrenEqual2(nextChildren, prevChildren) {
  if (nextChildren === prevChildren) {
    return true;
  }
  var count2 = reactExports.Children.count(nextChildren);
  if (count2 !== reactExports.Children.count(prevChildren)) {
    return false;
  }
  if (count2 === 0) {
    return true;
  }
  if (count2 === 1) {
    return isSingleChildEqual(Array.isArray(nextChildren) ? nextChildren[0] : nextChildren, Array.isArray(prevChildren) ? prevChildren[0] : prevChildren);
  }
  for (var i = 0; i < count2; i++) {
    var nextChild = nextChildren[i];
    var prevChild = prevChildren[i];
    if (Array.isArray(nextChild) || Array.isArray(prevChild)) {
      if (!isChildrenEqual2(nextChild, prevChild)) {
        return false;
      }
    } else if (!isSingleChildEqual(nextChild, prevChild)) {
      return false;
    }
  }
  return true;
};
var isSingleChildEqual = function isSingleChildEqual2(nextChild, prevChild) {
  if (isNil(nextChild) && isNil(prevChild)) {
    return true;
  }
  if (!isNil(nextChild) && !isNil(prevChild)) {
    var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties$h(_ref, _excluded$h);
    var _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties$h(_ref2, _excluded2$6);
    if (nextChildren && prevChildren) {
      return shallowEqual(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);
    }
    if (!nextChildren && !prevChildren) {
      return shallowEqual(nextProps, prevProps);
    }
    return false;
  }
  return false;
};
var renderByOrder = function renderByOrder2(children, renderMap) {
  var elements = [];
  var record = {};
  toArray(children).forEach(function(child, index2) {
    if (isSvgElement(child)) {
      elements.push(child);
    } else if (child) {
      var displayName = getDisplayName(child.type);
      var _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once = _ref3.once;
      if (handler && (!once || !record[displayName])) {
        var results = handler(child, displayName, index2);
        elements.push(results);
        record[displayName] = true;
      }
    }
  });
  return elements;
};
var getReactEventByType = function getReactEventByType2(e) {
  var type = e && e.type;
  if (type && REACT_BROWSER_EVENT_MAP[type]) {
    return REACT_BROWSER_EVENT_MAP[type];
  }
  return null;
};
var parseChildIndex = function parseChildIndex2(child, children) {
  return toArray(children).indexOf(child);
};
var _excluded$g = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$q.apply(this, arguments);
}
function _objectWithoutProperties$g(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$g(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$g(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function Surface(props) {
  var children = props.children, width = props.width, height = props.height, viewBox = props.viewBox, className = props.className, style = props.style, title = props.title, desc = props.desc, others = _objectWithoutProperties$g(props, _excluded$g);
  var svgView = viewBox || {
    width,
    height,
    x: 0,
    y: 0
  };
  var layerClass = clsx("recharts-surface", className);
  return /* @__PURE__ */ React.createElement("svg", _extends$q({}, filterProps(others, true, "svg"), {
    className: layerClass,
    width,
    height,
    style,
    viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height)
  }), /* @__PURE__ */ React.createElement("title", null, title), /* @__PURE__ */ React.createElement("desc", null, desc), children);
}
var _excluded$f = ["children", "className"];
function _extends$p() {
  _extends$p = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$p.apply(this, arguments);
}
function _objectWithoutProperties$f(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$f(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$f(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var Layer$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var children = props.children, className = props.className, others = _objectWithoutProperties$f(props, _excluded$f);
  var layerClass = clsx("recharts-layer", className);
  return /* @__PURE__ */ React.createElement("g", _extends$p({
    className: layerClass
  }, filterProps(others, true), {
    ref
  }), children);
});
var warn = function warn2(condition, format2) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
};
var _baseSlice;
var hasRequired_baseSlice;
function require_baseSlice() {
  if (hasRequired_baseSlice) return _baseSlice;
  hasRequired_baseSlice = 1;
  function baseSlice(array2, start2, end) {
    var index2 = -1, length = array2.length;
    if (start2 < 0) {
      start2 = -start2 > length ? 0 : length + start2;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start2 > end ? 0 : end - start2 >>> 0;
    start2 >>>= 0;
    var result = Array(length);
    while (++index2 < length) {
      result[index2] = array2[index2 + start2];
    }
    return result;
  }
  _baseSlice = baseSlice;
  return _baseSlice;
}
var _castSlice;
var hasRequired_castSlice;
function require_castSlice() {
  if (hasRequired_castSlice) return _castSlice;
  hasRequired_castSlice = 1;
  var baseSlice = require_baseSlice();
  function castSlice(array2, start2, end) {
    var length = array2.length;
    end = end === void 0 ? length : end;
    return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
  }
  _castSlice = castSlice;
  return _castSlice;
}
var _hasUnicode;
var hasRequired_hasUnicode;
function require_hasUnicode() {
  if (hasRequired_hasUnicode) return _hasUnicode;
  hasRequired_hasUnicode = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsZWJ = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
  function hasUnicode(string2) {
    return reHasUnicode.test(string2);
  }
  _hasUnicode = hasUnicode;
  return _hasUnicode;
}
var _asciiToArray;
var hasRequired_asciiToArray;
function require_asciiToArray() {
  if (hasRequired_asciiToArray) return _asciiToArray;
  hasRequired_asciiToArray = 1;
  function asciiToArray(string2) {
    return string2.split("");
  }
  _asciiToArray = asciiToArray;
  return _asciiToArray;
}
var _unicodeToArray;
var hasRequired_unicodeToArray;
function require_unicodeToArray() {
  if (hasRequired_unicodeToArray) return _unicodeToArray;
  hasRequired_unicodeToArray = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeToArray(string2) {
    return string2.match(reUnicode) || [];
  }
  _unicodeToArray = unicodeToArray;
  return _unicodeToArray;
}
var _stringToArray;
var hasRequired_stringToArray;
function require_stringToArray() {
  if (hasRequired_stringToArray) return _stringToArray;
  hasRequired_stringToArray = 1;
  var asciiToArray = require_asciiToArray(), hasUnicode = require_hasUnicode(), unicodeToArray = require_unicodeToArray();
  function stringToArray(string2) {
    return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
  }
  _stringToArray = stringToArray;
  return _stringToArray;
}
var _createCaseFirst;
var hasRequired_createCaseFirst;
function require_createCaseFirst() {
  if (hasRequired_createCaseFirst) return _createCaseFirst;
  hasRequired_createCaseFirst = 1;
  var castSlice = require_castSlice(), hasUnicode = require_hasUnicode(), stringToArray = require_stringToArray(), toString2 = requireToString();
  function createCaseFirst(methodName) {
    return function(string2) {
      string2 = toString2(string2);
      var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
      var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  _createCaseFirst = createCaseFirst;
  return _createCaseFirst;
}
var upperFirst_1;
var hasRequiredUpperFirst;
function requireUpperFirst() {
  if (hasRequiredUpperFirst) return upperFirst_1;
  hasRequiredUpperFirst = 1;
  var createCaseFirst = require_createCaseFirst();
  var upperFirst2 = createCaseFirst("toUpperCase");
  upperFirst_1 = upperFirst2;
  return upperFirst_1;
}
var upperFirstExports = requireUpperFirst();
const upperFirst = /* @__PURE__ */ getDefaultExportFromCjs(upperFirstExports);
function constant$1(x2) {
  return function constant2() {
    return x2;
  };
}
const cos = Math.cos;
const sin = Math.sin;
const sqrt$1 = Math.sqrt;
const pi$1 = Math.PI;
const tau$1 = 2 * pi$1;
const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }
    if (!r) return;
    if (da < 0) da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}
function array(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}
function shapeLine(x$1, y$1) {
  var defined3 = constant$1(true), context = null, curve = curveLinear, output = null, path = withPath(line);
  x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant$1(x$1);
  y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant$1(y$1);
  function line(data) {
    var i, n = (data = array(data)).length, d, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined3(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), line) : x$1;
  };
  line.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
  };
  line.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant$1(!!_), line) : defined3;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}
function shapeArea(x0, y0, y1) {
  var x1 = null, defined3 = constant$1(true), context = null, curve = curveLinear, output = null, path = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant$1(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$1(0) : constant$1(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant$1(+y1);
  function area(data) {
    var i, j, k2, n = (data = array(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined3(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return shapeLine().defined(defined3).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant$1(!!_), area) : defined3;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}
class Bump {
  constructor(context, x2) {
    this._context = context;
    this._x = x2;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x2, y2);
        else this._context.moveTo(x2, y2);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
        break;
      }
    }
    this._x0 = x2, this._y0 = y2;
  }
}
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}
const symbolCircle = {
  draw(context, size) {
    const r = sqrt$1(size / pi$1);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$1);
  }
};
const symbolCross = {
  draw(context, size) {
    const r = sqrt$1(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};
const tan30 = sqrt$1(1 / 3);
const tan30_2 = tan30 * 2;
const symbolDiamond = {
  draw(context, size) {
    const y2 = sqrt$1(size / tan30_2);
    const x2 = y2 * tan30;
    context.moveTo(0, -y2);
    context.lineTo(x2, 0);
    context.lineTo(0, y2);
    context.lineTo(-x2, 0);
    context.closePath();
  }
};
const symbolSquare = {
  draw(context, size) {
    const w = sqrt$1(size);
    const x2 = -w / 2;
    context.rect(x2, x2, w, w);
  }
};
const ka = 0.8908130915292852;
const kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10);
const kx = sin(tau$1 / 10) * kr;
const ky = -cos(tau$1 / 10) * kr;
const symbolStar = {
  draw(context, size) {
    const r = sqrt$1(size * ka);
    const x2 = kx * r;
    const y2 = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x2, y2);
    for (let i = 1; i < 5; ++i) {
      const a2 = tau$1 * i / 5;
      const c2 = cos(a2);
      const s2 = sin(a2);
      context.lineTo(s2 * r, -c2 * r);
      context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
    }
    context.closePath();
  }
};
const sqrt3 = sqrt$1(3);
const symbolTriangle = {
  draw(context, size) {
    const y2 = -sqrt$1(size / (sqrt3 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt3 * y2, -y2);
    context.lineTo(sqrt3 * y2, -y2);
    context.closePath();
  }
};
const c = -0.5;
const s = sqrt$1(3) / 2;
const k$2 = 1 / sqrt$1(12);
const a = (k$2 / 2 + 1) * 3;
const symbolWye = {
  draw(context, size) {
    const r = sqrt$1(size / a);
    const x0 = r / 2, y0 = r * k$2;
    const x1 = x0, y1 = r * k$2 + r;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};
function Symbol$1(type, size) {
  let context = null, path = withPath(symbol);
  type = typeof type === "function" ? type : constant$1(type || symbolCircle);
  size = typeof size === "function" ? size : constant$1(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}
function noop$5() {
}
function point$2(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$2(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context) {
  return new Basis(context);
}
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context) {
  return new BasisClosed(context);
}
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context) {
  return new BasisOpen(context);
}
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) this._context.lineTo(x2, y2);
    else this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context) {
  return new LinearClosed(context);
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point$1(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$1(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point$1(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m2, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i) a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i) m2 = a2[i] / b[i - 1], b[i] -= m2, r[i] -= m2 * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function curveNatural(context) {
  return new Natural(context);
}
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function stackOffsetNone(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m2 = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m2; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
function stackOrderNone(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function shapeStack() {
  var keys2 = constant$1([]), order = stackOrderNone, offset2 = stackOffsetNone, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys2.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset2(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys2 = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys2;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset2 = _ == null ? stackOffsetNone : _, stack) : offset2;
  };
  return stack;
}
function stackOffsetExpand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m2 = series[0].length, y2; j < m2; ++j) {
    for (y2 = i = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    if (y2) for (i = 0; i < n; ++i) series[i][j][1] /= y2;
  }
  stackOffsetNone(series, order);
}
function stackOffsetSilhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m2 = s0.length; j < m2; ++j) {
    for (var i = 0, y2 = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y2 / 2;
  }
  stackOffsetNone(series, order);
}
function stackOffsetWiggle(series, order) {
  if (!((n = series.length) > 0) || !((m2 = (s0 = series[order[0]]).length) > 0)) return;
  for (var y2 = 0, j = 1, s0, m2, n; j < m2; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    if (s1) y2 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y2;
  stackOffsetNone(series, order);
}
function _typeof$G(o) {
  "@babel/helpers - typeof";
  return _typeof$G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$G(o);
}
var _excluded$e = ["type", "size", "sizeType"];
function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$o.apply(this, arguments);
}
function ownKeys$z(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$z(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$z(Object(t), true).forEach(function(r2) {
      _defineProperty$F(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$z(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$F(obj, key, value) {
  key = _toPropertyKey$F(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$F(t) {
  var i = _toPrimitive$F(t, "string");
  return "symbol" == _typeof$G(i) ? i : i + "";
}
function _toPrimitive$F(t, r) {
  if ("object" != _typeof$G(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$G(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$e(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$e(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$e(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var symbolFactories = {
  symbolCircle,
  symbolCross,
  symbolDiamond,
  symbolSquare,
  symbolStar,
  symbolTriangle,
  symbolWye
};
var RADIAN$1 = Math.PI / 180;
var getSymbolFactory = function getSymbolFactory2(type) {
  var name2 = "symbol".concat(upperFirst(type));
  return symbolFactories[name2] || symbolCircle;
};
var calculateAreaSize = function calculateAreaSize2(size, sizeType, type) {
  if (sizeType === "area") {
    return size;
  }
  switch (type) {
    case "cross":
      return 5 * size * size / 9;
    case "diamond":
      return 0.5 * size * size / Math.sqrt(3);
    case "square":
      return size * size;
    case "star": {
      var angle2 = 18 * RADIAN$1;
      return 1.25 * size * size * (Math.tan(angle2) - Math.tan(angle2 * 2) * Math.pow(Math.tan(angle2), 2));
    }
    case "triangle":
      return Math.sqrt(3) * size * size / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * size * size / 8;
    default:
      return Math.PI * size * size / 4;
  }
};
var registerSymbol = function registerSymbol2(key, factory) {
  symbolFactories["symbol".concat(upperFirst(key))] = factory;
};
var Symbols = function Symbols2(_ref) {
  var _ref$type = _ref.type, type = _ref$type === void 0 ? "circle" : _ref$type, _ref$size = _ref.size, size = _ref$size === void 0 ? 64 : _ref$size, _ref$sizeType = _ref.sizeType, sizeType = _ref$sizeType === void 0 ? "area" : _ref$sizeType, rest = _objectWithoutProperties$e(_ref, _excluded$e);
  var props = _objectSpread$z(_objectSpread$z({}, rest), {}, {
    type,
    size,
    sizeType
  });
  var getPath4 = function getPath5() {
    var symbolFactory = getSymbolFactory(type);
    var symbol = Symbol$1().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));
    return symbol();
  };
  var className = props.className, cx = props.cx, cy = props.cy;
  var filteredProps = filterProps(props, true);
  if (cx === +cx && cy === +cy && size === +size) {
    return /* @__PURE__ */ React.createElement("path", _extends$o({}, filteredProps, {
      className: clsx("recharts-symbols", className),
      transform: "translate(".concat(cx, ", ").concat(cy, ")"),
      d: getPath4()
    }));
  }
  return null;
};
Symbols.registerSymbol = registerSymbol;
function _typeof$F(o) {
  "@babel/helpers - typeof";
  return _typeof$F = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$F(o);
}
function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$n.apply(this, arguments);
}
function ownKeys$y(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$y(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$y(Object(t), true).forEach(function(r2) {
      _defineProperty$E(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$y(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$E(descriptor.key), descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$e(t, o, e) {
  return o = _getPrototypeOf$f(o), _possibleConstructorReturn$f(t, _isNativeReflectConstruct$f() ? Reflect.construct(o, e || [], _getPrototypeOf$f(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$f(self2, call) {
  if (call && (_typeof$F(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$f(self2);
}
function _assertThisInitialized$f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$f() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$f(o);
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o, p2) {
  _setPrototypeOf$f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$f(o, p2);
}
function _defineProperty$E(obj, key, value) {
  key = _toPropertyKey$E(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$E(t) {
  var i = _toPrimitive$E(t, "string");
  return "symbol" == _typeof$F(i) ? i : i + "";
}
function _toPrimitive$E(t, r) {
  if ("object" != _typeof$F(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$F(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var SIZE = 32;
var DefaultLegendContent = /* @__PURE__ */ (function(_PureComponent) {
  function DefaultLegendContent2() {
    _classCallCheck$i(this, DefaultLegendContent2);
    return _callSuper$e(this, DefaultLegendContent2, arguments);
  }
  _inherits$f(DefaultLegendContent2, _PureComponent);
  return _createClass$i(DefaultLegendContent2, [{
    key: "renderIcon",
    value: (
      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      function renderIcon(data) {
        var inactiveColor = this.props.inactiveColor;
        var halfSize = SIZE / 2;
        var sixthSize = SIZE / 6;
        var thirdSize = SIZE / 3;
        var color2 = data.inactive ? inactiveColor : data.color;
        if (data.type === "plainline") {
          return /* @__PURE__ */ React.createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: color2,
            strokeDasharray: data.payload.strokeDasharray,
            x1: 0,
            y1: halfSize,
            x2: SIZE,
            y2: halfSize,
            className: "recharts-legend-icon"
          });
        }
        if (data.type === "line") {
          return /* @__PURE__ */ React.createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: color2,
            d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
            className: "recharts-legend-icon"
          });
        }
        if (data.type === "rect") {
          return /* @__PURE__ */ React.createElement("path", {
            stroke: "none",
            fill: color2,
            d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
            className: "recharts-legend-icon"
          });
        }
        if (/* @__PURE__ */ React.isValidElement(data.legendIcon)) {
          var iconProps = _objectSpread$y({}, data);
          delete iconProps.legendIcon;
          return /* @__PURE__ */ React.cloneElement(data.legendIcon, iconProps);
        }
        return /* @__PURE__ */ React.createElement(Symbols, {
          fill: color2,
          cx: halfSize,
          cy: halfSize,
          size: SIZE,
          sizeType: "diameter",
          type: data.type
        });
      }
    )
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this = this;
      var _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor;
      var viewBox = {
        x: 0,
        y: 0,
        width: SIZE,
        height: SIZE
      };
      var itemStyle = {
        display: layout === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      };
      var svgStyle = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return payload.map(function(entry, i) {
        var finalFormatter = entry.formatter || formatter;
        var className = clsx(_defineProperty$E(_defineProperty$E({
          "recharts-legend-item": true
        }, "legend-item-".concat(i), true), "inactive", entry.inactive));
        if (entry.type === "none") {
          return null;
        }
        var entryValue = !isFunction$2(entry.value) ? entry.value : null;
        warn(
          !isFunction$2(entry.value),
          `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`
          // eslint-disable-line max-len
        );
        var color2 = entry.inactive ? inactiveColor : entry.color;
        return /* @__PURE__ */ React.createElement("li", _extends$n({
          className,
          style: itemStyle,
          key: "legend-item-".concat(i)
        }, adaptEventsOfChild(_this.props, entry, i)), /* @__PURE__ */ React.createElement(Surface, {
          width: iconSize,
          height: iconSize,
          viewBox,
          style: svgStyle
        }, _this.renderIcon(entry)), /* @__PURE__ */ React.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: color2
          }
        }, finalFormatter ? finalFormatter(entryValue, entry, i) : entryValue));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;
      if (!payload || !payload.length) {
        return null;
      }
      var finalStyle = {
        padding: 0,
        margin: 0,
        textAlign: layout === "horizontal" ? align : "left"
      };
      return /* @__PURE__ */ React.createElement("ul", {
        className: "recharts-default-legend",
        style: finalStyle
      }, this.renderItems());
    }
  }]);
})(reactExports.PureComponent);
_defineProperty$E(DefaultLegendContent, "displayName", "Legend");
_defineProperty$E(DefaultLegendContent, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
});
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear) return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete) return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet) return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas) return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet) return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack) return _Stack;
  hasRequired_Stack = 1;
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd) return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas) return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache) return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome) return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while (++index2 < length) {
      if (predicate(array2[index2], index2, array2)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas) return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays) return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array2);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array2;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while (++index2 < arrLength) {
      var arrValue = array2[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array) return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root = require_root();
  var Uint8Array2 = root.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray) return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray) return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag) return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object2);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush) return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush(array2, values) {
    var index2 = -1, length = values.length, offset2 = array2.length;
    while (++index2 < length) {
      array2[offset2 + index2] = values[index2];
    }
    return array2;
  }
  _arrayPush = arrayPush;
  return _arrayPush;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush = require_arrayPush(), isArray2 = requireIsArray();
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter) return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array2[index2];
      if (predicate(value, index2, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray) return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols) return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol) {
      return propertyIsEnumerable.call(object2, symbol);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes) return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments) return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments;
  return isArguments_1;
}
var isBuffer$2 = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse) return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
isBuffer$2.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer$2.exports;
  hasRequiredIsBuffer = 1;
  (function(module, exports) {
    var root = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer2;
  })(isBuffer$2, isBuffer$2.exports);
  return isBuffer$2.exports;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex2(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  _isIndex = isIndex2;
  return _isIndex;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  isLength_1 = isLength;
  return isLength_1;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary) return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil) return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module, exports) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    })();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray2;
  return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex2 = require_isIndex(), isTypedArray2 = requireIsTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype) return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg) return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys) return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys) return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction2 = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
  function keys2(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  keys_1 = keys2;
  return keys_1;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys) return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys2 = requireKeys();
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys2, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects) return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object2);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object2;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView) return _DataView;
  hasRequired_DataView = 1;
  var getNative = require_getNative(), root = require_root();
  var DataView2 = getNative(root, "DataView");
  _DataView = DataView2;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise) return _Promise;
  hasRequired_Promise = 1;
  var getNative = require_getNative(), root = require_root();
  var Promise2 = getNative(root, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set) return _Set;
  hasRequired_Set = 1;
  var getNative = require_getNative(), root = require_root();
  var Set2 = getNative(root, "Set");
  _Set = Set2;
  return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap) return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative = require_getNative(), root = require_root();
  var WeakMap2 = getNative(root, "WeakMap");
  _WeakMap = WeakMap2;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag) return _getTag;
  hasRequired_getTag = 1;
  var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var getTag2 = baseGetTag;
  if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
    getTag2 = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag2;
  return _getTag;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag2 = require_getTag(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray2 = requireIsTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object2), othTag = othIsArr ? arrayTag : getTag2(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object2)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual) return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike();
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch) return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object2, source, matchData, customizer) {
    var index2 = matchData.length, length = index2, noCustomizer = !customizer;
    if (object2 == null) {
      return !length;
    }
    object2 = Object(object2);
    while (index2--) {
      var data = matchData[index2];
      if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
        return false;
      }
    }
    while (++index2 < length) {
      data = matchData[index2];
      var key = data[0], objValue = object2[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object2)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object2, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable) return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject2 = requireIsObject();
  function isStrictComparable(value) {
    return value === value && !isObject2(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData) return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys2 = requireKeys();
  function getMatchData(object2) {
    var result = keys2(object2), length = result.length;
    while (length--) {
      var key = result[length], value = object2[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object2) {
      if (object2 == null) {
        return false;
      }
      return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches) return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object2) {
      return object2 === source || baseIsMatch(object2, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn) return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath) return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isIndex2 = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object2, path, hasFunc) {
    path = castPath(path, object2);
    var index2 = -1, length = path.length, result = false;
    while (++index2 < length) {
      var key = toKey(path[index2]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result || ++index2 != length) {
      return result;
    }
    length = object2 == null ? 0 : object2.length;
    return !!length && isLength(length) && isIndex2(key, length) && (isArray2(object2) || isArguments(object2));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn) return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object2, path) {
    return object2 != null && hasPath(object2, path, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get2 = requireGet(), hasIn = requireHasIn(), isKey = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object2) {
      var objValue = get2(object2, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity_1;
  hasRequiredIdentity = 1;
  function identity4(value) {
    return value;
  }
  identity_1 = identity4;
  return identity_1;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty) return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object2) {
      return object2 == null ? void 0 : object2[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep) return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet = require_baseGet();
  function basePropertyDeep(path) {
    return function(object2) {
      return baseGet(object2, path);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty) return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey(), toKey = require_toKey();
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee) return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity4 = requireIdentity(), isArray2 = requireIsArray(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity4;
    }
    if (typeof value == "object") {
      return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex) return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array2, predicate, fromIndex, fromRight) {
    var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length) {
      if (predicate(array2[index2], index2, array2)) {
        return index2;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN) return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf) return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array2, value, fromIndex) {
    var index2 = fromIndex - 1, length = array2.length;
    while (++index2 < length) {
      if (array2[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf) return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array2, value, fromIndex) {
    return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}
var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes) return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array2, value) {
    var length = array2 == null ? 0 : array2.length;
    return !!length && baseIndexOf(array2, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}
var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith) return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array2, value, comparator) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while (++index2 < length) {
      if (comparator(value, array2[index2])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}
var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop) return noop_1;
  hasRequiredNoop = 1;
  function noop3() {
  }
  noop_1 = noop3;
  return noop_1;
}
var _createSet;
var hasRequired_createSet;
function require_createSet() {
  if (hasRequired_createSet) return _createSet;
  hasRequired_createSet = 1;
  var Set2 = require_Set(), noop3 = requireNoop(), setToArray = require_setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values) {
    return new Set2(values);
  };
  _createSet = createSet;
  return _createSet;
}
var _baseUniq;
var hasRequired_baseUniq;
function require_baseUniq() {
  if (hasRequired_baseUniq) return _baseUniq;
  hasRequired_baseUniq = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array2, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array2);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length) {
        var value = array2[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  _baseUniq = baseUniq;
  return _baseUniq;
}
var uniqBy_1;
var hasRequiredUniqBy;
function requireUniqBy() {
  if (hasRequiredUniqBy) return uniqBy_1;
  hasRequiredUniqBy = 1;
  var baseIteratee = require_baseIteratee(), baseUniq = require_baseUniq();
  function uniqBy2(array2, iteratee) {
    return array2 && array2.length ? baseUniq(array2, baseIteratee(iteratee, 2)) : [];
  }
  uniqBy_1 = uniqBy2;
  return uniqBy_1;
}
var uniqByExports = requireUniqBy();
const uniqBy = /* @__PURE__ */ getDefaultExportFromCjs(uniqByExports);
function getUniqPayload(payload, option, defaultUniqBy2) {
  if (option === true) {
    return uniqBy(payload, defaultUniqBy2);
  }
  if (isFunction$2(option)) {
    return uniqBy(payload, option);
  }
  return payload;
}
function _typeof$E(o) {
  "@babel/helpers - typeof";
  return _typeof$E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$E(o);
}
var _excluded$d = ["ref"];
function ownKeys$x(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$x(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$x(Object(t), true).forEach(function(r2) {
      _defineProperty$D(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$x(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$D(descriptor.key), descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$h(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$d(t, o, e) {
  return o = _getPrototypeOf$e(o), _possibleConstructorReturn$e(t, _isNativeReflectConstruct$e() ? Reflect.construct(o, e || [], _getPrototypeOf$e(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$e(self2, call) {
  if (call && (_typeof$E(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$e(o);
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o, p2) {
  _setPrototypeOf$e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$e(o, p2);
}
function _defineProperty$D(obj, key, value) {
  key = _toPropertyKey$D(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$D(t) {
  var i = _toPrimitive$D(t, "string");
  return "symbol" == _typeof$E(i) ? i : i + "";
}
function _toPrimitive$D(t, r) {
  if ("object" != _typeof$E(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$E(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _objectWithoutProperties$d(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$d(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$d(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function defaultUniqBy$1(entry) {
  return entry.value;
}
function renderContent$1(content, props) {
  if (/* @__PURE__ */ React.isValidElement(content)) {
    return /* @__PURE__ */ React.cloneElement(content, props);
  }
  if (typeof content === "function") {
    return /* @__PURE__ */ React.createElement(content, props);
  }
  props.ref;
  var otherProps = _objectWithoutProperties$d(props, _excluded$d);
  return /* @__PURE__ */ React.createElement(DefaultLegendContent, otherProps);
}
var EPS$1 = 1;
var Legend = /* @__PURE__ */ (function(_PureComponent) {
  function Legend2() {
    var _this;
    _classCallCheck$h(this, Legend2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper$d(this, Legend2, [].concat(args));
    _defineProperty$D(_this, "lastBoundingBox", {
      width: -1,
      height: -1
    });
    return _this;
  }
  _inherits$e(Legend2, _PureComponent);
  return _createClass$h(Legend2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.updateBBox();
    }
  }, {
    key: "getBBox",
    value: function getBBox() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var box = this.wrapperNode.getBoundingClientRect();
        box.height = this.wrapperNode.offsetHeight;
        box.width = this.wrapperNode.offsetWidth;
        return box;
      }
      return null;
    }
  }, {
    key: "updateBBox",
    value: function updateBBox() {
      var onBBoxUpdate = this.props.onBBoxUpdate;
      var box = this.getBBox();
      if (box) {
        if (Math.abs(box.width - this.lastBoundingBox.width) > EPS$1 || Math.abs(box.height - this.lastBoundingBox.height) > EPS$1) {
          this.lastBoundingBox.width = box.width;
          this.lastBoundingBox.height = box.height;
          if (onBBoxUpdate) {
            onBBoxUpdate(box);
          }
        }
      } else if (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) {
        this.lastBoundingBox.width = -1;
        this.lastBoundingBox.height = -1;
        if (onBBoxUpdate) {
          onBBoxUpdate(null);
        }
      }
    }
  }, {
    key: "getBBoxSnapshot",
    value: function getBBoxSnapshot() {
      if (this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0) {
        return _objectSpread$x({}, this.lastBoundingBox);
      }
      return {
        width: 0,
        height: 0
      };
    }
  }, {
    key: "getDefaultPosition",
    value: function getDefaultPosition(style) {
      var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight;
      var hPos, vPos;
      if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) {
        if (align === "center" && layout === "vertical") {
          var box = this.getBBoxSnapshot();
          hPos = {
            left: ((chartWidth || 0) - box.width) / 2
          };
        } else {
          hPos = align === "right" ? {
            right: margin && margin.right || 0
          } : {
            left: margin && margin.left || 0
          };
        }
      }
      if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) {
        if (verticalAlign === "middle") {
          var _box = this.getBBoxSnapshot();
          vPos = {
            top: ((chartHeight || 0) - _box.height) / 2
          };
        } else {
          vPos = verticalAlign === "bottom" ? {
            bottom: margin && margin.bottom || 0
          } : {
            top: margin && margin.top || 0
          };
        }
      }
      return _objectSpread$x(_objectSpread$x({}, hPos), vPos);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload;
      var outerStyle = _objectSpread$x(_objectSpread$x({
        position: "absolute",
        width: width || "auto",
        height: height || "auto"
      }, this.getDefaultPosition(wrapperStyle)), wrapperStyle);
      return /* @__PURE__ */ React.createElement("div", {
        className: "recharts-legend-wrapper",
        style: outerStyle,
        ref: function ref(node) {
          _this2.wrapperNode = node;
        }
      }, renderContent$1(content, _objectSpread$x(_objectSpread$x({}, this.props), {}, {
        payload: getUniqPayload(payload, payloadUniqBy, defaultUniqBy$1)
      })));
    }
  }], [{
    key: "getWithHeight",
    value: function getWithHeight(item, chartWidth) {
      var _this$defaultProps$it = _objectSpread$x(_objectSpread$x({}, this.defaultProps), item.props), layout = _this$defaultProps$it.layout;
      if (layout === "vertical" && isNumber(item.props.height)) {
        return {
          height: item.props.height
        };
      }
      if (layout === "horizontal") {
        return {
          width: item.props.width || chartWidth
        };
      }
      return null;
    }
  }]);
})(reactExports.PureComponent);
_defineProperty$D(Legend, "displayName", "Legend");
_defineProperty$D(Legend, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
});
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable) return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol2 = require_Symbol(), isArguments = requireIsArguments(), isArray2 = requireIsArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten) return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array2, depth, predicate, isStrict, result) {
    var index2 = -1, length = array2.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length) {
      var value = array2[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor) return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor) return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn) return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys2 = requireKeys();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor(object2, iteratee, keys2);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach) return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach) return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap) return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach(), isArrayLike = requireIsArrayLike();
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}
var _baseSortBy;
var hasRequired_baseSortBy;
function require_baseSortBy() {
  if (hasRequired_baseSortBy) return _baseSortBy;
  hasRequired_baseSortBy = 1;
  function baseSortBy(array2, comparer) {
    var length = array2.length;
    array2.sort(comparer);
    while (length--) {
      array2[length] = array2[length].value;
    }
    return array2;
  }
  _baseSortBy = baseSortBy;
  return _baseSortBy;
}
var _compareAscending;
var hasRequired_compareAscending;
function require_compareAscending() {
  if (hasRequired_compareAscending) return _compareAscending;
  hasRequired_compareAscending = 1;
  var isSymbol = requireIsSymbol();
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  _compareAscending = compareAscending;
  return _compareAscending;
}
var _compareMultiple;
var hasRequired_compareMultiple;
function require_compareMultiple() {
  if (hasRequired_compareMultiple) return _compareMultiple;
  hasRequired_compareMultiple = 1;
  var compareAscending = require_compareAscending();
  function compareMultiple(object2, other, orders) {
    var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while (++index2 < length) {
      var result = compareAscending(objCriteria[index2], othCriteria[index2]);
      if (result) {
        if (index2 >= ordersLength) {
          return result;
        }
        var order = orders[index2];
        return result * (order == "desc" ? -1 : 1);
      }
    }
    return object2.index - other.index;
  }
  _compareMultiple = compareMultiple;
  return _compareMultiple;
}
var _baseOrderBy;
var hasRequired_baseOrderBy;
function require_baseOrderBy() {
  if (hasRequired_baseOrderBy) return _baseOrderBy;
  hasRequired_baseOrderBy = 1;
  var arrayMap = require_arrayMap(), baseGet = require_baseGet(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary(), compareMultiple = require_compareMultiple(), identity4 = requireIdentity(), isArray2 = requireIsArray();
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray2(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity4];
    }
    var index2 = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index2, "value": value };
    });
    return baseSortBy(result, function(object2, other) {
      return compareMultiple(object2, other, orders);
    });
  }
  _baseOrderBy = baseOrderBy;
  return _baseOrderBy;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply) return _apply;
  hasRequired_apply = 1;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest) return _overRest;
  hasRequired_overRest = 1;
  var apply = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start2, transform) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array2 = Array(length);
      while (++index2 < length) {
        array2[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform(array2);
      return apply(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant) return constant_1;
  hasRequiredConstant = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant2;
  return constant_1;
}
var _defineProperty$C;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty) return _defineProperty$C;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty = (function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  })();
  _defineProperty$C = defineProperty;
  return _defineProperty$C;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString) return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant2 = requireConstant(), defineProperty = require_defineProperty(), identity4 = requireIdentity();
  var baseSetToString = !defineProperty ? identity4 : function(func, string2) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string2),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut) return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString) return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest) return _baseRest;
  hasRequired_baseRest = 1;
  var identity4 = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity4), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall) return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(), isArrayLike = requireIsArrayLike(), isIndex2 = require_isIndex(), isObject2 = requireIsObject();
  function isIterateeCall(value, index2, object2) {
    if (!isObject2(object2)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike(object2) && isIndex2(index2, object2.length) : type == "string" && index2 in object2) {
      return eq(object2[index2], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var sortBy_1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy) return sortBy_1;
  hasRequiredSortBy = 1;
  var baseFlatten = require_baseFlatten(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  var sortBy2 = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  sortBy_1 = sortBy2;
  return sortBy_1;
}
var sortByExports = requireSortBy();
const sortBy = /* @__PURE__ */ getDefaultExportFromCjs(sortByExports);
function _typeof$D(o) {
  "@babel/helpers - typeof";
  return _typeof$D = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$D(o);
}
function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$m.apply(this, arguments);
}
function _slicedToArray$b(arr, i) {
  return _arrayWithHoles$c(arr) || _iterableToArrayLimit$b(arr, i) || _unsupportedIterableToArray$j(arr, i) || _nonIterableRest$c();
}
function _nonIterableRest$c() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$j(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$j(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(o, minLen);
}
function _arrayLikeToArray$j(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$b(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$c(arr) {
  if (Array.isArray(arr)) return arr;
}
function ownKeys$w(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$w(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$w(Object(t), true).forEach(function(r2) {
      _defineProperty$B(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$w(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$B(obj, key, value) {
  key = _toPropertyKey$C(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$C(t) {
  var i = _toPrimitive$C(t, "string");
  return "symbol" == _typeof$D(i) ? i : i + "";
}
function _toPrimitive$C(t, r) {
  if ("object" != _typeof$D(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$D(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function defaultFormatter(value) {
  return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
var DefaultTooltipContent = function DefaultTooltipContent2(props) {
  var _props$separator = props.separator, separator = _props$separator === void 0 ? " : " : _props$separator, _props$contentStyle = props.contentStyle, contentStyle = _props$contentStyle === void 0 ? {} : _props$contentStyle, _props$itemStyle = props.itemStyle, itemStyle = _props$itemStyle === void 0 ? {} : _props$itemStyle, _props$labelStyle = props.labelStyle, labelStyle = _props$labelStyle === void 0 ? {} : _props$labelStyle, payload = props.payload, formatter = props.formatter, itemSorter = props.itemSorter, wrapperClassName = props.wrapperClassName, labelClassName = props.labelClassName, label = props.label, labelFormatter = props.labelFormatter, _props$accessibilityL = props.accessibilityLayer, accessibilityLayer = _props$accessibilityL === void 0 ? false : _props$accessibilityL;
  var renderContent2 = function renderContent3() {
    if (payload && payload.length) {
      var listStyle = {
        padding: 0,
        margin: 0
      };
      var items = (itemSorter ? sortBy(payload, itemSorter) : payload).map(function(entry, i) {
        if (entry.type === "none") {
          return null;
        }
        var finalItemStyle = _objectSpread$w({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: entry.color || "#000"
        }, itemStyle);
        var finalFormatter = entry.formatter || formatter || defaultFormatter;
        var value = entry.value, name2 = entry.name;
        var finalValue = value;
        var finalName = name2;
        if (finalFormatter && finalValue != null && finalName != null) {
          var formatted = finalFormatter(value, name2, entry, i, payload);
          if (Array.isArray(formatted)) {
            var _formatted = _slicedToArray$b(formatted, 2);
            finalValue = _formatted[0];
            finalName = _formatted[1];
          } else {
            finalValue = formatted;
          }
        }
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ React.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(i),
            style: finalItemStyle
          }, isNumOrStr(finalName) ? /* @__PURE__ */ React.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, finalName) : null, isNumOrStr(finalName) ? /* @__PURE__ */ React.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, separator) : null, /* @__PURE__ */ React.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, finalValue), /* @__PURE__ */ React.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, entry.unit || ""))
        );
      });
      return /* @__PURE__ */ React.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: listStyle
      }, items);
    }
    return null;
  };
  var finalStyle = _objectSpread$w({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, contentStyle);
  var finalLabelStyle = _objectSpread$w({
    margin: 0
  }, labelStyle);
  var hasLabel = !isNil(label);
  var finalLabel = hasLabel ? label : "";
  var wrapperCN = clsx("recharts-default-tooltip", wrapperClassName);
  var labelCN = clsx("recharts-tooltip-label", labelClassName);
  if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
    finalLabel = labelFormatter(label, payload);
  }
  var accessibilityAttributes = accessibilityLayer ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ React.createElement("div", _extends$m({
    className: wrapperCN,
    style: finalStyle
  }, accessibilityAttributes), /* @__PURE__ */ React.createElement("p", {
    className: labelCN,
    style: finalLabelStyle
  }, /* @__PURE__ */ React.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent2());
};
function _typeof$C(o) {
  "@babel/helpers - typeof";
  return _typeof$C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$C(o);
}
function _defineProperty$A(obj, key, value) {
  key = _toPropertyKey$B(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$B(t) {
  var i = _toPrimitive$B(t, "string");
  return "symbol" == _typeof$C(i) ? i : i + "";
}
function _toPrimitive$B(t, r) {
  if ("object" != _typeof$C(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$C(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
var TOOLTIP_HIDDEN = {
  visibility: "hidden"
};
function getTooltipCSSClassName(_ref) {
  var coordinate = _ref.coordinate, translateX = _ref.translateX, translateY = _ref.translateY;
  return clsx(CSS_CLASS_PREFIX, _defineProperty$A(_defineProperty$A(_defineProperty$A(_defineProperty$A({}, "".concat(CSS_CLASS_PREFIX, "-right"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x), "".concat(CSS_CLASS_PREFIX, "-left"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x), "".concat(CSS_CLASS_PREFIX, "-bottom"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y), "".concat(CSS_CLASS_PREFIX, "-top"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y));
}
function getTooltipTranslateXY(_ref2) {
  var allowEscapeViewBox = _ref2.allowEscapeViewBox, coordinate = _ref2.coordinate, key = _ref2.key, offsetTopLeft = _ref2.offsetTopLeft, position = _ref2.position, reverseDirection = _ref2.reverseDirection, tooltipDimension = _ref2.tooltipDimension, viewBox = _ref2.viewBox, viewBoxDimension = _ref2.viewBoxDimension;
  if (position && isNumber(position[key])) {
    return position[key];
  }
  var negative = coordinate[key] - tooltipDimension - offsetTopLeft;
  var positive = coordinate[key] + offsetTopLeft;
  if (allowEscapeViewBox[key]) {
    return reverseDirection[key] ? negative : positive;
  }
  if (reverseDirection[key]) {
    var _tooltipBoundary = negative;
    var _viewBoxBoundary = viewBox[key];
    if (_tooltipBoundary < _viewBoxBoundary) {
      return Math.max(positive, viewBox[key]);
    }
    return Math.max(negative, viewBox[key]);
  }
  var tooltipBoundary = positive + tooltipDimension;
  var viewBoxBoundary = viewBox[key] + viewBoxDimension;
  if (tooltipBoundary > viewBoxBoundary) {
    return Math.max(negative, viewBox[key]);
  }
  return Math.max(positive, viewBox[key]);
}
function getTransformStyle(_ref3) {
  var translateX = _ref3.translateX, translateY = _ref3.translateY, useTranslate3d = _ref3.useTranslate3d;
  return {
    transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
  };
}
function getTooltipTranslate(_ref4) {
  var allowEscapeViewBox = _ref4.allowEscapeViewBox, coordinate = _ref4.coordinate, offsetTopLeft = _ref4.offsetTopLeft, position = _ref4.position, reverseDirection = _ref4.reverseDirection, tooltipBox = _ref4.tooltipBox, useTranslate3d = _ref4.useTranslate3d, viewBox = _ref4.viewBox;
  var cssProperties, translateX, translateY;
  if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
    translateX = getTooltipTranslateXY({
      allowEscapeViewBox,
      coordinate,
      key: "x",
      offsetTopLeft,
      position,
      reverseDirection,
      tooltipDimension: tooltipBox.width,
      viewBox,
      viewBoxDimension: viewBox.width
    });
    translateY = getTooltipTranslateXY({
      allowEscapeViewBox,
      coordinate,
      key: "y",
      offsetTopLeft,
      position,
      reverseDirection,
      tooltipDimension: tooltipBox.height,
      viewBox,
      viewBoxDimension: viewBox.height
    });
    cssProperties = getTransformStyle({
      translateX,
      translateY,
      useTranslate3d
    });
  } else {
    cssProperties = TOOLTIP_HIDDEN;
  }
  return {
    cssProperties,
    cssClasses: getTooltipCSSClassName({
      translateX,
      translateY,
      coordinate
    })
  };
}
function _typeof$B(o) {
  "@babel/helpers - typeof";
  return _typeof$B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$B(o);
}
function ownKeys$v(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$v(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$v(Object(t), true).forEach(function(r2) {
      _defineProperty$z(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$v(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$A(descriptor.key), descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$c(t, o, e) {
  return o = _getPrototypeOf$d(o), _possibleConstructorReturn$d(t, _isNativeReflectConstruct$d() ? Reflect.construct(o, e || [], _getPrototypeOf$d(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$d(self2, call) {
  if (call && (_typeof$B(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$d(o);
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o, p2) {
  _setPrototypeOf$d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$d(o, p2);
}
function _defineProperty$z(obj, key, value) {
  key = _toPropertyKey$A(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$A(t) {
  var i = _toPrimitive$A(t, "string");
  return "symbol" == _typeof$B(i) ? i : i + "";
}
function _toPrimitive$A(t, r) {
  if ("object" != _typeof$B(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$B(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var EPSILON$2 = 1;
var TooltipBoundingBox = /* @__PURE__ */ (function(_PureComponent) {
  function TooltipBoundingBox2() {
    var _this;
    _classCallCheck$g(this, TooltipBoundingBox2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper$c(this, TooltipBoundingBox2, [].concat(args));
    _defineProperty$z(_this, "state", {
      dismissed: false,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      },
      lastBoundingBox: {
        width: -1,
        height: -1
      }
    });
    _defineProperty$z(_this, "handleKeyDown", function(event) {
      if (event.key === "Escape") {
        var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
        _this.setState({
          dismissed: true,
          dismissedAtCoordinate: {
            x: (_this$props$coordinat = (_this$props$coordinat2 = _this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
            y: (_this$props$coordinat3 = (_this$props$coordinat4 = _this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
          }
        });
      }
    });
    return _this;
  }
  _inherits$d(TooltipBoundingBox2, _PureComponent);
  return _createClass$g(TooltipBoundingBox2, [{
    key: "updateBBox",
    value: function updateBBox() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var box = this.wrapperNode.getBoundingClientRect();
        if (Math.abs(box.width - this.state.lastBoundingBox.width) > EPSILON$2 || Math.abs(box.height - this.state.lastBoundingBox.height) > EPSILON$2) {
          this.setState({
            lastBoundingBox: {
              width: box.width,
              height: box.height
            }
          });
        }
      } else if (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) {
        this.setState({
          lastBoundingBox: {
            width: -1,
            height: -1
          }
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      document.addEventListener("keydown", this.handleKeyDown);
      this.updateBBox();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this$props$coordinat5, _this$props$coordinat6;
      if (this.props.active) {
        this.updateBBox();
      }
      if (!this.state.dismissed) {
        return;
      }
      if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {
        this.state.dismissed = false;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, children = _this$props.children, coordinate = _this$props.coordinate, hasPayload = _this$props.hasPayload, isAnimationActive = _this$props.isAnimationActive, offset2 = _this$props.offset, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;
      var _getTooltipTranslate = getTooltipTranslate({
        allowEscapeViewBox,
        coordinate,
        offsetTopLeft: offset2,
        position,
        reverseDirection,
        tooltipBox: this.state.lastBoundingBox,
        useTranslate3d,
        viewBox
      }), cssClasses = _getTooltipTranslate.cssClasses, cssProperties = _getTooltipTranslate.cssProperties;
      var outerStyle = _objectSpread$v(_objectSpread$v({
        transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0
      }, cssProperties), {}, {
        pointerEvents: "none",
        visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
        position: "absolute",
        top: 0,
        left: 0
      }, wrapperStyle);
      return (
        // This element allow listening to the `Escape` key.
        // See https://github.com/recharts/recharts/pull/2925
        /* @__PURE__ */ React.createElement("div", {
          tabIndex: -1,
          className: cssClasses,
          style: outerStyle,
          ref: function ref(node) {
            _this2.wrapperNode = node;
          }
        }, children)
      );
    }
  }]);
})(reactExports.PureComponent);
var parseIsSsrByDefault = function parseIsSsrByDefault2() {
  return !(typeof window !== "undefined" && window.document && window.document.createElement && window.setTimeout);
};
var Global = {
  isSsr: parseIsSsrByDefault()
};
function _typeof$A(o) {
  "@babel/helpers - typeof";
  return _typeof$A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$A(o);
}
function ownKeys$u(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$u(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$u(Object(t), true).forEach(function(r2) {
      _defineProperty$y(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$u(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$z(descriptor.key), descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$b(t, o, e) {
  return o = _getPrototypeOf$c(o), _possibleConstructorReturn$c(t, _isNativeReflectConstruct$c() ? Reflect.construct(o, e || [], _getPrototypeOf$c(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$c(self2, call) {
  if (call && (_typeof$A(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$c(o);
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o, p2) {
  _setPrototypeOf$c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$c(o, p2);
}
function _defineProperty$y(obj, key, value) {
  key = _toPropertyKey$z(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$z(t) {
  var i = _toPrimitive$z(t, "string");
  return "symbol" == _typeof$A(i) ? i : i + "";
}
function _toPrimitive$z(t, r) {
  if ("object" != _typeof$A(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$A(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function defaultUniqBy(entry) {
  return entry.dataKey;
}
function renderContent(content, props) {
  if (/* @__PURE__ */ React.isValidElement(content)) {
    return /* @__PURE__ */ React.cloneElement(content, props);
  }
  if (typeof content === "function") {
    return /* @__PURE__ */ React.createElement(content, props);
  }
  return /* @__PURE__ */ React.createElement(DefaultTooltipContent, props);
}
var Tooltip$1 = /* @__PURE__ */ (function(_PureComponent) {
  function Tooltip2() {
    _classCallCheck$f(this, Tooltip2);
    return _callSuper$b(this, Tooltip2, arguments);
  }
  _inherits$c(Tooltip2, _PureComponent);
  return _createClass$f(Tooltip2, [{
    key: "render",
    value: function render() {
      var _this = this;
      var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, content = _this$props.content, coordinate = _this$props.coordinate, filterNull = _this$props.filterNull, isAnimationActive = _this$props.isAnimationActive, offset2 = _this$props.offset, payload = _this$props.payload, payloadUniqBy = _this$props.payloadUniqBy, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;
      var finalPayload = payload !== null && payload !== void 0 ? payload : [];
      if (filterNull && finalPayload.length) {
        finalPayload = getUniqPayload(payload.filter(function(entry) {
          return entry.value != null && (entry.hide !== true || _this.props.includeHidden);
        }), payloadUniqBy, defaultUniqBy);
      }
      var hasPayload = finalPayload.length > 0;
      return /* @__PURE__ */ React.createElement(TooltipBoundingBox, {
        allowEscapeViewBox,
        animationDuration,
        animationEasing,
        isAnimationActive,
        active,
        coordinate,
        hasPayload,
        offset: offset2,
        position,
        reverseDirection,
        useTranslate3d,
        viewBox,
        wrapperStyle
      }, renderContent(content, _objectSpread$u(_objectSpread$u({}, this.props), {}, {
        payload: finalPayload
      })));
    }
  }]);
})(reactExports.PureComponent);
_defineProperty$y(Tooltip$1, "displayName", "Tooltip");
_defineProperty$y(Tooltip$1, "defaultProps", {
  accessibilityLayer: false,
  allowEscapeViewBox: {
    x: false,
    y: false
  },
  animationDuration: 400,
  animationEasing: "ease",
  contentStyle: {},
  coordinate: {
    x: 0,
    y: 0
  },
  cursor: true,
  cursorStyle: {},
  filterNull: true,
  isAnimationActive: !Global.isSsr,
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: false,
    y: false
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: false,
  viewBox: {
    x: 0,
    y: 0,
    height: 0,
    width: 0
  },
  wrapperStyle: {}
});
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now_1;
  hasRequiredNow = 1;
  var root = require_root();
  var now2 = function() {
    return root.Date.now();
  };
  now_1 = now2;
  return now_1;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string2) {
    var index2 = string2.length;
    while (index2-- && reWhitespace.test(string2.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var debounce_1;
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce_1;
  hasRequiredDebounce = 1;
  var isObject2 = requireIsObject(), now2 = requireNow(), toNumber = requireToNumber();
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time2) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time2;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time2) {
      lastInvokeTime = time2;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time2) : result;
    }
    function remainingWait(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time2 = now2();
      if (shouldInvoke(time2)) {
        return trailingEdge(time2);
      }
      timerId = setTimeout(timerExpired, remainingWait(time2));
    }
    function trailingEdge(time2) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time2);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now2());
    }
    function debounced() {
      var time2 = now2(), isInvoking = shouldInvoke(time2);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time2;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  debounce_1 = debounce;
  return debounce_1;
}
var throttle_1;
var hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle) return throttle_1;
  hasRequiredThrottle = 1;
  var debounce = requireDebounce(), isObject2 = requireIsObject();
  var FUNC_ERROR_TEXT = "Expected a function";
  function throttle2(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject2(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  throttle_1 = throttle2;
  return throttle_1;
}
var throttleExports = requireThrottle();
const throttle = /* @__PURE__ */ getDefaultExportFromCjs(throttleExports);
function _typeof$z(o) {
  "@babel/helpers - typeof";
  return _typeof$z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$z(o);
}
function ownKeys$t(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$t(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$t(Object(t), true).forEach(function(r2) {
      _defineProperty$x(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$t(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$x(obj, key, value) {
  key = _toPropertyKey$y(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$y(t) {
  var i = _toPrimitive$y(t, "string");
  return "symbol" == _typeof$z(i) ? i : i + "";
}
function _toPrimitive$y(t, r) {
  if ("object" != _typeof$z(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$z(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _slicedToArray$a(arr, i) {
  return _arrayWithHoles$b(arr) || _iterableToArrayLimit$a(arr, i) || _unsupportedIterableToArray$i(arr, i) || _nonIterableRest$b();
}
function _nonIterableRest$b() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$i(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$i(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen);
}
function _arrayLikeToArray$i(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$a(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$b(arr) {
  if (Array.isArray(arr)) return arr;
}
var ResponsiveContainer = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
  var aspect = _ref.aspect, _ref$initialDimension = _ref.initialDimension, initialDimension = _ref$initialDimension === void 0 ? {
    width: -1,
    height: -1
  } : _ref$initialDimension, _ref$width = _ref.width, width = _ref$width === void 0 ? "100%" : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? "100%" : _ref$height, _ref$minWidth = _ref.minWidth, minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce = _ref$debounce === void 0 ? 0 : _ref$debounce, id = _ref.id, className = _ref.className, onResize = _ref.onResize, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style;
  var containerRef = reactExports.useRef(null);
  var onResizeRef = reactExports.useRef();
  onResizeRef.current = onResize;
  reactExports.useImperativeHandle(ref, function() {
    return Object.defineProperty(containerRef.current, "current", {
      get: function get2() {
        console.warn("The usage of ref.current.current is deprecated and will no longer be supported.");
        return containerRef.current;
      },
      configurable: true
    });
  });
  var _useState = reactExports.useState({
    containerWidth: initialDimension.width,
    containerHeight: initialDimension.height
  }), _useState2 = _slicedToArray$a(_useState, 2), sizes = _useState2[0], setSizes = _useState2[1];
  var setContainerSize = reactExports.useCallback(function(newWidth, newHeight) {
    setSizes(function(prevState) {
      var roundedWidth = Math.round(newWidth);
      var roundedHeight = Math.round(newHeight);
      if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
        return prevState;
      }
      return {
        containerWidth: roundedWidth,
        containerHeight: roundedHeight
      };
    });
  }, []);
  reactExports.useEffect(function() {
    var callback = function callback2(entries) {
      var _onResizeRef$current;
      var _entries$0$contentRec = entries[0].contentRect, containerWidth2 = _entries$0$contentRec.width, containerHeight2 = _entries$0$contentRec.height;
      setContainerSize(containerWidth2, containerHeight2);
      (_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth2, containerHeight2);
    };
    if (debounce > 0) {
      callback = throttle(callback, debounce, {
        trailing: true,
        leading: false
      });
    }
    var observer = new ResizeObserver(callback);
    var _containerRef$current = containerRef.current.getBoundingClientRect(), containerWidth = _containerRef$current.width, containerHeight = _containerRef$current.height;
    setContainerSize(containerWidth, containerHeight);
    observer.observe(containerRef.current);
    return function() {
      observer.disconnect();
    };
  }, [setContainerSize, debounce]);
  var chartContent = reactExports.useMemo(function() {
    var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;
    if (containerWidth < 0 || containerHeight < 0) {
      return null;
    }
    warn(isPercent(width) || isPercent(height), "The width(%s) and height(%s) are both fixed numbers,\n       maybe you don't need to use a ResponsiveContainer.", width, height);
    warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
    var calculatedWidth = isPercent(width) ? containerWidth : width;
    var calculatedHeight = isPercent(height) ? containerHeight : height;
    if (aspect && aspect > 0) {
      if (calculatedWidth) {
        calculatedHeight = calculatedWidth / aspect;
      } else if (calculatedHeight) {
        calculatedWidth = calculatedHeight * aspect;
      }
      if (maxHeight && calculatedHeight > maxHeight) {
        calculatedHeight = maxHeight;
      }
    }
    warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
    var isCharts = !Array.isArray(children) && getDisplayName(children.type).endsWith("Chart");
    return React.Children.map(children, function(child) {
      if (/* @__PURE__ */ React.isValidElement(child)) {
        return /* @__PURE__ */ reactExports.cloneElement(child, _objectSpread$t({
          width: calculatedWidth,
          height: calculatedHeight
        }, isCharts ? {
          style: _objectSpread$t({
            height: "100%",
            width: "100%",
            maxHeight: calculatedHeight,
            maxWidth: calculatedWidth
          }, child.props.style)
        } : {}));
      }
      return child;
    });
  }, [aspect, children, height, maxHeight, minHeight, minWidth, sizes, width]);
  return /* @__PURE__ */ React.createElement("div", {
    id: id ? "".concat(id) : void 0,
    className: clsx("recharts-responsive-container", className),
    style: _objectSpread$t(_objectSpread$t({}, style), {}, {
      width,
      height,
      minWidth,
      minHeight,
      maxHeight
    }),
    ref: containerRef
  }, chartContent);
});
var Cell = function Cell2(_props) {
  return null;
};
Cell.displayName = "Cell";
function _typeof$y(o) {
  "@babel/helpers - typeof";
  return _typeof$y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$y(o);
}
function ownKeys$s(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$s(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$s(Object(t), true).forEach(function(r2) {
      _defineProperty$w(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$s(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$w(obj, key, value) {
  key = _toPropertyKey$x(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$x(t) {
  var i = _toPrimitive$x(t, "string");
  return "symbol" == _typeof$y(i) ? i : i + "";
}
function _toPrimitive$x(t, r) {
  if ("object" != _typeof$y(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$y(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var stringCache = {
  widthCache: {},
  cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function removeInvalidKeys(obj) {
  var copyObj = _objectSpread$s({}, obj);
  Object.keys(copyObj).forEach(function(key) {
    if (!copyObj[key]) {
      delete copyObj[key];
    }
  });
  return copyObj;
}
var getStringSize = function getStringSize2(text) {
  var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (text === void 0 || text === null || Global.isSsr) {
    return {
      width: 0,
      height: 0
    };
  }
  var copyStyle = removeInvalidKeys(style);
  var cacheKey = JSON.stringify({
    text,
    copyStyle
  });
  if (stringCache.widthCache[cacheKey]) {
    return stringCache.widthCache[cacheKey];
  }
  try {
    var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (!measurementSpan) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    var measurementSpanStyle = _objectSpread$s(_objectSpread$s({}, SPAN_STYLE), copyStyle);
    Object.assign(measurementSpan.style, measurementSpanStyle);
    measurementSpan.textContent = "".concat(text);
    var rect = measurementSpan.getBoundingClientRect();
    var result = {
      width: rect.width,
      height: rect.height
    };
    stringCache.widthCache[cacheKey] = result;
    if (++stringCache.cacheCount > MAX_CACHE_NUM) {
      stringCache.cacheCount = 0;
      stringCache.widthCache = {};
    }
    return result;
  } catch (e) {
    return {
      width: 0,
      height: 0
    };
  }
};
var getOffset = function getOffset2(rect) {
  return {
    top: rect.top + window.scrollY - document.documentElement.clientTop,
    left: rect.left + window.scrollX - document.documentElement.clientLeft
  };
};
function _typeof$x(o) {
  "@babel/helpers - typeof";
  return _typeof$x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$x(o);
}
function _slicedToArray$9(arr, i) {
  return _arrayWithHoles$a(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$h(arr, i) || _nonIterableRest$a();
}
function _nonIterableRest$a() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$h(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$h(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen);
}
function _arrayLikeToArray$h(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$9(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$a(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$w(descriptor.key), descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$e(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$w(t) {
  var i = _toPrimitive$w(t, "string");
  return "symbol" == _typeof$x(i) ? i : i + "";
}
function _toPrimitive$w(t, r) {
  if ("object" != _typeof$x(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$x(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
var CONVERSION_RATES = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  "in": 96,
  Q: 96 / (2.54 * 40),
  px: 1
};
var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
var STR_NAN = "NaN";
function convertToPx(value, unit2) {
  return value * CONVERSION_RATES[unit2];
}
var DecimalCSS = /* @__PURE__ */ (function() {
  function DecimalCSS2(num, unit2) {
    _classCallCheck$e(this, DecimalCSS2);
    this.num = num;
    this.unit = unit2;
    this.num = num;
    this.unit = unit2;
    if (Number.isNaN(num)) {
      this.unit = "";
    }
    if (unit2 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit2)) {
      this.num = NaN;
      this.unit = "";
    }
    if (FIXED_CSS_LENGTH_UNITS.includes(unit2)) {
      this.num = convertToPx(num, unit2);
      this.unit = "px";
    }
  }
  return _createClass$e(DecimalCSS2, [{
    key: "add",
    value: function add2(other) {
      if (this.unit !== other.unit) {
        return new DecimalCSS2(NaN, "");
      }
      return new DecimalCSS2(this.num + other.num, this.unit);
    }
  }, {
    key: "subtract",
    value: function subtract2(other) {
      if (this.unit !== other.unit) {
        return new DecimalCSS2(NaN, "");
      }
      return new DecimalCSS2(this.num - other.num, this.unit);
    }
  }, {
    key: "multiply",
    value: function multiply2(other) {
      if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
        return new DecimalCSS2(NaN, "");
      }
      return new DecimalCSS2(this.num * other.num, this.unit || other.unit);
    }
  }, {
    key: "divide",
    value: function divide2(other) {
      if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
        return new DecimalCSS2(NaN, "");
      }
      return new DecimalCSS2(this.num / other.num, this.unit || other.unit);
    }
  }, {
    key: "toString",
    value: function toString2() {
      return "".concat(this.num).concat(this.unit);
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return Number.isNaN(this.num);
    }
  }], [{
    key: "parse",
    value: function parse2(str) {
      var _NUM_SPLIT_REGEX$exec;
      var _ref = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [], _ref2 = _slicedToArray$9(_ref, 3), numStr = _ref2[1], unit2 = _ref2[2];
      return new DecimalCSS2(parseFloat(numStr), unit2 !== null && unit2 !== void 0 ? unit2 : "");
    }
  }]);
})();
function calculateArithmetic(expr) {
  if (expr.includes(STR_NAN)) {
    return STR_NAN;
  }
  var newExpr = expr;
  while (newExpr.includes("*") || newExpr.includes("/")) {
    var _MULTIPLY_OR_DIVIDE_R;
    var _ref3 = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [], _ref4 = _slicedToArray$9(_ref3, 4), leftOperand = _ref4[1], operator = _ref4[2], rightOperand = _ref4[3];
    var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
    var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
    var result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
    if (result.isNaN()) {
      return STR_NAN;
    }
    newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
  }
  while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
    var _ADD_OR_SUBTRACT_REGE;
    var _ref5 = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [], _ref6 = _slicedToArray$9(_ref5, 4), _leftOperand = _ref6[1], _operator = _ref6[2], _rightOperand = _ref6[3];
    var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
    var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
    var _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
    if (_result.isNaN()) {
      return STR_NAN;
    }
    newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
  }
  return newExpr;
}
var PARENTHESES_REGEX = /\(([^()]*)\)/;
function calculateParentheses(expr) {
  var newExpr = expr;
  while (newExpr.includes("(")) {
    var _PARENTHESES_REGEX$ex = PARENTHESES_REGEX.exec(newExpr), _PARENTHESES_REGEX$ex2 = _slicedToArray$9(_PARENTHESES_REGEX$ex, 2), parentheticalExpression = _PARENTHESES_REGEX$ex2[1];
    newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
  }
  return newExpr;
}
function evaluateExpression(expression) {
  var newExpr = expression.replace(/\s+/g, "");
  newExpr = calculateParentheses(newExpr);
  newExpr = calculateArithmetic(newExpr);
  return newExpr;
}
function safeEvaluateExpression(expression) {
  try {
    return evaluateExpression(expression);
  } catch (e) {
    return STR_NAN;
  }
}
function reduceCSSCalc(expression) {
  var result = safeEvaluateExpression(expression.slice(5, -1));
  if (result === STR_NAN) {
    return "";
  }
  return result;
}
var _excluded$c = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], _excluded2$5 = ["dx", "dy", "angle", "className", "breakAll"];
function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$l.apply(this, arguments);
}
function _objectWithoutProperties$c(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$c(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$c(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _slicedToArray$8(arr, i) {
  return _arrayWithHoles$9(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$g(arr, i) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$g(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen);
}
function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$8(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$9(arr) {
  if (Array.isArray(arr)) return arr;
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
var calculateWordWidths = function calculateWordWidths2(_ref) {
  var children = _ref.children, breakAll2 = _ref.breakAll, style = _ref.style;
  try {
    var words = [];
    if (!isNil(children)) {
      if (breakAll2) {
        words = children.toString().split("");
      } else {
        words = children.toString().split(BREAKING_SPACES);
      }
    }
    var wordsWithComputedWidth = words.map(function(word) {
      return {
        word,
        width: getStringSize(word, style).width
      };
    });
    var spaceWidth = breakAll2 ? 0 : getStringSize(" ", style).width;
    return {
      wordsWithComputedWidth,
      spaceWidth
    };
  } catch (e) {
    return null;
  }
};
var calculateWordsByLines = function calculateWordsByLines2(_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {
  var maxLines = _ref2.maxLines, children = _ref2.children, style = _ref2.style, breakAll2 = _ref2.breakAll;
  var shouldLimitLines = isNumber(maxLines);
  var text = children;
  var calculate = function calculate2() {
    var words = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return words.reduce(function(result2, _ref3) {
      var word = _ref3.word, width = _ref3.width;
      var currentLine = result2[result2.length - 1];
      if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
        currentLine.words.push(word);
        currentLine.width += width + spaceWidth;
      } else {
        var newLine = {
          words: [word],
          width
        };
        result2.push(newLine);
      }
      return result2;
    }, []);
  };
  var originalResult = calculate(initialWordsWithComputedWith);
  var findLongestLine = function findLongestLine2(words) {
    return words.reduce(function(a2, b) {
      return a2.width > b.width ? a2 : b;
    });
  };
  if (!shouldLimitLines) {
    return originalResult;
  }
  var suffix = "…";
  var checkOverflow = function checkOverflow2(index2) {
    var tempText = text.slice(0, index2);
    var words = calculateWordWidths({
      breakAll: breakAll2,
      style,
      children: tempText + suffix
    }).wordsWithComputedWidth;
    var result2 = calculate(words);
    var doesOverflow = result2.length > maxLines || findLongestLine(result2).width > Number(lineWidth);
    return [doesOverflow, result2];
  };
  var start2 = 0;
  var end = text.length - 1;
  var iterations = 0;
  var trimmedResult;
  while (start2 <= end && iterations <= text.length - 1) {
    var middle = Math.floor((start2 + end) / 2);
    var prev = middle - 1;
    var _checkOverflow = checkOverflow(prev), _checkOverflow2 = _slicedToArray$8(_checkOverflow, 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1];
    var _checkOverflow3 = checkOverflow(middle), _checkOverflow4 = _slicedToArray$8(_checkOverflow3, 1), doesMiddleOverflow = _checkOverflow4[0];
    if (!doesPrevOverflow && !doesMiddleOverflow) {
      start2 = middle + 1;
    }
    if (doesPrevOverflow && doesMiddleOverflow) {
      end = middle - 1;
    }
    if (!doesPrevOverflow && doesMiddleOverflow) {
      trimmedResult = result;
      break;
    }
    iterations++;
  }
  return trimmedResult || originalResult;
};
var getWordsWithoutCalculate = function getWordsWithoutCalculate2(children) {
  var words = !isNil(children) ? children.toString().split(BREAKING_SPACES) : [];
  return [{
    words
  }];
};
var getWordsByLines = function getWordsByLines2(_ref4) {
  var width = _ref4.width, scaleToFit = _ref4.scaleToFit, children = _ref4.children, style = _ref4.style, breakAll2 = _ref4.breakAll, maxLines = _ref4.maxLines;
  if ((width || scaleToFit) && !Global.isSsr) {
    var wordsWithComputedWidth, spaceWidth;
    var wordWidths = calculateWordWidths({
      breakAll: breakAll2,
      children,
      style
    });
    if (wordWidths) {
      var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;
      wordsWithComputedWidth = wcw;
      spaceWidth = sw;
    } else {
      return getWordsWithoutCalculate(children);
    }
    return calculateWordsByLines({
      breakAll: breakAll2,
      children,
      maxLines,
      style
    }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
  }
  return getWordsWithoutCalculate(children);
};
var DEFAULT_FILL = "#808080";
var Text = function Text2(_ref5) {
  var _ref5$x = _ref5.x, propsX = _ref5$x === void 0 ? 0 : _ref5$x, _ref5$y = _ref5.y, propsY = _ref5$y === void 0 ? 0 : _ref5$y, _ref5$lineHeight = _ref5.lineHeight, lineHeight = _ref5$lineHeight === void 0 ? "1em" : _ref5$lineHeight, _ref5$capHeight = _ref5.capHeight, capHeight = _ref5$capHeight === void 0 ? "0.71em" : _ref5$capHeight, _ref5$scaleToFit = _ref5.scaleToFit, scaleToFit = _ref5$scaleToFit === void 0 ? false : _ref5$scaleToFit, _ref5$textAnchor = _ref5.textAnchor, textAnchor = _ref5$textAnchor === void 0 ? "start" : _ref5$textAnchor, _ref5$verticalAnchor = _ref5.verticalAnchor, verticalAnchor = _ref5$verticalAnchor === void 0 ? "end" : _ref5$verticalAnchor, _ref5$fill = _ref5.fill, fill = _ref5$fill === void 0 ? DEFAULT_FILL : _ref5$fill, props = _objectWithoutProperties$c(_ref5, _excluded$c);
  var wordsByLines = reactExports.useMemo(function() {
    return getWordsByLines({
      breakAll: props.breakAll,
      children: props.children,
      maxLines: props.maxLines,
      scaleToFit,
      style: props.style,
      width: props.width
    });
  }, [props.breakAll, props.children, props.maxLines, scaleToFit, props.style, props.width]);
  var dx = props.dx, dy = props.dy, angle2 = props.angle, className = props.className, breakAll2 = props.breakAll, textProps = _objectWithoutProperties$c(props, _excluded2$5);
  if (!isNumOrStr(propsX) || !isNumOrStr(propsY)) {
    return null;
  }
  var x2 = propsX + (isNumber(dx) ? dx : 0);
  var y2 = propsY + (isNumber(dy) ? dy : 0);
  var startDy;
  switch (verticalAnchor) {
    case "start":
      startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
      break;
    case "middle":
      startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
      break;
    default:
      startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
      break;
  }
  var transforms = [];
  if (scaleToFit) {
    var lineWidth = wordsByLines[0].width;
    var width = props.width;
    transforms.push("scale(".concat((isNumber(width) ? width / lineWidth : 1) / lineWidth, ")"));
  }
  if (angle2) {
    transforms.push("rotate(".concat(angle2, ", ").concat(x2, ", ").concat(y2, ")"));
  }
  if (transforms.length) {
    textProps.transform = transforms.join(" ");
  }
  return /* @__PURE__ */ React.createElement("text", _extends$l({}, filterProps(textProps, true), {
    x: x2,
    y: y2,
    className: clsx("recharts-text", className),
    textAnchor,
    fill: fill.includes("url") ? DEFAULT_FILL : fill
  }), wordsByLines.map(function(line, index2) {
    var words = line.words.join(breakAll2 ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ React.createElement("tspan", {
        x: x2,
        dy: index2 === 0 ? startDy : lineHeight,
        key: "".concat(words, "-").concat(index2)
      }, words)
    );
  }));
};
function ascending(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function descending(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x2) => ascending(f(d), x2);
    delta = (d, x2) => f(d) - x2;
  } else {
    compare1 = f === ascending || f === descending ? f : zero$1;
    compare2 = f;
    delta = f;
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero$1() {
  return 0;
}
function number$2(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values, valueof) {
  {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a2, b) => {
    const x2 = compare(a2, b);
    if (x2 || x2 === 0) return x2;
    return (compare(b, b) === 0) - (compare(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b) {
  return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
}
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start2, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  if (!(count2 > 0)) return [];
  if (start2 === stop) return [start2];
  const reverse3 = stop < start2, [i1, i2, inc] = reverse3 ? tickSpec(stop, start2, count2) : tickSpec(start2, stop, count2);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse3) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse3 = stop < start2, inc = reverse3 ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse3 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function max$1(values, valueof) {
  let max2;
  {
    for (const value of values) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min$1(values, valueof) {
  let min2;
  {
    for (const value of values) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
function quickselect(array2, k2, left = 0, right = Infinity, compare) {
  k2 = Math.floor(k2);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array2.length - 1, right));
  if (!(left <= k2 && k2 <= right)) return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m2 = k2 - left + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n + sd));
      const newRight = Math.min(right, Math.floor(k2 + (n - m2) * s2 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left;
    let j = right;
    swap(array2, left, k2);
    if (compare(array2[right], t) > 0) swap(array2, left, right);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0) ++i;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left], t) === 0) swap(array2, left, j);
    else ++j, swap(array2, j, right);
    if (j <= k2) left = j + 1;
    if (k2 <= j) right = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}
function quantile$1(values, p2, valueof) {
  values = Float64Array.from(numbers(values));
  if (!(n = values.length) || isNaN(p2 = +p2)) return;
  if (p2 <= 0 || n < 2) return min$1(values);
  if (p2 >= 1) return max$1(values);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = max$1(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min$1(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p2, valueof = number$2) {
  if (!(n = values.length) || isNaN(p2 = +p2)) return;
  if (p2 <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p2 >= 1) return +valueof(values[n - 1], n - 1, values);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}
function range$2(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range3 = new Array(n);
  while (++i < n) {
    range3[i] = start2 + i * step;
  }
  return range3;
}
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range3 = [], unknown = implicit;
  function scale2(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit) return unknown;
      index2.set(d, i = domain.push(d) - 1);
    }
    return range3[i % range3.length];
  }
  scale2.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _) {
      if (index2.has(value)) continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale2;
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), scale2) : range3.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round2) step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round2) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range$2(n).map(function(i) {
      return start2 + step * i;
    });
    return ordinalRange(reverse3 ? values.reverse() : values);
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_) {
    return arguments.length ? (round2 = !!_, rescale()) : round2;
  };
  scale2.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale2.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale2) {
  var copy2 = scale2.copy;
  scale2.padding = scale2.paddingOuter;
  delete scale2.paddingInner;
  delete scale2.paddingOuter;
  scale2.copy = function() {
    return pointish(copy2());
  };
  return scale2;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s2 = max2 - min2, l = (max2 + min2) / 2;
  if (s2) {
    if (r === max2) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max2) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const constant = (x2) => () => x2;
function linear$1(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
    return Math.pow(a2 + t * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear$1(a2, d) : constant(isNaN(a2) ? b : a2);
}
const rgb = (function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb$1(start2)).r, (end = rgb$1(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
})(1);
function numberArray(a2, b) {
  if (!b) b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c2[i] = a2[i] * (1 - t) + b[i] * t;
    return c2;
  };
}
function isNumberArray$1(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i) x2[i] = interpolate(a2[i], b[i]);
  for (; i < nb; ++i) c2[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c2[i] = x2[i](t);
    return c2;
  };
}
function date$1(a2, b) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}
function interpolateNumber$1(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}
function object(a2, b) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b === null || typeof b !== "object") b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = interpolate(a2[k2], b[k2]);
    } else {
      c2[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i) c2[k2] = i[k2](t);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i]) s2[i] += bm;
      else s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: interpolateNumber$1(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i]) s2[i] += bs;
    else s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}
function interpolate(a2, b) {
  var t = typeof b, c2;
  return b == null || t === "boolean" ? constant(b) : (t === "number" ? interpolateNumber$1 : t === "string" ? (c2 = color(b)) ? (b = c2, rgb) : string : b instanceof color ? rgb : b instanceof Date ? date$1 : isNumberArray$1(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber$1)(a2, b);
}
function interpolateRound(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}
function piecewise(interpolate$1, values) {
  if (values === void 0) values = interpolate$1, interpolate$1 = interpolate;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate$1(v, v = values[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$5(x2) {
  return x2;
}
function normalize$1(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t;
  if (a2 > b) t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range3, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0) d0 = normalize$1(d1, d0), r0 = interpolate2(r1, r0);
  else d0 = normalize$1(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range3, interpolate2) {
  var j = Math.min(domain.length, range3.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize$1(domain[i], domain[i + 1]);
    r[i] = interpolate2(range3[i], range3[i + 1]);
  }
  return function(x2) {
    var i2 = bisectRight(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy$2(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
  var domain = unit, range3 = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp2 = identity$5, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range3.length);
    if (clamp2 !== identity$5) clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range3, interpolate$1)))(transform(clamp2(x2)));
  }
  scale2.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise2(range3, domain.map(transform), interpolateNumber$1)))(y2)));
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale2.rangeRound = function(_) {
    return range3 = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity$5, rescale()) : clamp2 !== identity$5;
  };
  scale2.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t, u2) {
    transform = t, untransform = u2;
    return rescale();
  };
}
function continuous() {
  return transformer$2()(identity$5, identity$5);
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p2) {
  if ((i = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s2[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s2[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p2) {
  var d = formatDecimalParts(x2, p2);
  if (!d) return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i - 1))[0];
}
function formatRounded(x2, p2) {
  var d = formatDecimalParts(x2, p2);
  if (!d) return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x2, p2) => (x2 * 100).toFixed(p2),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p2) => x2.toExponential(p2),
  "f": (x2, p2) => x2.toFixed(p2),
  "g": (x2, p2) => x2.toPrecision(p2),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p2) => formatRounded(x2 * 100, p2),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$4(x2) {
  return x2;
}
var map$3 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$4 : formatGroup(map$3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$4 : formatNumerals(map$3.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$1;
var format;
var formatPrefix;
defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format = locale$1.format;
  formatPrefix = locale$1.formatPrefix;
  return locale$1;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale2.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale2.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy$2(scale2, linear());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
function identity$3(domain) {
  var unknown;
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
  }
  scale2.invert = scale2;
  scale2.domain = scale2.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number$1), scale2) : domain.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return identity$3(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
  return linearish(scale2);
}
function nice(domain, interval) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f) {
  return (x2, k2) => -f(-x2, k2);
}
function loggish(transform) {
  const scale2 = transform(transformLog, transformExp);
  const domain = scale2.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.ticks = (count2) => {
    const d = domain();
    let u2 = d[0];
    let v = d[d.length - 1];
    const r = v < u2;
    if (r) [u2, v] = [v, u2];
    let i = logs(u2);
    let j = logs(v);
    let k2;
    let t;
    const n = count2 == null ? 10 : +count2;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u2 > 0) for (; i <= j; ++i) {
        for (k2 = 1; k2 < base; ++k2) {
          t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u2) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      else for (; i <= j; ++i) {
        for (k2 = base - 1; k2 >= 1; --k2) {
          t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u2) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u2, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale2.tickFormat = (count2, specifier) => {
    if (count2 == null) count2 = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity) return specifier;
    const k2 = Math.max(1, base * count2 / scale2.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale2.nice = () => {
    return domain(nice(domain(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale2;
}
function log$2() {
  const scale2 = loggish(transformer$2()).domain([1, 10]);
  scale2.copy = () => copy$2(scale2, log$2()).base(scale2.base());
  initRange.apply(scale2, arguments);
  return scale2;
}
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform) {
  var c2 = 1, scale2 = transform(transformSymlog(c2), transformSymexp(c2));
  scale2.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale2);
}
function symlog() {
  var scale2 = symlogish(transformer$2());
  scale2.copy = function() {
    return copy$2(scale2, symlog()).constant(scale2.constant());
  };
  return initRange.apply(scale2, arguments);
}
function transformPow(exponent2) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform) {
  var scale2 = transform(identity$5, identity$5), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform(identity$5, identity$5) : exponent2 === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale2.exponent = function(_) {
    return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
  };
  return linearish(scale2);
}
function pow() {
  var scale2 = powish(transformer$2());
  scale2.copy = function() {
    return copy$2(scale2, pow()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}
function square(x2) {
  return Math.sign(x2) * x2 * x2;
}
function unsquare(x2) {
  return Math.sign(x2) * Math.sqrt(Math.abs(x2));
}
function radial() {
  var squared = continuous(), range3 = [0, 1], round2 = false, unknown;
  function scale2(x2) {
    var y2 = unsquare(squared(x2));
    return isNaN(y2) ? unknown : round2 ? Math.round(y2) : y2;
  }
  scale2.invert = function(y2) {
    return squared.invert(square(y2));
  };
  scale2.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale2) : squared.domain();
  };
  scale2.range = function(_) {
    return arguments.length ? (squared.range((range3 = Array.from(_, number$1)).map(square)), scale2) : range3.slice();
  };
  scale2.rangeRound = function(_) {
    return scale2.range(_).round(true);
  };
  scale2.round = function(_) {
    return arguments.length ? (round2 = !!_, scale2) : round2;
  };
  scale2.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale2) : squared.clamp();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return radial(squared.domain(), range3).round(round2).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
function quantile() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range3.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale2;
  }
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range3[bisectRight(thresholds, x2)];
  }
  scale2.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale2.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.quantiles = function() {
    return thresholds.slice();
  };
  scale2.copy = function() {
    return quantile().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
function quantize() {
  var x0 = 0, x1 = 1, n = 1, domain = [0.5], range3 = [0, 1], unknown;
  function scale2(x2) {
    return x2 != null && x2 <= x2 ? range3[bisectRight(domain, x2, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale2;
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale2.range = function(_) {
    return arguments.length ? (n = (range3 = Array.from(_)).length - 1, rescale()) : range3.slice();
  };
  scale2.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : scale2;
  };
  scale2.thresholds = function() {
    return domain.slice();
  };
  scale2.copy = function() {
    return quantize().domain([x0, x1]).range(range3).unknown(unknown);
  };
  return initRange.apply(linearish(scale2), arguments);
}
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n = 1;
  function scale2(x2) {
    return x2 != null && x2 <= x2 ? range3[bisectRight(domain, x2, 0, n)] : unknown;
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range3.length - 1), scale2) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), n = Math.min(domain.length, range3.length - 1), scale2) : range3.slice();
  };
  scale2.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = (date2) => {
    const d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = (start2, stop, step) => {
    const range3 = [];
    start2 = interval.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0)) return range3;
    let previous;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range3;
  };
  interval.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval.count = (start2, end) => {
      t0.setTime(+start2), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
    };
  }
  return interval;
}
const millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start2, end) => {
  return end - start2;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0)) return null;
  if (!(k2 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k2);
  }, (start2, end) => {
    return (end - start2) / k2;
  });
};
millisecond.range;
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
const second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start2, end) => {
  return (end - start2) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
second.range;
const timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
timeMinute.range;
const utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
utcMinute.range;
const timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getHours();
});
timeHour.range;
const utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
utcHour.range;
const timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
timeDay.range;
const utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
utcDay.range;
const unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
unixDay.range;
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start2, end) => {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
timeMonth.range;
const utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start2, end) => {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
utcMonth.range;
const timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start2, end) => {
  return end.getFullYear() - start2.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
timeYear.range;
const utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start2, end) => {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
utcYear.range;
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse3 = stop < start2;
    if (reverse3) [start2, stop] = [stop, start2];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval ? interval.range(start2, +stop + 1) : [];
    return reverse3 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i === 0) return millisecond.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m2, d) {
  return { y: y2, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string2.push(specifier.slice(j, i));
          if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null) c2 = specifier.charAt(++i);
          else pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2]) c2 = format2(date2, pad2);
          string2.push(c2);
          j = i + 1;
        }
      }
      string2.push(specifier.slice(j, i));
      return string2.join("");
    };
  }
  function newParse(specifier, Z2) {
    return function(string2) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week, day;
      if (i != string2.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z2 && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string2, j) {
    var i = 0, n = specifier.length, m2 = string2.length, c2, parse2;
    while (i < n) {
      if (j >= m2) return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse2 || (j = parse2(d, string2, j)) < 0) return -1;
      } else if (c2 != string2.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string2, i) {
    var n = periodRe.exec(string2.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string2, i) {
    var n = shortWeekdayRe.exec(string2.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string2, i) {
    var n = weekdayRe.exec(string2.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string2, i) {
    var n = shortMonthRe.exec(string2.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string2, i) {
    var n = monthRe.exec(string2.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string2, i) {
    return parseSpecifier(d, locale_dateTime, string2, i);
  }
  function parseLocaleDate(d, string2, i) {
    return parseSpecifier(d, locale_date, string2, i);
  }
  function parseLocaleTime(d, string2, i) {
    return parseSpecifier(d, locale_time, string2, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p2 = newParse(specifier += "", false);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p2 = newParse(specifier += "", true);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length = string2.length;
  return sign2 + (length < width ? new Array(width - length + 1).join(fill) + string2 : string2);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string2, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string2, i) {
  var n = percentRe.exec(string2.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p2) {
  return pad(d.getDate(), p2, 2);
}
function formatHour24(d, p2) {
  return pad(d.getHours(), p2, 2);
}
function formatHour12(d, p2) {
  return pad(d.getHours() % 12 || 12, p2, 2);
}
function formatDayOfYear(d, p2) {
  return pad(1 + timeDay.count(timeYear(d), d), p2, 3);
}
function formatMilliseconds(d, p2) {
  return pad(d.getMilliseconds(), p2, 3);
}
function formatMicroseconds(d, p2) {
  return formatMilliseconds(d, p2) + "000";
}
function formatMonthNumber(d, p2) {
  return pad(d.getMonth() + 1, p2, 2);
}
function formatMinutes(d, p2) {
  return pad(d.getMinutes(), p2, 2);
}
function formatSeconds(d, p2) {
  return pad(d.getSeconds(), p2, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p2) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p2, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p2) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p2, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p2) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p2, 2);
}
function formatYear(d, p2) {
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatYearISO(d, p2) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatFullYear(d, p2) {
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatFullYearISO(d, p2) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p2) {
  return pad(d.getUTCDate(), p2, 2);
}
function formatUTCHour24(d, p2) {
  return pad(d.getUTCHours(), p2, 2);
}
function formatUTCHour12(d, p2) {
  return pad(d.getUTCHours() % 12 || 12, p2, 2);
}
function formatUTCDayOfYear(d, p2) {
  return pad(1 + utcDay.count(utcYear(d), d), p2, 3);
}
function formatUTCMilliseconds(d, p2) {
  return pad(d.getUTCMilliseconds(), p2, 3);
}
function formatUTCMicroseconds(d, p2) {
  return formatUTCMilliseconds(d, p2) + "000";
}
function formatUTCMonthNumber(d, p2) {
  return pad(d.getUTCMonth() + 1, p2, 2);
}
function formatUTCMinutes(d, p2) {
  return pad(d.getUTCMinutes(), p2, 2);
}
function formatUTCSeconds(d, p2) {
  return pad(d.getUTCSeconds(), p2, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p2) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p2, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p2) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p2, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p2) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p2, 2);
}
function formatUTCYear(d, p2) {
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCYearISO(d, p2) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCFullYear(d, p2) {
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCFullYearISO(d, p2) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var locale;
var timeFormat;
var utcFormat;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  locale.parse;
  utcFormat = locale.utcFormat;
  locale.utcParse;
  return locale;
}
function date(t) {
  return new Date(t);
}
function number(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  var scale2 = continuous(), invert2 = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale2.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale2.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };
  scale2.ticks = function(interval) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };
  scale2.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale2.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d, interval)) : scale2;
  };
  scale2.copy = function() {
    return copy$2(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale2;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
  var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$5, clamp2 = false, unknown;
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale2) : [x0, x1];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range3(interpolate2) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale2) : [interpolator(0), interpolator(1)];
    };
  }
  scale2.range = range3(interpolate);
  scale2.rangeRound = range3(interpolateRound);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t) {
    transform = t, t02 = t(x0), t12 = t(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale2;
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale2 = linearish(transformer$1()(identity$5));
  scale2.copy = function() {
    return copy$1(scale2, sequential());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialLog() {
  var scale2 = loggish(transformer$1()).domain([1, 10]);
  scale2.copy = function() {
    return copy$1(scale2, sequentialLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSymlog() {
  var scale2 = symlogish(transformer$1());
  scale2.copy = function() {
    return copy$1(scale2, sequentialSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialPow() {
  var scale2 = powish(transformer$1());
  scale2.copy = function() {
    return copy$1(scale2, sequentialPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function sequentialQuantile() {
  var domain = [], interpolator = identity$5;
  function scale2(x2) {
    if (x2 != null && !isNaN(x2 = +x2)) return interpolator((bisectRight(domain, x2, 1) - 1) / (domain.length - 1));
  }
  scale2.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return scale2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  scale2.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };
  scale2.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (_, i) => quantile$1(domain, i / n));
  };
  scale2.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale2, arguments);
}
function transformer() {
  var x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t02, t12, t2, k10, k21, interpolator = identity$5, transform, clamp2 = false, unknown;
  function scale2(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t12) * (s2 * x3 < s2 * t12 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1, scale2) : [x0, x1, x2];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range3(interpolate2) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale2.range = range3(interpolate);
  scale2.rangeRound = range3(interpolateRound);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t) {
    transform = t, t02 = t(x0), t12 = t(x1), t2 = t(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1;
    return scale2;
  };
}
function diverging() {
  var scale2 = linearish(transformer()(identity$5));
  scale2.copy = function() {
    return copy$1(scale2, diverging());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingLog() {
  var scale2 = loggish(transformer()).domain([0.1, 1, 10]);
  scale2.copy = function() {
    return copy$1(scale2, divergingLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSymlog() {
  var scale2 = symlogish(transformer());
  scale2.copy = function() {
    return copy$1(scale2, divergingSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingPow() {
  var scale2 = powish(transformer());
  scale2.copy = function() {
    return copy$1(scale2, divergingPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
const d3Scales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: band,
  scaleDiverging: diverging,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  scaleIdentity: identity$3,
  scaleImplicit: implicit,
  scaleLinear: linear,
  scaleLog: log$2,
  scaleOrdinal: ordinal,
  scalePoint: point,
  scalePow: pow,
  scaleQuantile: quantile,
  scaleQuantize: quantize,
  scaleRadial: radial,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialQuantile: sequentialQuantile,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSqrt: sqrt,
  scaleSymlog: symlog,
  scaleThreshold: threshold,
  scaleTime: time,
  scaleUtc: utcTime,
  tickFormat
}, Symbol.toStringTag, { value: "Module" }));
var _baseExtremum;
var hasRequired_baseExtremum;
function require_baseExtremum() {
  if (hasRequired_baseExtremum) return _baseExtremum;
  hasRequired_baseExtremum = 1;
  var isSymbol = requireIsSymbol();
  function baseExtremum(array2, iteratee, comparator) {
    var index2 = -1, length = array2.length;
    while (++index2 < length) {
      var value = array2[index2], current = iteratee(value);
      if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
        var computed = current, result = value;
      }
    }
    return result;
  }
  _baseExtremum = baseExtremum;
  return _baseExtremum;
}
var _baseGt;
var hasRequired_baseGt;
function require_baseGt() {
  if (hasRequired_baseGt) return _baseGt;
  hasRequired_baseGt = 1;
  function baseGt(value, other) {
    return value > other;
  }
  _baseGt = baseGt;
  return _baseGt;
}
var max_1;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max_1;
  hasRequiredMax = 1;
  var baseExtremum = require_baseExtremum(), baseGt = require_baseGt(), identity4 = requireIdentity();
  function max2(array2) {
    return array2 && array2.length ? baseExtremum(array2, identity4, baseGt) : void 0;
  }
  max_1 = max2;
  return max_1;
}
var maxExports = requireMax();
const max = /* @__PURE__ */ getDefaultExportFromCjs(maxExports);
var _baseLt;
var hasRequired_baseLt;
function require_baseLt() {
  if (hasRequired_baseLt) return _baseLt;
  hasRequired_baseLt = 1;
  function baseLt(value, other) {
    return value < other;
  }
  _baseLt = baseLt;
  return _baseLt;
}
var min_1;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min_1;
  hasRequiredMin = 1;
  var baseExtremum = require_baseExtremum(), baseLt = require_baseLt(), identity4 = requireIdentity();
  function min2(array2) {
    return array2 && array2.length ? baseExtremum(array2, identity4, baseLt) : void 0;
  }
  min_1 = min2;
  return min_1;
}
var minExports = requireMin();
const min = /* @__PURE__ */ getDefaultExportFromCjs(minExports);
var map_1;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map_1;
  hasRequiredMap = 1;
  var arrayMap = require_arrayMap(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), isArray2 = requireIsArray();
  function map2(collection, iteratee) {
    var func = isArray2(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  map_1 = map2;
  return map_1;
}
var flatMap_1;
var hasRequiredFlatMap;
function requireFlatMap() {
  if (hasRequiredFlatMap) return flatMap_1;
  hasRequiredFlatMap = 1;
  var baseFlatten = require_baseFlatten(), map2 = requireMap();
  function flatMap2(collection, iteratee) {
    return baseFlatten(map2(collection, iteratee), 1);
  }
  flatMap_1 = flatMap2;
  return flatMap_1;
}
var flatMapExports = requireFlatMap();
const flatMap = /* @__PURE__ */ getDefaultExportFromCjs(flatMapExports);
var isEqual_1;
var hasRequiredIsEqual;
function requireIsEqual() {
  if (hasRequiredIsEqual) return isEqual_1;
  hasRequiredIsEqual = 1;
  var baseIsEqual = require_baseIsEqual();
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  isEqual_1 = isEqual2;
  return isEqual_1;
}
var isEqualExports = requireIsEqual();
const isEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(isEqualExports);
var MAX_DIGITS = 1e9, defaults = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P$1 = {};
P$1.absoluteValue = P$1.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s) x2.s = 1;
  return x2;
};
P$1.comparedTo = P$1.cmp = function(y2) {
  var i, j, xdL, ydL, x2 = this;
  y2 = new x2.constructor(y2);
  if (x2.s !== y2.s) return x2.s || -y2.s;
  if (x2.e !== y2.e) return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
  xdL = x2.d.length;
  ydL = y2.d.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (x2.d[i] !== y2.d[i]) return x2.d[i] > y2.d[i] ^ x2.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
};
P$1.decimalPlaces = P$1.dp = function() {
  var x2 = this, w = x2.d.length - 1, dp = (w - x2.e) * LOG_BASE;
  w = x2.d[w];
  if (w) for (; w % 10 == 0; w /= 10) dp--;
  return dp < 0 ? 0 : dp;
};
P$1.dividedBy = P$1.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P$1.dividedToIntegerBy = P$1.idiv = function(y2) {
  var x2 = this, Ctor = x2.constructor;
  return round$1(divide(x2, new Ctor(y2), 0, 1), Ctor.precision);
};
P$1.equals = P$1.eq = function(y2) {
  return !this.cmp(y2);
};
P$1.exponent = function() {
  return getBase10Exponent(this);
};
P$1.greaterThan = P$1.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P$1.greaterThanOrEqualTo = P$1.gte = function(y2) {
  return this.cmp(y2) >= 0;
};
P$1.isInteger = P$1.isint = function() {
  return this.e > this.d.length - 2;
};
P$1.isNegative = P$1.isneg = function() {
  return this.s < 0;
};
P$1.isPositive = P$1.ispos = function() {
  return this.s > 0;
};
P$1.isZero = function() {
  return this.s === 0;
};
P$1.lessThan = P$1.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P$1.lessThanOrEqualTo = P$1.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P$1.logarithm = P$1.log = function(base) {
  var r, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);
    if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
  }
  if (x2.s < 1) throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
  if (x2.eq(ONE)) return new Ctor(0);
  external = false;
  r = divide(ln(x2, wpr), ln(base, wpr), wpr);
  external = true;
  return round$1(r, pr);
};
P$1.minus = P$1.sub = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? subtract$1(x2, y2) : add$2(x2, (y2.s = -y2.s, y2));
};
P$1.modulo = P$1.mod = function(y2) {
  var q, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
  y2 = new Ctor(y2);
  if (!y2.s) throw Error(decimalError + "NaN");
  if (!x2.s) return round$1(new Ctor(x2), pr);
  external = false;
  q = divide(x2, y2, 0, 1).times(y2);
  external = true;
  return x2.minus(q);
};
P$1.naturalExponential = P$1.exp = function() {
  return exp(this);
};
P$1.naturalLogarithm = P$1.ln = function() {
  return ln(this);
};
P$1.negated = P$1.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s || 0;
  return x2;
};
P$1.plus = P$1.add = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? add$2(x2, y2) : subtract$1(x2, (y2.s = -y2.s, y2));
};
P$1.precision = P$1.sd = function(z) {
  var e, sd, w, x2 = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  e = getBase10Exponent(x2) + 1;
  w = x2.d.length - 1;
  sd = w * LOG_BASE + 1;
  w = x2.d[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) sd--;
    for (w = x2.d[0]; w >= 10; w /= 10) sd++;
  }
  return z && e > sd ? e : sd;
};
P$1.squareRoot = P$1.sqrt = function() {
  var e, n, pr, r, s2, t, wpr, x2 = this, Ctor = x2.constructor;
  if (x2.s < 1) {
    if (!x2.s) return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e = getBase10Exponent(x2);
  external = false;
  s2 = Math.sqrt(+x2);
  if (s2 == 0 || s2 == 1 / 0) {
    n = digitsToString(x2.d);
    if ((n.length + e) % 2 == 0) n += "0";
    s2 = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s2 == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s2.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s2.toString());
  }
  pr = Ctor.precision;
  s2 = wpr = pr + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x2, t, wpr + 2)).times(0.5);
    if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
      n = n.slice(wpr - 3, wpr + 1);
      if (s2 == wpr && n == "4999") {
        round$1(t, pr + 1, 0);
        if (t.times(t).eq(x2)) {
          r = t;
          break;
        }
      } else if (n != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round$1(r, pr);
};
P$1.times = P$1.mul = function(y2) {
  var carry, e, i, k2, r, rL, t, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
  if (!x2.s || !y2.s) return new Ctor(0);
  y2.s *= x2.s;
  e = x2.e + y2.e;
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k2 = xdL + i; k2 > i; ) {
      t = r[k2] + yd[i] * xd[k2 - i - 1] + carry;
      r[k2--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k2] = (r[k2] + carry) % BASE | 0;
  }
  for (; !r[--rL]; ) r.pop();
  if (carry) ++e;
  else r.shift();
  y2.d = r;
  y2.e = e;
  return external ? round$1(y2, Ctor.precision) : y2;
};
P$1.toDecimalPlaces = P$1.todp = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0) return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return round$1(x2, dp + getBase10Exponent(x2) + 1, rm);
};
P$1.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = toString(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = round$1(new Ctor(x2), dp + 1, rm);
    str = toString(x2, true, dp + 1);
  }
  return str;
};
P$1.toFixed = function(dp, rm) {
  var str, y2, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) return toString(x2);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  y2 = round$1(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
  str = toString(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
  return x2.isneg() && !x2.isZero() ? "-" + str : str;
};
P$1.toInteger = P$1.toint = function() {
  var x2 = this, Ctor = x2.constructor;
  return round$1(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
};
P$1.toNumber = function() {
  return +this;
};
P$1.toPower = P$1.pow = function(y2) {
  var e, k2, pr, r, sign2, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn = +(y2 = new Ctor(y2));
  if (!y2.s) return new Ctor(ONE);
  x2 = new Ctor(x2);
  if (!x2.s) {
    if (y2.s < 1) throw Error(decimalError + "Infinity");
    return x2;
  }
  if (x2.eq(ONE)) return x2;
  pr = Ctor.precision;
  if (y2.eq(ONE)) return round$1(x2, pr);
  e = y2.e;
  k2 = y2.d.length - 1;
  yIsInt = e >= k2;
  sign2 = x2.s;
  if (!yIsInt) {
    if (sign2 < 0) throw Error(decimalError + "NaN");
  } else if ((k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = new Ctor(ONE);
    e = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k2 % 2) {
        r = r.times(x2);
        truncate(r.d, e);
      }
      k2 = mathfloor(k2 / 2);
      if (k2 === 0) break;
      x2 = x2.times(x2);
      truncate(x2.d, e);
    }
    external = true;
    return y2.s < 0 ? new Ctor(ONE).div(r) : round$1(r, pr);
  }
  sign2 = sign2 < 0 && y2.d[Math.max(e, k2)] & 1 ? -1 : 1;
  x2.s = 1;
  external = false;
  r = y2.times(ln(x2, pr + guard));
  external = true;
  r = exp(r);
  r.s = sign2;
  return r;
};
P$1.toPrecision = function(sd, rm) {
  var e, str, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    e = getBase10Exponent(x2);
    str = toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = round$1(new Ctor(x2), sd, rm);
    e = getBase10Exponent(x2);
    str = toString(x2, sd <= e || e <= Ctor.toExpNeg, sd);
  }
  return str;
};
P$1.toSignificantDigits = P$1.tosd = function(sd, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return round$1(new Ctor(x2), sd, rm);
};
P$1.toString = P$1.valueOf = P$1.val = P$1.toJSON = P$1[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x2 = this, e = getBase10Exponent(x2), Ctor = x2.constructor;
  return toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
};
function add$2(x2, y2) {
  var carry, d, e, i, k2, len, xd, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (!y2.s) y2 = new Ctor(x2);
    return external ? round$1(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  k2 = x2.e;
  e = y2.e;
  xd = xd.slice();
  i = k2 - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y2.d = xd;
  y2.e = e;
  return external ? round$1(y2, pr) : y2;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function digitsToString(d) {
  var i, k2, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k2 = LOG_BASE - ws.length;
      if (k2) str += getZeroString(k2);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k2 = LOG_BASE - ws.length;
    if (k2) str += getZeroString(k2);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str + w;
}
var divide = /* @__PURE__ */ (function() {
  function multiplyInteger(x2, k2) {
    var temp, carry = 0, i = x2.length;
    for (x2 = x2.slice(); i--; ) {
      temp = x2[i] * k2 + carry;
      x2[i] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry) x2.unshift(carry);
    return x2;
  }
  function compare(a2, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a2[i] != b[i]) {
          r = a2[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a2, b, aL) {
    var i = 0;
    for (; aL--; ) {
      a2[aL] -= i;
      i = a2[aL] < b[aL] ? 1 : 0;
      a2[aL] = i * BASE + a2[aL] - b[aL];
    }
    for (; !a2[0] && a2.length > 1; ) a2.shift();
  }
  return function(x2, y2, pr, dp) {
    var cmp, e, i, k2, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
    if (!x2.s) return new Ctor(x2);
    if (!y2.s) throw Error(decimalError + "Division by zero");
    e = x2.e - y2.e;
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); ) ++i;
    if (yd[i] > (xd[i] || 0)) --e;
    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) return new Ctor(0);
    sd = sd / LOG_BASE + 2 | 0;
    i = 0;
    if (yL == 1) {
      k2 = 0;
      yd = yd[0];
      sd++;
      for (; (i < xL || k2) && sd--; i++) {
        t = k2 * BASE + (xd[i] || 0);
        qd[i] = t / yd | 0;
        k2 = t % yd | 0;
      }
    } else {
      k2 = BASE / (yd[0] + 1) | 0;
      if (k2 > 1) {
        yd = multiplyInteger(yd, k2);
        xd = multiplyInteger(xd, k2);
        yL = yd.length;
        xL = xd.length;
      }
      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; ) rem[remL++] = 0;
      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];
      if (yd[1] >= BASE / 2) ++yd0;
      do {
        k2 = 0;
        cmp = compare(yd, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
          k2 = rem0 / yd0 | 0;
          if (k2 > 1) {
            if (k2 >= BASE) k2 = BASE - 1;
            prod = multiplyInteger(yd, k2);
            prodL = prod.length;
            remL = rem.length;
            cmp = compare(prod, rem, prodL, remL);
            if (cmp == 1) {
              k2--;
              subtract2(prod, yL < prodL ? yz : yd, prodL);
            }
          } else {
            if (k2 == 0) cmp = k2 = 1;
            prod = yd.slice();
          }
          prodL = prod.length;
          if (prodL < remL) prod.unshift(0);
          subtract2(rem, prod, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 1) {
              k2++;
              subtract2(rem, yL < remL ? yz : yd, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k2++;
          rem = [0];
        }
        qd[i++] = k2;
        if (cmp && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }
      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }
    if (!qd[0]) qd.shift();
    q.e = e;
    return round$1(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
  };
})();
function exp(x2, sd) {
  var denominator, guard, pow2, sum, t, wpr, i = 0, k2 = 0, Ctor = x2.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x2) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x2));
  if (!x2.s) return new Ctor(ONE);
  {
    external = false;
    wpr = pr;
  }
  t = new Ctor(0.03125);
  while (x2.abs().gte(0.1)) {
    x2 = x2.times(t);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = round$1(pow2.times(x2), wpr);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow2, denominator, wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      while (k2--) sum = round$1(sum.times(sum), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round$1(sum, pr)) : sum;
    }
    sum = t;
  }
}
function getBase10Exponent(x2) {
  var e = x2.e * LOG_BASE, w = x2.d[0];
  for (; w >= 10; w /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round$1(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k2) {
  var zs = "";
  for (; k2--; ) zs += "0";
  return zs;
}
function ln(y2, sd) {
  var c2, c0, denominator, e, numerator, sum, t, wpr, x2, n = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
  if (x3.s < 1) throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
  if (x3.eq(ONE)) return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x3.eq(10)) {
    if (sd == null) external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c2 = digitsToString(xd);
  c0 = c2.charAt(0);
  e = getBase10Exponent(x3);
  if (Math.abs(e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n++;
    }
    e = getBase10Exponent(x3);
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x3 = ln(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? (external = true, round$1(x3, pr)) : x3;
  }
  sum = numerator = x3 = divide(x3.minus(ONE), x3.plus(ONE), wpr);
  x2 = round$1(x3.times(x3), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round$1(numerator.times(x2), wpr);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round$1(sum, pr)) : sum;
    }
    sum = t;
    denominator += 2;
  }
}
function parseDecimal(x2, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; ) ++i;
  for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    e = e - i - 1;
    x2.e = mathfloor(e / LOG_BASE);
    x2.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x2.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x2.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x2.d.push(+str);
    if (external && (x2.e > MAX_E || x2.e < -MAX_E)) throw Error(exponentOutOfRange + e);
  } else {
    x2.s = 0;
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function round$1(x2, sd, rm) {
  var i, j, k2, n, rd, doRound, w, xdi, xd = x2.d;
  for (n = 1, k2 = xd[0]; k2 >= 10; k2 /= 10) n++;
  i = sd - n;
  if (i < 0) {
    i += LOG_BASE;
    j = sd;
    w = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k2 = xd.length;
    if (xdi >= k2) return x2;
    w = k2 = xd[xdi];
    for (n = 1; k2 >= 10; k2 /= 10) n++;
    i %= LOG_BASE;
    j = i - LOG_BASE + n;
  }
  if (rm !== void 0) {
    k2 = mathpow(10, n - j - 1);
    rd = w / k2 % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k2;
    doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k2 = getBase10Exponent(x2);
      xd.length = 1;
      sd = sd - k2 - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x2.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x2.e = x2.s = 0;
    }
    return x2;
  }
  if (i == 0) {
    xd.length = xdi;
    k2 = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k2 = mathpow(10, LOG_BASE - i);
    xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k2 : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k2) == BASE) {
          xd[0] = 1;
          ++x2.e;
        }
        break;
      } else {
        xd[xdi] += k2;
        if (xd[xdi] != BASE) break;
        xd[xdi--] = 0;
        k2 = 1;
      }
    }
  }
  for (i = xd.length; xd[--i] === 0; ) xd.pop();
  if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  }
  return x2;
}
function subtract$1(x2, y2) {
  var d, e, i, j, k2, len, xd, xe2, xLTy, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (y2.s) y2.s = -y2.s;
    else y2 = new Ctor(x2);
    return external ? round$1(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  e = y2.e;
  xe2 = x2.e;
  xd = xd.slice();
  k2 = xe2 - e;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d = yd;
      e = xe2;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i) {
      k2 = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k2; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y2.s = -y2.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k2; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(0);
  y2.d = xd;
  y2.e = e;
  return external ? round$1(y2, pr) : y2;
}
function toString(x2, isExp, sd) {
  var k2, e = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k2 = sd - len) > 0) str += getZeroString(k2);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k2 = sd - e - 1) > 0) str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e + 1) < len) str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString(k2);
    }
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone(obj) {
  var i, p2, ps;
  function Decimal2(value) {
    var x2 = this;
    if (!(x2 instanceof Decimal2)) return new Decimal2(value);
    x2.constructor = Decimal2;
    if (value instanceof Decimal2) {
      x2.s = value.s;
      x2.e = value.e;
      x2.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x2.s = 1;
      } else if (value < 0) {
        value = -value;
        x2.s = -1;
      } else {
        x2.s = 0;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x2.e = 0;
        x2.d = [value];
        return;
      }
      return parseDecimal(x2, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x2.s = -1;
    } else {
      x2.s = 1;
    }
    if (isDecimal.test(value)) parseDecimal(x2, value);
    else throw Error(invalidArgument + value);
  }
  Decimal2.prototype = P$1;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.clone = clone;
  Decimal2.config = Decimal2.set = config$1;
  if (obj === void 0) obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p2 = ps[i++])) obj[p2] = this[p2];
  }
  Decimal2.config(obj);
  return Decimal2;
}
function config$1(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i, p2, v, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i = 0; i < ps.length; i += 3) {
    if ((v = obj[p2 = ps[i]]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p2] = v;
      else throw Error(invalidArgument + p2 + ": " + v);
    }
  }
  if ((v = obj[p2 = "LN10"]) !== void 0) {
    if (v == Math.LN10) this[p2] = new this(v);
    else throw Error(invalidArgument + p2 + ": " + v);
  }
  return this;
}
var Decimal = clone(defaults);
ONE = new Decimal(1);
const Decimal$1 = Decimal;
function _toConsumableArray$a(arr) {
  return _arrayWithoutHoles$a(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$f(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen);
}
function _iterableToArray$b(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles$a(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$f(arr);
}
function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var identity$2 = function identity(i) {
  return i;
};
var PLACE_HOLDER = {};
var isPlaceHolder = function isPlaceHolder2(val) {
  return val === PLACE_HOLDER;
};
var curry0 = function curry02(fn) {
  return function _curried() {
    if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) {
      return _curried;
    }
    return fn.apply(void 0, arguments);
  };
};
var curryN = function curryN2(n, fn) {
  if (n === 1) {
    return fn;
  }
  return curry0(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var argsLength = args.filter(function(arg) {
      return arg !== PLACE_HOLDER;
    }).length;
    if (argsLength >= n) {
      return fn.apply(void 0, args);
    }
    return curryN2(n - argsLength, curry0(function() {
      for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        restArgs[_key2] = arguments[_key2];
      }
      var newArgs = args.map(function(arg) {
        return isPlaceHolder(arg) ? restArgs.shift() : arg;
      });
      return fn.apply(void 0, _toConsumableArray$a(newArgs).concat(restArgs));
    }));
  });
};
var curry = function curry2(fn) {
  return curryN(fn.length, fn);
};
var range$1 = function range(begin, end) {
  var arr = [];
  for (var i = begin; i < end; ++i) {
    arr[i - begin] = i;
  }
  return arr;
};
var map$2 = curry(function(fn, arr) {
  if (Array.isArray(arr)) {
    return arr.map(fn);
  }
  return Object.keys(arr).map(function(key) {
    return arr[key];
  }).map(fn);
});
var compose = function compose2() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  if (!args.length) {
    return identity$2;
  }
  var fns = args.reverse();
  var firstFn = fns[0];
  var tailsFn = fns.slice(1);
  return function() {
    return tailsFn.reduce(function(res, fn) {
      return fn(res);
    }, firstFn.apply(void 0, arguments));
  };
};
var reverse = function reverse2(arr) {
  if (Array.isArray(arr)) {
    return arr.reverse();
  }
  return arr.split("").reverse.join("");
};
var memoize$2 = function memoize(fn) {
  var lastArgs = null;
  var lastResult2 = null;
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    if (lastArgs && args.every(function(val, i) {
      return val === lastArgs[i];
    })) {
      return lastResult2;
    }
    lastArgs = args;
    lastResult2 = fn.apply(void 0, args);
    return lastResult2;
  };
};
function getDigitCount(value) {
  var result;
  if (value === 0) {
    result = 1;
  } else {
    result = Math.floor(new Decimal$1(value).abs().log(10).toNumber()) + 1;
  }
  return result;
}
function rangeStep(start2, end, step) {
  var num = new Decimal$1(start2);
  var i = 0;
  var result = [];
  while (num.lt(end) && i < 1e5) {
    result.push(num.toNumber());
    num = num.add(step);
    i++;
  }
  return result;
}
var interpolateNumber2 = curry(function(a2, b, t) {
  var newA = +a2;
  var newB = +b;
  return newA + t * (newB - newA);
});
var uninterpolateNumber = curry(function(a2, b, x2) {
  var diff = b - +a2;
  diff = diff || Infinity;
  return (x2 - a2) / diff;
});
var uninterpolateTruncation = curry(function(a2, b, x2) {
  var diff = b - +a2;
  diff = diff || Infinity;
  return Math.max(0, Math.min(1, (x2 - a2) / diff));
});
const Arithmetic = {
  rangeStep,
  getDigitCount,
  interpolateNumber: interpolateNumber2,
  uninterpolateNumber,
  uninterpolateTruncation
};
function _toConsumableArray$9(arr) {
  return _arrayWithoutHoles$9(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$e(arr) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$a(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles$9(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$e(arr);
}
function _slicedToArray$7(arr, i) {
  return _arrayWithHoles$8(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$e(arr, i) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$e(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen);
}
function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$7(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e2 = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles$8(arr) {
  if (Array.isArray(arr)) return arr;
}
function getValidInterval(_ref) {
  var _ref2 = _slicedToArray$7(_ref, 2), min2 = _ref2[0], max2 = _ref2[1];
  var validMin = min2, validMax = max2;
  if (min2 > max2) {
    validMin = max2;
    validMax = min2;
  }
  return [validMin, validMax];
}
function getFormatStep(roughStep, allowDecimals, correctionFactor) {
  if (roughStep.lte(0)) {
    return new Decimal$1(0);
  }
  var digitCount = Arithmetic.getDigitCount(roughStep.toNumber());
  var digitCountValue = new Decimal$1(10).pow(digitCount);
  var stepRatio = roughStep.div(digitCountValue);
  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
  var amendStepRatio = new Decimal$1(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
  var formatStep = amendStepRatio.mul(digitCountValue);
  return allowDecimals ? formatStep : new Decimal$1(Math.ceil(formatStep));
}
function getTickOfSingleValue(value, tickCount, allowDecimals) {
  var step = 1;
  var middle = new Decimal$1(value);
  if (!middle.isint() && allowDecimals) {
    var absVal = Math.abs(value);
    if (absVal < 1) {
      step = new Decimal$1(10).pow(Arithmetic.getDigitCount(value) - 1);
      middle = new Decimal$1(Math.floor(middle.div(step).toNumber())).mul(step);
    } else if (absVal > 1) {
      middle = new Decimal$1(Math.floor(value));
    }
  } else if (value === 0) {
    middle = new Decimal$1(Math.floor((tickCount - 1) / 2));
  } else if (!allowDecimals) {
    middle = new Decimal$1(Math.floor(value));
  }
  var middleIndex = Math.floor((tickCount - 1) / 2);
  var fn = compose(map$2(function(n) {
    return middle.add(new Decimal$1(n - middleIndex).mul(step)).toNumber();
  }), range$1);
  return fn(0, tickCount);
}
function calculateStep(min2, max2, tickCount, allowDecimals) {
  var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((max2 - min2) / (tickCount - 1))) {
    return {
      step: new Decimal$1(0),
      tickMin: new Decimal$1(0),
      tickMax: new Decimal$1(0)
    };
  }
  var step = getFormatStep(new Decimal$1(max2).sub(min2).div(tickCount - 1), allowDecimals, correctionFactor);
  var middle;
  if (min2 <= 0 && max2 >= 0) {
    middle = new Decimal$1(0);
  } else {
    middle = new Decimal$1(min2).add(max2).div(2);
    middle = middle.sub(new Decimal$1(middle).mod(step));
  }
  var belowCount = Math.ceil(middle.sub(min2).div(step).toNumber());
  var upCount = Math.ceil(new Decimal$1(max2).sub(middle).div(step).toNumber());
  var scaleCount = belowCount + upCount + 1;
  if (scaleCount > tickCount) {
    return calculateStep(min2, max2, tickCount, allowDecimals, correctionFactor + 1);
  }
  if (scaleCount < tickCount) {
    upCount = max2 > 0 ? upCount + (tickCount - scaleCount) : upCount;
    belowCount = max2 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
  }
  return {
    step,
    tickMin: middle.sub(new Decimal$1(belowCount).mul(step)),
    tickMax: middle.add(new Decimal$1(upCount).mul(step))
  };
}
function getNiceTickValuesFn(_ref3) {
  var _ref4 = _slicedToArray$7(_ref3, 2), min2 = _ref4[0], max2 = _ref4[1];
  var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var count2 = Math.max(tickCount, 2);
  var _getValidInterval = getValidInterval([min2, max2]), _getValidInterval2 = _slicedToArray$7(_getValidInterval, 2), cormin = _getValidInterval2[0], cormax = _getValidInterval2[1];
  if (cormin === -Infinity || cormax === Infinity) {
    var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray$9(range$1(0, tickCount - 1).map(function() {
      return Infinity;
    }))) : [].concat(_toConsumableArray$9(range$1(0, tickCount - 1).map(function() {
      return -Infinity;
    })), [cormax]);
    return min2 > max2 ? reverse(_values) : _values;
  }
  if (cormin === cormax) {
    return getTickOfSingleValue(cormin, tickCount, allowDecimals);
  }
  var _calculateStep = calculateStep(cormin, cormax, count2, allowDecimals), step = _calculateStep.step, tickMin = _calculateStep.tickMin, tickMax = _calculateStep.tickMax;
  var values = Arithmetic.rangeStep(tickMin, tickMax.add(new Decimal$1(0.1).mul(step)), step);
  return min2 > max2 ? reverse(values) : values;
}
function getTickValuesFixedDomainFn(_ref7, tickCount) {
  var _ref8 = _slicedToArray$7(_ref7, 2), min2 = _ref8[0], max2 = _ref8[1];
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var _getValidInterval5 = getValidInterval([min2, max2]), _getValidInterval6 = _slicedToArray$7(_getValidInterval5, 2), cormin = _getValidInterval6[0], cormax = _getValidInterval6[1];
  if (cormin === -Infinity || cormax === Infinity) {
    return [min2, max2];
  }
  if (cormin === cormax) {
    return [cormin];
  }
  var count2 = Math.max(tickCount, 2);
  var step = getFormatStep(new Decimal$1(cormax).sub(cormin).div(count2 - 1), allowDecimals, 0);
  var values = [].concat(_toConsumableArray$9(Arithmetic.rangeStep(new Decimal$1(cormin), new Decimal$1(cormax).sub(new Decimal$1(0.99).mul(step)), step)), [cormax]);
  return min2 > max2 ? reverse(values) : values;
}
var getNiceTickValues = memoize$2(getNiceTickValuesFn);
var getTickValuesFixedDomain = memoize$2(getTickValuesFixedDomainFn);
var prefix = "Invariant failed";
function invariant(condition, message2) {
  {
    throw new Error(prefix);
  }
}
var _excluded$b = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];
function _typeof$w(o) {
  "@babel/helpers - typeof";
  return _typeof$w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$w(o);
}
function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$k.apply(this, arguments);
}
function _slicedToArray$6(arr, i) {
  return _arrayWithHoles$7(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$d(arr, i) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$d(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen);
}
function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$6(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$7(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$b(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$b(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$v(descriptor.key), descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$a(t, o, e) {
  return o = _getPrototypeOf$b(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$b() ? Reflect.construct(o, e || [], _getPrototypeOf$b(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$b(self2, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$b(o);
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p2) {
  _setPrototypeOf$b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
    o2.__proto__ = p22;
    return o2;
  };
  return _setPrototypeOf$b(o, p2);
}
function _defineProperty$v(obj, key, value) {
  key = _toPropertyKey$v(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$v(t) {
  var i = _toPrimitive$v(t, "string");
  return "symbol" == _typeof$w(i) ? i : i + "";
}
function _toPrimitive$v(t, r) {
  if ("object" != _typeof$w(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$w(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var ErrorBar = /* @__PURE__ */ (function(_React$Component) {
  function ErrorBar2() {
    _classCallCheck$d(this, ErrorBar2);
    return _callSuper$a(this, ErrorBar2, arguments);
  }
  _inherits$b(ErrorBar2, _React$Component);
  return _createClass$d(ErrorBar2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, offset2 = _this$props.offset, layout = _this$props.layout, width = _this$props.width, dataKey = _this$props.dataKey, data = _this$props.data, dataPointFormatter = _this$props.dataPointFormatter, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, others = _objectWithoutProperties$b(_this$props, _excluded$b);
      var svgProps = filterProps(others, false);
      !!(this.props.direction === "x" && xAxis.type !== "number") ? invariant() : void 0;
      var errorBars = data.map(function(entry) {
        var _dataPointFormatter = dataPointFormatter(entry, dataKey), x2 = _dataPointFormatter.x, y2 = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;
        if (!errorVal) {
          return null;
        }
        var lineCoordinates = [];
        var lowBound, highBound;
        if (Array.isArray(errorVal)) {
          var _errorVal = _slicedToArray$6(errorVal, 2);
          lowBound = _errorVal[0];
          highBound = _errorVal[1];
        } else {
          lowBound = highBound = errorVal;
        }
        if (layout === "vertical") {
          var scale2 = xAxis.scale;
          var yMid = y2 + offset2;
          var yMin = yMid + width;
          var yMax = yMid - width;
          var xMin = scale2(value - lowBound);
          var xMax = scale2(value + highBound);
          lineCoordinates.push({
            x1: xMax,
            y1: yMin,
            x2: xMax,
            y2: yMax
          });
          lineCoordinates.push({
            x1: xMin,
            y1: yMid,
            x2: xMax,
            y2: yMid
          });
          lineCoordinates.push({
            x1: xMin,
            y1: yMin,
            x2: xMin,
            y2: yMax
          });
        } else if (layout === "horizontal") {
          var _scale = yAxis.scale;
          var xMid = x2 + offset2;
          var _xMin = xMid - width;
          var _xMax = xMid + width;
          var _yMin = _scale(value - lowBound);
          var _yMax = _scale(value + highBound);
          lineCoordinates.push({
            x1: _xMin,
            y1: _yMax,
            x2: _xMax,
            y2: _yMax
          });
          lineCoordinates.push({
            x1: xMid,
            y1: _yMin,
            x2: xMid,
            y2: _yMax
          });
          lineCoordinates.push({
            x1: _xMin,
            y1: _yMin,
            x2: _xMax,
            y2: _yMin
          });
        }
        return /* @__PURE__ */ React.createElement(Layer$1, _extends$k({
          className: "recharts-errorBar",
          key: "bar-".concat(lineCoordinates.map(function(c2) {
            return "".concat(c2.x1, "-").concat(c2.x2, "-").concat(c2.y1, "-").concat(c2.y2);
          }))
        }, svgProps), lineCoordinates.map(function(coordinates) {
          return /* @__PURE__ */ React.createElement("line", _extends$k({}, coordinates, {
            key: "line-".concat(coordinates.x1, "-").concat(coordinates.x2, "-").concat(coordinates.y1, "-").concat(coordinates.y2)
          }));
        }));
      });
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: "recharts-errorBars"
      }, errorBars);
    }
  }]);
})(React.Component);
_defineProperty$v(ErrorBar, "defaultProps", {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  layout: "horizontal"
});
_defineProperty$v(ErrorBar, "displayName", "ErrorBar");
function _typeof$v(o) {
  "@babel/helpers - typeof";
  return _typeof$v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$v(o);
}
function ownKeys$r(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$r(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$r(Object(t), true).forEach(function(r2) {
      _defineProperty$u(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$u(obj, key, value) {
  key = _toPropertyKey$u(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$u(t) {
  var i = _toPrimitive$u(t, "string");
  return "symbol" == _typeof$v(i) ? i : i + "";
}
function _toPrimitive$u(t, r) {
  if ("object" != _typeof$v(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$v(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var getLegendProps = function getLegendProps2(_ref) {
  var children = _ref.children, formattedGraphicalItems = _ref.formattedGraphicalItems, legendWidth = _ref.legendWidth, legendContent = _ref.legendContent;
  var legendItem = findChildByType(children, Legend);
  if (!legendItem) {
    return null;
  }
  var legendDefaultProps = Legend.defaultProps;
  var legendProps = legendDefaultProps !== void 0 ? _objectSpread$r(_objectSpread$r({}, legendDefaultProps), legendItem.props) : {};
  var legendData;
  if (legendItem.props && legendItem.props.payload) {
    legendData = legendItem.props && legendItem.props.payload;
  } else if (legendContent === "children") {
    legendData = (formattedGraphicalItems || []).reduce(function(result, _ref2) {
      var item = _ref2.item, props = _ref2.props;
      var data = props.sectors || props.data || [];
      return result.concat(data.map(function(entry) {
        return {
          type: legendItem.props.iconType || item.props.legendType,
          value: entry.name,
          color: entry.fill,
          payload: entry
        };
      }));
    }, []);
  } else {
    legendData = (formattedGraphicalItems || []).map(function(_ref3) {
      var item = _ref3.item;
      var itemDefaultProps = item.type.defaultProps;
      var itemProps = itemDefaultProps !== void 0 ? _objectSpread$r(_objectSpread$r({}, itemDefaultProps), item.props) : {};
      var dataKey = itemProps.dataKey, name2 = itemProps.name, legendType = itemProps.legendType, hide = itemProps.hide;
      return {
        inactive: hide,
        dataKey,
        type: legendProps.iconType || legendType || "square",
        color: getMainColorOfGraphicItem(item),
        value: name2 || dataKey,
        // @ts-expect-error property strokeDasharray is required in Payload but optional in props
        payload: itemProps
      };
    });
  }
  return _objectSpread$r(_objectSpread$r(_objectSpread$r({}, legendProps), Legend.getWithHeight(legendItem, legendWidth)), {}, {
    payload: legendData,
    item: legendItem
  });
};
function _typeof$u(o) {
  "@babel/helpers - typeof";
  return _typeof$u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$u(o);
}
function _toConsumableArray$8(arr) {
  return _arrayWithoutHoles$8(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$c(arr) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$c(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen);
}
function _iterableToArray$9(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$8(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$c(arr);
}
function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys$q(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$q(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$q(Object(t), true).forEach(function(r2) {
      _defineProperty$t(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$t(obj, key, value) {
  key = _toPropertyKey$t(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$t(t) {
  var i = _toPrimitive$t(t, "string");
  return "symbol" == _typeof$u(i) ? i : i + "";
}
function _toPrimitive$t(t, r) {
  if ("object" != _typeof$u(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$u(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
  if (isNil(obj) || isNil(dataKey)) {
    return defaultValue;
  }
  if (isNumOrStr(dataKey)) {
    return get(obj, dataKey, defaultValue);
  }
  if (isFunction$2(dataKey)) {
    return dataKey(obj);
  }
  return defaultValue;
}
function getDomainOfDataByKey(data, key, type, filterNil) {
  var flattenData = flatMap(data, function(entry) {
    return getValueByDataKey(entry, key);
  });
  if (type === "number") {
    var domain = flattenData.filter(function(entry) {
      return isNumber(entry) || parseFloat(entry);
    });
    return domain.length ? [min(domain), max(domain)] : [Infinity, -Infinity];
  }
  var validateData = filterNil ? flattenData.filter(function(entry) {
    return !isNil(entry);
  }) : flattenData;
  return validateData.map(function(entry) {
    return isNumOrStr(entry) || entry instanceof Date ? entry : "";
  });
}
var calculateActiveTickIndex = function calculateActiveTickIndex2(coordinate) {
  var _ticks$length;
  var ticks2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var unsortedTicks = arguments.length > 2 ? arguments[2] : void 0;
  var axis = arguments.length > 3 ? arguments[3] : void 0;
  var index2 = -1;
  var len = (_ticks$length = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
  if (len <= 1) {
    return 0;
  }
  if (axis && axis.axisType === "angleAxis" && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {
    var range3 = axis.range;
    for (var i = 0; i < len; i++) {
      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
      var cur = unsortedTicks[i].coordinate;
      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
      var sameDirectionCoord = void 0;
      if (mathSign(cur - before) !== mathSign(after - cur)) {
        var diffInterval = [];
        if (mathSign(after - cur) === mathSign(range3[1] - range3[0])) {
          sameDirectionCoord = after;
          var curInRange = cur + range3[1] - range3[0];
          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
        } else {
          sameDirectionCoord = before;
          var afterInRange = after + range3[1] - range3[0];
          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
        }
        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
          index2 = unsortedTicks[i].index;
          break;
        }
      } else {
        var minValue = Math.min(before, after);
        var maxValue = Math.max(before, after);
        if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
          index2 = unsortedTicks[i].index;
          break;
        }
      }
    }
  } else {
    for (var _i = 0; _i < len; _i++) {
      if (_i === 0 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2) {
        index2 = ticks2[_i].index;
        break;
      }
    }
  }
  return index2;
};
var getMainColorOfGraphicItem = function getMainColorOfGraphicItem2(item) {
  var _item$type;
  var _ref = item, displayName = _ref.type.displayName;
  var defaultedProps = (_item$type = item.type) !== null && _item$type !== void 0 && _item$type.defaultProps ? _objectSpread$q(_objectSpread$q({}, item.type.defaultProps), item.props) : item.props;
  var stroke = defaultedProps.stroke, fill = defaultedProps.fill;
  var result;
  switch (displayName) {
    case "Line":
      result = stroke;
      break;
    case "Area":
    case "Radar":
      result = stroke && stroke !== "none" ? stroke : fill;
      break;
    default:
      result = fill;
      break;
  }
  return result;
};
var getBarSizeList = function getBarSizeList2(_ref2) {
  var globalSize = _ref2.barSize, totalSize = _ref2.totalSize, _ref2$stackGroups = _ref2.stackGroups, stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;
  if (!stackGroups) {
    return {};
  }
  var result = {};
  var numericAxisIds = Object.keys(stackGroups);
  for (var i = 0, len = numericAxisIds.length; i < len; i++) {
    var sgs = stackGroups[numericAxisIds[i]].stackGroups;
    var stackIds = Object.keys(sgs);
    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {
      var _sgs$stackIds$j = sgs[stackIds[j]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId;
      var barItems = items.filter(function(item) {
        return getDisplayName(item.type).indexOf("Bar") >= 0;
      });
      if (barItems && barItems.length) {
        var barItemDefaultProps = barItems[0].type.defaultProps;
        var barItemProps = barItemDefaultProps !== void 0 ? _objectSpread$q(_objectSpread$q({}, barItemDefaultProps), barItems[0].props) : barItems[0].props;
        var selfSize = barItemProps.barSize;
        var cateId = barItemProps[cateAxisId];
        if (!result[cateId]) {
          result[cateId] = [];
        }
        var barSize = isNil(selfSize) ? globalSize : selfSize;
        result[cateId].push({
          item: barItems[0],
          stackList: barItems.slice(1),
          barSize: isNil(barSize) ? void 0 : getPercentValue(barSize, totalSize, 0)
        });
      }
    }
  }
  return result;
};
var getBarPosition = function getBarPosition2(_ref3) {
  var barGap = _ref3.barGap, barCategoryGap = _ref3.barCategoryGap, bandSize = _ref3.bandSize, _ref3$sizeList = _ref3.sizeList, sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList, maxBarSize = _ref3.maxBarSize;
  var len = sizeList.length;
  if (len < 1) return null;
  var realBarGap = getPercentValue(barGap, bandSize, 0, true);
  var result;
  var initialValue = [];
  if (sizeList[0].barSize === +sizeList[0].barSize) {
    var useFull = false;
    var fullBarSize = bandSize / len;
    var sum = sizeList.reduce(function(res, entry) {
      return res + entry.barSize || 0;
    }, 0);
    sum += (len - 1) * realBarGap;
    if (sum >= bandSize) {
      sum -= (len - 1) * realBarGap;
      realBarGap = 0;
    }
    if (sum >= bandSize && fullBarSize > 0) {
      useFull = true;
      fullBarSize *= 0.9;
      sum = len * fullBarSize;
    }
    var offset2 = (bandSize - sum) / 2 >> 0;
    var prev = {
      offset: offset2 - realBarGap,
      size: 0
    };
    result = sizeList.reduce(function(res, entry) {
      var newPosition = {
        item: entry.item,
        position: {
          offset: prev.offset + prev.size + realBarGap,
          // @ts-expect-error the type check above does not check for type number explicitly
          size: useFull ? fullBarSize : entry.barSize
        }
      };
      var newRes = [].concat(_toConsumableArray$8(res), [newPosition]);
      prev = newRes[newRes.length - 1].position;
      if (entry.stackList && entry.stackList.length) {
        entry.stackList.forEach(function(item) {
          newRes.push({
            item,
            position: prev
          });
        });
      }
      return newRes;
    }, initialValue);
  } else {
    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
      realBarGap = 0;
    }
    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
    if (originalSize > 1) {
      originalSize >>= 0;
    }
    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
    result = sizeList.reduce(function(res, entry, i) {
      var newRes = [].concat(_toConsumableArray$8(res), [{
        item: entry.item,
        position: {
          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
          size
        }
      }]);
      if (entry.stackList && entry.stackList.length) {
        entry.stackList.forEach(function(item) {
          newRes.push({
            item,
            position: newRes[newRes.length - 1].position
          });
        });
      }
      return newRes;
    }, initialValue);
  }
  return result;
};
var appendOffsetOfLegend = function appendOffsetOfLegend2(offset2, _unused, props, legendBox) {
  var children = props.children, width = props.width, margin = props.margin;
  var legendWidth = width - (margin.left || 0) - (margin.right || 0);
  var legendProps = getLegendProps({
    children,
    legendWidth
  });
  if (legendProps) {
    var _ref4 = legendBox || {}, boxWidth = _ref4.width, boxHeight = _ref4.height;
    var align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;
    if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset2[align])) {
      return _objectSpread$q(_objectSpread$q({}, offset2), {}, _defineProperty$t({}, align, offset2[align] + (boxWidth || 0)));
    }
    if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset2[verticalAlign])) {
      return _objectSpread$q(_objectSpread$q({}, offset2), {}, _defineProperty$t({}, verticalAlign, offset2[verticalAlign] + (boxHeight || 0)));
    }
  }
  return offset2;
};
var isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis2(layout, axisType, direction) {
  if (isNil(axisType)) {
    return true;
  }
  if (layout === "horizontal") {
    return axisType === "yAxis";
  }
  if (layout === "vertical") {
    return axisType === "xAxis";
  }
  if (direction === "x") {
    return axisType === "xAxis";
  }
  if (direction === "y") {
    return axisType === "yAxis";
  }
  return true;
};
var getDomainOfErrorBars = function getDomainOfErrorBars2(data, item, dataKey, layout, axisType) {
  var children = item.props.children;
  var errorBars = findAllByType(children, ErrorBar).filter(function(errorBarChild) {
    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);
  });
  if (errorBars && errorBars.length) {
    var keys2 = errorBars.map(function(errorBarChild) {
      return errorBarChild.props.dataKey;
    });
    return data.reduce(function(result, entry) {
      var entryValue = getValueByDataKey(entry, dataKey);
      if (isNil(entryValue)) return result;
      var mainValue = Array.isArray(entryValue) ? [min(entryValue), max(entryValue)] : [entryValue, entryValue];
      var errorDomain = keys2.reduce(function(prevErrorArr, k2) {
        var errorValue = getValueByDataKey(entry, k2, 0);
        var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);
        var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);
        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
      }, [Infinity, -Infinity]);
      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
    }, [Infinity, -Infinity]);
  }
  return null;
};
var parseErrorBarsOfAxis = function parseErrorBarsOfAxis2(data, items, dataKey, axisType, layout) {
  var domains = items.map(function(item) {
    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);
  }).filter(function(entry) {
    return !isNil(entry);
  });
  if (domains && domains.length) {
    return domains.reduce(function(result, entry) {
      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
    }, [Infinity, -Infinity]);
  }
  return null;
};
var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis2(data, items, type, layout, filterNil) {
  var domains = items.map(function(item) {
    var dataKey = item.props.dataKey;
    if (type === "number" && dataKey) {
      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);
    }
    return getDomainOfDataByKey(data, dataKey, type, filterNil);
  });
  if (type === "number") {
    return domains.reduce(
      // @ts-expect-error if (type === number) means that the domain is numerical type
      // - but this link is missing in the type definition
      function(result, entry) {
        return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
      },
      [Infinity, -Infinity]
    );
  }
  var tag = {};
  return domains.reduce(function(result, entry) {
    for (var i = 0, len = entry.length; i < len; i++) {
      if (!tag[entry[i]]) {
        tag[entry[i]] = true;
        result.push(entry[i]);
      }
    }
    return result;
  }, []);
};
var isCategoricalAxis = function isCategoricalAxis2(layout, axisType) {
  return layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
};
var getCoordinatesOfGrid = function getCoordinatesOfGrid2(ticks2, minValue, maxValue, syncWithTicks) {
  if (syncWithTicks) {
    return ticks2.map(function(entry) {
      return entry.coordinate;
    });
  }
  var hasMin, hasMax;
  var values = ticks2.map(function(entry) {
    if (entry.coordinate === minValue) {
      hasMin = true;
    }
    if (entry.coordinate === maxValue) {
      hasMax = true;
    }
    return entry.coordinate;
  });
  if (!hasMin) {
    values.push(minValue);
  }
  if (!hasMax) {
    values.push(maxValue);
  }
  return values;
};
var getTicksOfAxis = function getTicksOfAxis2(axis, isGrid, isAll) {
  if (!axis) return null;
  var scale2 = axis.scale;
  var duplicateDomain = axis.duplicateDomain, type = axis.type, range3 = axis.range;
  var offsetForBand = axis.realScaleType === "scaleBand" ? scale2.bandwidth() / 2 : 2;
  var offset2 = (isGrid || isAll) && type === "category" && scale2.bandwidth ? scale2.bandwidth() / offsetForBand : 0;
  offset2 = axis.axisType === "angleAxis" && (range3 === null || range3 === void 0 ? void 0 : range3.length) >= 2 ? mathSign(range3[0] - range3[1]) * 2 * offset2 : offset2;
  if (isGrid && (axis.ticks || axis.niceTicks)) {
    var result = (axis.ticks || axis.niceTicks).map(function(entry) {
      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: scale2(scaleContent) + offset2,
        value: entry,
        offset: offset2
      };
    });
    return result.filter(function(row) {
      return !isNan(row.coordinate);
    });
  }
  if (axis.isCategorical && axis.categoricalDomain) {
    return axis.categoricalDomain.map(function(entry, index2) {
      return {
        coordinate: scale2(entry) + offset2,
        value: entry,
        index: index2,
        offset: offset2
      };
    });
  }
  if (scale2.ticks && !isAll) {
    return scale2.ticks(axis.tickCount).map(function(entry) {
      return {
        coordinate: scale2(entry) + offset2,
        value: entry,
        offset: offset2
      };
    });
  }
  return scale2.domain().map(function(entry, index2) {
    return {
      coordinate: scale2(entry) + offset2,
      value: duplicateDomain ? duplicateDomain[entry] : entry,
      index: index2,
      offset: offset2
    };
  });
};
var handlerWeakMap = /* @__PURE__ */ new WeakMap();
var combineEventHandlers = function combineEventHandlers2(defaultHandler, childHandler) {
  if (typeof childHandler !== "function") {
    return defaultHandler;
  }
  if (!handlerWeakMap.has(defaultHandler)) {
    handlerWeakMap.set(defaultHandler, /* @__PURE__ */ new WeakMap());
  }
  var childWeakMap = handlerWeakMap.get(defaultHandler);
  if (childWeakMap.has(childHandler)) {
    return childWeakMap.get(childHandler);
  }
  var combineHandler = function combineHandler2() {
    defaultHandler.apply(void 0, arguments);
    childHandler.apply(void 0, arguments);
  };
  childWeakMap.set(childHandler, combineHandler);
  return combineHandler;
};
var parseScale = function parseScale2(axis, chartType, hasBar) {
  var scale2 = axis.scale, type = axis.type, layout = axis.layout, axisType = axis.axisType;
  if (scale2 === "auto") {
    if (layout === "radial" && axisType === "radiusAxis") {
      return {
        scale: band(),
        realScaleType: "band"
      };
    }
    if (layout === "radial" && axisType === "angleAxis") {
      return {
        scale: linear(),
        realScaleType: "linear"
      };
    }
    if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) {
      return {
        scale: point(),
        realScaleType: "point"
      };
    }
    if (type === "category") {
      return {
        scale: band(),
        realScaleType: "band"
      };
    }
    return {
      scale: linear(),
      realScaleType: "linear"
    };
  }
  if (isString(scale2)) {
    var name2 = "scale".concat(upperFirst(scale2));
    return {
      scale: (d3Scales[name2] || point)(),
      realScaleType: d3Scales[name2] ? name2 : "point"
    };
  }
  return isFunction$2(scale2) ? {
    scale: scale2
  } : {
    scale: point(),
    realScaleType: "point"
  };
};
var EPS = 1e-4;
var checkDomainOfScale = function checkDomainOfScale2(scale2) {
  var domain = scale2.domain();
  if (!domain || domain.length <= 2) {
    return;
  }
  var len = domain.length;
  var range3 = scale2.range();
  var minValue = Math.min(range3[0], range3[1]) - EPS;
  var maxValue = Math.max(range3[0], range3[1]) + EPS;
  var first = scale2(domain[0]);
  var last2 = scale2(domain[len - 1]);
  if (first < minValue || first > maxValue || last2 < minValue || last2 > maxValue) {
    scale2.domain([domain[0], domain[len - 1]]);
  }
};
var findPositionOfBar = function findPositionOfBar2(barPosition, child) {
  if (!barPosition) {
    return null;
  }
  for (var i = 0, len = barPosition.length; i < len; i++) {
    if (barPosition[i].item === child) {
      return barPosition[i].position;
    }
  }
  return null;
};
var truncateByDomain = function truncateByDomain2(value, domain) {
  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {
    return value;
  }
  var minValue = Math.min(domain[0], domain[1]);
  var maxValue = Math.max(domain[0], domain[1]);
  var result = [value[0], value[1]];
  if (!isNumber(value[0]) || value[0] < minValue) {
    result[0] = minValue;
  }
  if (!isNumber(value[1]) || value[1] > maxValue) {
    result[1] = maxValue;
  }
  if (result[0] > maxValue) {
    result[0] = maxValue;
  }
  if (result[1] < minValue) {
    result[1] = minValue;
  }
  return result;
};
var offsetSign = function offsetSign2(series) {
  var n = series.length;
  if (n <= 0) {
    return;
  }
  for (var j = 0, m2 = series[0].length; j < m2; ++j) {
    var positive = 0;
    var negative = 0;
    for (var i = 0; i < n; ++i) {
      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
      if (value >= 0) {
        series[i][j][0] = positive;
        series[i][j][1] = positive + value;
        positive = series[i][j][1];
      } else {
        series[i][j][0] = negative;
        series[i][j][1] = negative + value;
        negative = series[i][j][1];
      }
    }
  }
};
var offsetPositive = function offsetPositive2(series) {
  var n = series.length;
  if (n <= 0) {
    return;
  }
  for (var j = 0, m2 = series[0].length; j < m2; ++j) {
    var positive = 0;
    for (var i = 0; i < n; ++i) {
      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
      if (value >= 0) {
        series[i][j][0] = positive;
        series[i][j][1] = positive + value;
        positive = series[i][j][1];
      } else {
        series[i][j][0] = 0;
        series[i][j][1] = 0;
      }
    }
  }
};
var STACK_OFFSET_MAP = {
  sign: offsetSign,
  // @ts-expect-error definitelytyped types are incorrect
  expand: stackOffsetExpand,
  // @ts-expect-error definitelytyped types are incorrect
  none: stackOffsetNone,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: stackOffsetSilhouette,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: stackOffsetWiggle,
  positive: offsetPositive
};
var getStackedData = function getStackedData2(data, stackItems, offsetType) {
  var dataKeys = stackItems.map(function(item) {
    return item.props.dataKey;
  });
  var offsetAccessor = STACK_OFFSET_MAP[offsetType];
  var stack = shapeStack().keys(dataKeys).value(function(d, key) {
    return +getValueByDataKey(d, key, 0);
  }).order(stackOrderNone).offset(offsetAccessor);
  return stack(data);
};
var getStackGroupsByAxisId = function getStackGroupsByAxisId2(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
  if (!data) {
    return null;
  }
  var items = reverseStackOrder ? _items.reverse() : _items;
  var parentStackGroupsInitialValue = {};
  var stackGroups = items.reduce(function(result, item) {
    var _item$type2;
    var defaultedProps = (_item$type2 = item.type) !== null && _item$type2 !== void 0 && _item$type2.defaultProps ? _objectSpread$q(_objectSpread$q({}, item.type.defaultProps), item.props) : item.props;
    var stackId = defaultedProps.stackId, hide = defaultedProps.hide;
    if (hide) {
      return result;
    }
    var axisId = defaultedProps[numericAxisId];
    var parentGroup = result[axisId] || {
      hasStack: false,
      stackGroups: {}
    };
    if (isNumOrStr(stackId)) {
      var childGroup = parentGroup.stackGroups[stackId] || {
        numericAxisId,
        cateAxisId,
        items: []
      };
      childGroup.items.push(item);
      parentGroup.hasStack = true;
      parentGroup.stackGroups[stackId] = childGroup;
    } else {
      parentGroup.stackGroups[uniqueId("_stackId_")] = {
        numericAxisId,
        cateAxisId,
        items: [item]
      };
    }
    return _objectSpread$q(_objectSpread$q({}, result), {}, _defineProperty$t({}, axisId, parentGroup));
  }, parentStackGroupsInitialValue);
  var axisStackGroupsInitialValue = {};
  return Object.keys(stackGroups).reduce(function(result, axisId) {
    var group = stackGroups[axisId];
    if (group.hasStack) {
      var stackGroupsInitialValue = {};
      group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {
        var g = group.stackGroups[stackId];
        return _objectSpread$q(_objectSpread$q({}, res), {}, _defineProperty$t({}, stackId, {
          numericAxisId,
          cateAxisId,
          items: g.items,
          stackedData: getStackedData(data, g.items, offsetType)
        }));
      }, stackGroupsInitialValue);
    }
    return _objectSpread$q(_objectSpread$q({}, result), {}, _defineProperty$t({}, axisId, group));
  }, axisStackGroupsInitialValue);
};
var getTicksOfScale = function getTicksOfScale2(scale2, opts) {
  var realScaleType = opts.realScaleType, type = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals;
  var scaleType = realScaleType || opts.scale;
  if (scaleType !== "auto" && scaleType !== "linear") {
    return null;
  }
  if (tickCount && type === "number" && originalDomain && (originalDomain[0] === "auto" || originalDomain[1] === "auto")) {
    var domain = scale2.domain();
    if (!domain.length) {
      return null;
    }
    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);
    scale2.domain([min(tickValues), max(tickValues)]);
    return {
      niceTicks: tickValues
    };
  }
  if (tickCount && type === "number") {
    var _domain = scale2.domain();
    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);
    return {
      niceTicks: _tickValues
    };
  }
  return null;
};
function getCateCoordinateOfLine(_ref5) {
  var axis = _ref5.axis, ticks2 = _ref5.ticks, bandSize = _ref5.bandSize, entry = _ref5.entry, index2 = _ref5.index, dataKey = _ref5.dataKey;
  if (axis.type === "category") {
    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNil(entry[axis.dataKey])) {
      var matchedTick = findEntryInArray(ticks2, "value", entry[axis.dataKey]);
      if (matchedTick) {
        return matchedTick.coordinate + bandSize / 2;
      }
    }
    return ticks2[index2] ? ticks2[index2].coordinate + bandSize / 2 : null;
  }
  var value = getValueByDataKey(entry, !isNil(dataKey) ? dataKey : axis.dataKey);
  return !isNil(value) ? axis.scale(value) : null;
}
var getCateCoordinateOfBar = function getCateCoordinateOfBar2(_ref6) {
  var axis = _ref6.axis, ticks2 = _ref6.ticks, offset2 = _ref6.offset, bandSize = _ref6.bandSize, entry = _ref6.entry, index2 = _ref6.index;
  if (axis.type === "category") {
    return ticks2[index2] ? ticks2[index2].coordinate + offset2 : null;
  }
  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index2]);
  return !isNil(value) ? axis.scale(value) - bandSize / 2 + offset2 : null;
};
var getBaseValueOfBar = function getBaseValueOfBar2(_ref7) {
  var numericAxis = _ref7.numericAxis;
  var domain = numericAxis.scale.domain();
  if (numericAxis.type === "number") {
    var minValue = Math.min(domain[0], domain[1]);
    var maxValue = Math.max(domain[0], domain[1]);
    if (minValue <= 0 && maxValue >= 0) {
      return 0;
    }
    if (maxValue < 0) {
      return maxValue;
    }
    return minValue;
  }
  return domain[0];
};
var getStackedDataOfItem = function getStackedDataOfItem2(item, stackGroups) {
  var _item$type3;
  var defaultedProps = (_item$type3 = item.type) !== null && _item$type3 !== void 0 && _item$type3.defaultProps ? _objectSpread$q(_objectSpread$q({}, item.type.defaultProps), item.props) : item.props;
  var stackId = defaultedProps.stackId;
  if (isNumOrStr(stackId)) {
    var group = stackGroups[stackId];
    if (group) {
      var itemIndex = group.items.indexOf(item);
      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
    }
  }
  return null;
};
var getDomainOfSingle = function getDomainOfSingle2(data) {
  return data.reduce(function(result, entry) {
    return [min(entry.concat([result[0]]).filter(isNumber)), max(entry.concat([result[1]]).filter(isNumber))];
  }, [Infinity, -Infinity]);
};
var getDomainOfStackGroups = function getDomainOfStackGroups2(stackGroups, startIndex, endIndex) {
  return Object.keys(stackGroups).reduce(function(result, stackId) {
    var group = stackGroups[stackId];
    var stackedData = group.stackedData;
    var domain = stackedData.reduce(function(res, entry) {
      var s2 = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));
      return [Math.min(res[0], s2[0]), Math.max(res[1], s2[1])];
    }, [Infinity, -Infinity]);
    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
  }, [Infinity, -Infinity]).map(function(result) {
    return result === Infinity || result === -Infinity ? 0 : result;
  });
};
var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var parseSpecifiedDomain = function parseSpecifiedDomain2(specifiedDomain, dataDomain, allowDataOverflow) {
  if (isFunction$2(specifiedDomain)) {
    return specifiedDomain(dataDomain, allowDataOverflow);
  }
  if (!Array.isArray(specifiedDomain)) {
    return dataDomain;
  }
  var domain = [];
  if (isNumber(specifiedDomain[0])) {
    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
    domain[0] = dataDomain[0] - value;
  } else if (isFunction$2(specifiedDomain[0])) {
    domain[0] = specifiedDomain[0](dataDomain[0]);
  } else {
    domain[0] = dataDomain[0];
  }
  if (isNumber(specifiedDomain[1])) {
    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];
    domain[1] = dataDomain[1] + _value;
  } else if (isFunction$2(specifiedDomain[1])) {
    domain[1] = specifiedDomain[1](dataDomain[1]);
  } else {
    domain[1] = dataDomain[1];
  }
  return domain;
};
var getBandSizeOfAxis = function getBandSizeOfAxis2(axis, ticks2, isBar) {
  if (axis && axis.scale && axis.scale.bandwidth) {
    var bandWidth = axis.scale.bandwidth();
    if (!isBar || bandWidth > 0) {
      return bandWidth;
    }
  }
  if (axis && ticks2 && ticks2.length >= 2) {
    var orderedTicks = sortBy(ticks2, function(o) {
      return o.coordinate;
    });
    var bandSize = Infinity;
    for (var i = 1, len = orderedTicks.length; i < len; i++) {
      var cur = orderedTicks[i];
      var prev = orderedTicks[i - 1];
      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
    }
    return bandSize === Infinity ? 0 : bandSize;
  }
  return isBar ? void 0 : 0;
};
var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis2(specifiedDomain, calculatedDomain, axisChild) {
  if (!specifiedDomain || !specifiedDomain.length) {
    return calculatedDomain;
  }
  if (isEqual$1(specifiedDomain, get(axisChild, "type.defaultProps.domain"))) {
    return calculatedDomain;
  }
  return specifiedDomain;
};
var getTooltipItem = function getTooltipItem2(graphicalItem, payload) {
  var defaultedProps = graphicalItem.type.defaultProps ? _objectSpread$q(_objectSpread$q({}, graphicalItem.type.defaultProps), graphicalItem.props) : graphicalItem.props;
  var dataKey = defaultedProps.dataKey, name2 = defaultedProps.name, unit2 = defaultedProps.unit, formatter = defaultedProps.formatter, tooltipType = defaultedProps.tooltipType, chartType = defaultedProps.chartType, hide = defaultedProps.hide;
  return _objectSpread$q(_objectSpread$q({}, filterProps(graphicalItem, false)), {}, {
    dataKey,
    unit: unit2,
    formatter,
    name: name2 || dataKey,
    color: getMainColorOfGraphicItem(graphicalItem),
    value: getValueByDataKey(payload, dataKey),
    type: tooltipType,
    payload,
    chartType,
    hide
  });
};
function _typeof$t(o) {
  "@babel/helpers - typeof";
  return _typeof$t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$t(o);
}
function ownKeys$p(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$p(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$p(Object(t), true).forEach(function(r2) {
      _defineProperty$s(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$s(obj, key, value) {
  key = _toPropertyKey$s(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$s(t) {
  var i = _toPrimitive$s(t, "string");
  return "symbol" == _typeof$t(i) ? i : i + "";
}
function _toPrimitive$s(t, r) {
  if ("object" != _typeof$t(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$t(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var RADIAN = Math.PI / 180;
var radianToDegree = function radianToDegree2(angleInRadian) {
  return angleInRadian * 180 / Math.PI;
};
var polarToCartesian = function polarToCartesian2(cx, cy, radius, angle2) {
  return {
    x: cx + Math.cos(-RADIAN * angle2) * radius,
    y: cy + Math.sin(-RADIAN * angle2) * radius
  };
};
var distanceBetweenPoints = function distanceBetweenPoints2(point2, anotherPoint) {
  var x1 = point2.x, y1 = point2.y;
  var x2 = anotherPoint.x, y2 = anotherPoint.y;
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};
var getAngleOfPoint = function getAngleOfPoint2(_ref, _ref2) {
  var x2 = _ref.x, y2 = _ref.y;
  var cx = _ref2.cx, cy = _ref2.cy;
  var radius = distanceBetweenPoints({
    x: x2,
    y: y2
  }, {
    x: cx,
    y: cy
  });
  if (radius <= 0) {
    return {
      radius
    };
  }
  var cos2 = (x2 - cx) / radius;
  var angleInRadian = Math.acos(cos2);
  if (y2 > cy) {
    angleInRadian = 2 * Math.PI - angleInRadian;
  }
  return {
    radius,
    angle: radianToDegree(angleInRadian),
    angleInRadian
  };
};
var formatAngleOfSector = function formatAngleOfSector2(_ref3) {
  var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min2 = Math.min(startCnt, endCnt);
  return {
    startAngle: startAngle - min2 * 360,
    endAngle: endAngle - min2 * 360
  };
};
var reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor2(angle2, _ref4) {
  var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min2 = Math.min(startCnt, endCnt);
  return angle2 + min2 * 360;
};
var inRangeOfSector = function inRangeOfSector2(_ref5, sector) {
  var x2 = _ref5.x, y2 = _ref5.y;
  var _getAngleOfPoint = getAngleOfPoint({
    x: x2,
    y: y2
  }, sector), radius = _getAngleOfPoint.radius, angle2 = _getAngleOfPoint.angle;
  var innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;
  if (radius < innerRadius || radius > outerRadius) {
    return false;
  }
  if (radius === 0) {
    return true;
  }
  var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle;
  var formatAngle = angle2;
  var inRange;
  if (startAngle <= endAngle) {
    while (formatAngle > endAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < startAngle) {
      formatAngle += 360;
    }
    inRange = formatAngle >= startAngle && formatAngle <= endAngle;
  } else {
    while (formatAngle > startAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < endAngle) {
      formatAngle += 360;
    }
    inRange = formatAngle >= endAngle && formatAngle <= startAngle;
  }
  if (inRange) {
    return _objectSpread$p(_objectSpread$p({}, sector), {}, {
      radius,
      angle: reverseFormatAngleOfSetor(formatAngle, sector)
    });
  }
  return null;
};
function _typeof$s(o) {
  "@babel/helpers - typeof";
  return _typeof$s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$s(o);
}
var _excluded$a = ["offset"];
function _toConsumableArray$7(arr) {
  return _arrayWithoutHoles$7(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$b(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen);
}
function _iterableToArray$8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$b(arr);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _objectWithoutProperties$a(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$a(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function ownKeys$o(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$o(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$o(Object(t), true).forEach(function(r2) {
      _defineProperty$r(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$r(obj, key, value) {
  key = _toPropertyKey$r(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$r(t) {
  var i = _toPrimitive$r(t, "string");
  return "symbol" == _typeof$s(i) ? i : i + "";
}
function _toPrimitive$r(t, r) {
  if ("object" != _typeof$s(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$s(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$j.apply(this, arguments);
}
var getLabel = function getLabel2(props) {
  var value = props.value, formatter = props.formatter;
  var label = isNil(props.children) ? value : props.children;
  if (isFunction$2(formatter)) {
    return formatter(label);
  }
  return label;
};
var getDeltaAngle$1 = function getDeltaAngle(startAngle, endAngle) {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
  return sign2 * deltaAngle;
};
var renderRadialLabel = function renderRadialLabel2(labelProps, label, attrs) {
  var position = labelProps.position, viewBox = labelProps.viewBox, offset2 = labelProps.offset, className = labelProps.className;
  var _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise;
  var radius = (innerRadius + outerRadius) / 2;
  var deltaAngle = getDeltaAngle$1(startAngle, endAngle);
  var sign2 = deltaAngle >= 0 ? 1 : -1;
  var labelAngle, direction;
  if (position === "insideStart") {
    labelAngle = startAngle + sign2 * offset2;
    direction = clockWise;
  } else if (position === "insideEnd") {
    labelAngle = endAngle - sign2 * offset2;
    direction = !clockWise;
  } else if (position === "end") {
    labelAngle = endAngle + sign2 * offset2;
    direction = clockWise;
  }
  direction = deltaAngle <= 0 ? direction : !direction;
  var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
  var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
  var path = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
  var id = isNil(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
  return /* @__PURE__ */ React.createElement("text", _extends$j({}, attrs, {
    dominantBaseline: "central",
    className: clsx("recharts-radial-bar-label", className)
  }), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("path", {
    id,
    d: path
  })), /* @__PURE__ */ React.createElement("textPath", {
    xlinkHref: "#".concat(id)
  }, label));
};
var getAttrsOfPolarLabel = function getAttrsOfPolarLabel2(props) {
  var viewBox = props.viewBox, offset2 = props.offset, position = props.position;
  var _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
  var midAngle = (startAngle + endAngle) / 2;
  if (position === "outside") {
    var _polarToCartesian = polarToCartesian(cx, cy, outerRadius + offset2, midAngle), _x = _polarToCartesian.x, _y = _polarToCartesian.y;
    return {
      x: _x,
      y: _y,
      textAnchor: _x >= cx ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (position === "center") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  }
  if (position === "centerTop") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  }
  if (position === "centerBottom") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  }
  var r = (innerRadius + outerRadius) / 2;
  var _polarToCartesian2 = polarToCartesian(cx, cy, r, midAngle), x2 = _polarToCartesian2.x, y2 = _polarToCartesian2.y;
  return {
    x: x2,
    y: y2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
};
var getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel2(props) {
  var viewBox = props.viewBox, parentViewBox = props.parentViewBox, offset2 = props.offset, position = props.position;
  var _ref3 = viewBox, x2 = _ref3.x, y2 = _ref3.y, width = _ref3.width, height = _ref3.height;
  var verticalSign = height >= 0 ? 1 : -1;
  var verticalOffset = verticalSign * offset2;
  var verticalEnd = verticalSign > 0 ? "end" : "start";
  var verticalStart = verticalSign > 0 ? "start" : "end";
  var horizontalSign = width >= 0 ? 1 : -1;
  var horizontalOffset = horizontalSign * offset2;
  var horizontalEnd = horizontalSign > 0 ? "end" : "start";
  var horizontalStart = horizontalSign > 0 ? "start" : "end";
  if (position === "top") {
    var attrs = {
      x: x2 + width / 2,
      y: y2 - verticalSign * offset2,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    };
    return _objectSpread$o(_objectSpread$o({}, attrs), parentViewBox ? {
      height: Math.max(y2 - parentViewBox.y, 0),
      width
    } : {});
  }
  if (position === "bottom") {
    var _attrs = {
      x: x2 + width / 2,
      y: y2 + height + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    };
    return _objectSpread$o(_objectSpread$o({}, _attrs), parentViewBox ? {
      height: Math.max(parentViewBox.y + parentViewBox.height - (y2 + height), 0),
      width
    } : {});
  }
  if (position === "left") {
    var _attrs2 = {
      x: x2 - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    };
    return _objectSpread$o(_objectSpread$o({}, _attrs2), parentViewBox ? {
      width: Math.max(_attrs2.x - parentViewBox.x, 0),
      height
    } : {});
  }
  if (position === "right") {
    var _attrs3 = {
      x: x2 + width + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    };
    return _objectSpread$o(_objectSpread$o({}, _attrs3), parentViewBox ? {
      width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
      height
    } : {});
  }
  var sizeAttrs = parentViewBox ? {
    width,
    height
  } : {};
  if (position === "insideLeft") {
    return _objectSpread$o({
      x: x2 + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideRight") {
    return _objectSpread$o({
      x: x2 + width - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideTop") {
    return _objectSpread$o({
      x: x2 + width / 2,
      y: y2 + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottom") {
    return _objectSpread$o({
      x: x2 + width / 2,
      y: y2 + height - verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideTopLeft") {
    return _objectSpread$o({
      x: x2 + horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideTopRight") {
    return _objectSpread$o({
      x: x2 + width - horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottomLeft") {
    return _objectSpread$o({
      x: x2 + horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideBottomRight") {
    return _objectSpread$o({
      x: x2 + width - horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (isObject$2(position) && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) {
    return _objectSpread$o({
      x: x2 + getPercentValue(position.x, width),
      y: y2 + getPercentValue(position.y, height),
      textAnchor: "end",
      verticalAnchor: "end"
    }, sizeAttrs);
  }
  return _objectSpread$o({
    x: x2 + width / 2,
    y: y2 + height / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, sizeAttrs);
};
var isPolar = function isPolar2(viewBox) {
  return "cx" in viewBox && isNumber(viewBox.cx);
};
function Label(_ref4) {
  var _ref4$offset = _ref4.offset, offset2 = _ref4$offset === void 0 ? 5 : _ref4$offset, restProps = _objectWithoutProperties$a(_ref4, _excluded$a);
  var props = _objectSpread$o({
    offset: offset2
  }, restProps);
  var viewBox = props.viewBox, position = props.position, value = props.value, children = props.children, content = props.content, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, textBreakAll = props.textBreakAll;
  if (!viewBox || isNil(value) && isNil(children) && !/* @__PURE__ */ reactExports.isValidElement(content) && !isFunction$2(content)) {
    return null;
  }
  if (/* @__PURE__ */ reactExports.isValidElement(content)) {
    return /* @__PURE__ */ reactExports.cloneElement(content, props);
  }
  var label;
  if (isFunction$2(content)) {
    label = /* @__PURE__ */ reactExports.createElement(content, props);
    if (/* @__PURE__ */ reactExports.isValidElement(label)) {
      return label;
    }
  } else {
    label = getLabel(props);
  }
  var isPolarLabel = isPolar(viewBox);
  var attrs = filterProps(props, true);
  if (isPolarLabel && (position === "insideStart" || position === "insideEnd" || position === "end")) {
    return renderRadialLabel(props, label, attrs);
  }
  var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);
  return /* @__PURE__ */ React.createElement(Text, _extends$j({
    className: clsx("recharts-label", className)
  }, attrs, positionAttrs, {
    breakAll: textBreakAll
  }), label);
}
Label.displayName = "Label";
var parseViewBox = function parseViewBox2(props) {
  var cx = props.cx, cy = props.cy, angle2 = props.angle, startAngle = props.startAngle, endAngle = props.endAngle, r = props.r, radius = props.radius, innerRadius = props.innerRadius, outerRadius = props.outerRadius, x2 = props.x, y2 = props.y, top = props.top, left = props.left, width = props.width, height = props.height, clockWise = props.clockWise, labelViewBox = props.labelViewBox;
  if (labelViewBox) {
    return labelViewBox;
  }
  if (isNumber(width) && isNumber(height)) {
    if (isNumber(x2) && isNumber(y2)) {
      return {
        x: x2,
        y: y2,
        width,
        height
      };
    }
    if (isNumber(top) && isNumber(left)) {
      return {
        x: top,
        y: left,
        width,
        height
      };
    }
  }
  if (isNumber(x2) && isNumber(y2)) {
    return {
      x: x2,
      y: y2,
      width: 0,
      height: 0
    };
  }
  if (isNumber(cx) && isNumber(cy)) {
    return {
      cx,
      cy,
      startAngle: startAngle || angle2 || 0,
      endAngle: endAngle || angle2 || 0,
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || radius || r || 0,
      clockWise
    };
  }
  if (props.viewBox) {
    return props.viewBox;
  }
  return {};
};
var parseLabel = function parseLabel2(label, viewBox) {
  if (!label) {
    return null;
  }
  if (label === true) {
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      viewBox
    });
  }
  if (isNumOrStr(label)) {
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      viewBox,
      value: label
    });
  }
  if (/* @__PURE__ */ reactExports.isValidElement(label)) {
    if (label.type === Label) {
      return /* @__PURE__ */ reactExports.cloneElement(label, {
        key: "label-implicit",
        viewBox
      });
    }
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      content: label,
      viewBox
    });
  }
  if (isFunction$2(label)) {
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      content: label,
      viewBox
    });
  }
  if (isObject$2(label)) {
    return /* @__PURE__ */ React.createElement(Label, _extends$j({
      viewBox
    }, label, {
      key: "label-implicit"
    }));
  }
  return null;
};
var renderCallByParent$1 = function renderCallByParent(parentProps, viewBox) {
  var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
    return null;
  }
  var children = parentProps.children;
  var parentViewBox = parseViewBox(parentProps);
  var explicitChildren = findAllByType(children, Label).map(function(child, index2) {
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      viewBox: viewBox || parentViewBox,
      // eslint-disable-next-line react/no-array-index-key
      key: "label-".concat(index2)
    });
  });
  if (!checkPropsLabel) {
    return explicitChildren;
  }
  var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);
  return [implicitLabel].concat(_toConsumableArray$7(explicitChildren));
};
Label.parseViewBox = parseViewBox;
Label.renderCallByParent = renderCallByParent$1;
var last_1;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast) return last_1;
  hasRequiredLast = 1;
  function last2(array2) {
    var length = array2 == null ? 0 : array2.length;
    return length ? array2[length - 1] : void 0;
  }
  last_1 = last2;
  return last_1;
}
var lastExports = requireLast();
const last = /* @__PURE__ */ getDefaultExportFromCjs(lastExports);
function _typeof$r(o) {
  "@babel/helpers - typeof";
  return _typeof$r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$r(o);
}
var _excluded$9 = ["valueAccessor"], _excluded2$4 = ["data", "dataKey", "clockWise", "id", "textBreakAll"];
function _toConsumableArray$6(arr) {
  return _arrayWithoutHoles$6(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$a(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen);
}
function _iterableToArray$7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$a(arr);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$i.apply(this, arguments);
}
function ownKeys$n(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$n(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$n(Object(t), true).forEach(function(r2) {
      _defineProperty$q(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$q(obj, key, value) {
  key = _toPropertyKey$q(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$q(t) {
  var i = _toPrimitive$q(t, "string");
  return "symbol" == _typeof$r(i) ? i : i + "";
}
function _toPrimitive$q(t, r) {
  if ("object" != _typeof$r(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$r(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$9(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$9(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var defaultAccessor = function defaultAccessor2(entry) {
  return Array.isArray(entry.value) ? last(entry.value) : entry.value;
};
function LabelList(_ref) {
  var _ref$valueAccessor = _ref.valueAccessor, valueAccessor = _ref$valueAccessor === void 0 ? defaultAccessor : _ref$valueAccessor, restProps = _objectWithoutProperties$9(_ref, _excluded$9);
  var data = restProps.data, dataKey = restProps.dataKey, clockWise = restProps.clockWise, id = restProps.id, textBreakAll = restProps.textBreakAll, others = _objectWithoutProperties$9(restProps, _excluded2$4);
  if (!data || !data.length) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Layer$1, {
    className: "recharts-label-list"
  }, data.map(function(entry, index2) {
    var value = isNil(dataKey) ? valueAccessor(entry, index2) : getValueByDataKey(entry && entry.payload, dataKey);
    var idProps = isNil(id) ? {} : {
      id: "".concat(id, "-").concat(index2)
    };
    return /* @__PURE__ */ React.createElement(Label, _extends$i({}, filterProps(entry, true), others, idProps, {
      parentViewBox: entry.parentViewBox,
      value,
      textBreakAll,
      viewBox: Label.parseViewBox(isNil(clockWise) ? entry : _objectSpread$n(_objectSpread$n({}, entry), {}, {
        clockWise
      })),
      key: "label-".concat(index2),
      index: index2
    }));
  }));
}
LabelList.displayName = "LabelList";
function parseLabelList(label, data) {
  if (!label) {
    return null;
  }
  if (label === true) {
    return /* @__PURE__ */ React.createElement(LabelList, {
      key: "labelList-implicit",
      data
    });
  }
  if (/* @__PURE__ */ React.isValidElement(label) || isFunction$2(label)) {
    return /* @__PURE__ */ React.createElement(LabelList, {
      key: "labelList-implicit",
      data,
      content: label
    });
  }
  if (isObject$2(label)) {
    return /* @__PURE__ */ React.createElement(LabelList, _extends$i({
      data
    }, label, {
      key: "labelList-implicit"
    }));
  }
  return null;
}
function renderCallByParent2(parentProps, data) {
  var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
    return null;
  }
  var children = parentProps.children;
  var explicitChildren = findAllByType(children, LabelList).map(function(child, index2) {
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      data,
      // eslint-disable-next-line react/no-array-index-key
      key: "labelList-".concat(index2)
    });
  });
  if (!checkPropsLabel) {
    return explicitChildren;
  }
  var implicitLabelList = parseLabelList(parentProps.label, data);
  return [implicitLabelList].concat(_toConsumableArray$6(explicitChildren));
}
LabelList.renderCallByParent = renderCallByParent2;
function _typeof$q(o) {
  "@babel/helpers - typeof";
  return _typeof$q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$q(o);
}
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
function ownKeys$m(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$m(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$m(Object(t), true).forEach(function(r2) {
      _defineProperty$p(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$p(obj, key, value) {
  key = _toPropertyKey$p(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$p(t) {
  var i = _toPrimitive$p(t, "string");
  return "symbol" == _typeof$q(i) ? i : i + "";
}
function _toPrimitive$p(t, r) {
  if ("object" != _typeof$q(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$q(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var getDeltaAngle2 = function getDeltaAngle3(startAngle, endAngle) {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
  return sign2 * deltaAngle;
};
var getTangentCircle = function getTangentCircle2(_ref) {
  var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle2 = _ref.angle, sign2 = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal;
  var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
  var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
  var centerAngle = cornerIsExternal ? angle2 : angle2 + sign2 * theta;
  var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
  var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
  var lineTangencyAngle = cornerIsExternal ? angle2 - sign2 * theta : angle2;
  var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);
  return {
    center,
    circleTangency,
    lineTangency,
    theta
  };
};
var getSectorPath = function getSectorPath2(_ref2) {
  var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
  var angle2 = getDeltaAngle2(startAngle, endAngle);
  var tempEndAngle = startAngle + angle2;
  var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
  var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
  var path = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle2) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
  if (innerRadius > 0) {
    var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
    var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
    path += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle2) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
  } else {
    path += "L ".concat(cx, ",").concat(cy, " Z");
  }
  return path;
};
var getSectorWithCorner = function getSectorWithCorner2(_ref3) {
  var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
  var sign2 = mathSign(endAngle - startAngle);
  var _getTangentCircle = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: startAngle,
    sign: sign2,
    cornerRadius,
    cornerIsExternal
  }), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta;
  var _getTangentCircle2 = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: endAngle,
    sign: -sign2,
    cornerRadius,
    cornerIsExternal
  }), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta;
  var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
  if (outerArcAngle < 0) {
    if (forceCornerRadius) {
      return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
    }
    return getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  var path = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign2 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
  if (innerRadius > 0) {
    var _getTangentCircle3 = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: startAngle,
      sign: sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    }), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta;
    var _getTangentCircle4 = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: endAngle,
      sign: -sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    }), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta;
    var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
    if (innerArcAngle < 0 && cornerRadius === 0) {
      return "".concat(path, "L").concat(cx, ",").concat(cy, "Z");
    }
    path += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign2 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
  } else {
    path += "L".concat(cx, ",").concat(cy, "Z");
  }
  return path;
};
var defaultProps$f = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: false,
  cornerIsExternal: false
};
var Sector = function Sector2(sectorProps) {
  var props = _objectSpread$m(_objectSpread$m({}, defaultProps$f), sectorProps);
  var cx = props.cx, cy = props.cy, innerRadius = props.innerRadius, outerRadius = props.outerRadius, cornerRadius = props.cornerRadius, forceCornerRadius = props.forceCornerRadius, cornerIsExternal = props.cornerIsExternal, startAngle = props.startAngle, endAngle = props.endAngle, className = props.className;
  if (outerRadius < innerRadius || startAngle === endAngle) {
    return null;
  }
  var layerClass = clsx("recharts-sector", className);
  var deltaRadius = outerRadius - innerRadius;
  var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
  var path;
  if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
    path = getSectorWithCorner({
      cx,
      cy,
      innerRadius,
      outerRadius,
      cornerRadius: Math.min(cr, deltaRadius / 2),
      forceCornerRadius,
      cornerIsExternal,
      startAngle,
      endAngle
    });
  } else {
    path = getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  return /* @__PURE__ */ React.createElement("path", _extends$h({}, filterProps(props, true), {
    className: layerClass,
    d: path,
    role: "img"
  }));
};
function _typeof$p(o) {
  "@babel/helpers - typeof";
  return _typeof$p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$p(o);
}
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function ownKeys$l(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$l(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$l(Object(t), true).forEach(function(r2) {
      _defineProperty$o(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$o(obj, key, value) {
  key = _toPropertyKey$o(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$o(t) {
  var i = _toPrimitive$o(t, "string");
  return "symbol" == _typeof$p(i) ? i : i + "";
}
function _toPrimitive$o(t, r) {
  if ("object" != _typeof$p(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$p(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var CURVE_FACTORIES = {
  curveBasisClosed,
  curveBasisOpen,
  curveBasis,
  curveBumpX: bumpX,
  curveBumpY: bumpY,
  curveLinearClosed,
  curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore
};
var defined = function defined2(p2) {
  return p2.x === +p2.x && p2.y === +p2.y;
};
var getX = function getX2(p2) {
  return p2.x;
};
var getY = function getY2(p2) {
  return p2.y;
};
var getCurveFactory = function getCurveFactory2(type, layout) {
  if (isFunction$2(type)) {
    return type;
  }
  var name2 = "curve".concat(upperFirst(type));
  if ((name2 === "curveMonotone" || name2 === "curveBump") && layout) {
    return CURVE_FACTORIES["".concat(name2).concat(layout === "vertical" ? "Y" : "X")];
  }
  return CURVE_FACTORIES[name2] || curveLinear;
};
var getPath$1 = function getPath(_ref) {
  var _ref$type = _ref.type, type = _ref$type === void 0 ? "linear" : _ref$type, _ref$points = _ref.points, points = _ref$points === void 0 ? [] : _ref$points, baseLine = _ref.baseLine, layout = _ref.layout, _ref$connectNulls = _ref.connectNulls, connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls;
  var curveFactory = getCurveFactory(type, layout);
  var formatPoints = connectNulls ? points.filter(function(entry) {
    return defined(entry);
  }) : points;
  var lineFunction;
  if (Array.isArray(baseLine)) {
    var formatBaseLine = connectNulls ? baseLine.filter(function(base) {
      return defined(base);
    }) : baseLine;
    var areaPoints = formatPoints.map(function(entry, index2) {
      return _objectSpread$l(_objectSpread$l({}, entry), {}, {
        base: formatBaseLine[index2]
      });
    });
    if (layout === "vertical") {
      lineFunction = shapeArea().y(getY).x1(getX).x0(function(d) {
        return d.base.x;
      });
    } else {
      lineFunction = shapeArea().x(getX).y1(getY).y0(function(d) {
        return d.base.y;
      });
    }
    lineFunction.defined(defined).curve(curveFactory);
    return lineFunction(areaPoints);
  }
  if (layout === "vertical" && isNumber(baseLine)) {
    lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);
  } else if (isNumber(baseLine)) {
    lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);
  } else {
    lineFunction = shapeLine().x(getX).y(getY);
  }
  lineFunction.defined(defined).curve(curveFactory);
  return lineFunction(formatPoints);
};
var Curve = function Curve2(props) {
  var className = props.className, points = props.points, path = props.path, pathRef = props.pathRef;
  if ((!points || !points.length) && !path) {
    return null;
  }
  var realPath = points && points.length ? getPath$1(props) : path;
  return /* @__PURE__ */ reactExports.createElement("path", _extends$g({}, filterProps(props, false), adaptEventHandlers(props), {
    className: clsx("recharts-curve", className),
    d: realPath,
    ref: pathRef
  }));
};
var propTypes = { exports: {} };
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes.exports;
  hasRequiredPropTypes = 1;
  {
    propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual2(a2, b, state) {
    return comparatorA(a2, b, state) && comparatorB(a2, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a2, b, state) {
    if (!a2 || !b || typeof a2 !== "object" || typeof b !== "object") {
      return areItemsEqual(a2, b, state);
    }
    var cache2 = state.cache;
    var cachedA = cache2.get(a2);
    var cachedB = cache2.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a2;
    }
    cache2.set(a2, b);
    cache2.set(b, a2);
    var result = areItemsEqual(a2, b, state);
    cache2.delete(a2);
    cache2.delete(b);
    return result;
  };
}
function getStrictProperties(object2) {
  return getOwnPropertyNames(object2).concat(getOwnPropertySymbols(object2));
}
var hasOwn = Object.hasOwn || (function(object2, property) {
  return hasOwnProperty$1.call(object2, property);
});
function sameValueZeroEqual(a2, b) {
  return a2 === b || !a2 && !b && a2 !== a2 && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;
function areArraysEqual(a2, b, state) {
  var index2 = a2.length;
  if (b.length !== index2) {
    return false;
  }
  while (index2-- > 0) {
    if (!state.equals(a2[index2], b[index2], index2, index2, a2, b, state)) {
      return false;
    }
  }
  return true;
}
function areDatesEqual(a2, b) {
  return sameValueZeroEqual(a2.getTime(), b.getTime());
}
function areErrorsEqual(a2, b) {
  return a2.name === b.name && a2.message === b.message && a2.cause === b.cause && a2.stack === b.stack;
}
function areFunctionsEqual(a2, b) {
  return a2 === b;
}
function areMapsEqual(a2, b, state) {
  var size = a2.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a2.entries();
  var aResult;
  var bResult;
  var index2 = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.entries();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      var aEntry = aResult.value;
      var bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index2, matchIndex, a2, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a2, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index2++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a2, b, state) {
  var properties = keys(a2);
  var index2 = properties.length;
  if (keys(b).length !== index2) {
    return false;
  }
  while (index2-- > 0) {
    if (!isPropertyEqual(a2, b, state, properties[index2])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a2, b, state) {
  var properties = getStrictProperties(a2);
  var index2 = properties.length;
  if (getStrictProperties(b).length !== index2) {
    return false;
  }
  var property;
  var descriptorA;
  var descriptorB;
  while (index2-- > 0) {
    property = properties[index2];
    if (!isPropertyEqual(a2, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a2, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a2, b) {
  return sameValueZeroEqual(a2.valueOf(), b.valueOf());
}
function areRegExpsEqual(a2, b) {
  return a2.source === b.source && a2.flags === b.flags;
}
function areSetsEqual(a2, b, state) {
  var size = a2.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a2.values();
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.values();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a2, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a2, b) {
  var index2 = a2.length;
  if (b.length !== index2) {
    return false;
  }
  while (index2-- > 0) {
    if (a2[index2] !== b[index2]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a2, b) {
  return a2.hostname === b.hostname && a2.pathname === b.pathname && a2.protocol === b.protocol && a2.port === b.port && a2.hash === b.hash && a2.username === b.username && a2.password === b.password;
}
function isPropertyEqual(a2, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a2.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a2[property], b[property], property, property, a2, b, state);
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var URL_TAG = "[object URL]";
var isArray$3 = Array.isArray;
var isTypedArray$1 = typeof ArrayBuffer === "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var assign = Object.assign;
var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a2) {
  var areArraysEqual2 = _a2.areArraysEqual, areDatesEqual2 = _a2.areDatesEqual, areErrorsEqual2 = _a2.areErrorsEqual, areFunctionsEqual2 = _a2.areFunctionsEqual, areMapsEqual2 = _a2.areMapsEqual, areNumbersEqual2 = _a2.areNumbersEqual, areObjectsEqual2 = _a2.areObjectsEqual, arePrimitiveWrappersEqual2 = _a2.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a2.areRegExpsEqual, areSetsEqual2 = _a2.areSetsEqual, areTypedArraysEqual2 = _a2.areTypedArraysEqual, areUrlsEqual2 = _a2.areUrlsEqual;
  return function comparator(a2, b, state) {
    if (a2 === b) {
      return true;
    }
    if (a2 == null || b == null) {
      return false;
    }
    var type = typeof a2;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a2, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a2, b, state);
      }
      return false;
    }
    var constructor = a2.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a2, b, state);
    }
    if (isArray$3(a2)) {
      return areArraysEqual2(a2, b, state);
    }
    if (isTypedArray$1 != null && isTypedArray$1(a2)) {
      return areTypedArraysEqual2(a2, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a2, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a2, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a2, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a2, b, state);
    }
    var tag = getTag(a2);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a2, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a2, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a2, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a2, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a2.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a2, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a2, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a2, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a2, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a2, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig(_a2) {
  var circular = _a2.circular, createCustomConfig = _a2.createCustomConfig, strict = _a2.strict;
  var config2 = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,
    areUrlsEqual
  };
  if (createCustomConfig) {
    config2 = assign({}, config2, createCustomConfig(config2));
  }
  if (circular) {
    var areArraysEqual$1 = createIsCircular(config2.areArraysEqual);
    var areMapsEqual$1 = createIsCircular(config2.areMapsEqual);
    var areObjectsEqual$1 = createIsCircular(config2.areObjectsEqual);
    var areSetsEqual$1 = createIsCircular(config2.areSetsEqual);
    config2 = assign({}, config2, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config2;
}
function createInternalEqualityComparator(compare) {
  return function(a2, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a2, b, state);
  };
}
function createIsEqual(_a2) {
  var circular = _a2.circular, comparator = _a2.comparator, createState = _a2.createState, equals2 = _a2.equals, strict = _a2.strict;
  if (createState) {
    return function isEqual2(a2, b) {
      var _a3 = createState(), _b = _a3.cache, cache2 = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta = _a3.meta;
      return comparator(a2, b, {
        cache: cache2,
        equals: equals2,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual2(a2, b) {
      return comparator(a2, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: equals2,
        meta: void 0,
        strict
      });
    };
  }
  var state = {
    cache: void 0,
    equals: equals2,
    meta: void 0,
    strict
  };
  return function isEqual2(a2, b) {
    return comparator(a2, b, state);
  };
}
var deepEqual$2 = createCustomEqual();
createCustomEqual({ strict: true });
createCustomEqual({ circular: true });
createCustomEqual({
  circular: true,
  strict: true
});
createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  strict: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: true
});
function createCustomEqual(options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.circular, circular = _a2 === void 0 ? false : _a2, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;
  var config2 = createEqualityComparatorConfig(options);
  var comparator = createEqualityComparator(config2);
  var equals2 = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals: equals2, strict });
}
function safeRequestAnimationFrame(callback) {
  if (typeof requestAnimationFrame !== "undefined") requestAnimationFrame(callback);
}
function setRafTimeout(callback) {
  var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var currTime = -1;
  var shouldUpdate = function shouldUpdate2(now2) {
    if (currTime < 0) {
      currTime = now2;
    }
    if (now2 - currTime > timeout) {
      callback(now2);
      currTime = -1;
    } else {
      safeRequestAnimationFrame(shouldUpdate2);
    }
  };
  requestAnimationFrame(shouldUpdate);
}
function _typeof$o(o) {
  "@babel/helpers - typeof";
  return _typeof$o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$o(o);
}
function _toArray(arr) {
  return _arrayWithHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArray$6(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr)) return arr;
}
function createAnimateManager() {
  var currStyle = {};
  var handleChange = function handleChange2() {
    return null;
  };
  var shouldStop = false;
  var setStyle = function setStyle2(_style) {
    if (shouldStop) {
      return;
    }
    if (Array.isArray(_style)) {
      if (!_style.length) {
        return;
      }
      var styles = _style;
      var _styles = _toArray(styles), curr = _styles[0], restStyles = _styles.slice(1);
      if (typeof curr === "number") {
        setRafTimeout(setStyle2.bind(null, restStyles), curr);
        return;
      }
      setStyle2(curr);
      setRafTimeout(setStyle2.bind(null, restStyles));
      return;
    }
    if (_typeof$o(_style) === "object") {
      currStyle = _style;
      handleChange(currStyle);
    }
    if (typeof _style === "function") {
      _style();
    }
  };
  return {
    stop: function stop() {
      shouldStop = true;
    },
    start: function start2(style) {
      shouldStop = false;
      setStyle(style);
    },
    subscribe: function subscribe(_handleChange) {
      handleChange = _handleChange;
      return function() {
        handleChange = function handleChange2() {
          return null;
        };
      };
    }
  };
}
function _typeof$n(o) {
  "@babel/helpers - typeof";
  return _typeof$n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$n(o);
}
function ownKeys$k(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$k(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$k(Object(t), true).forEach(function(r2) {
      _defineProperty$n(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$n(obj, key, value) {
  key = _toPropertyKey$n(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$n(arg) {
  var key = _toPrimitive$n(arg, "string");
  return _typeof$n(key) === "symbol" ? key : String(key);
}
function _toPrimitive$n(input, hint2) {
  if (_typeof$n(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint2);
    if (_typeof$n(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint2 === "string" ? String : Number)(input);
}
var getIntersectionKeys = function getIntersectionKeys2(preObj, nextObj) {
  return [Object.keys(preObj), Object.keys(nextObj)].reduce(function(a2, b) {
    return a2.filter(function(c2) {
      return b.includes(c2);
    });
  });
};
var identity$1 = function identity2(param) {
  return param;
};
var getDashCase = function getDashCase2(name2) {
  return name2.replace(/([A-Z])/g, function(v) {
    return "-".concat(v.toLowerCase());
  });
};
var mapObject = function mapObject2(fn, obj) {
  return Object.keys(obj).reduce(function(res, key) {
    return _objectSpread$k(_objectSpread$k({}, res), {}, _defineProperty$n({}, key, fn(key, obj[key])));
  }, {});
};
var getTransitionVal = function getTransitionVal2(props, duration, easing) {
  return props.map(function(prop) {
    return "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing);
  }).join(",");
};
function _slicedToArray$5(arr, i) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$5(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u2 = t.return(), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr)) return arr;
}
function _toConsumableArray$5(arr) {
  return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
}
function _iterableToArray$5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$8(arr);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var ACCURACY = 1e-4;
var cubicBezierFactor = function cubicBezierFactor2(c1, c2) {
  return [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
};
var multyTime = function multyTime2(params, t) {
  return params.map(function(param, i) {
    return param * Math.pow(t, i);
  }).reduce(function(pre, curr) {
    return pre + curr;
  });
};
var cubicBezier = function cubicBezier2(c1, c2) {
  return function(t) {
    var params = cubicBezierFactor(c1, c2);
    return multyTime(params, t);
  };
};
var derivativeCubicBezier = function derivativeCubicBezier2(c1, c2) {
  return function(t) {
    var params = cubicBezierFactor(c1, c2);
    var newParams = [].concat(_toConsumableArray$5(params.map(function(param, i) {
      return param * i;
    }).slice(1)), [0]);
    return multyTime(newParams, t);
  };
};
var configBezier = function configBezier2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var x1 = args[0], y1 = args[1], x2 = args[2], y2 = args[3];
  if (args.length === 1) {
    switch (args[0]) {
      case "linear":
        x1 = 0;
        y1 = 0;
        x2 = 1;
        y2 = 1;
        break;
      case "ease":
        x1 = 0.25;
        y1 = 0.1;
        x2 = 0.25;
        y2 = 1;
        break;
      case "ease-in":
        x1 = 0.42;
        y1 = 0;
        x2 = 1;
        y2 = 1;
        break;
      case "ease-out":
        x1 = 0.42;
        y1 = 0;
        x2 = 0.58;
        y2 = 1;
        break;
      case "ease-in-out":
        x1 = 0;
        y1 = 0;
        x2 = 0.58;
        y2 = 1;
        break;
      default: {
        var easing = args[0].split("(");
        if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
          var _easing$1$split$0$spl = easing[1].split(")")[0].split(",").map(function(x3) {
            return parseFloat(x3);
          });
          var _easing$1$split$0$spl2 = _slicedToArray$5(_easing$1$split$0$spl, 4);
          x1 = _easing$1$split$0$spl2[0];
          y1 = _easing$1$split$0$spl2[1];
          x2 = _easing$1$split$0$spl2[2];
          y2 = _easing$1$split$0$spl2[3];
        }
      }
    }
  }
  var curveX = cubicBezier(x1, x2);
  var curveY = cubicBezier(y1, y2);
  var derCurveX = derivativeCubicBezier(x1, x2);
  var rangeValue = function rangeValue2(value) {
    if (value > 1) {
      return 1;
    }
    if (value < 0) {
      return 0;
    }
    return value;
  };
  var bezier = function bezier2(_t) {
    var t = _t > 1 ? 1 : _t;
    var x3 = t;
    for (var i = 0; i < 8; ++i) {
      var evalT = curveX(x3) - t;
      var derVal = derCurveX(x3);
      if (Math.abs(evalT - t) < ACCURACY || derVal < ACCURACY) {
        return curveY(x3);
      }
      x3 = rangeValue(x3 - evalT / derVal);
    }
    return curveY(x3);
  };
  bezier.isStepper = false;
  return bezier;
};
var configSpring = function configSpring2() {
  var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _config$stiff = config2.stiff, stiff = _config$stiff === void 0 ? 100 : _config$stiff, _config$damping = config2.damping, damping = _config$damping === void 0 ? 8 : _config$damping, _config$dt = config2.dt, dt = _config$dt === void 0 ? 17 : _config$dt;
  var stepper = function stepper2(currX, destX, currV) {
    var FSpring = -(currX - destX) * stiff;
    var FDamping = currV * damping;
    var newV = currV + (FSpring - FDamping) * dt / 1e3;
    var newX = currV * dt / 1e3 + currX;
    if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
      return [destX, 0];
    }
    return [newX, newV];
  };
  stepper.isStepper = true;
  stepper.dt = dt;
  return stepper;
};
var configEasing = function configEasing2() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var easing = args[0];
  if (typeof easing === "string") {
    switch (easing) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return configBezier(easing);
      case "spring":
        return configSpring();
      default:
        if (easing.split("(")[0] === "cubic-bezier") {
          return configBezier(easing);
        }
    }
  }
  if (typeof easing === "function") {
    return easing;
  }
  return null;
};
function _typeof$m(o) {
  "@babel/helpers - typeof";
  return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$m(o);
}
function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
}
function ownKeys$j(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$j(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$j(Object(t), true).forEach(function(r2) {
      _defineProperty$m(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$m(obj, key, value) {
  key = _toPropertyKey$m(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$m(arg) {
  var key = _toPrimitive$m(arg, "string");
  return _typeof$m(key) === "symbol" ? key : String(key);
}
function _toPrimitive$m(input, hint2) {
  if (_typeof$m(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint2);
    if (_typeof$m(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint2 === "string" ? String : Number)(input);
}
function _slicedToArray$4(arr, i) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$4(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u2 = t.return(), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr)) return arr;
}
var alpha = function alpha2(begin, end, k2) {
  return begin + (end - begin) * k2;
};
var needContinue = function needContinue2(_ref) {
  var from = _ref.from, to = _ref.to;
  return from !== to;
};
var calStepperVals = function calStepperVals2(easing, preVals, steps) {
  var nextStepVals = mapObject(function(key, val) {
    if (needContinue(val)) {
      var _easing = easing(val.from, val.to, val.velocity), _easing2 = _slicedToArray$4(_easing, 2), newX = _easing2[0], newV = _easing2[1];
      return _objectSpread$j(_objectSpread$j({}, val), {}, {
        from: newX,
        velocity: newV
      });
    }
    return val;
  }, preVals);
  if (steps < 1) {
    return mapObject(function(key, val) {
      if (needContinue(val)) {
        return _objectSpread$j(_objectSpread$j({}, val), {}, {
          velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
          from: alpha(val.from, nextStepVals[key].from, steps)
        });
      }
      return val;
    }, preVals);
  }
  return calStepperVals2(easing, nextStepVals, steps - 1);
};
const configUpdate = (function(from, to, easing, duration, render) {
  var interKeys = getIntersectionKeys(from, to);
  var timingStyle = interKeys.reduce(function(res, key) {
    return _objectSpread$j(_objectSpread$j({}, res), {}, _defineProperty$m({}, key, [from[key], to[key]]));
  }, {});
  var stepperStyle = interKeys.reduce(function(res, key) {
    return _objectSpread$j(_objectSpread$j({}, res), {}, _defineProperty$m({}, key, {
      from: from[key],
      velocity: 0,
      to: to[key]
    }));
  }, {});
  var cafId = -1;
  var preTime;
  var beginTime;
  var update = function update2() {
    return null;
  };
  var getCurrStyle = function getCurrStyle2() {
    return mapObject(function(key, val) {
      return val.from;
    }, stepperStyle);
  };
  var shouldStopAnimation = function shouldStopAnimation2() {
    return !Object.values(stepperStyle).filter(needContinue).length;
  };
  var stepperUpdate = function stepperUpdate2(now2) {
    if (!preTime) {
      preTime = now2;
    }
    var deltaTime = now2 - preTime;
    var steps = deltaTime / easing.dt;
    stepperStyle = calStepperVals(easing, stepperStyle, steps);
    render(_objectSpread$j(_objectSpread$j(_objectSpread$j({}, from), to), getCurrStyle()));
    preTime = now2;
    if (!shouldStopAnimation()) {
      cafId = requestAnimationFrame(update);
    }
  };
  var timingUpdate = function timingUpdate2(now2) {
    if (!beginTime) {
      beginTime = now2;
    }
    var t = (now2 - beginTime) / duration;
    var currStyle = mapObject(function(key, val) {
      return alpha.apply(void 0, _toConsumableArray$4(val).concat([easing(t)]));
    }, timingStyle);
    render(_objectSpread$j(_objectSpread$j(_objectSpread$j({}, from), to), currStyle));
    if (t < 1) {
      cafId = requestAnimationFrame(update);
    } else {
      var finalStyle = mapObject(function(key, val) {
        return alpha.apply(void 0, _toConsumableArray$4(val).concat([easing(1)]));
      }, timingStyle);
      render(_objectSpread$j(_objectSpread$j(_objectSpread$j({}, from), to), finalStyle));
    }
  };
  update = easing.isStepper ? stepperUpdate : timingUpdate;
  return function() {
    requestAnimationFrame(update);
    return function() {
      cancelAnimationFrame(cafId);
    };
  };
});
function _typeof$l(o) {
  "@babel/helpers - typeof";
  return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$l(o);
}
var _excluded$8 = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"];
function _objectWithoutProperties$8(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}
function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys$i(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$i(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$i(Object(t), true).forEach(function(r2) {
      _defineProperty$l(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$l(obj, key, value) {
  key = _toPropertyKey$l(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$l(descriptor.key), descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$l(arg) {
  var key = _toPrimitive$l(arg, "string");
  return _typeof$l(key) === "symbol" ? key : String(key);
}
function _toPrimitive$l(input, hint2) {
  if (_typeof$l(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint2);
    if (_typeof$l(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint2 === "string" ? String : Number)(input);
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p2) {
  _setPrototypeOf$a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$a(o, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$a(o);
}
var Animate = /* @__PURE__ */ (function(_PureComponent) {
  _inherits$a(Animate2, _PureComponent);
  var _super = _createSuper(Animate2);
  function Animate2(props, context) {
    var _this;
    _classCallCheck$c(this, Animate2);
    _this = _super.call(this, props, context);
    var _this$props = _this.props, isActive = _this$props.isActive, attributeName = _this$props.attributeName, from = _this$props.from, to = _this$props.to, steps = _this$props.steps, children = _this$props.children, duration = _this$props.duration;
    _this.handleStyleChange = _this.handleStyleChange.bind(_assertThisInitialized$a(_this));
    _this.changeStyle = _this.changeStyle.bind(_assertThisInitialized$a(_this));
    if (!isActive || duration <= 0) {
      _this.state = {
        style: {}
      };
      if (typeof children === "function") {
        _this.state = {
          style: to
        };
      }
      return _possibleConstructorReturn$a(_this);
    }
    if (steps && steps.length) {
      _this.state = {
        style: steps[0].style
      };
    } else if (from) {
      if (typeof children === "function") {
        _this.state = {
          style: from
        };
        return _possibleConstructorReturn$a(_this);
      }
      _this.state = {
        style: attributeName ? _defineProperty$l({}, attributeName, from) : from
      };
    } else {
      _this.state = {
        style: {}
      };
    }
    return _this;
  }
  _createClass$c(Animate2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props2 = this.props, isActive = _this$props2.isActive, canBegin = _this$props2.canBegin;
      this.mounted = true;
      if (!isActive || !canBegin) {
        return;
      }
      this.runAnimation(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props3 = this.props, isActive = _this$props3.isActive, canBegin = _this$props3.canBegin, attributeName = _this$props3.attributeName, shouldReAnimate = _this$props3.shouldReAnimate, to = _this$props3.to, currentFrom = _this$props3.from;
      var style = this.state.style;
      if (!canBegin) {
        return;
      }
      if (!isActive) {
        var newState = {
          style: attributeName ? _defineProperty$l({}, attributeName, to) : to
        };
        if (this.state && style) {
          if (attributeName && style[attributeName] !== to || !attributeName && style !== to) {
            this.setState(newState);
          }
        }
        return;
      }
      if (deepEqual$2(prevProps.to, to) && prevProps.canBegin && prevProps.isActive) {
        return;
      }
      var isTriggered = !prevProps.canBegin || !prevProps.isActive;
      if (this.manager) {
        this.manager.stop();
      }
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
      var from = isTriggered || shouldReAnimate ? currentFrom : prevProps.to;
      if (this.state && style) {
        var _newState = {
          style: attributeName ? _defineProperty$l({}, attributeName, from) : from
        };
        if (attributeName && style[attributeName] !== from || !attributeName && style !== from) {
          this.setState(_newState);
        }
      }
      this.runAnimation(_objectSpread$i(_objectSpread$i({}, this.props), {}, {
        from,
        begin: 0
      }));
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
      var onAnimationEnd2 = this.props.onAnimationEnd;
      if (this.unSubscribe) {
        this.unSubscribe();
      }
      if (this.manager) {
        this.manager.stop();
        this.manager = null;
      }
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
      if (onAnimationEnd2) {
        onAnimationEnd2();
      }
    }
  }, {
    key: "handleStyleChange",
    value: function handleStyleChange(style) {
      this.changeStyle(style);
    }
  }, {
    key: "changeStyle",
    value: function changeStyle(style) {
      if (this.mounted) {
        this.setState({
          style
        });
      }
    }
  }, {
    key: "runJSAnimation",
    value: function runJSAnimation(props) {
      var _this2 = this;
      var from = props.from, to = props.to, duration = props.duration, easing = props.easing, begin = props.begin, onAnimationEnd2 = props.onAnimationEnd, onAnimationStart2 = props.onAnimationStart;
      var startAnimation = configUpdate(from, to, configEasing(easing), duration, this.changeStyle);
      var finalStartAnimation = function finalStartAnimation2() {
        _this2.stopJSAnimation = startAnimation();
      };
      this.manager.start([onAnimationStart2, begin, finalStartAnimation, duration, onAnimationEnd2]);
    }
  }, {
    key: "runStepAnimation",
    value: function runStepAnimation(props) {
      var _this3 = this;
      var steps = props.steps, begin = props.begin, onAnimationStart2 = props.onAnimationStart;
      var _steps$ = steps[0], initialStyle = _steps$.style, _steps$$duration = _steps$.duration, initialTime = _steps$$duration === void 0 ? 0 : _steps$$duration;
      var addStyle = function addStyle2(sequence, nextItem, index2) {
        if (index2 === 0) {
          return sequence;
        }
        var duration = nextItem.duration, _nextItem$easing = nextItem.easing, easing = _nextItem$easing === void 0 ? "ease" : _nextItem$easing, style = nextItem.style, nextProperties = nextItem.properties, onAnimationEnd2 = nextItem.onAnimationEnd;
        var preItem = index2 > 0 ? steps[index2 - 1] : nextItem;
        var properties = nextProperties || Object.keys(style);
        if (typeof easing === "function" || easing === "spring") {
          return [].concat(_toConsumableArray$3(sequence), [_this3.runJSAnimation.bind(_this3, {
            from: preItem.style,
            to: style,
            duration,
            easing
          }), duration]);
        }
        var transition = getTransitionVal(properties, duration, easing);
        var newStyle = _objectSpread$i(_objectSpread$i(_objectSpread$i({}, preItem.style), style), {}, {
          transition
        });
        return [].concat(_toConsumableArray$3(sequence), [newStyle, duration, onAnimationEnd2]).filter(identity$1);
      };
      return this.manager.start([onAnimationStart2].concat(_toConsumableArray$3(steps.reduce(addStyle, [initialStyle, Math.max(initialTime, begin)])), [props.onAnimationEnd]));
    }
  }, {
    key: "runAnimation",
    value: function runAnimation(props) {
      if (!this.manager) {
        this.manager = createAnimateManager();
      }
      var begin = props.begin, duration = props.duration, attributeName = props.attributeName, propsTo = props.to, easing = props.easing, onAnimationStart2 = props.onAnimationStart, onAnimationEnd2 = props.onAnimationEnd, steps = props.steps, children = props.children;
      var manager = this.manager;
      this.unSubscribe = manager.subscribe(this.handleStyleChange);
      if (typeof easing === "function" || typeof children === "function" || easing === "spring") {
        this.runJSAnimation(props);
        return;
      }
      if (steps.length > 1) {
        this.runStepAnimation(props);
        return;
      }
      var to = attributeName ? _defineProperty$l({}, attributeName, propsTo) : propsTo;
      var transition = getTransitionVal(Object.keys(to), duration, easing);
      manager.start([onAnimationStart2, begin, _objectSpread$i(_objectSpread$i({}, to), {}, {
        transition
      }), duration, onAnimationEnd2]);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props, children = _this$props4.children;
      _this$props4.begin;
      var duration = _this$props4.duration;
      _this$props4.attributeName;
      _this$props4.easing;
      var isActive = _this$props4.isActive;
      _this$props4.steps;
      _this$props4.from;
      _this$props4.to;
      _this$props4.canBegin;
      _this$props4.onAnimationEnd;
      _this$props4.shouldReAnimate;
      _this$props4.onAnimationReStart;
      var others = _objectWithoutProperties$8(_this$props4, _excluded$8);
      var count2 = reactExports.Children.count(children);
      var stateStyle = this.state.style;
      if (typeof children === "function") {
        return children(stateStyle);
      }
      if (!isActive || count2 === 0 || duration <= 0) {
        return children;
      }
      var cloneContainer = function cloneContainer2(container) {
        var _container$props = container.props, _container$props$styl = _container$props.style, style = _container$props$styl === void 0 ? {} : _container$props$styl, className = _container$props.className;
        var res = /* @__PURE__ */ reactExports.cloneElement(container, _objectSpread$i(_objectSpread$i({}, others), {}, {
          style: _objectSpread$i(_objectSpread$i({}, style), stateStyle),
          className
        }));
        return res;
      };
      if (count2 === 1) {
        return cloneContainer(reactExports.Children.only(children));
      }
      return /* @__PURE__ */ React.createElement("div", null, reactExports.Children.map(children, function(child) {
        return cloneContainer(child);
      }));
    }
  }]);
  return Animate2;
})(reactExports.PureComponent);
Animate.displayName = "Animate";
Animate.defaultProps = {
  begin: 0,
  duration: 1e3,
  from: "",
  to: "",
  attributeName: "",
  easing: "ease",
  isActive: true,
  canBegin: true,
  steps: [],
  onAnimationEnd: function onAnimationEnd() {
  },
  onAnimationStart: function onAnimationStart() {
  }
};
Animate.propTypes = {
  from: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  to: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  attributeName: PropTypes.string,
  // animation duration
  duration: PropTypes.number,
  begin: PropTypes.number,
  easing: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  steps: PropTypes.arrayOf(PropTypes.shape({
    duration: PropTypes.number.isRequired,
    style: PropTypes.object.isRequired,
    easing: PropTypes.oneOfType([PropTypes.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), PropTypes.func]),
    // transition css properties(dash case), optional
    properties: PropTypes.arrayOf("string"),
    onAnimationEnd: PropTypes.func
  })),
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  isActive: PropTypes.bool,
  canBegin: PropTypes.bool,
  onAnimationEnd: PropTypes.func,
  // decide if it should reanimate with initial from style when props change
  shouldReAnimate: PropTypes.bool,
  onAnimationStart: PropTypes.func,
  onAnimationReStart: PropTypes.func
};
function _typeof$k(o) {
  "@babel/helpers - typeof";
  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$k(o);
}
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$5(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$3(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr)) return arr;
}
function ownKeys$h(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$h(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$h(Object(t), true).forEach(function(r2) {
      _defineProperty$k(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$k(obj, key, value) {
  key = _toPropertyKey$k(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$k(t) {
  var i = _toPrimitive$k(t, "string");
  return "symbol" == _typeof$k(i) ? i : i + "";
}
function _toPrimitive$k(t, r) {
  if ("object" != _typeof$k(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$k(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var getRectanglePath = function getRectanglePath2(x2, y2, width, height, radius) {
  var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
  var ySign = height >= 0 ? 1 : -1;
  var xSign = width >= 0 ? 1 : -1;
  var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
  var path;
  if (maxRadius > 0 && radius instanceof Array) {
    var newRadius = [0, 0, 0, 0];
    for (var i = 0, len = 4; i < len; i++) {
      newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
    }
    path = "M".concat(x2, ",").concat(y2 + ySign * newRadius[0]);
    if (newRadius[0] > 0) {
      path += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x2 + xSign * newRadius[0], ",").concat(y2);
    }
    path += "L ".concat(x2 + width - xSign * newRadius[1], ",").concat(y2);
    if (newRadius[1] > 0) {
      path += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width, ",").concat(y2 + ySign * newRadius[1]);
    }
    path += "L ".concat(x2 + width, ",").concat(y2 + height - ySign * newRadius[2]);
    if (newRadius[2] > 0) {
      path += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width - xSign * newRadius[2], ",").concat(y2 + height);
    }
    path += "L ".concat(x2 + xSign * newRadius[3], ",").concat(y2 + height);
    if (newRadius[3] > 0) {
      path += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x2, ",").concat(y2 + height - ySign * newRadius[3]);
    }
    path += "Z";
  } else if (maxRadius > 0 && radius === +radius && radius > 0) {
    var _newRadius = Math.min(maxRadius, radius);
    path = "M ".concat(x2, ",").concat(y2 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + xSign * _newRadius, ",").concat(y2, "\n            L ").concat(x2 + width - xSign * _newRadius, ",").concat(y2, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width, ",").concat(y2 + ySign * _newRadius, "\n            L ").concat(x2 + width, ",").concat(y2 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width - xSign * _newRadius, ",").concat(y2 + height, "\n            L ").concat(x2 + xSign * _newRadius, ",").concat(y2 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2, ",").concat(y2 + height - ySign * _newRadius, " Z");
  } else {
    path = "M ".concat(x2, ",").concat(y2, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
  }
  return path;
};
var isInRectangle = function isInRectangle2(point2, rect) {
  if (!point2 || !rect) {
    return false;
  }
  var px = point2.x, py = point2.y;
  var x2 = rect.x, y2 = rect.y, width = rect.width, height = rect.height;
  if (Math.abs(width) > 0 && Math.abs(height) > 0) {
    var minX = Math.min(x2, x2 + width);
    var maxX = Math.max(x2, x2 + width);
    var minY = Math.min(y2, y2 + height);
    var maxY = Math.max(y2, y2 + height);
    return px >= minX && px <= maxX && py >= minY && py <= maxY;
  }
  return false;
};
var defaultProps$e = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: false,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
};
var Rectangle = function Rectangle2(rectangleProps) {
  var props = _objectSpread$h(_objectSpread$h({}, defaultProps$e), rectangleProps);
  var pathRef = reactExports.useRef();
  var _useState = reactExports.useState(-1), _useState2 = _slicedToArray$3(_useState, 2), totalLength = _useState2[0], setTotalLength = _useState2[1];
  reactExports.useEffect(function() {
    if (pathRef.current && pathRef.current.getTotalLength) {
      try {
        var pathTotalLength = pathRef.current.getTotalLength();
        if (pathTotalLength) {
          setTotalLength(pathTotalLength);
        }
      } catch (err) {
      }
    }
  }, []);
  var x2 = props.x, y2 = props.y, width = props.width, height = props.height, radius = props.radius, className = props.className;
  var animationEasing = props.animationEasing, animationDuration = props.animationDuration, animationBegin = props.animationBegin, isAnimationActive = props.isAnimationActive, isUpdateAnimationActive = props.isUpdateAnimationActive;
  if (x2 !== +x2 || y2 !== +y2 || width !== +width || height !== +height || width === 0 || height === 0) {
    return null;
  }
  var layerClass = clsx("recharts-rectangle", className);
  if (!isUpdateAnimationActive) {
    return /* @__PURE__ */ React.createElement("path", _extends$f({}, filterProps(props, true), {
      className: layerClass,
      d: getRectanglePath(x2, y2, width, height, radius)
    }));
  }
  return /* @__PURE__ */ React.createElement(Animate, {
    canBegin: totalLength > 0,
    from: {
      width,
      height,
      x: x2,
      y: y2
    },
    to: {
      width,
      height,
      x: x2,
      y: y2
    },
    duration: animationDuration,
    animationEasing,
    isActive: isUpdateAnimationActive
  }, function(_ref) {
    var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
    return /* @__PURE__ */ React.createElement(Animate, {
      canBegin: totalLength > 0,
      from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
      to: "".concat(totalLength, "px 0px"),
      attributeName: "strokeDasharray",
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing
    }, /* @__PURE__ */ React.createElement("path", _extends$f({}, filterProps(props, true), {
      className: layerClass,
      d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
      ref: pathRef
    })));
  });
};
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
var Dot = function Dot2(props) {
  var cx = props.cx, cy = props.cy, r = props.r, className = props.className;
  var layerClass = clsx("recharts-dot", className);
  if (cx === +cx && cy === +cy && r === +r) {
    return /* @__PURE__ */ reactExports.createElement("circle", _extends$e({}, filterProps(props, false), adaptEventHandlers(props), {
      className: layerClass,
      cx,
      cy,
      r
    }));
  }
  return null;
};
function _typeof$j(o) {
  "@babel/helpers - typeof";
  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$j(o);
}
var _excluded$7 = ["x", "y", "top", "left", "width", "height", "className"];
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function ownKeys$g(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$g(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$g(Object(t), true).forEach(function(r2) {
      _defineProperty$j(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$j(obj, key, value) {
  key = _toPropertyKey$j(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$j(t) {
  var i = _toPrimitive$j(t, "string");
  return "symbol" == _typeof$j(i) ? i : i + "";
}
function _toPrimitive$j(t, r) {
  if ("object" != _typeof$j(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$j(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var getPath2 = function getPath3(x2, y2, width, height, top, left) {
  return "M".concat(x2, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y2, "h").concat(width);
};
var Cross = function Cross2(_ref) {
  var _ref$x = _ref.x, x2 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y2 = _ref$y === void 0 ? 0 : _ref$y, _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top, _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$width = _ref.width, width = _ref$width === void 0 ? 0 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 0 : _ref$height, className = _ref.className, rest = _objectWithoutProperties$7(_ref, _excluded$7);
  var props = _objectSpread$g({
    x: x2,
    y: y2,
    top,
    left,
    width,
    height
  }, rest);
  if (!isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
    return null;
  }
  return /* @__PURE__ */ React.createElement("path", _extends$d({}, filterProps(props, true), {
    className: clsx("recharts-cross", className),
    d: getPath2(x2, y2, width, height, top, left)
  }));
};
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype) return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject2(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject2;
  return isPlainObject_1;
}
var isPlainObjectExports = requireIsPlainObject();
const isPlainObject$1 = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObjectExports);
var isBoolean_1;
var hasRequiredIsBoolean;
function requireIsBoolean() {
  if (hasRequiredIsBoolean) return isBoolean_1;
  hasRequiredIsBoolean = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var boolTag = "[object Boolean]";
  function isBoolean2(value) {
    return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
  }
  isBoolean_1 = isBoolean2;
  return isBoolean_1;
}
var isBooleanExports = requireIsBoolean();
const isBoolean$1 = /* @__PURE__ */ getDefaultExportFromCjs(isBooleanExports);
function _typeof$i(o) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$i(o);
}
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$2(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr)) return arr;
}
function ownKeys$f(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$f(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$f(Object(t), true).forEach(function(r2) {
      _defineProperty$i(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$i(obj, key, value) {
  key = _toPropertyKey$i(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$i(t) {
  var i = _toPrimitive$i(t, "string");
  return "symbol" == _typeof$i(i) ? i : i + "";
}
function _toPrimitive$i(t, r) {
  if ("object" != _typeof$i(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$i(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var getTrapezoidPath = function getTrapezoidPath2(x2, y2, upperWidth, lowerWidth, height) {
  var widthGap = upperWidth - lowerWidth;
  var path;
  path = "M ".concat(x2, ",").concat(y2);
  path += "L ".concat(x2 + upperWidth, ",").concat(y2);
  path += "L ".concat(x2 + upperWidth - widthGap / 2, ",").concat(y2 + height);
  path += "L ".concat(x2 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y2 + height);
  path += "L ".concat(x2, ",").concat(y2, " Z");
  return path;
};
var defaultProps$d = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
};
var Trapezoid = function Trapezoid2(props) {
  var trapezoidProps = _objectSpread$f(_objectSpread$f({}, defaultProps$d), props);
  var pathRef = reactExports.useRef();
  var _useState = reactExports.useState(-1), _useState2 = _slicedToArray$2(_useState, 2), totalLength = _useState2[0], setTotalLength = _useState2[1];
  reactExports.useEffect(function() {
    if (pathRef.current && pathRef.current.getTotalLength) {
      try {
        var pathTotalLength = pathRef.current.getTotalLength();
        if (pathTotalLength) {
          setTotalLength(pathTotalLength);
        }
      } catch (err) {
      }
    }
  }, []);
  var x2 = trapezoidProps.x, y2 = trapezoidProps.y, upperWidth = trapezoidProps.upperWidth, lowerWidth = trapezoidProps.lowerWidth, height = trapezoidProps.height, className = trapezoidProps.className;
  var animationEasing = trapezoidProps.animationEasing, animationDuration = trapezoidProps.animationDuration, animationBegin = trapezoidProps.animationBegin, isUpdateAnimationActive = trapezoidProps.isUpdateAnimationActive;
  if (x2 !== +x2 || y2 !== +y2 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {
    return null;
  }
  var layerClass = clsx("recharts-trapezoid", className);
  if (!isUpdateAnimationActive) {
    return /* @__PURE__ */ React.createElement("g", null, /* @__PURE__ */ React.createElement("path", _extends$c({}, filterProps(trapezoidProps, true), {
      className: layerClass,
      d: getTrapezoidPath(x2, y2, upperWidth, lowerWidth, height)
    })));
  }
  return /* @__PURE__ */ React.createElement(Animate, {
    canBegin: totalLength > 0,
    from: {
      upperWidth: 0,
      lowerWidth: 0,
      height,
      x: x2,
      y: y2
    },
    to: {
      upperWidth,
      lowerWidth,
      height,
      x: x2,
      y: y2
    },
    duration: animationDuration,
    animationEasing,
    isActive: isUpdateAnimationActive
  }, function(_ref) {
    var currUpperWidth = _ref.upperWidth, currLowerWidth = _ref.lowerWidth, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
    return /* @__PURE__ */ React.createElement(Animate, {
      canBegin: totalLength > 0,
      from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
      to: "".concat(totalLength, "px 0px"),
      attributeName: "strokeDasharray",
      begin: animationBegin,
      duration: animationDuration,
      easing: animationEasing
    }, /* @__PURE__ */ React.createElement("path", _extends$c({}, filterProps(trapezoidProps, true), {
      className: layerClass,
      d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
      ref: pathRef
    })));
  });
};
var _excluded$6 = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function _typeof$h(o) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$h(o);
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function ownKeys$e(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$e(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$e(Object(t), true).forEach(function(r2) {
      _defineProperty$h(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$h(obj, key, value) {
  key = _toPropertyKey$h(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$h(t) {
  var i = _toPrimitive$h(t, "string");
  return "symbol" == _typeof$h(i) ? i : i + "";
}
function _toPrimitive$h(t, r) {
  if ("object" != _typeof$h(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$h(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function defaultPropTransformer(option, props) {
  return _objectSpread$e(_objectSpread$e({}, props), option);
}
function isSymbolsProps(shapeType, _elementProps) {
  return shapeType === "symbols";
}
function ShapeSelector(_ref) {
  var shapeType = _ref.shapeType, elementProps = _ref.elementProps;
  switch (shapeType) {
    case "rectangle":
      return /* @__PURE__ */ React.createElement(Rectangle, elementProps);
    case "trapezoid":
      return /* @__PURE__ */ React.createElement(Trapezoid, elementProps);
    case "sector":
      return /* @__PURE__ */ React.createElement(Sector, elementProps);
    case "symbols":
      if (isSymbolsProps(shapeType)) {
        return /* @__PURE__ */ React.createElement(Symbols, elementProps);
      }
      break;
    default:
      return null;
  }
}
function getPropsFromShapeOption(option) {
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    return option.props;
  }
  return option;
}
function Shape(_ref2) {
  var option = _ref2.option, shapeType = _ref2.shapeType, _ref2$propTransformer = _ref2.propTransformer, propTransformer = _ref2$propTransformer === void 0 ? defaultPropTransformer : _ref2$propTransformer, _ref2$activeClassName = _ref2.activeClassName, activeClassName = _ref2$activeClassName === void 0 ? "recharts-active-shape" : _ref2$activeClassName, isActive = _ref2.isActive, props = _objectWithoutProperties$6(_ref2, _excluded$6);
  var shape;
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    shape = /* @__PURE__ */ reactExports.cloneElement(option, _objectSpread$e(_objectSpread$e({}, props), getPropsFromShapeOption(option)));
  } else if (isFunction$2(option)) {
    shape = option(props);
  } else if (isPlainObject$1(option) && !isBoolean$1(option)) {
    var nextProps = propTransformer(option, props);
    shape = /* @__PURE__ */ React.createElement(ShapeSelector, {
      shapeType,
      elementProps: nextProps
    });
  } else {
    var elementProps = props;
    shape = /* @__PURE__ */ React.createElement(ShapeSelector, {
      shapeType,
      elementProps
    });
  }
  if (isActive) {
    return /* @__PURE__ */ React.createElement(Layer$1, {
      className: activeClassName
    }, shape);
  }
  return shape;
}
function isFunnel(graphicalItem, _item) {
  return _item != null && "trapezoids" in graphicalItem.props;
}
function isPie(graphicalItem, _item) {
  return _item != null && "sectors" in graphicalItem.props;
}
function isScatter(graphicalItem, _item) {
  return _item != null && "points" in graphicalItem.props;
}
function compareFunnel(shapeData, activeTooltipItem) {
  var _activeTooltipItem$la, _activeTooltipItem$la2;
  var xMatches = shapeData.x === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la === void 0 ? void 0 : _activeTooltipItem$la.x) || shapeData.x === activeTooltipItem.x;
  var yMatches = shapeData.y === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la2 = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la2 === void 0 ? void 0 : _activeTooltipItem$la2.y) || shapeData.y === activeTooltipItem.y;
  return xMatches && yMatches;
}
function comparePie(shapeData, activeTooltipItem) {
  var startAngleMatches = shapeData.endAngle === activeTooltipItem.endAngle;
  var endAngleMatches = shapeData.startAngle === activeTooltipItem.startAngle;
  return startAngleMatches && endAngleMatches;
}
function compareScatter(shapeData, activeTooltipItem) {
  var xMatches = shapeData.x === activeTooltipItem.x;
  var yMatches = shapeData.y === activeTooltipItem.y;
  var zMatches = shapeData.z === activeTooltipItem.z;
  return xMatches && yMatches && zMatches;
}
function getComparisonFn(graphicalItem, activeItem) {
  var comparison;
  if (isFunnel(graphicalItem, activeItem)) {
    comparison = compareFunnel;
  } else if (isPie(graphicalItem, activeItem)) {
    comparison = comparePie;
  } else if (isScatter(graphicalItem, activeItem)) {
    comparison = compareScatter;
  }
  return comparison;
}
function getShapeDataKey(graphicalItem, activeItem) {
  var shapeKey;
  if (isFunnel(graphicalItem, activeItem)) {
    shapeKey = "trapezoids";
  } else if (isPie(graphicalItem, activeItem)) {
    shapeKey = "sectors";
  } else if (isScatter(graphicalItem, activeItem)) {
    shapeKey = "points";
  }
  return shapeKey;
}
function getActiveShapeTooltipPayload(graphicalItem, activeItem) {
  if (isFunnel(graphicalItem, activeItem)) {
    var _activeItem$tooltipPa;
    return (_activeItem$tooltipPa = activeItem.tooltipPayload) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa[0]) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa.payload) === null || _activeItem$tooltipPa === void 0 ? void 0 : _activeItem$tooltipPa.payload;
  }
  if (isPie(graphicalItem, activeItem)) {
    var _activeItem$tooltipPa2;
    return (_activeItem$tooltipPa2 = activeItem.tooltipPayload) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2[0]) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2.payload) === null || _activeItem$tooltipPa2 === void 0 ? void 0 : _activeItem$tooltipPa2.payload;
  }
  if (isScatter(graphicalItem, activeItem)) {
    return activeItem.payload;
  }
  return {};
}
function getActiveShapeIndexForTooltip(_ref3) {
  var activeTooltipItem = _ref3.activeTooltipItem, graphicalItem = _ref3.graphicalItem, itemData = _ref3.itemData;
  var shapeKey = getShapeDataKey(graphicalItem, activeTooltipItem);
  var tooltipPayload = getActiveShapeTooltipPayload(graphicalItem, activeTooltipItem);
  var activeItemMatches = itemData.filter(function(datum, dataIndex) {
    var valuesMatch = isEqual$1(tooltipPayload, datum);
    var mouseCoordinateMatches = graphicalItem.props[shapeKey].filter(function(shapeData) {
      var comparison = getComparisonFn(graphicalItem, activeTooltipItem);
      return comparison(shapeData, activeTooltipItem);
    });
    var indexOfMouseCoordinates = graphicalItem.props[shapeKey].indexOf(mouseCoordinateMatches[mouseCoordinateMatches.length - 1]);
    var coordinatesMatch = dataIndex === indexOfMouseCoordinates;
    return valuesMatch && coordinatesMatch;
  });
  var activeIndex = itemData.indexOf(activeItemMatches[activeItemMatches.length - 1]);
  return activeIndex;
}
var _baseRange;
var hasRequired_baseRange;
function require_baseRange() {
  if (hasRequired_baseRange) return _baseRange;
  hasRequired_baseRange = 1;
  var nativeCeil = Math.ceil, nativeMax = Math.max;
  function baseRange(start2, end, step, fromRight) {
    var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result = Array(length);
    while (length--) {
      result[fromRight ? length : ++index2] = start2;
      start2 += step;
    }
    return result;
  }
  _baseRange = baseRange;
  return _baseRange;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite) return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var _createRange;
var hasRequired_createRange;
function require_createRange() {
  if (hasRequired_createRange) return _createRange;
  hasRequired_createRange = 1;
  var baseRange = require_baseRange(), isIterateeCall = require_isIterateeCall(), toFinite = requireToFinite();
  function createRange(fromRight) {
    return function(start2, end, step) {
      if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
        end = step = void 0;
      }
      start2 = toFinite(start2);
      if (end === void 0) {
        end = start2;
        start2 = 0;
      } else {
        end = toFinite(end);
      }
      step = step === void 0 ? start2 < end ? 1 : -1 : toFinite(step);
      return baseRange(start2, end, step, fromRight);
    };
  }
  _createRange = createRange;
  return _createRange;
}
var range_1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range_1;
  hasRequiredRange = 1;
  var createRange = require_createRange();
  var range3 = createRange();
  range_1 = range3;
  return range_1;
}
var rangeExports = requireRange();
const range2 = /* @__PURE__ */ getDefaultExportFromCjs(rangeExports);
function _typeof$g(o) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$g(o);
}
function ownKeys$d(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$d(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$d(Object(t), true).forEach(function(r2) {
      _defineProperty$g(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$g(obj, key, value) {
  key = _toPropertyKey$g(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$g(t) {
  var i = _toPrimitive$g(t, "string");
  return "symbol" == _typeof$g(i) ? i : i + "";
}
function _toPrimitive$g(t, r) {
  if ("object" != _typeof$g(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$g(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var PREFIX_LIST = ["Webkit", "Moz", "O", "ms"];
var generatePrefixStyle = function generatePrefixStyle2(name2, value) {
  var camelName = name2.replace(/(\w)/, function(v) {
    return v.toUpperCase();
  });
  var result = PREFIX_LIST.reduce(function(res, entry) {
    return _objectSpread$d(_objectSpread$d({}, res), {}, _defineProperty$g({}, entry + camelName, value));
  }, {});
  result[name2] = value;
  return result;
};
function _typeof$f(o) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$f(o);
}
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function ownKeys$c(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$c(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$c(Object(t), true).forEach(function(r2) {
      _defineProperty$f(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$f(descriptor.key), descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$b(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$9(t, o, e) {
  return o = _getPrototypeOf$9(o), _possibleConstructorReturn$9(t, _isNativeReflectConstruct$9() ? Reflect.construct(o, e || [], _getPrototypeOf$9(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$9(self2, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$9(o);
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p2) {
  _setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$9(o, p2);
}
function _defineProperty$f(obj, key, value) {
  key = _toPropertyKey$f(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$f(t) {
  var i = _toPrimitive$f(t, "string");
  return "symbol" == _typeof$f(i) ? i : i + "";
}
function _toPrimitive$f(t, r) {
  if ("object" != _typeof$f(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$f(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var createScale = function createScale2(_ref) {
  var data = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x2 = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;
  if (!data || !data.length) {
    return {};
  }
  var len = data.length;
  var scale2 = point().domain(range2(0, len)).range([x2, x2 + width - travellerWidth]);
  var scaleValues = scale2.domain().map(function(entry) {
    return scale2(entry);
  });
  return {
    isTextActive: false,
    isSlideMoving: false,
    isTravellerMoving: false,
    isTravellerFocused: false,
    startX: scale2(startIndex),
    endX: scale2(endIndex),
    scale: scale2,
    scaleValues
  };
};
var isTouch = function isTouch2(e) {
  return e.changedTouches && !!e.changedTouches.length;
};
var Brush = /* @__PURE__ */ (function(_PureComponent) {
  function Brush2(props) {
    var _this;
    _classCallCheck$b(this, Brush2);
    _this = _callSuper$9(this, Brush2, [props]);
    _defineProperty$f(_this, "handleDrag", function(e) {
      if (_this.leaveTimer) {
        clearTimeout(_this.leaveTimer);
        _this.leaveTimer = null;
      }
      if (_this.state.isTravellerMoving) {
        _this.handleTravellerMove(e);
      } else if (_this.state.isSlideMoving) {
        _this.handleSlideDrag(e);
      }
    });
    _defineProperty$f(_this, "handleTouchMove", function(e) {
      if (e.changedTouches != null && e.changedTouches.length > 0) {
        _this.handleDrag(e.changedTouches[0]);
      }
    });
    _defineProperty$f(_this, "handleDragEnd", function() {
      _this.setState({
        isTravellerMoving: false,
        isSlideMoving: false
      }, function() {
        var _this$props = _this.props, endIndex = _this$props.endIndex, onDragEnd = _this$props.onDragEnd, startIndex = _this$props.startIndex;
        onDragEnd === null || onDragEnd === void 0 || onDragEnd({
          endIndex,
          startIndex
        });
      });
      _this.detachDragEndListener();
    });
    _defineProperty$f(_this, "handleLeaveWrapper", function() {
      if (_this.state.isTravellerMoving || _this.state.isSlideMoving) {
        _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);
      }
    });
    _defineProperty$f(_this, "handleEnterSlideOrTraveller", function() {
      _this.setState({
        isTextActive: true
      });
    });
    _defineProperty$f(_this, "handleLeaveSlideOrTraveller", function() {
      _this.setState({
        isTextActive: false
      });
    });
    _defineProperty$f(_this, "handleSlideDragStart", function(e) {
      var event = isTouch(e) ? e.changedTouches[0] : e;
      _this.setState({
        isTravellerMoving: false,
        isSlideMoving: true,
        slideMoveStartX: event.pageX
      });
      _this.attachDragEndListener();
    });
    _this.travellerDragStartHandlers = {
      startX: _this.handleTravellerDragStart.bind(_this, "startX"),
      endX: _this.handleTravellerDragStart.bind(_this, "endX")
    };
    _this.state = {};
    return _this;
  }
  _inherits$9(Brush2, _PureComponent);
  return _createClass$b(Brush2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.leaveTimer) {
        clearTimeout(this.leaveTimer);
        this.leaveTimer = null;
      }
      this.detachDragEndListener();
    }
  }, {
    key: "getIndex",
    value: function getIndex(_ref2) {
      var startX = _ref2.startX, endX = _ref2.endX;
      var scaleValues = this.state.scaleValues;
      var _this$props2 = this.props, gap = _this$props2.gap, data = _this$props2.data;
      var lastIndex = data.length - 1;
      var min2 = Math.min(startX, endX);
      var max2 = Math.max(startX, endX);
      var minIndex = Brush2.getIndexInRange(scaleValues, min2);
      var maxIndex = Brush2.getIndexInRange(scaleValues, max2);
      return {
        startIndex: minIndex - minIndex % gap,
        endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
      };
    }
  }, {
    key: "getTextOfTick",
    value: function getTextOfTick(index2) {
      var _this$props3 = this.props, data = _this$props3.data, tickFormatter = _this$props3.tickFormatter, dataKey = _this$props3.dataKey;
      var text = getValueByDataKey(data[index2], dataKey, index2);
      return isFunction$2(tickFormatter) ? tickFormatter(text, index2) : text;
    }
  }, {
    key: "attachDragEndListener",
    value: function attachDragEndListener() {
      window.addEventListener("mouseup", this.handleDragEnd, true);
      window.addEventListener("touchend", this.handleDragEnd, true);
      window.addEventListener("mousemove", this.handleDrag, true);
    }
  }, {
    key: "detachDragEndListener",
    value: function detachDragEndListener() {
      window.removeEventListener("mouseup", this.handleDragEnd, true);
      window.removeEventListener("touchend", this.handleDragEnd, true);
      window.removeEventListener("mousemove", this.handleDrag, true);
    }
  }, {
    key: "handleSlideDrag",
    value: function handleSlideDrag(e) {
      var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX;
      var _this$props4 = this.props, x2 = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, startIndex = _this$props4.startIndex, endIndex = _this$props4.endIndex, onChange = _this$props4.onChange;
      var delta = e.pageX - slideMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - endX, x2 + width - travellerWidth - startX);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - startX, x2 - endX);
      }
      var newIndex = this.getIndex({
        startX: startX + delta,
        endX: endX + delta
      });
      if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {
        onChange(newIndex);
      }
      this.setState({
        startX: startX + delta,
        endX: endX + delta,
        slideMoveStartX: e.pageX
      });
    }
  }, {
    key: "handleTravellerDragStart",
    value: function handleTravellerDragStart(id, e) {
      var event = isTouch(e) ? e.changedTouches[0] : e;
      this.setState({
        isSlideMoving: false,
        isTravellerMoving: true,
        movingTravellerId: id,
        brushMoveStartX: event.pageX
      });
      this.attachDragEndListener();
    }
  }, {
    key: "handleTravellerMove",
    value: function handleTravellerMove(e) {
      var _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX;
      var prevValue = this.state[movingTravellerId];
      var _this$props5 = this.props, x2 = _this$props5.x, width = _this$props5.width, travellerWidth = _this$props5.travellerWidth, onChange = _this$props5.onChange, gap = _this$props5.gap, data = _this$props5.data;
      var params = {
        startX: this.state.startX,
        endX: this.state.endX
      };
      var delta = e.pageX - brushMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - prevValue);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - prevValue);
      }
      params[movingTravellerId] = prevValue + delta;
      var newIndex = this.getIndex(params);
      var startIndex = newIndex.startIndex, endIndex = newIndex.endIndex;
      var isFullGap = function isFullGap2() {
        var lastIndex = data.length - 1;
        if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {
          return true;
        }
        return false;
      };
      this.setState(_defineProperty$f(_defineProperty$f({}, movingTravellerId, prevValue + delta), "brushMoveStartX", e.pageX), function() {
        if (onChange) {
          if (isFullGap()) {
            onChange(newIndex);
          }
        }
      });
    }
  }, {
    key: "handleTravellerMoveKeyboard",
    value: function handleTravellerMoveKeyboard(direction, id) {
      var _this2 = this;
      var _this$state3 = this.state, scaleValues = _this$state3.scaleValues, startX = _this$state3.startX, endX = _this$state3.endX;
      var currentScaleValue = this.state[id];
      var currentIndex = scaleValues.indexOf(currentScaleValue);
      if (currentIndex === -1) {
        return;
      }
      var newIndex = currentIndex + direction;
      if (newIndex === -1 || newIndex >= scaleValues.length) {
        return;
      }
      var newScaleValue = scaleValues[newIndex];
      if (id === "startX" && newScaleValue >= endX || id === "endX" && newScaleValue <= startX) {
        return;
      }
      this.setState(_defineProperty$f({}, id, newScaleValue), function() {
        _this2.props.onChange(_this2.getIndex({
          startX: _this2.state.startX,
          endX: _this2.state.endX
        }));
      });
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var _this$props6 = this.props, x2 = _this$props6.x, y2 = _this$props6.y, width = _this$props6.width, height = _this$props6.height, fill = _this$props6.fill, stroke = _this$props6.stroke;
      return /* @__PURE__ */ React.createElement("rect", {
        stroke,
        fill,
        x: x2,
        y: y2,
        width,
        height
      });
    }
  }, {
    key: "renderPanorama",
    value: function renderPanorama() {
      var _this$props7 = this.props, x2 = _this$props7.x, y2 = _this$props7.y, width = _this$props7.width, height = _this$props7.height, data = _this$props7.data, children = _this$props7.children, padding = _this$props7.padding;
      var chartElement = reactExports.Children.only(children);
      if (!chartElement) {
        return null;
      }
      return /* @__PURE__ */ React.cloneElement(chartElement, {
        x: x2,
        y: y2,
        width,
        height,
        margin: padding,
        compact: true,
        data
      });
    }
  }, {
    key: "renderTravellerLayer",
    value: function renderTravellerLayer(travellerX, id) {
      var _data$startIndex, _data$endIndex, _this3 = this;
      var _this$props8 = this.props, y2 = _this$props8.y, travellerWidth = _this$props8.travellerWidth, height = _this$props8.height, traveller = _this$props8.traveller, ariaLabel = _this$props8.ariaLabel, data = _this$props8.data, startIndex = _this$props8.startIndex, endIndex = _this$props8.endIndex;
      var x2 = Math.max(travellerX, this.props.x);
      var travellerProps = _objectSpread$c(_objectSpread$c({}, filterProps(this.props, false)), {}, {
        x: x2,
        y: y2,
        width: travellerWidth,
        height
      });
      var ariaLabelBrush = ariaLabel || "Min value: ".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, ", Max value: ").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);
      return /* @__PURE__ */ React.createElement(Layer$1, {
        tabIndex: 0,
        role: "slider",
        "aria-label": ariaLabelBrush,
        "aria-valuenow": travellerX,
        className: "recharts-brush-traveller",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers[id],
        onTouchStart: this.travellerDragStartHandlers[id],
        onKeyDown: function onKeyDown(e) {
          if (!["ArrowLeft", "ArrowRight"].includes(e.key)) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          _this3.handleTravellerMoveKeyboard(e.key === "ArrowRight" ? 1 : -1, id);
        },
        onFocus: function onFocus() {
          _this3.setState({
            isTravellerFocused: true
          });
        },
        onBlur: function onBlur() {
          _this3.setState({
            isTravellerFocused: false
          });
        },
        style: {
          cursor: "col-resize"
        }
      }, Brush2.renderTraveller(traveller, travellerProps));
    }
  }, {
    key: "renderSlide",
    value: function renderSlide(startX, endX) {
      var _this$props9 = this.props, y2 = _this$props9.y, height = _this$props9.height, stroke = _this$props9.stroke, travellerWidth = _this$props9.travellerWidth;
      var x2 = Math.min(startX, endX) + travellerWidth;
      var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
      return /* @__PURE__ */ React.createElement("rect", {
        className: "recharts-brush-slide",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.handleSlideDragStart,
        onTouchStart: this.handleSlideDragStart,
        style: {
          cursor: "move"
        },
        stroke: "none",
        fill: stroke,
        fillOpacity: 0.2,
        x: x2,
        y: y2,
        width,
        height
      });
    }
  }, {
    key: "renderText",
    value: function renderText() {
      var _this$props10 = this.props, startIndex = _this$props10.startIndex, endIndex = _this$props10.endIndex, y2 = _this$props10.y, height = _this$props10.height, travellerWidth = _this$props10.travellerWidth, stroke = _this$props10.stroke;
      var _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX;
      var offset2 = 5;
      var attrs = {
        pointerEvents: "none",
        fill: stroke
      };
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: "recharts-brush-texts"
      }, /* @__PURE__ */ React.createElement(Text, _extends$b({
        textAnchor: "end",
        verticalAnchor: "middle",
        x: Math.min(startX, endX) - offset2,
        y: y2 + height / 2
      }, attrs), this.getTextOfTick(startIndex)), /* @__PURE__ */ React.createElement(Text, _extends$b({
        textAnchor: "start",
        verticalAnchor: "middle",
        x: Math.max(startX, endX) + travellerWidth + offset2,
        y: y2 + height / 2
      }, attrs), this.getTextOfTick(endIndex)));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props11 = this.props, data = _this$props11.data, className = _this$props11.className, children = _this$props11.children, x2 = _this$props11.x, y2 = _this$props11.y, width = _this$props11.width, height = _this$props11.height, alwaysShowText = _this$props11.alwaysShowText;
      var _this$state5 = this.state, startX = _this$state5.startX, endX = _this$state5.endX, isTextActive = _this$state5.isTextActive, isSlideMoving = _this$state5.isSlideMoving, isTravellerMoving = _this$state5.isTravellerMoving, isTravellerFocused = _this$state5.isTravellerFocused;
      if (!data || !data.length || !isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {
        return null;
      }
      var layerClass = clsx("recharts-brush", className);
      var isPanoramic = React.Children.count(children) === 1;
      var style = generatePrefixStyle("userSelect", "none");
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: layerClass,
        onMouseLeave: this.handleLeaveWrapper,
        onTouchMove: this.handleTouchMove,
        style
      }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, "startX"), this.renderTravellerLayer(endX, "endX"), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && this.renderText());
    }
  }], [{
    key: "renderDefaultTraveller",
    value: function renderDefaultTraveller(props) {
      var x2 = props.x, y2 = props.y, width = props.width, height = props.height, stroke = props.stroke;
      var lineY = Math.floor(y2 + height / 2) - 1;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("rect", {
        x: x2,
        y: y2,
        width,
        height,
        fill: stroke,
        stroke: "none"
      }), /* @__PURE__ */ React.createElement("line", {
        x1: x2 + 1,
        y1: lineY,
        x2: x2 + width - 1,
        y2: lineY,
        fill: "none",
        stroke: "#fff"
      }), /* @__PURE__ */ React.createElement("line", {
        x1: x2 + 1,
        y1: lineY + 2,
        x2: x2 + width - 1,
        y2: lineY + 2,
        fill: "none",
        stroke: "#fff"
      }));
    }
  }, {
    key: "renderTraveller",
    value: function renderTraveller(option, props) {
      var rectangle;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        rectangle = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (isFunction$2(option)) {
        rectangle = option(props);
      } else {
        rectangle = Brush2.renderDefaultTraveller(props);
      }
      return rectangle;
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var data = nextProps.data, width = nextProps.width, x2 = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;
      if (data !== prevState.prevData || updateId !== prevState.prevUpdateId) {
        return _objectSpread$c({
          prevData: data,
          prevTravellerWidth: travellerWidth,
          prevUpdateId: updateId,
          prevX: x2,
          prevWidth: width
        }, data && data.length ? createScale({
          data,
          width,
          x: x2,
          travellerWidth,
          startIndex,
          endIndex
        }) : {
          scale: null,
          scaleValues: null
        });
      }
      if (prevState.scale && (width !== prevState.prevWidth || x2 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
        prevState.scale.range([x2, x2 + width - travellerWidth]);
        var scaleValues = prevState.scale.domain().map(function(entry) {
          return prevState.scale(entry);
        });
        return {
          prevData: data,
          prevTravellerWidth: travellerWidth,
          prevUpdateId: updateId,
          prevX: x2,
          prevWidth: width,
          startX: prevState.scale(nextProps.startIndex),
          endX: prevState.scale(nextProps.endIndex),
          scaleValues
        };
      }
      return null;
    }
  }, {
    key: "getIndexInRange",
    value: function getIndexInRange(valueRange, x2) {
      var len = valueRange.length;
      var start2 = 0;
      var end = len - 1;
      while (end - start2 > 1) {
        var middle = Math.floor((start2 + end) / 2);
        if (valueRange[middle] > x2) {
          end = middle;
        } else {
          start2 = middle;
        }
      }
      return x2 >= valueRange[end] ? end : start2;
    }
  }]);
})(reactExports.PureComponent);
_defineProperty$f(Brush, "displayName", "Brush");
_defineProperty$f(Brush, "defaultProps", {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  },
  leaveTimeOut: 1e3,
  alwaysShowText: false
});
var _baseSome;
var hasRequired_baseSome;
function require_baseSome() {
  if (hasRequired_baseSome) return _baseSome;
  hasRequired_baseSome = 1;
  var baseEach = require_baseEach();
  function baseSome(collection, predicate) {
    var result;
    baseEach(collection, function(value, index2, collection2) {
      result = predicate(value, index2, collection2);
      return !result;
    });
    return !!result;
  }
  _baseSome = baseSome;
  return _baseSome;
}
var some_1;
var hasRequiredSome;
function requireSome() {
  if (hasRequiredSome) return some_1;
  hasRequiredSome = 1;
  var arraySome = require_arraySome(), baseIteratee = require_baseIteratee(), baseSome = require_baseSome(), isArray2 = requireIsArray(), isIterateeCall = require_isIterateeCall();
  function some2(collection, predicate, guard) {
    var func = isArray2(collection) ? arraySome : baseSome;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = void 0;
    }
    return func(collection, baseIteratee(predicate, 3));
  }
  some_1 = some2;
  return some_1;
}
var someExports = requireSome();
const some$1 = /* @__PURE__ */ getDefaultExportFromCjs(someExports);
var ifOverflowMatches = function ifOverflowMatches2(props, value) {
  var alwaysShow = props.alwaysShow;
  var ifOverflow = props.ifOverflow;
  if (alwaysShow) {
    ifOverflow = "extendDomain";
  }
  return ifOverflow === value;
};
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue) return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
var mapValues_1;
var hasRequiredMapValues;
function requireMapValues() {
  if (hasRequiredMapValues) return mapValues_1;
  hasRequiredMapValues = 1;
  var baseAssignValue = require_baseAssignValue(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee();
  function mapValues2(object2, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee, 3);
    baseForOwn(object2, function(value, key, object3) {
      baseAssignValue(result, key, iteratee(value, key, object3));
    });
    return result;
  }
  mapValues_1 = mapValues2;
  return mapValues_1;
}
var mapValuesExports = requireMapValues();
const mapValues = /* @__PURE__ */ getDefaultExportFromCjs(mapValuesExports);
var _arrayEvery;
var hasRequired_arrayEvery;
function require_arrayEvery() {
  if (hasRequired_arrayEvery) return _arrayEvery;
  hasRequired_arrayEvery = 1;
  function arrayEvery(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while (++index2 < length) {
      if (!predicate(array2[index2], index2, array2)) {
        return false;
      }
    }
    return true;
  }
  _arrayEvery = arrayEvery;
  return _arrayEvery;
}
var _baseEvery;
var hasRequired_baseEvery;
function require_baseEvery() {
  if (hasRequired_baseEvery) return _baseEvery;
  hasRequired_baseEvery = 1;
  var baseEach = require_baseEach();
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index2, collection2) {
      result = !!predicate(value, index2, collection2);
      return result;
    });
    return result;
  }
  _baseEvery = baseEvery;
  return _baseEvery;
}
var every_1;
var hasRequiredEvery;
function requireEvery() {
  if (hasRequiredEvery) return every_1;
  hasRequiredEvery = 1;
  var arrayEvery = require_arrayEvery(), baseEvery = require_baseEvery(), baseIteratee = require_baseIteratee(), isArray2 = requireIsArray(), isIterateeCall = require_isIterateeCall();
  function every2(collection, predicate, guard) {
    var func = isArray2(collection) ? arrayEvery : baseEvery;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = void 0;
    }
    return func(collection, baseIteratee(predicate, 3));
  }
  every_1 = every2;
  return every_1;
}
var everyExports = requireEvery();
const every = /* @__PURE__ */ getDefaultExportFromCjs(everyExports);
var _excluded$5 = ["x", "y"];
function _typeof$e(o) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$e(o);
}
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function ownKeys$b(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$b(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$b(Object(t), true).forEach(function(r2) {
      _defineProperty$e(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$e(obj, key, value) {
  key = _toPropertyKey$e(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$e(t) {
  var i = _toPrimitive$e(t, "string");
  return "symbol" == _typeof$e(i) ? i : i + "";
}
function _toPrimitive$e(t, r) {
  if ("object" != _typeof$e(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$e(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function typeguardBarRectangleProps(_ref, props) {
  var xProp = _ref.x, yProp = _ref.y, option = _objectWithoutProperties$5(_ref, _excluded$5);
  var xValue = "".concat(xProp);
  var x2 = parseInt(xValue, 10);
  var yValue = "".concat(yProp);
  var y2 = parseInt(yValue, 10);
  var heightValue = "".concat(props.height || option.height);
  var height = parseInt(heightValue, 10);
  var widthValue = "".concat(props.width || option.width);
  var width = parseInt(widthValue, 10);
  return _objectSpread$b(_objectSpread$b(_objectSpread$b(_objectSpread$b(_objectSpread$b({}, props), option), x2 ? {
    x: x2
  } : {}), y2 ? {
    y: y2
  } : {}), {}, {
    height,
    width,
    name: props.name,
    radius: props.radius
  });
}
function BarRectangle(props) {
  return /* @__PURE__ */ React.createElement(Shape, _extends$a({
    shapeType: "rectangle",
    propTransformer: typeguardBarRectangleProps,
    activeClassName: "recharts-active-bar"
  }, props));
}
var minPointSizeCallback = function minPointSizeCallback2(minPointSize) {
  var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return function(value, index2) {
    if (typeof minPointSize === "number") return minPointSize;
    var isValueNumberOrNil = isNumber(value) || isNullish(value);
    if (isValueNumberOrNil) {
      return minPointSize(value, index2);
    }
    !isValueNumberOrNil ? invariant() : void 0;
    return defaultValue;
  };
};
var _excluded$4 = ["value", "background"];
var _Bar;
function _typeof$d(o) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$d(o);
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
function ownKeys$a(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$a(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$a(Object(t), true).forEach(function(r2) {
      _defineProperty$d(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$d(descriptor.key), descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$a(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$8(t, o, e) {
  return o = _getPrototypeOf$8(o), _possibleConstructorReturn$8(t, _isNativeReflectConstruct$8() ? Reflect.construct(o, e || [], _getPrototypeOf$8(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$8(self2, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$8(o);
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p2) {
  _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$8(o, p2);
}
function _defineProperty$d(obj, key, value) {
  key = _toPropertyKey$d(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$d(t) {
  var i = _toPrimitive$d(t, "string");
  return "symbol" == _typeof$d(i) ? i : i + "";
}
function _toPrimitive$d(t, r) {
  if ("object" != _typeof$d(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$d(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var Bar = /* @__PURE__ */ (function(_PureComponent) {
  function Bar2() {
    var _this;
    _classCallCheck$a(this, Bar2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper$8(this, Bar2, [].concat(args));
    _defineProperty$d(_this, "state", {
      isAnimationFinished: false
    });
    _defineProperty$d(_this, "id", uniqueId("recharts-bar-"));
    _defineProperty$d(_this, "handleAnimationEnd", function() {
      var onAnimationEnd2 = _this.props.onAnimationEnd;
      _this.setState({
        isAnimationFinished: true
      });
      if (onAnimationEnd2) {
        onAnimationEnd2();
      }
    });
    _defineProperty$d(_this, "handleAnimationStart", function() {
      var onAnimationStart2 = _this.props.onAnimationStart;
      _this.setState({
        isAnimationFinished: false
      });
      if (onAnimationStart2) {
        onAnimationStart2();
      }
    });
    return _this;
  }
  _inherits$8(Bar2, _PureComponent);
  return _createClass$a(Bar2, [{
    key: "renderRectanglesStatically",
    value: function renderRectanglesStatically(data) {
      var _this2 = this;
      var _this$props = this.props, shape = _this$props.shape, dataKey = _this$props.dataKey, activeIndex = _this$props.activeIndex, activeBar = _this$props.activeBar;
      var baseProps = filterProps(this.props, false);
      return data && data.map(function(entry, i) {
        var isActive = i === activeIndex;
        var option = isActive ? activeBar : shape;
        var props = _objectSpread$a(_objectSpread$a(_objectSpread$a({}, baseProps), entry), {}, {
          isActive,
          option,
          index: i,
          dataKey,
          onAnimationStart: _this2.handleAnimationStart,
          onAnimationEnd: _this2.handleAnimationEnd
        });
        return /* @__PURE__ */ React.createElement(Layer$1, _extends$9({
          className: "recharts-bar-rectangle"
        }, adaptEventsOfChild(_this2.props, entry, i), {
          // https://github.com/recharts/recharts/issues/5415
          // eslint-disable-next-line react/no-array-index-key
          key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i)
        }), /* @__PURE__ */ React.createElement(BarRectangle, props));
      });
    }
  }, {
    key: "renderRectanglesWithAnimation",
    value: function renderRectanglesWithAnimation() {
      var _this3 = this;
      var _this$props2 = this.props, data = _this$props2.data, layout = _this$props2.layout, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;
      var prevData = this.state.prevData;
      return /* @__PURE__ */ React.createElement(Animate, {
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "bar-".concat(animationId),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(_ref) {
        var t = _ref.t;
        var stepData = data.map(function(entry, index2) {
          var prev = prevData && prevData[index2];
          if (prev) {
            var interpolatorX = interpolateNumber$2(prev.x, entry.x);
            var interpolatorY = interpolateNumber$2(prev.y, entry.y);
            var interpolatorWidth = interpolateNumber$2(prev.width, entry.width);
            var interpolatorHeight = interpolateNumber$2(prev.height, entry.height);
            return _objectSpread$a(_objectSpread$a({}, entry), {}, {
              x: interpolatorX(t),
              y: interpolatorY(t),
              width: interpolatorWidth(t),
              height: interpolatorHeight(t)
            });
          }
          if (layout === "horizontal") {
            var _interpolatorHeight = interpolateNumber$2(0, entry.height);
            var h = _interpolatorHeight(t);
            return _objectSpread$a(_objectSpread$a({}, entry), {}, {
              y: entry.y + entry.height - h,
              height: h
            });
          }
          var interpolator = interpolateNumber$2(0, entry.width);
          var w = interpolator(t);
          return _objectSpread$a(_objectSpread$a({}, entry), {}, {
            width: w
          });
        });
        return /* @__PURE__ */ React.createElement(Layer$1, null, _this3.renderRectanglesStatically(stepData));
      });
    }
  }, {
    key: "renderRectangles",
    value: function renderRectangles() {
      var _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive;
      var prevData = this.state.prevData;
      if (isAnimationActive && data && data.length && (!prevData || !isEqual$1(prevData, data))) {
        return this.renderRectanglesWithAnimation();
      }
      return this.renderRectanglesStatically(data);
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var _this4 = this;
      var _this$props4 = this.props, data = _this$props4.data, dataKey = _this$props4.dataKey, activeIndex = _this$props4.activeIndex;
      var backgroundProps = filterProps(this.props.background, false);
      return data.map(function(entry, i) {
        entry.value;
        var background = entry.background, rest = _objectWithoutProperties$4(entry, _excluded$4);
        if (!background) {
          return null;
        }
        var props = _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, rest), {}, {
          fill: "#eee"
        }, background), backgroundProps), adaptEventsOfChild(_this4.props, entry, i)), {}, {
          onAnimationStart: _this4.handleAnimationStart,
          onAnimationEnd: _this4.handleAnimationEnd,
          dataKey,
          index: i,
          className: "recharts-bar-background-rectangle"
        });
        return /* @__PURE__ */ React.createElement(BarRectangle, _extends$9({
          key: "background-bar-".concat(i),
          option: _this4.props.background,
          isActive: i === activeIndex
        }, props));
      });
    }
  }, {
    key: "renderErrorBar",
    value: function renderErrorBar(needClip, clipPathId) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props5 = this.props, data = _this$props5.data, xAxis = _this$props5.xAxis, yAxis = _this$props5.yAxis, layout = _this$props5.layout, children = _this$props5.children;
      var errorBarItems = findAllByType(children, ErrorBar);
      if (!errorBarItems) {
        return null;
      }
      var offset2 = layout === "vertical" ? data[0].height / 2 : data[0].width / 2;
      var dataPointFormatter = function dataPointFormatter2(dataPoint, dataKey) {
        var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
        return {
          x: dataPoint.x,
          y: dataPoint.y,
          value,
          errorVal: getValueByDataKey(dataPoint, dataKey)
        };
      };
      var errorBarProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer$1, errorBarProps, errorBarItems.map(function(item) {
        return /* @__PURE__ */ React.cloneElement(item, {
          key: "error-bar-".concat(clipPathId, "-").concat(item.props.dataKey),
          data,
          xAxis,
          yAxis,
          layout,
          offset: offset2,
          dataPointFormatter
        });
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props, hide = _this$props6.hide, data = _this$props6.data, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, background = _this$props6.background, id = _this$props6.id;
      if (hide || !data || !data.length) {
        return null;
      }
      var isAnimationFinished = this.state.isAnimationFinished;
      var layerClass = clsx("recharts-bar", className);
      var needClipX = xAxis && xAxis.allowDataOverflow;
      var needClipY = yAxis && yAxis.allowDataOverflow;
      var needClip = needClipX || needClipY;
      var clipPathId = isNil(id) ? this.id : id;
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: layerClass
      }, needClipX || needClipY ? /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: needClipX ? left : left - width / 2,
        y: needClipY ? top : top - height / 2,
        width: needClipX ? width : width * 2,
        height: needClipY ? height : height * 2
      }))) : null, /* @__PURE__ */ React.createElement(Layer$1, {
        className: "recharts-bar-rectangles",
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      }, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, data));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.animationId !== prevState.prevAnimationId) {
        return {
          prevAnimationId: nextProps.animationId,
          curData: nextProps.data,
          prevData: prevState.curData
        };
      }
      if (nextProps.data !== prevState.curData) {
        return {
          curData: nextProps.data
        };
      }
      return null;
    }
  }]);
})(reactExports.PureComponent);
_Bar = Bar;
_defineProperty$d(Bar, "displayName", "Bar");
_defineProperty$d(Bar, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  legendType: "rect",
  minPointSize: 0,
  hide: false,
  data: [],
  layout: "vertical",
  activeBar: false,
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease"
});
_defineProperty$d(Bar, "getComposedData", function(_ref2) {
  var props = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset2 = _ref2.offset;
  var pos = findPositionOfBar(barPosition, item);
  if (!pos) {
    return null;
  }
  var layout = props.layout;
  var itemDefaultProps = item.type.defaultProps;
  var itemProps = itemDefaultProps !== void 0 ? _objectSpread$a(_objectSpread$a({}, itemDefaultProps), item.props) : item.props;
  var dataKey = itemProps.dataKey, children = itemProps.children, minPointSizeProp = itemProps.minPointSize;
  var numericAxis = layout === "horizontal" ? yAxis : xAxis;
  var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
  var baseValue = getBaseValueOfBar({
    numericAxis
  });
  var cells = findAllByType(children, Cell);
  var rects = displayedData.map(function(entry, index2) {
    var value, x2, y2, width, height, background;
    if (stackedData) {
      value = truncateByDomain(stackedData[dataStartIndex + index2], stackedDomain);
    } else {
      value = getValueByDataKey(entry, dataKey);
      if (!Array.isArray(value)) {
        value = [baseValue, value];
      }
    }
    var minPointSize = minPointSizeCallback(minPointSizeProp, _Bar.defaultProps.minPointSize)(value[1], index2);
    if (layout === "horizontal") {
      var _ref4;
      var _ref3 = [yAxis.scale(value[0]), yAxis.scale(value[1])], baseValueScale = _ref3[0], currentValueScale = _ref3[1];
      x2 = getCateCoordinateOfBar({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index2
      });
      y2 = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : void 0;
      width = pos.size;
      var computedHeight = baseValueScale - currentValueScale;
      height = Number.isNaN(computedHeight) ? 0 : computedHeight;
      background = {
        x: x2,
        y: yAxis.y,
        width,
        height: yAxis.height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
        var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
        y2 -= delta;
        height += delta;
      }
    } else {
      var _ref5 = [xAxis.scale(value[0]), xAxis.scale(value[1])], _baseValueScale = _ref5[0], _currentValueScale = _ref5[1];
      x2 = _baseValueScale;
      y2 = getCateCoordinateOfBar({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index2
      });
      width = _currentValueScale - _baseValueScale;
      height = pos.size;
      background = {
        x: xAxis.x,
        y: y2,
        width: xAxis.width,
        height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
        var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
        width += _delta;
      }
    }
    return _objectSpread$a(_objectSpread$a(_objectSpread$a({}, entry), {}, {
      x: x2,
      y: y2,
      width,
      height,
      value: stackedData ? value : value[1],
      payload: entry,
      background
    }, cells && cells[index2] && cells[index2].props), {}, {
      tooltipPayload: [getTooltipItem(item, entry)],
      tooltipPosition: {
        x: x2 + width / 2,
        y: y2 + height / 2
      }
    });
  });
  return _objectSpread$a({
    data: rects,
    layout
  }, offset2);
});
function _typeof$c(o) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$c(o);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$c(descriptor.key), descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$9(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function ownKeys$9(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$9(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$9(Object(t), true).forEach(function(r2) {
      _defineProperty$c(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$c(obj, key, value) {
  key = _toPropertyKey$c(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$c(t) {
  var i = _toPrimitive$c(t, "string");
  return "symbol" == _typeof$c(i) ? i : i + "";
}
function _toPrimitive$c(t, r) {
  if ("object" != _typeof$c(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$c(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var formatAxisMap = function formatAxisMap2(props, axisMap, offset2, axisType, chartName) {
  var width = props.width, height = props.height, layout = props.layout, children = props.children;
  var ids = Object.keys(axisMap);
  var steps = {
    left: offset2.left,
    leftMirror: offset2.left,
    right: width - offset2.right,
    rightMirror: width - offset2.right,
    top: offset2.top,
    topMirror: offset2.top,
    bottom: height - offset2.bottom,
    bottomMirror: height - offset2.bottom
  };
  var hasBar = !!findChildByType(children, Bar);
  return ids.reduce(function(result, id) {
    var axis = axisMap[id];
    var orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed;
    var offsetKey = "".concat(orientation).concat(mirror ? "Mirror" : "");
    var calculatedPadding, range3, x2, y2, needSpace;
    if (axis.type === "number" && (axis.padding === "gap" || axis.padding === "no-gap")) {
      var diff = domain[1] - domain[0];
      var smallestDistanceBetweenValues = Infinity;
      var sortedValues = axis.categoricalDomain.sort(compareValues);
      sortedValues.forEach(function(value, index2) {
        if (index2 > 0) {
          smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index2 - 1] || 0), smallestDistanceBetweenValues);
        }
      });
      if (Number.isFinite(smallestDistanceBetweenValues)) {
        var smallestDistanceInPercent = smallestDistanceBetweenValues / diff;
        var rangeWidth = axis.layout === "vertical" ? offset2.height : offset2.width;
        if (axis.padding === "gap") {
          calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;
        }
        if (axis.padding === "no-gap") {
          var gap = getPercentValue(props.barCategoryGap, smallestDistanceInPercent * rangeWidth);
          var halfBand = smallestDistanceInPercent * rangeWidth / 2;
          calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;
        }
      }
    }
    if (axisType === "xAxis") {
      range3 = [offset2.left + (padding.left || 0) + (calculatedPadding || 0), offset2.left + offset2.width - (padding.right || 0) - (calculatedPadding || 0)];
    } else if (axisType === "yAxis") {
      range3 = layout === "horizontal" ? [offset2.top + offset2.height - (padding.bottom || 0), offset2.top + (padding.top || 0)] : [offset2.top + (padding.top || 0) + (calculatedPadding || 0), offset2.top + offset2.height - (padding.bottom || 0) - (calculatedPadding || 0)];
    } else {
      range3 = axis.range;
    }
    if (reversed) {
      range3 = [range3[1], range3[0]];
    }
    var _parseScale = parseScale(axis, chartName, hasBar), scale2 = _parseScale.scale, realScaleType = _parseScale.realScaleType;
    scale2.domain(domain).range(range3);
    checkDomainOfScale(scale2);
    var ticks2 = getTicksOfScale(scale2, _objectSpread$9(_objectSpread$9({}, axis), {}, {
      realScaleType
    }));
    if (axisType === "xAxis") {
      needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
      x2 = offset2.left;
      y2 = steps[offsetKey] - needSpace * axis.height;
    } else if (axisType === "yAxis") {
      needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
      x2 = steps[offsetKey] - needSpace * axis.width;
      y2 = offset2.top;
    }
    var finalAxis = _objectSpread$9(_objectSpread$9(_objectSpread$9({}, axis), ticks2), {}, {
      realScaleType,
      x: x2,
      y: y2,
      scale: scale2,
      width: axisType === "xAxis" ? offset2.width : axis.width,
      height: axisType === "yAxis" ? offset2.height : axis.height
    });
    finalAxis.bandSize = getBandSizeOfAxis(finalAxis, ticks2);
    if (!axis.hide && axisType === "xAxis") {
      steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;
    } else if (!axis.hide) {
      steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;
    }
    return _objectSpread$9(_objectSpread$9({}, result), {}, _defineProperty$c({}, id, finalAxis));
  }, {});
};
var rectWithPoints = function rectWithPoints2(_ref, _ref2) {
  var x1 = _ref.x, y1 = _ref.y;
  var x2 = _ref2.x, y2 = _ref2.y;
  return {
    x: Math.min(x1, x2),
    y: Math.min(y1, y2),
    width: Math.abs(x2 - x1),
    height: Math.abs(y2 - y1)
  };
};
var rectWithCoords = function rectWithCoords2(_ref3) {
  var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;
  return rectWithPoints({
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  });
};
var ScaleHelper = /* @__PURE__ */ (function() {
  function ScaleHelper2(scale2) {
    _classCallCheck$9(this, ScaleHelper2);
    this.scale = scale2;
  }
  return _createClass$9(ScaleHelper2, [{
    key: "domain",
    get: function get2() {
      return this.scale.domain;
    }
  }, {
    key: "range",
    get: function get2() {
      return this.scale.range;
    }
  }, {
    key: "rangeMin",
    get: function get2() {
      return this.range()[0];
    }
  }, {
    key: "rangeMax",
    get: function get2() {
      return this.range()[1];
    }
  }, {
    key: "bandwidth",
    get: function get2() {
      return this.scale.bandwidth;
    }
  }, {
    key: "apply",
    value: function apply(value) {
      var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;
      if (value === void 0) {
        return void 0;
      }
      if (position) {
        switch (position) {
          case "start": {
            return this.scale(value);
          }
          case "middle": {
            var offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
            return this.scale(value) + offset2;
          }
          case "end": {
            var _offset = this.bandwidth ? this.bandwidth() : 0;
            return this.scale(value) + _offset;
          }
          default: {
            return this.scale(value);
          }
        }
      }
      if (bandAware) {
        var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
        return this.scale(value) + _offset2;
      }
      return this.scale(value);
    }
  }, {
    key: "isInRange",
    value: function isInRange(value) {
      var range3 = this.range();
      var first = range3[0];
      var last2 = range3[range3.length - 1];
      return first <= last2 ? value >= first && value <= last2 : value >= last2 && value <= first;
    }
  }], [{
    key: "create",
    value: function create2(obj) {
      return new ScaleHelper2(obj);
    }
  }]);
})();
_defineProperty$c(ScaleHelper, "EPS", 1e-4);
var createLabeledScales = function createLabeledScales2(options) {
  var scales = Object.keys(options).reduce(function(res, key) {
    return _objectSpread$9(_objectSpread$9({}, res), {}, _defineProperty$c({}, key, ScaleHelper.create(options[key])));
  }, {});
  return _objectSpread$9(_objectSpread$9({}, scales), {}, {
    apply: function apply(coord) {
      var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;
      return mapValues(coord, function(value, label) {
        return scales[label].apply(value, {
          bandAware,
          position
        });
      });
    },
    isInRange: function isInRange(coord) {
      return every(coord, function(value, label) {
        return scales[label].isInRange(value);
      });
    }
  });
};
function normalizeAngle(angle2) {
  return (angle2 % 180 + 180) % 180;
}
var getAngledRectangleWidth = function getAngledRectangleWidth2(_ref6) {
  var width = _ref6.width, height = _ref6.height;
  var angle2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var normalizedAngle = normalizeAngle(angle2);
  var angleRadians = normalizedAngle * Math.PI / 180;
  var angleThreshold = Math.atan(height / width);
  var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
  return Math.abs(angledWidth);
};
var _createFind;
var hasRequired_createFind;
function require_createFind() {
  if (hasRequired_createFind) return _createFind;
  hasRequired_createFind = 1;
  var baseIteratee = require_baseIteratee(), isArrayLike = requireIsArrayLike(), keys2 = requireKeys();
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys2(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  _createFind = createFind;
  return _createFind;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger) return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite();
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var findIndex_1;
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex) return findIndex_1;
  hasRequiredFindIndex = 1;
  var baseFindIndex = require_baseFindIndex(), baseIteratee = require_baseIteratee(), toInteger = requireToInteger();
  var nativeMax = Math.max;
  function findIndex(array2, predicate, fromIndex) {
    var length = array2 == null ? 0 : array2.length;
    if (!length) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length + index2, 0);
    }
    return baseFindIndex(array2, baseIteratee(predicate, 3), index2);
  }
  findIndex_1 = findIndex;
  return findIndex_1;
}
var find_1;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind) return find_1;
  hasRequiredFind = 1;
  var createFind = require_createFind(), findIndex = requireFindIndex();
  var find2 = createFind(findIndex);
  find_1 = find2;
  return find_1;
}
var findExports = requireFind();
const find = /* @__PURE__ */ getDefaultExportFromCjs(findExports);
var memoizeExports = requireMemoize();
const memoize$1 = /* @__PURE__ */ getDefaultExportFromCjs(memoizeExports);
var calculateViewBox = memoize$1(function(offset2) {
  return {
    x: offset2.left,
    y: offset2.top,
    width: offset2.width,
    height: offset2.height
  };
}, function(offset2) {
  return ["l", offset2.left, "t", offset2.top, "w", offset2.width, "h", offset2.height].join("");
});
var XAxisContext = /* @__PURE__ */ reactExports.createContext(void 0);
var YAxisContext = /* @__PURE__ */ reactExports.createContext(void 0);
var ViewBoxContext = /* @__PURE__ */ reactExports.createContext(void 0);
var OffsetContext = /* @__PURE__ */ reactExports.createContext({});
var ClipPathIdContext = /* @__PURE__ */ reactExports.createContext(void 0);
var ChartHeightContext = /* @__PURE__ */ reactExports.createContext(0);
var ChartWidthContext = /* @__PURE__ */ reactExports.createContext(0);
var ChartLayoutContextProvider = function ChartLayoutContextProvider2(props) {
  var _props$state = props.state, xAxisMap = _props$state.xAxisMap, yAxisMap = _props$state.yAxisMap, offset2 = _props$state.offset, clipPathId = props.clipPathId, children = props.children, width = props.width, height = props.height;
  var viewBox = calculateViewBox(offset2);
  return /* @__PURE__ */ React.createElement(XAxisContext.Provider, {
    value: xAxisMap
  }, /* @__PURE__ */ React.createElement(YAxisContext.Provider, {
    value: yAxisMap
  }, /* @__PURE__ */ React.createElement(OffsetContext.Provider, {
    value: offset2
  }, /* @__PURE__ */ React.createElement(ViewBoxContext.Provider, {
    value: viewBox
  }, /* @__PURE__ */ React.createElement(ClipPathIdContext.Provider, {
    value: clipPathId
  }, /* @__PURE__ */ React.createElement(ChartHeightContext.Provider, {
    value: height
  }, /* @__PURE__ */ React.createElement(ChartWidthContext.Provider, {
    value: width
  }, children)))))));
};
var useClipPathId = function useClipPathId2() {
  return reactExports.useContext(ClipPathIdContext);
};
var useXAxisOrThrow = function useXAxisOrThrow2(xAxisId) {
  var xAxisMap = reactExports.useContext(XAxisContext);
  !(xAxisMap != null) ? invariant() : void 0;
  var xAxis = xAxisMap[xAxisId];
  !(xAxis != null) ? invariant() : void 0;
  return xAxis;
};
var useArbitraryXAxis = function useArbitraryXAxis2() {
  var xAxisMap = reactExports.useContext(XAxisContext);
  return getAnyElementOfObject(xAxisMap);
};
var useYAxisWithFiniteDomainOrRandom = function useYAxisWithFiniteDomainOrRandom2() {
  var yAxisMap = reactExports.useContext(YAxisContext);
  var yAxisWithFiniteDomain = find(yAxisMap, function(axis) {
    return every(axis.domain, Number.isFinite);
  });
  return yAxisWithFiniteDomain || getAnyElementOfObject(yAxisMap);
};
var useYAxisOrThrow = function useYAxisOrThrow2(yAxisId) {
  var yAxisMap = reactExports.useContext(YAxisContext);
  !(yAxisMap != null) ? invariant() : void 0;
  var yAxis = yAxisMap[yAxisId];
  !(yAxis != null) ? invariant() : void 0;
  return yAxis;
};
var useViewBox = function useViewBox2() {
  var viewBox = reactExports.useContext(ViewBoxContext);
  return viewBox;
};
var useOffset = function useOffset2() {
  return reactExports.useContext(OffsetContext);
};
var useChartWidth = function useChartWidth2() {
  return reactExports.useContext(ChartWidthContext);
};
var useChartHeight = function useChartHeight2() {
  return reactExports.useContext(ChartHeightContext);
};
function _typeof$b(o) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$b(o);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$b(descriptor.key), descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$7(t, o, e) {
  return o = _getPrototypeOf$7(o), _possibleConstructorReturn$7(t, _isNativeReflectConstruct$7() ? Reflect.construct(o, e || [], _getPrototypeOf$7(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$7(self2, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$7(o);
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p2) {
  _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$7(o, p2);
}
function ownKeys$8(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$8(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$8(Object(t), true).forEach(function(r2) {
      _defineProperty$b(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$b(obj, key, value) {
  key = _toPropertyKey$b(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$b(t) {
  var i = _toPrimitive$b(t, "string");
  return "symbol" == _typeof$b(i) ? i : i + "";
}
function _toPrimitive$b(t, r) {
  if ("object" != _typeof$b(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$b(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$1(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
var renderLine = function renderLine2(option, props) {
  var line;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    line = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (isFunction$2(option)) {
    line = option(props);
  } else {
    line = /* @__PURE__ */ React.createElement("line", _extends$8({}, props, {
      className: "recharts-reference-line-line"
    }));
  }
  return line;
};
var getEndPoints = function getEndPoints2(scales, isFixedX, isFixedY, isSegment, viewBox, position, xAxisOrientation, yAxisOrientation, props) {
  var x2 = viewBox.x, y2 = viewBox.y, width = viewBox.width, height = viewBox.height;
  if (isFixedY) {
    var yCoord = props.y;
    var coord = scales.y.apply(yCoord, {
      position
    });
    if (ifOverflowMatches(props, "discard") && !scales.y.isInRange(coord)) {
      return null;
    }
    var points = [{
      x: x2 + width,
      y: coord
    }, {
      x: x2,
      y: coord
    }];
    return yAxisOrientation === "left" ? points.reverse() : points;
  }
  if (isFixedX) {
    var xCoord = props.x;
    var _coord = scales.x.apply(xCoord, {
      position
    });
    if (ifOverflowMatches(props, "discard") && !scales.x.isInRange(_coord)) {
      return null;
    }
    var _points = [{
      x: _coord,
      y: y2 + height
    }, {
      x: _coord,
      y: y2
    }];
    return xAxisOrientation === "top" ? _points.reverse() : _points;
  }
  if (isSegment) {
    var segment = props.segment;
    var _points2 = segment.map(function(p2) {
      return scales.apply(p2, {
        position
      });
    });
    if (ifOverflowMatches(props, "discard") && some$1(_points2, function(p2) {
      return !scales.isInRange(p2);
    })) {
      return null;
    }
    return _points2;
  }
  return null;
};
function ReferenceLineImpl(props) {
  var fixedX = props.x, fixedY = props.y, segment = props.segment, xAxisId = props.xAxisId, yAxisId = props.yAxisId, shape = props.shape, className = props.className, alwaysShow = props.alwaysShow;
  var clipPathId = useClipPathId();
  var xAxis = useXAxisOrThrow(xAxisId);
  var yAxis = useYAxisOrThrow(yAxisId);
  var viewBox = useViewBox();
  if (!clipPathId || !viewBox) {
    return null;
  }
  warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var isX = isNumOrStr(fixedX);
  var isY = isNumOrStr(fixedY);
  var isSegment = segment && segment.length === 2;
  var endPoints = getEndPoints(scales, isX, isY, isSegment, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);
  if (!endPoints) {
    return null;
  }
  var _endPoints = _slicedToArray$1(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y;
  var clipPath = ifOverflowMatches(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
  var lineProps = _objectSpread$8(_objectSpread$8({
    clipPath
  }, filterProps(props, true)), {}, {
    x1,
    y1,
    x2,
    y2
  });
  return /* @__PURE__ */ React.createElement(Layer$1, {
    className: clsx("recharts-reference-line", className)
  }, renderLine(shape, lineProps), Label.renderCallByParent(props, rectWithCoords({
    x1,
    y1,
    x2,
    y2
  })));
}
var ReferenceLine = /* @__PURE__ */ (function(_React$Component) {
  function ReferenceLine2() {
    _classCallCheck$8(this, ReferenceLine2);
    return _callSuper$7(this, ReferenceLine2, arguments);
  }
  _inherits$7(ReferenceLine2, _React$Component);
  return _createClass$8(ReferenceLine2, [{
    key: "render",
    value: function render() {
      return /* @__PURE__ */ React.createElement(ReferenceLineImpl, this.props);
    }
  }]);
})(React.Component);
_defineProperty$b(ReferenceLine, "displayName", "ReferenceLine");
_defineProperty$b(ReferenceLine, "defaultProps", {
  isFront: false,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  fill: "none",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1,
  position: "middle"
});
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _typeof$a(o) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$a(o);
}
function ownKeys$7(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$7(Object(t), true).forEach(function(r2) {
      _defineProperty$a(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$a(descriptor.key), descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$6(t, o, e) {
  return o = _getPrototypeOf$6(o), _possibleConstructorReturn$6(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf$6(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$6(o);
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$6(o, p2);
}
function _defineProperty$a(obj, key, value) {
  key = _toPropertyKey$a(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$a(t) {
  var i = _toPrimitive$a(t, "string");
  return "symbol" == _typeof$a(i) ? i : i + "";
}
function _toPrimitive$a(t, r) {
  if ("object" != _typeof$a(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$a(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var getCoordinate = function getCoordinate2(props) {
  var x2 = props.x, y2 = props.y, xAxis = props.xAxis, yAxis = props.yAxis;
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var result = scales.apply({
    x: x2,
    y: y2
  }, {
    bandAware: true
  });
  if (ifOverflowMatches(props, "discard") && !scales.isInRange(result)) {
    return null;
  }
  return result;
};
var ReferenceDot = /* @__PURE__ */ (function(_React$Component) {
  function ReferenceDot2() {
    _classCallCheck$7(this, ReferenceDot2);
    return _callSuper$6(this, ReferenceDot2, arguments);
  }
  _inherits$6(ReferenceDot2, _React$Component);
  return _createClass$7(ReferenceDot2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, x2 = _this$props.x, y2 = _this$props.y, r = _this$props.r, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;
      var isX = isNumOrStr(x2);
      var isY = isNumOrStr(y2);
      warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
      if (!isX || !isY) {
        return null;
      }
      var coordinate = getCoordinate(this.props);
      if (!coordinate) {
        return null;
      }
      var cx = coordinate.x, cy = coordinate.y;
      var _this$props2 = this.props, shape = _this$props2.shape, className = _this$props2.className;
      var clipPath = ifOverflowMatches(this.props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
      var dotProps = _objectSpread$7(_objectSpread$7({
        clipPath
      }, filterProps(this.props, true)), {}, {
        cx,
        cy
      });
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: clsx("recharts-reference-dot", className)
      }, ReferenceDot2.renderDot(shape, dotProps), Label.renderCallByParent(this.props, {
        x: cx - r,
        y: cy - r,
        width: 2 * r,
        height: 2 * r
      }));
    }
  }]);
})(React.Component);
_defineProperty$a(ReferenceDot, "displayName", "ReferenceDot");
_defineProperty$a(ReferenceDot, "defaultProps", {
  isFront: false,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
});
_defineProperty$a(ReferenceDot, "renderDot", function(option, props) {
  var dot2;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    dot2 = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (isFunction$2(option)) {
    dot2 = option(props);
  } else {
    dot2 = /* @__PURE__ */ React.createElement(Dot, _extends$7({}, props, {
      cx: props.cx,
      cy: props.cy,
      className: "recharts-reference-dot-dot"
    }));
  }
  return dot2;
});
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function _typeof$9(o) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$9(o);
}
function ownKeys$6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$6(Object(t), true).forEach(function(r2) {
      _defineProperty$9(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$9(descriptor.key), descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$5(t, o, e) {
  return o = _getPrototypeOf$5(o), _possibleConstructorReturn$5(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf$5(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$5(o, p2);
}
function _defineProperty$9(obj, key, value) {
  key = _toPropertyKey$9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$9(t) {
  var i = _toPrimitive$9(t, "string");
  return "symbol" == _typeof$9(i) ? i : i + "";
}
function _toPrimitive$9(t, r) {
  if ("object" != _typeof$9(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$9(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var getRect = function getRect2(hasX1, hasX2, hasY1, hasY2, props) {
  var xValue1 = props.x1, xValue2 = props.x2, yValue1 = props.y1, yValue2 = props.y2, xAxis = props.xAxis, yAxis = props.yAxis;
  if (!xAxis || !yAxis) return null;
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var p1 = {
    x: hasX1 ? scales.x.apply(xValue1, {
      position: "start"
    }) : scales.x.rangeMin,
    y: hasY1 ? scales.y.apply(yValue1, {
      position: "start"
    }) : scales.y.rangeMin
  };
  var p2 = {
    x: hasX2 ? scales.x.apply(xValue2, {
      position: "end"
    }) : scales.x.rangeMax,
    y: hasY2 ? scales.y.apply(yValue2, {
      position: "end"
    }) : scales.y.rangeMax
  };
  if (ifOverflowMatches(props, "discard") && (!scales.isInRange(p1) || !scales.isInRange(p2))) {
    return null;
  }
  return rectWithPoints(p1, p2);
};
var ReferenceArea = /* @__PURE__ */ (function(_React$Component) {
  function ReferenceArea2() {
    _classCallCheck$6(this, ReferenceArea2);
    return _callSuper$5(this, ReferenceArea2, arguments);
  }
  _inherits$5(ReferenceArea2, _React$Component);
  return _createClass$6(ReferenceArea2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, x1 = _this$props.x1, x2 = _this$props.x2, y1 = _this$props.y1, y2 = _this$props.y2, className = _this$props.className, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;
      warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
      var hasX1 = isNumOrStr(x1);
      var hasX2 = isNumOrStr(x2);
      var hasY1 = isNumOrStr(y1);
      var hasY2 = isNumOrStr(y2);
      var shape = this.props.shape;
      if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {
        return null;
      }
      var rect = getRect(hasX1, hasX2, hasY1, hasY2, this.props);
      if (!rect && !shape) {
        return null;
      }
      var clipPath = ifOverflowMatches(this.props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: clsx("recharts-reference-area", className)
      }, ReferenceArea2.renderRect(shape, _objectSpread$6(_objectSpread$6({
        clipPath
      }, filterProps(this.props, true)), rect)), Label.renderCallByParent(this.props, rect));
    }
  }]);
})(React.Component);
_defineProperty$9(ReferenceArea, "displayName", "ReferenceArea");
_defineProperty$9(ReferenceArea, "defaultProps", {
  isFront: false,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#ccc",
  fillOpacity: 0.5,
  stroke: "none",
  strokeWidth: 1
});
_defineProperty$9(ReferenceArea, "renderRect", function(option, props) {
  var rect;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    rect = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (isFunction$2(option)) {
    rect = option(props);
  } else {
    rect = /* @__PURE__ */ React.createElement(Rectangle, _extends$6({}, props, {
      className: "recharts-reference-area-rect"
    }));
  }
  return rect;
});
function getEveryNthWithCondition(array2, n, isValid) {
  if (n < 1) {
    return [];
  }
  if (n === 1 && isValid === void 0) {
    return array2;
  }
  var result = [];
  for (var i = 0; i < array2.length; i += n) {
    {
      result.push(array2[i]);
    }
  }
  return result;
}
function getAngledTickWidth(contentSize, unitSize, angle2) {
  var size = {
    width: contentSize.width + unitSize.width,
    height: contentSize.height + unitSize.height
  };
  return getAngledRectangleWidth(size, angle2);
}
function getTickBoundaries(viewBox, sign2, sizeKey) {
  var isWidth = sizeKey === "width";
  var x2 = viewBox.x, y2 = viewBox.y, width = viewBox.width, height = viewBox.height;
  if (sign2 === 1) {
    return {
      start: isWidth ? x2 : y2,
      end: isWidth ? x2 + width : y2 + height
    };
  }
  return {
    start: isWidth ? x2 + width : y2 + height,
    end: isWidth ? x2 : y2
  };
}
function isVisible(sign2, tickPosition, getSize, start2, end) {
  if (sign2 * tickPosition < sign2 * start2 || sign2 * tickPosition > sign2 * end) {
    return false;
  }
  var size = getSize();
  return sign2 * (tickPosition - sign2 * size / 2 - start2) >= 0 && sign2 * (tickPosition + sign2 * size / 2 - end) <= 0;
}
function getNumberIntervalTicks(ticks2, interval) {
  return getEveryNthWithCondition(ticks2, interval + 1);
}
function getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap) {
  var result = (ticks2 || []).slice();
  var initialStart = boundaries.start, end = boundaries.end;
  var index2 = 0;
  var stepsize = 1;
  var start2 = initialStart;
  var _loop = function _loop2() {
    var entry = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2[index2];
    if (entry === void 0) {
      return {
        v: getEveryNthWithCondition(ticks2, stepsize)
      };
    }
    var i = index2;
    var size;
    var getSize = function getSize2() {
      if (size === void 0) {
        size = getTickSize(entry, i);
      }
      return size;
    };
    var tickCoord = entry.coordinate;
    var isShow = index2 === 0 || isVisible(sign2, tickCoord, getSize, start2, end);
    if (!isShow) {
      index2 = 0;
      start2 = initialStart;
      stepsize += 1;
    }
    if (isShow) {
      start2 = tickCoord + sign2 * (getSize() / 2 + minTickGap);
      index2 += stepsize;
    }
  }, _ret;
  while (stepsize <= result.length) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return [];
}
function _typeof$8(o) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$8(o);
}
function ownKeys$5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$5(Object(t), true).forEach(function(r2) {
      _defineProperty$8(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$8(obj, key, value) {
  key = _toPropertyKey$8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$8(t) {
  var i = _toPrimitive$8(t, "string");
  return "symbol" == _typeof$8(i) ? i : i + "";
}
function _toPrimitive$8(t, r) {
  if ("object" != _typeof$8(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$8(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap) {
  var result = (ticks2 || []).slice();
  var len = result.length;
  var start2 = boundaries.start;
  var end = boundaries.end;
  var _loop = function _loop2(i2) {
    var entry = result[i2];
    var size;
    var getSize = function getSize2() {
      if (size === void 0) {
        size = getTickSize(entry, i2);
      }
      return size;
    };
    if (i2 === len - 1) {
      var gap = sign2 * (entry.coordinate + sign2 * getSize() / 2 - end);
      result[i2] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
        tickCoord: gap > 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i2] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    var isShow = isVisible(sign2, entry.tickCoord, getSize, start2, end);
    if (isShow) {
      end = entry.tickCoord - sign2 * (getSize() / 2 + minTickGap);
      result[i2] = _objectSpread$5(_objectSpread$5({}, entry), {}, {
        isShow: true
      });
    }
  };
  for (var i = len - 1; i >= 0; i--) {
    _loop(i);
  }
  return result;
}
function getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, preserveEnd) {
  var result = (ticks2 || []).slice();
  var len = result.length;
  var start2 = boundaries.start, end = boundaries.end;
  if (preserveEnd) {
    var tail = ticks2[len - 1];
    var tailSize = getTickSize(tail, len - 1);
    var tailGap = sign2 * (tail.coordinate + sign2 * tailSize / 2 - end);
    result[len - 1] = tail = _objectSpread$5(_objectSpread$5({}, tail), {}, {
      tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign2 : tail.coordinate
    });
    var isTailShow = isVisible(sign2, tail.tickCoord, function() {
      return tailSize;
    }, start2, end);
    if (isTailShow) {
      end = tail.tickCoord - sign2 * (tailSize / 2 + minTickGap);
      result[len - 1] = _objectSpread$5(_objectSpread$5({}, tail), {}, {
        isShow: true
      });
    }
  }
  var count2 = preserveEnd ? len - 1 : len;
  var _loop2 = function _loop22(i2) {
    var entry = result[i2];
    var size;
    var getSize = function getSize2() {
      if (size === void 0) {
        size = getTickSize(entry, i2);
      }
      return size;
    };
    if (i2 === 0) {
      var gap = sign2 * (entry.coordinate - sign2 * getSize() / 2 - start2);
      result[i2] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
        tickCoord: gap < 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i2] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    var isShow = isVisible(sign2, entry.tickCoord, getSize, start2, end);
    if (isShow) {
      start2 = entry.tickCoord + sign2 * (getSize() / 2 + minTickGap);
      result[i2] = _objectSpread$5(_objectSpread$5({}, entry), {}, {
        isShow: true
      });
    }
  };
  for (var i = 0; i < count2; i++) {
    _loop2(i);
  }
  return result;
}
function getTicks(props, fontSize, letterSpacing) {
  var tick = props.tick, ticks2 = props.ticks, viewBox = props.viewBox, minTickGap = props.minTickGap, orientation = props.orientation, interval = props.interval, tickFormatter = props.tickFormatter, unit2 = props.unit, angle2 = props.angle;
  if (!ticks2 || !ticks2.length || !tick) {
    return [];
  }
  if (isNumber(interval) || Global.isSsr) {
    return getNumberIntervalTicks(ticks2, typeof interval === "number" && isNumber(interval) ? interval : 0);
  }
  var candidates = [];
  var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
  var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
    fontSize,
    letterSpacing
  }) : {
    width: 0,
    height: 0
  };
  var getTickSize = function getTickSize2(content, index2) {
    var value = isFunction$2(tickFormatter) ? tickFormatter(content.value, index2) : content.value;
    return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
      fontSize,
      letterSpacing
    }), unitSize, angle2) : getStringSize(value, {
      fontSize,
      letterSpacing
    })[sizeKey];
  };
  var sign2 = ticks2.length >= 2 ? mathSign(ticks2[1].coordinate - ticks2[0].coordinate) : 1;
  var boundaries = getTickBoundaries(viewBox, sign2, sizeKey);
  if (interval === "equidistantPreserveStart") {
    return getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap);
  }
  if (interval === "preserveStart" || interval === "preserveStartEnd") {
    candidates = getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, interval === "preserveStartEnd");
  } else {
    candidates = getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap);
  }
  return candidates.filter(function(entry) {
    return entry.isShow;
  });
}
var _excluded$3 = ["viewBox"], _excluded2$3 = ["viewBox"], _excluded3 = ["ticks"];
function _typeof$7(o) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$7(o);
}
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function ownKeys$4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$4(Object(t), true).forEach(function(r2) {
      _defineProperty$7(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$7(descriptor.key), descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$4(t, o, e) {
  return o = _getPrototypeOf$4(o), _possibleConstructorReturn$4(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf$4(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$4(o, p2);
}
function _defineProperty$7(obj, key, value) {
  key = _toPropertyKey$7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$7(t) {
  var i = _toPrimitive$7(t, "string");
  return "symbol" == _typeof$7(i) ? i : i + "";
}
function _toPrimitive$7(t, r) {
  if ("object" != _typeof$7(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$7(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var CartesianAxis = /* @__PURE__ */ (function(_Component) {
  function CartesianAxis2(props) {
    var _this;
    _classCallCheck$5(this, CartesianAxis2);
    _this = _callSuper$4(this, CartesianAxis2, [props]);
    _this.state = {
      fontSize: "",
      letterSpacing: ""
    };
    return _this;
  }
  _inherits$4(CartesianAxis2, _Component);
  return _createClass$5(CartesianAxis2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(_ref, nextState) {
      var viewBox = _ref.viewBox, restProps = _objectWithoutProperties$3(_ref, _excluded$3);
      var _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties$3(_this$props, _excluded2$3);
      return !shallowEqual(viewBox, viewBoxOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(nextState, this.state);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var htmlLayer = this.layerReference;
      if (!htmlLayer) return;
      var tick = htmlLayer.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
      if (tick) {
        this.setState({
          fontSize: window.getComputedStyle(tick).fontSize,
          letterSpacing: window.getComputedStyle(tick).letterSpacing
        });
      }
    }
    /**
     * Calculate the coordinates of endpoints in ticks
     * @param  {Object} data The data of a simple tick
     * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
     *  (x2, y2): The coordinate of endpoint close to axis
     */
  }, {
    key: "getTickLineCoord",
    value: function getTickLineCoord(data) {
      var _this$props2 = this.props, x2 = _this$props2.x, y2 = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin;
      var x1, x22, y1, y22, tx, ty;
      var sign2 = mirror ? -1 : 1;
      var finalTickSize = data.tickSize || tickSize;
      var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
      switch (orientation) {
        case "top":
          x1 = x22 = data.coordinate;
          y22 = y2 + +!mirror * height;
          y1 = y22 - sign2 * finalTickSize;
          ty = y1 - sign2 * tickMargin;
          tx = tickCoord;
          break;
        case "left":
          y1 = y22 = data.coordinate;
          x22 = x2 + +!mirror * width;
          x1 = x22 - sign2 * finalTickSize;
          tx = x1 - sign2 * tickMargin;
          ty = tickCoord;
          break;
        case "right":
          y1 = y22 = data.coordinate;
          x22 = x2 + +mirror * width;
          x1 = x22 + sign2 * finalTickSize;
          tx = x1 + sign2 * tickMargin;
          ty = tickCoord;
          break;
        default:
          x1 = x22 = data.coordinate;
          y22 = y2 + +mirror * height;
          y1 = y22 + sign2 * finalTickSize;
          ty = y1 + sign2 * tickMargin;
          tx = tickCoord;
          break;
      }
      return {
        line: {
          x1,
          y1,
          x2: x22,
          y2: y22
        },
        tick: {
          x: tx,
          y: ty
        }
      };
    }
  }, {
    key: "getTickTextAnchor",
    value: function getTickTextAnchor() {
      var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror;
      var textAnchor;
      switch (orientation) {
        case "left":
          textAnchor = mirror ? "start" : "end";
          break;
        case "right":
          textAnchor = mirror ? "end" : "start";
          break;
        default:
          textAnchor = "middle";
          break;
      }
      return textAnchor;
    }
  }, {
    key: "getTickVerticalAnchor",
    value: function getTickVerticalAnchor() {
      var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror;
      var verticalAnchor = "end";
      switch (orientation) {
        case "left":
        case "right":
          verticalAnchor = "middle";
          break;
        case "top":
          verticalAnchor = mirror ? "start" : "end";
          break;
        default:
          verticalAnchor = mirror ? "end" : "start";
          break;
      }
      return verticalAnchor;
    }
  }, {
    key: "renderAxisLine",
    value: function renderAxisLine() {
      var _this$props5 = this.props, x2 = _this$props5.x, y2 = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine;
      var props = _objectSpread$4(_objectSpread$4(_objectSpread$4({}, filterProps(this.props, false)), filterProps(axisLine, false)), {}, {
        fill: "none"
      });
      if (orientation === "top" || orientation === "bottom") {
        var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
        props = _objectSpread$4(_objectSpread$4({}, props), {}, {
          x1: x2,
          y1: y2 + needHeight * height,
          x2: x2 + width,
          y2: y2 + needHeight * height
        });
      } else {
        var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
        props = _objectSpread$4(_objectSpread$4({}, props), {}, {
          x1: x2 + needWidth * width,
          y1: y2,
          x2: x2 + needWidth * width,
          y2: y2 + height
        });
      }
      return /* @__PURE__ */ React.createElement("line", _extends$5({}, props, {
        className: clsx("recharts-cartesian-axis-line", get(axisLine, "className"))
      }));
    }
  }, {
    key: "renderTicks",
    value: (
      /**
       * render the ticks
       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
       * @param {string} fontSize Fontsize to consider for tick spacing
       * @param {string} letterSpacing Letterspacing to consider for tick spacing
       * @return {ReactComponent} renderedTicks
       */
      function renderTicks(ticks2, fontSize, letterSpacing) {
        var _this2 = this;
        var _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit2 = _this$props6.unit;
        var finalTicks = getTicks(_objectSpread$4(_objectSpread$4({}, this.props), {}, {
          ticks: ticks2
        }), fontSize, letterSpacing);
        var textAnchor = this.getTickTextAnchor();
        var verticalAnchor = this.getTickVerticalAnchor();
        var axisProps = filterProps(this.props, false);
        var customTickProps = filterProps(tick, false);
        var tickLineProps = _objectSpread$4(_objectSpread$4({}, axisProps), {}, {
          fill: "none"
        }, filterProps(tickLine, false));
        var items = finalTicks.map(function(entry, i) {
          var _this2$getTickLineCoo = _this2.getTickLineCoord(entry), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick;
          var tickProps = _objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4({
            textAnchor,
            verticalAnchor
          }, axisProps), {}, {
            stroke: "none",
            fill: stroke
          }, customTickProps), tickCoord), {}, {
            index: i,
            payload: entry,
            visibleTicksCount: finalTicks.length,
            tickFormatter
          });
          return /* @__PURE__ */ React.createElement(Layer$1, _extends$5({
            className: "recharts-cartesian-axis-tick",
            key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
          }, adaptEventsOfChild(_this2.props, entry, i)), tickLine && /* @__PURE__ */ React.createElement("line", _extends$5({}, tickLineProps, lineCoord, {
            className: clsx("recharts-cartesian-axis-tick-line", get(tickLine, "className"))
          })), tick && CartesianAxis2.renderTickItem(tick, tickProps, "".concat(isFunction$2(tickFormatter) ? tickFormatter(entry.value, i) : entry.value).concat(unit2 || "")));
        });
        return /* @__PURE__ */ React.createElement("g", {
          className: "recharts-cartesian-axis-ticks"
        }, items);
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      var _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className, hide = _this$props7.hide;
      if (hide) {
        return null;
      }
      var _this$props8 = this.props, ticks2 = _this$props8.ticks, noTicksProps = _objectWithoutProperties$3(_this$props8, _excluded3);
      var finalTicks = ticks2;
      if (isFunction$2(ticksGenerator)) {
        finalTicks = ticks2 && ticks2.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);
      }
      if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) {
        return null;
      }
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: clsx("recharts-cartesian-axis", className),
        ref: function ref(_ref2) {
          _this3.layerReference = _ref2;
        }
      }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), Label.renderCallByParent(this.props));
    }
  }], [{
    key: "renderTickItem",
    value: function renderTickItem(option, props, value) {
      var tickItem;
      var combinedClassName = clsx(props.className, "recharts-cartesian-axis-tick-value");
      if (/* @__PURE__ */ React.isValidElement(option)) {
        tickItem = /* @__PURE__ */ React.cloneElement(option, _objectSpread$4(_objectSpread$4({}, props), {}, {
          className: combinedClassName
        }));
      } else if (isFunction$2(option)) {
        tickItem = option(_objectSpread$4(_objectSpread$4({}, props), {}, {
          className: combinedClassName
        }));
      } else {
        tickItem = /* @__PURE__ */ React.createElement(Text, _extends$5({}, props, {
          className: "recharts-cartesian-axis-tick-value"
        }), value);
      }
      return tickItem;
    }
  }]);
})(reactExports.Component);
_defineProperty$7(CartesianAxis, "displayName", "CartesianAxis");
_defineProperty$7(CartesianAxis, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: true,
  axisLine: true,
  tick: true,
  mirror: false,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
});
var _excluded$2 = ["x1", "y1", "x2", "y2", "key"], _excluded2$2 = ["offset"];
function _typeof$6(o) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$6(o);
}
function ownKeys$3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$3(Object(t), true).forEach(function(r2) {
      _defineProperty$6(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$6(obj, key, value) {
  key = _toPropertyKey$6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$6(t) {
  var i = _toPrimitive$6(t, "string");
  return "symbol" == _typeof$6(i) ? i : i + "";
}
function _toPrimitive$6(t, r) {
  if ("object" != _typeof$6(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$6(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var Background = function Background2(props) {
  var fill = props.fill;
  if (!fill || fill === "none") {
    return null;
  }
  var fillOpacity = props.fillOpacity, x2 = props.x, y2 = props.y, width = props.width, height = props.height, ry = props.ry;
  return /* @__PURE__ */ React.createElement("rect", {
    x: x2,
    y: y2,
    ry,
    width,
    height,
    stroke: "none",
    fill,
    fillOpacity,
    className: "recharts-cartesian-grid-bg"
  });
};
function renderLineItem(option, props) {
  var lineItem;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    lineItem = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (isFunction$2(option)) {
    lineItem = option(props);
  } else {
    var x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2, key = props.key, others = _objectWithoutProperties$2(props, _excluded$2);
    var _filterProps = filterProps(others, false);
    _filterProps.offset;
    var restOfFilteredProps = _objectWithoutProperties$2(_filterProps, _excluded2$2);
    lineItem = /* @__PURE__ */ React.createElement("line", _extends$4({}, restOfFilteredProps, {
      x1,
      y1,
      x2,
      y2,
      fill: "none",
      key
    }));
  }
  return lineItem;
}
function HorizontalGridLines(props) {
  var x2 = props.x, width = props.width, _props$horizontal = props.horizontal, horizontal = _props$horizontal === void 0 ? true : _props$horizontal, horizontalPoints = props.horizontalPoints;
  if (!horizontal || !horizontalPoints || !horizontalPoints.length) {
    return null;
  }
  var items = horizontalPoints.map(function(entry, i) {
    var lineItemProps = _objectSpread$3(_objectSpread$3({}, props), {}, {
      x1: x2,
      y1: entry,
      x2: x2 + width,
      y2: entry,
      key: "line-".concat(i),
      index: i
    });
    return renderLineItem(horizontal, lineItemProps);
  });
  return /* @__PURE__ */ React.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, items);
}
function VerticalGridLines(props) {
  var y2 = props.y, height = props.height, _props$vertical = props.vertical, vertical = _props$vertical === void 0 ? true : _props$vertical, verticalPoints = props.verticalPoints;
  if (!vertical || !verticalPoints || !verticalPoints.length) {
    return null;
  }
  var items = verticalPoints.map(function(entry, i) {
    var lineItemProps = _objectSpread$3(_objectSpread$3({}, props), {}, {
      x1: entry,
      y1: y2,
      x2: entry,
      y2: y2 + height,
      key: "line-".concat(i),
      index: i
    });
    return renderLineItem(vertical, lineItemProps);
  });
  return /* @__PURE__ */ React.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, items);
}
function HorizontalStripes(props) {
  var horizontalFill = props.horizontalFill, fillOpacity = props.fillOpacity, x2 = props.x, y2 = props.y, width = props.width, height = props.height, horizontalPoints = props.horizontalPoints, _props$horizontal2 = props.horizontal, horizontal = _props$horizontal2 === void 0 ? true : _props$horizontal2;
  if (!horizontal || !horizontalFill || !horizontalFill.length) {
    return null;
  }
  var roundedSortedHorizontalPoints = horizontalPoints.map(function(e) {
    return Math.round(e + y2 - y2);
  }).sort(function(a2, b) {
    return a2 - b;
  });
  if (y2 !== roundedSortedHorizontalPoints[0]) {
    roundedSortedHorizontalPoints.unshift(0);
  }
  var items = roundedSortedHorizontalPoints.map(function(entry, i) {
    var lastStripe = !roundedSortedHorizontalPoints[i + 1];
    var lineHeight = lastStripe ? y2 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
    if (lineHeight <= 0) {
      return null;
    }
    var colorIndex = i % horizontalFill.length;
    return /* @__PURE__ */ React.createElement("rect", {
      key: "react-".concat(i),
      y: entry,
      x: x2,
      height: lineHeight,
      width,
      stroke: "none",
      fill: horizontalFill[colorIndex],
      fillOpacity,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ React.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, items);
}
function VerticalStripes(props) {
  var _props$vertical2 = props.vertical, vertical = _props$vertical2 === void 0 ? true : _props$vertical2, verticalFill = props.verticalFill, fillOpacity = props.fillOpacity, x2 = props.x, y2 = props.y, width = props.width, height = props.height, verticalPoints = props.verticalPoints;
  if (!vertical || !verticalFill || !verticalFill.length) {
    return null;
  }
  var roundedSortedVerticalPoints = verticalPoints.map(function(e) {
    return Math.round(e + x2 - x2);
  }).sort(function(a2, b) {
    return a2 - b;
  });
  if (x2 !== roundedSortedVerticalPoints[0]) {
    roundedSortedVerticalPoints.unshift(0);
  }
  var items = roundedSortedVerticalPoints.map(function(entry, i) {
    var lastStripe = !roundedSortedVerticalPoints[i + 1];
    var lineWidth = lastStripe ? x2 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
    if (lineWidth <= 0) {
      return null;
    }
    var colorIndex = i % verticalFill.length;
    return /* @__PURE__ */ React.createElement("rect", {
      key: "react-".concat(i),
      x: entry,
      y: y2,
      width: lineWidth,
      height,
      stroke: "none",
      fill: verticalFill[colorIndex],
      fillOpacity,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ React.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, items);
}
var defaultVerticalCoordinatesGenerator = function defaultVerticalCoordinatesGenerator2(_ref, syncWithTicks) {
  var xAxis = _ref.xAxis, width = _ref.width, height = _ref.height, offset2 = _ref.offset;
  return getCoordinatesOfGrid(getTicks(_objectSpread$3(_objectSpread$3(_objectSpread$3({}, CartesianAxis.defaultProps), xAxis), {}, {
    ticks: getTicksOfAxis(xAxis, true),
    viewBox: {
      x: 0,
      y: 0,
      width,
      height
    }
  })), offset2.left, offset2.left + offset2.width, syncWithTicks);
};
var defaultHorizontalCoordinatesGenerator = function defaultHorizontalCoordinatesGenerator2(_ref2, syncWithTicks) {
  var yAxis = _ref2.yAxis, width = _ref2.width, height = _ref2.height, offset2 = _ref2.offset;
  return getCoordinatesOfGrid(getTicks(_objectSpread$3(_objectSpread$3(_objectSpread$3({}, CartesianAxis.defaultProps), yAxis), {}, {
    ticks: getTicksOfAxis(yAxis, true),
    viewBox: {
      x: 0,
      y: 0,
      width,
      height
    }
  })), offset2.top, offset2.top + offset2.height, syncWithTicks);
};
var defaultProps$c = {
  horizontal: true,
  vertical: true,
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: []
};
function CartesianGrid(props) {
  var _props$stroke, _props$fill, _props$horizontal3, _props$horizontalFill, _props$vertical3, _props$verticalFill;
  var chartWidth = useChartWidth();
  var chartHeight = useChartHeight();
  var offset2 = useOffset();
  var propsIncludingDefaults = _objectSpread$3(_objectSpread$3({}, props), {}, {
    stroke: (_props$stroke = props.stroke) !== null && _props$stroke !== void 0 ? _props$stroke : defaultProps$c.stroke,
    fill: (_props$fill = props.fill) !== null && _props$fill !== void 0 ? _props$fill : defaultProps$c.fill,
    horizontal: (_props$horizontal3 = props.horizontal) !== null && _props$horizontal3 !== void 0 ? _props$horizontal3 : defaultProps$c.horizontal,
    horizontalFill: (_props$horizontalFill = props.horizontalFill) !== null && _props$horizontalFill !== void 0 ? _props$horizontalFill : defaultProps$c.horizontalFill,
    vertical: (_props$vertical3 = props.vertical) !== null && _props$vertical3 !== void 0 ? _props$vertical3 : defaultProps$c.vertical,
    verticalFill: (_props$verticalFill = props.verticalFill) !== null && _props$verticalFill !== void 0 ? _props$verticalFill : defaultProps$c.verticalFill,
    x: isNumber(props.x) ? props.x : offset2.left,
    y: isNumber(props.y) ? props.y : offset2.top,
    width: isNumber(props.width) ? props.width : offset2.width,
    height: isNumber(props.height) ? props.height : offset2.height
  });
  var x2 = propsIncludingDefaults.x, y2 = propsIncludingDefaults.y, width = propsIncludingDefaults.width, height = propsIncludingDefaults.height, syncWithTicks = propsIncludingDefaults.syncWithTicks, horizontalValues = propsIncludingDefaults.horizontalValues, verticalValues = propsIncludingDefaults.verticalValues;
  var xAxis = useArbitraryXAxis();
  var yAxis = useYAxisWithFiniteDomainOrRandom();
  if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x2) || x2 !== +x2 || !isNumber(y2) || y2 !== +y2) {
    return null;
  }
  var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
  var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
  var horizontalPoints = propsIncludingDefaults.horizontalPoints, verticalPoints = propsIncludingDefaults.verticalPoints;
  if ((!horizontalPoints || !horizontalPoints.length) && isFunction$2(horizontalCoordinatesGenerator)) {
    var isHorizontalValues = horizontalValues && horizontalValues.length;
    var generatorResult = horizontalCoordinatesGenerator({
      yAxis: yAxis ? _objectSpread$3(_objectSpread$3({}, yAxis), {}, {
        ticks: isHorizontalValues ? horizontalValues : yAxis.ticks
      }) : void 0,
      width: chartWidth,
      height: chartHeight,
      offset: offset2
    }, isHorizontalValues ? true : syncWithTicks);
    warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$6(generatorResult), "]"));
    if (Array.isArray(generatorResult)) {
      horizontalPoints = generatorResult;
    }
  }
  if ((!verticalPoints || !verticalPoints.length) && isFunction$2(verticalCoordinatesGenerator)) {
    var isVerticalValues = verticalValues && verticalValues.length;
    var _generatorResult = verticalCoordinatesGenerator({
      xAxis: xAxis ? _objectSpread$3(_objectSpread$3({}, xAxis), {}, {
        ticks: isVerticalValues ? verticalValues : xAxis.ticks
      }) : void 0,
      width: chartWidth,
      height: chartHeight,
      offset: offset2
    }, isVerticalValues ? true : syncWithTicks);
    warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$6(_generatorResult), "]"));
    if (Array.isArray(_generatorResult)) {
      verticalPoints = _generatorResult;
    }
  }
  return /* @__PURE__ */ React.createElement("g", {
    className: "recharts-cartesian-grid"
  }, /* @__PURE__ */ React.createElement(Background, {
    fill: propsIncludingDefaults.fill,
    fillOpacity: propsIncludingDefaults.fillOpacity,
    x: propsIncludingDefaults.x,
    y: propsIncludingDefaults.y,
    width: propsIncludingDefaults.width,
    height: propsIncludingDefaults.height,
    ry: propsIncludingDefaults.ry
  }), /* @__PURE__ */ React.createElement(HorizontalGridLines, _extends$4({}, propsIncludingDefaults, {
    offset: offset2,
    horizontalPoints,
    xAxis,
    yAxis
  })), /* @__PURE__ */ React.createElement(VerticalGridLines, _extends$4({}, propsIncludingDefaults, {
    offset: offset2,
    verticalPoints,
    xAxis,
    yAxis
  })), /* @__PURE__ */ React.createElement(HorizontalStripes, _extends$4({}, propsIncludingDefaults, {
    horizontalPoints
  })), /* @__PURE__ */ React.createElement(VerticalStripes, _extends$4({}, propsIncludingDefaults, {
    verticalPoints
  })));
}
CartesianGrid.displayName = "CartesianGrid";
var _excluded$1 = ["type", "layout", "connectNulls", "ref"], _excluded2$1 = ["key"];
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function ownKeys$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2(Object(t), true).forEach(function(r2) {
      _defineProperty$5(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}
function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$5(descriptor.key), descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$3(t, o, e) {
  return o = _getPrototypeOf$3(o), _possibleConstructorReturn$3(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf$3(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$3(o, p2);
}
function _defineProperty$5(obj, key, value) {
  key = _toPropertyKey$5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$5(t) {
  var i = _toPrimitive$5(t, "string");
  return "symbol" == _typeof$5(i) ? i : i + "";
}
function _toPrimitive$5(t, r) {
  if ("object" != _typeof$5(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$5(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var Line = /* @__PURE__ */ (function(_PureComponent) {
  function Line2() {
    var _this;
    _classCallCheck$4(this, Line2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper$3(this, Line2, [].concat(args));
    _defineProperty$5(_this, "state", {
      isAnimationFinished: true,
      totalLength: 0
    });
    _defineProperty$5(_this, "generateSimpleStrokeDasharray", function(totalLength, length) {
      return "".concat(length, "px ").concat(totalLength - length, "px");
    });
    _defineProperty$5(_this, "getStrokeDasharray", function(length, totalLength, lines) {
      var lineLength = lines.reduce(function(pre, next) {
        return pre + next;
      });
      if (!lineLength) {
        return _this.generateSimpleStrokeDasharray(totalLength, length);
      }
      var count2 = Math.floor(length / lineLength);
      var remainLength = length % lineLength;
      var restLength = totalLength - length;
      var remainLines = [];
      for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) {
        if (sum + lines[i] > remainLength) {
          remainLines = [].concat(_toConsumableArray$2(lines.slice(0, i)), [remainLength - sum]);
          break;
        }
      }
      var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
      return [].concat(_toConsumableArray$2(Line2.repeat(lines, count2)), _toConsumableArray$2(remainLines), emptyLines).map(function(line) {
        return "".concat(line, "px");
      }).join(", ");
    });
    _defineProperty$5(_this, "id", uniqueId("recharts-line-"));
    _defineProperty$5(_this, "pathRef", function(node) {
      _this.mainCurve = node;
    });
    _defineProperty$5(_this, "handleAnimationEnd", function() {
      _this.setState({
        isAnimationFinished: true
      });
      if (_this.props.onAnimationEnd) {
        _this.props.onAnimationEnd();
      }
    });
    _defineProperty$5(_this, "handleAnimationStart", function() {
      _this.setState({
        isAnimationFinished: false
      });
      if (_this.props.onAnimationStart) {
        _this.props.onAnimationStart();
      }
    });
    return _this;
  }
  _inherits$3(Line2, _PureComponent);
  return _createClass$4(Line2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this.props.isAnimationActive) {
        return;
      }
      var totalLength = this.getTotalLength();
      this.setState({
        totalLength
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (!this.props.isAnimationActive) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength !== this.state.totalLength) {
        this.setState({
          totalLength
        });
      }
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength() {
      var curveDom = this.mainCurve;
      try {
        return curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;
      } catch (err) {
        return 0;
      }
    }
  }, {
    key: "renderErrorBar",
    value: function renderErrorBar(needClip, clipPathId) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props = this.props, points = _this$props.points, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, layout = _this$props.layout, children = _this$props.children;
      var errorBarItems = findAllByType(children, ErrorBar);
      if (!errorBarItems) {
        return null;
      }
      var dataPointFormatter = function dataPointFormatter2(dataPoint, dataKey) {
        return {
          x: dataPoint.x,
          y: dataPoint.y,
          value: dataPoint.value,
          errorVal: getValueByDataKey(dataPoint.payload, dataKey)
        };
      };
      var errorBarProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer$1, errorBarProps, errorBarItems.map(function(item) {
        return /* @__PURE__ */ React.cloneElement(item, {
          key: "bar-".concat(item.props.dataKey),
          data: points,
          xAxis,
          yAxis,
          layout,
          dataPointFormatter
        });
      }));
    }
  }, {
    key: "renderDots",
    value: function renderDots(needClip, clipDot, clipPathId) {
      var isAnimationActive = this.props.isAnimationActive;
      if (isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props2 = this.props, dot2 = _this$props2.dot, points = _this$props2.points, dataKey = _this$props2.dataKey;
      var lineProps = filterProps(this.props, false);
      var customDotProps = filterProps(dot2, true);
      var dots = points.map(function(entry, i) {
        var dotProps = _objectSpread$2(_objectSpread$2(_objectSpread$2({
          key: "dot-".concat(i),
          r: 3
        }, lineProps), customDotProps), {}, {
          index: i,
          cx: entry.x,
          cy: entry.y,
          value: entry.value,
          dataKey,
          payload: entry.payload,
          points
        });
        return Line2.renderDotItem(dot2, dotProps);
      });
      var dotsProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer$1, _extends$3({
        className: "recharts-line-dots",
        key: "dots"
      }, dotsProps), dots);
    }
  }, {
    key: "renderCurveStatically",
    value: function renderCurveStatically(points, needClip, clipPathId, props) {
      var _this$props3 = this.props, type = _this$props3.type, layout = _this$props3.layout, connectNulls = _this$props3.connectNulls;
      _this$props3.ref;
      var others = _objectWithoutProperties$1(_this$props3, _excluded$1);
      var curveProps = _objectSpread$2(_objectSpread$2(_objectSpread$2({}, filterProps(others, true)), {}, {
        fill: "none",
        className: "recharts-line-curve",
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
        points
      }, props), {}, {
        type,
        layout,
        connectNulls
      });
      return /* @__PURE__ */ React.createElement(Curve, _extends$3({}, curveProps, {
        pathRef: this.pathRef
      }));
    }
  }, {
    key: "renderCurveWithAnimation",
    value: function renderCurveWithAnimation(needClip, clipPathId) {
      var _this2 = this;
      var _this$props4 = this.props, points = _this$props4.points, strokeDasharray = _this$props4.strokeDasharray, isAnimationActive = _this$props4.isAnimationActive, animationBegin = _this$props4.animationBegin, animationDuration = _this$props4.animationDuration, animationEasing = _this$props4.animationEasing, animationId = _this$props4.animationId, animateNewValues = _this$props4.animateNewValues, width = _this$props4.width, height = _this$props4.height;
      var _this$state = this.state, prevPoints = _this$state.prevPoints, totalLength = _this$state.totalLength;
      return /* @__PURE__ */ React.createElement(Animate, {
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "line-".concat(animationId),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(_ref) {
        var t = _ref.t;
        if (prevPoints) {
          var prevPointsDiffFactor = prevPoints.length / points.length;
          var stepData = points.map(function(entry, index2) {
            var prevPointIndex = Math.floor(index2 * prevPointsDiffFactor);
            if (prevPoints[prevPointIndex]) {
              var prev = prevPoints[prevPointIndex];
              var interpolatorX = interpolateNumber$2(prev.x, entry.x);
              var interpolatorY = interpolateNumber$2(prev.y, entry.y);
              return _objectSpread$2(_objectSpread$2({}, entry), {}, {
                x: interpolatorX(t),
                y: interpolatorY(t)
              });
            }
            if (animateNewValues) {
              var _interpolatorX = interpolateNumber$2(width * 2, entry.x);
              var _interpolatorY = interpolateNumber$2(height / 2, entry.y);
              return _objectSpread$2(_objectSpread$2({}, entry), {}, {
                x: _interpolatorX(t),
                y: _interpolatorY(t)
              });
            }
            return _objectSpread$2(_objectSpread$2({}, entry), {}, {
              x: entry.x,
              y: entry.y
            });
          });
          return _this2.renderCurveStatically(stepData, needClip, clipPathId);
        }
        var interpolator = interpolateNumber$2(0, totalLength);
        var curLength = interpolator(t);
        var currentStrokeDasharray;
        if (strokeDasharray) {
          var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map(function(num) {
            return parseFloat(num);
          });
          currentStrokeDasharray = _this2.getStrokeDasharray(curLength, totalLength, lines);
        } else {
          currentStrokeDasharray = _this2.generateSimpleStrokeDasharray(totalLength, curLength);
        }
        return _this2.renderCurveStatically(points, needClip, clipPathId, {
          strokeDasharray: currentStrokeDasharray
        });
      });
    }
  }, {
    key: "renderCurve",
    value: function renderCurve(needClip, clipPathId) {
      var _this$props5 = this.props, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;
      var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, totalLength = _this$state2.totalLength;
      if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !isEqual$1(prevPoints, points))) {
        return this.renderCurveWithAnimation(needClip, clipPathId);
      }
      return this.renderCurveStatically(points, needClip, clipPathId);
    }
  }, {
    key: "render",
    value: function render() {
      var _filterProps;
      var _this$props6 = this.props, hide = _this$props6.hide, dot2 = _this$props6.dot, points = _this$props6.points, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, top = _this$props6.top, left = _this$props6.left, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, id = _this$props6.id;
      if (hide || !points || !points.length) {
        return null;
      }
      var isAnimationFinished = this.state.isAnimationFinished;
      var hasSinglePoint = points.length === 1;
      var layerClass = clsx("recharts-line", className);
      var needClipX = xAxis && xAxis.allowDataOverflow;
      var needClipY = yAxis && yAxis.allowDataOverflow;
      var needClip = needClipX || needClipY;
      var clipPathId = isNil(id) ? this.id : id;
      var _ref2 = (_filterProps = filterProps(dot2, false)) !== null && _filterProps !== void 0 ? _filterProps : {
        r: 3,
        strokeWidth: 2
      }, _ref2$r = _ref2.r, r = _ref2$r === void 0 ? 3 : _ref2$r, _ref2$strokeWidth = _ref2.strokeWidth, strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;
      var _ref3 = hasClipDot(dot2) ? dot2 : {}, _ref3$clipDot = _ref3.clipDot, clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;
      var dotSize = r * 2 + strokeWidth;
      return /* @__PURE__ */ React.createElement(Layer$1, {
        className: layerClass
      }, needClipX || needClipY ? /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: needClipX ? left : left - width / 2,
        y: needClipY ? top : top - height / 2,
        width: needClipX ? width : width * 2,
        height: needClipY ? height : height * 2
      })), !clipDot && /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-dots-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: left - dotSize / 2,
        y: top - dotSize / 2,
        width: width + dotSize,
        height: height + dotSize
      }))) : null, !hasSinglePoint && this.renderCurve(needClip, clipPathId), this.renderErrorBar(needClip, clipPathId), (hasSinglePoint || dot2) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, points));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.animationId !== prevState.prevAnimationId) {
        return {
          prevAnimationId: nextProps.animationId,
          curPoints: nextProps.points,
          prevPoints: prevState.curPoints
        };
      }
      if (nextProps.points !== prevState.curPoints) {
        return {
          curPoints: nextProps.points
        };
      }
      return null;
    }
  }, {
    key: "repeat",
    value: function repeat(lines, count2) {
      var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray$2(lines), [0]) : lines;
      var result = [];
      for (var i = 0; i < count2; ++i) {
        result = [].concat(_toConsumableArray$2(result), _toConsumableArray$2(linesUnit));
      }
      return result;
    }
  }, {
    key: "renderDotItem",
    value: function renderDotItem(option, props) {
      var dotItem;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        dotItem = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (isFunction$2(option)) {
        dotItem = option(props);
      } else {
        var key = props.key, dotProps = _objectWithoutProperties$1(props, _excluded2$1);
        var className = clsx("recharts-line-dot", typeof option !== "boolean" ? option.className : "");
        dotItem = /* @__PURE__ */ React.createElement(Dot, _extends$3({
          key
        }, dotProps, {
          className
        }));
      }
      return dotItem;
    }
  }]);
})(reactExports.PureComponent);
_defineProperty$5(Line, "displayName", "Line");
_defineProperty$5(Line, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  connectNulls: false,
  activeDot: true,
  dot: true,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  fill: "#fff",
  points: [],
  isAnimationActive: !Global.isSsr,
  animateNewValues: true,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  hide: false,
  label: false
});
_defineProperty$5(Line, "getComposedData", function(_ref4) {
  var props = _ref4.props, xAxis = _ref4.xAxis, yAxis = _ref4.yAxis, xAxisTicks = _ref4.xAxisTicks, yAxisTicks = _ref4.yAxisTicks, dataKey = _ref4.dataKey, bandSize = _ref4.bandSize, displayedData = _ref4.displayedData, offset2 = _ref4.offset;
  var layout = props.layout;
  var points = displayedData.map(function(entry, index2) {
    var value = getValueByDataKey(entry, dataKey);
    if (layout === "horizontal") {
      return {
        x: getCateCoordinateOfLine({
          axis: xAxis,
          ticks: xAxisTicks,
          bandSize,
          entry,
          index: index2
        }),
        y: isNil(value) ? null : yAxis.scale(value),
        value,
        payload: entry
      };
    }
    return {
      x: isNil(value) ? null : xAxis.scale(value),
      y: getCateCoordinateOfLine({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        entry,
        index: index2
      }),
      value,
      payload: entry
    };
  });
  return _objectSpread$2({
    points,
    layout
  }, offset2);
});
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$2(t, o, e) {
  return o = _getPrototypeOf$2(o), _possibleConstructorReturn$2(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf$2(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey$4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$4(t) {
  var i = _toPrimitive$4(t, "string");
  return "symbol" == _typeof$4(i) ? i : i + "";
}
function _toPrimitive$4(t, r) {
  if ("object" != _typeof$4(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$4(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function XAxisImpl(_ref) {
  var xAxisId = _ref.xAxisId;
  var width = useChartWidth();
  var height = useChartHeight();
  var axisOptions = useXAxisOrThrow(xAxisId);
  if (axisOptions == null) {
    return null;
  }
  return (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ reactExports.createElement(CartesianAxis, _extends$2({}, axisOptions, {
      className: clsx("recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType), axisOptions.className),
      viewBox: {
        x: 0,
        y: 0,
        width,
        height
      },
      ticksGenerator: function ticksGenerator(axis) {
        return getTicksOfAxis(axis, true);
      }
    }))
  );
}
var XAxis = /* @__PURE__ */ (function(_React$Component) {
  function XAxis2() {
    _classCallCheck$3(this, XAxis2);
    return _callSuper$2(this, XAxis2, arguments);
  }
  _inherits$2(XAxis2, _React$Component);
  return _createClass$3(XAxis2, [{
    key: "render",
    value: function render() {
      return /* @__PURE__ */ reactExports.createElement(XAxisImpl, this.props);
    }
  }]);
})(reactExports.Component);
_defineProperty$4(XAxis, "displayName", "XAxis");
_defineProperty$4(XAxis, "defaultProps", {
  allowDecimals: true,
  hide: false,
  orientation: "bottom",
  width: 0,
  height: 30,
  mirror: false,
  xAxisId: 0,
  tickCount: 5,
  type: "category",
  padding: {
    left: 0,
    right: 0
  },
  allowDataOverflow: false,
  scale: "auto",
  reversed: false,
  allowDuplicatedCategory: true
});
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$1(t, o, e) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey$3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$3(t) {
  var i = _toPrimitive$3(t, "string");
  return "symbol" == _typeof$3(i) ? i : i + "";
}
function _toPrimitive$3(t, r) {
  if ("object" != _typeof$3(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$3(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var YAxisImpl = function YAxisImpl2(_ref) {
  var yAxisId = _ref.yAxisId;
  var width = useChartWidth();
  var height = useChartHeight();
  var axisOptions = useYAxisOrThrow(yAxisId);
  if (axisOptions == null) {
    return null;
  }
  return (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ reactExports.createElement(CartesianAxis, _extends$1({}, axisOptions, {
      className: clsx("recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType), axisOptions.className),
      viewBox: {
        x: 0,
        y: 0,
        width,
        height
      },
      ticksGenerator: function ticksGenerator(axis) {
        return getTicksOfAxis(axis, true);
      }
    }))
  );
};
var YAxis = /* @__PURE__ */ (function(_React$Component) {
  function YAxis2() {
    _classCallCheck$2(this, YAxis2);
    return _callSuper$1(this, YAxis2, arguments);
  }
  _inherits$1(YAxis2, _React$Component);
  return _createClass$2(YAxis2, [{
    key: "render",
    value: function render() {
      return /* @__PURE__ */ reactExports.createElement(YAxisImpl, this.props);
    }
  }]);
})(reactExports.Component);
_defineProperty$3(YAxis, "displayName", "YAxis");
_defineProperty$3(YAxis, "defaultProps", {
  allowDuplicatedCategory: true,
  allowDecimals: true,
  hide: false,
  orientation: "left",
  width: 60,
  height: 0,
  mirror: false,
  yAxisId: 0,
  tickCount: 5,
  type: "number",
  padding: {
    top: 0,
    bottom: 0
  },
  allowDataOverflow: false,
  scale: "auto",
  reversed: false
});
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var detectReferenceElementsDomain = function detectReferenceElementsDomain2(children, domain, axisId, axisType, specifiedTicks) {
  var lines = findAllByType(children, ReferenceLine);
  var dots = findAllByType(children, ReferenceDot);
  var elements = [].concat(_toConsumableArray$1(lines), _toConsumableArray$1(dots));
  var areas = findAllByType(children, ReferenceArea);
  var idKey = "".concat(axisType, "Id");
  var valueKey = axisType[0];
  var finalDomain = domain;
  if (elements.length) {
    finalDomain = elements.reduce(function(result, el) {
      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[valueKey])) {
        var value = el.props[valueKey];
        return [Math.min(result[0], value), Math.max(result[1], value)];
      }
      return result;
    }, finalDomain);
  }
  if (areas.length) {
    var key1 = "".concat(valueKey, "1");
    var key2 = "".concat(valueKey, "2");
    finalDomain = areas.reduce(function(result, el) {
      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[key1]) && isNumber(el.props[key2])) {
        var value1 = el.props[key1];
        var value2 = el.props[key2];
        return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
      }
      return result;
    }, finalDomain);
  }
  if (specifiedTicks && specifiedTicks.length) {
    finalDomain = specifiedTicks.reduce(function(result, tick) {
      if (isNumber(tick)) {
        return [Math.min(result[0], tick), Math.max(result[1], tick)];
      }
      return result;
    }, finalDomain);
  }
  return finalDomain;
};
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix2 ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee2 = new Array(l); i < l; i++) {
        ee2[i] = handlers[i].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var eventCenter = new EventEmitter();
var SYNC_EVENT = "recharts.syncMouseEvents";
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$2(t) {
  var i = _toPrimitive$2(t, "string");
  return "symbol" == _typeof$2(i) ? i : i + "";
}
function _toPrimitive$2(t, r) {
  if ("object" != _typeof$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var AccessibilityManager = /* @__PURE__ */ (function() {
  function AccessibilityManager2() {
    _classCallCheck$1(this, AccessibilityManager2);
    _defineProperty$2(this, "activeIndex", 0);
    _defineProperty$2(this, "coordinateList", []);
    _defineProperty$2(this, "layout", "horizontal");
  }
  return _createClass$1(AccessibilityManager2, [{
    key: "setDetails",
    value: function setDetails(_ref) {
      var _ref2;
      var _ref$coordinateList = _ref.coordinateList, coordinateList = _ref$coordinateList === void 0 ? null : _ref$coordinateList, _ref$container = _ref.container, container = _ref$container === void 0 ? null : _ref$container, _ref$layout = _ref.layout, layout = _ref$layout === void 0 ? null : _ref$layout, _ref$offset = _ref.offset, offset2 = _ref$offset === void 0 ? null : _ref$offset, _ref$mouseHandlerCall = _ref.mouseHandlerCallback, mouseHandlerCallback = _ref$mouseHandlerCall === void 0 ? null : _ref$mouseHandlerCall;
      this.coordinateList = (_ref2 = coordinateList !== null && coordinateList !== void 0 ? coordinateList : this.coordinateList) !== null && _ref2 !== void 0 ? _ref2 : [];
      this.container = container !== null && container !== void 0 ? container : this.container;
      this.layout = layout !== null && layout !== void 0 ? layout : this.layout;
      this.offset = offset2 !== null && offset2 !== void 0 ? offset2 : this.offset;
      this.mouseHandlerCallback = mouseHandlerCallback !== null && mouseHandlerCallback !== void 0 ? mouseHandlerCallback : this.mouseHandlerCallback;
      this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);
    }
  }, {
    key: "focus",
    value: function focus() {
      this.spoofMouse();
    }
  }, {
    key: "keyboardEvent",
    value: function keyboardEvent(e) {
      if (this.coordinateList.length === 0) {
        return;
      }
      switch (e.key) {
        case "ArrowRight": {
          if (this.layout !== "horizontal") {
            return;
          }
          this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1);
          this.spoofMouse();
          break;
        }
        case "ArrowLeft": {
          if (this.layout !== "horizontal") {
            return;
          }
          this.activeIndex = Math.max(this.activeIndex - 1, 0);
          this.spoofMouse();
          break;
        }
      }
    }
  }, {
    key: "setIndex",
    value: function setIndex(newIndex) {
      this.activeIndex = newIndex;
    }
  }, {
    key: "spoofMouse",
    value: function spoofMouse() {
      var _window, _window2;
      if (this.layout !== "horizontal") {
        return;
      }
      if (this.coordinateList.length === 0) {
        return;
      }
      var _this$container$getBo = this.container.getBoundingClientRect(), x2 = _this$container$getBo.x, y2 = _this$container$getBo.y, height = _this$container$getBo.height;
      var coordinate = this.coordinateList[this.activeIndex].coordinate;
      var scrollOffsetX = ((_window = window) === null || _window === void 0 ? void 0 : _window.scrollX) || 0;
      var scrollOffsetY = ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.scrollY) || 0;
      var pageX = x2 + coordinate + scrollOffsetX;
      var pageY = y2 + this.offset.top + height / 2 + scrollOffsetY;
      this.mouseHandlerCallback({
        pageX,
        pageY
      });
    }
  }]);
})();
function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {
  if (axisType === "number" && allowDataOverflow === true && Array.isArray(domain)) {
    var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];
    var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];
    if (!!domainStart && !!domainEnd && isNumber(domainStart) && isNumber(domainEnd)) {
      return true;
    }
  }
  return false;
}
function getCursorRectangle(layout, activeCoordinate, offset2, tooltipAxisBandSize) {
  var halfSize = tooltipAxisBandSize / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset2.left + 0.5,
    y: layout === "horizontal" ? offset2.top + 0.5 : activeCoordinate.y - halfSize,
    width: layout === "horizontal" ? tooltipAxisBandSize : offset2.width - 1,
    height: layout === "horizontal" ? offset2.height - 1 : tooltipAxisBandSize
  };
}
function getRadialCursorPoints(activeCoordinate) {
  var cx = activeCoordinate.cx, cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle;
  var startPoint = polarToCartesian(cx, cy, radius, startAngle);
  var endPoint = polarToCartesian(cx, cy, radius, endAngle);
  return {
    points: [startPoint, endPoint],
    cx,
    cy,
    radius,
    startAngle,
    endAngle
  };
}
function getCursorPoints(layout, activeCoordinate, offset2) {
  var x1, y1, x2, y2;
  if (layout === "horizontal") {
    x1 = activeCoordinate.x;
    x2 = x1;
    y1 = offset2.top;
    y2 = offset2.top + offset2.height;
  } else if (layout === "vertical") {
    y1 = activeCoordinate.y;
    y2 = y1;
    x1 = offset2.left;
    x2 = offset2.left + offset2.width;
  } else if (activeCoordinate.cx != null && activeCoordinate.cy != null) {
    if (layout === "centric") {
      var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle2 = activeCoordinate.angle;
      var innerPoint = polarToCartesian(cx, cy, innerRadius, angle2);
      var outerPoint = polarToCartesian(cx, cy, outerRadius, angle2);
      x1 = innerPoint.x;
      y1 = innerPoint.y;
      x2 = outerPoint.x;
      y2 = outerPoint.y;
    } else {
      return getRadialCursorPoints(activeCoordinate);
    }
  }
  return [{
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  }];
}
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(t) {
  var i = _toPrimitive$1(t, "string");
  return "symbol" == _typeof$1(i) ? i : i + "";
}
function _toPrimitive$1(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$1(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function Cursor(props) {
  var _element$props$cursor, _defaultProps;
  var element = props.element, tooltipEventType = props.tooltipEventType, isActive = props.isActive, activeCoordinate = props.activeCoordinate, activePayload = props.activePayload, offset2 = props.offset, activeTooltipIndex = props.activeTooltipIndex, tooltipAxisBandSize = props.tooltipAxisBandSize, layout = props.layout, chartName = props.chartName;
  var elementPropsCursor = (_element$props$cursor = element.props.cursor) !== null && _element$props$cursor !== void 0 ? _element$props$cursor : (_defaultProps = element.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps.cursor;
  if (!element || !elementPropsCursor || !isActive || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") {
    return null;
  }
  var restProps;
  var cursorComp = Curve;
  if (chartName === "ScatterChart") {
    restProps = activeCoordinate;
    cursorComp = Cross;
  } else if (chartName === "BarChart") {
    restProps = getCursorRectangle(layout, activeCoordinate, offset2, tooltipAxisBandSize);
    cursorComp = Rectangle;
  } else if (layout === "radial") {
    var _getRadialCursorPoint = getRadialCursorPoints(activeCoordinate), cx = _getRadialCursorPoint.cx, cy = _getRadialCursorPoint.cy, radius = _getRadialCursorPoint.radius, startAngle = _getRadialCursorPoint.startAngle, endAngle = _getRadialCursorPoint.endAngle;
    restProps = {
      cx,
      cy,
      startAngle,
      endAngle,
      innerRadius: radius,
      outerRadius: radius
    };
    cursorComp = Sector;
  } else {
    restProps = {
      points: getCursorPoints(layout, activeCoordinate, offset2)
    };
    cursorComp = Curve;
  }
  var cursorProps = _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({
    stroke: "#ccc",
    pointerEvents: "none"
  }, offset2), restProps), filterProps(elementPropsCursor, false)), {}, {
    payload: activePayload,
    payloadIndex: activeTooltipIndex,
    className: clsx("recharts-tooltip-cursor", elementPropsCursor.className)
  });
  return /* @__PURE__ */ reactExports.isValidElement(elementPropsCursor) ? /* @__PURE__ */ reactExports.cloneElement(elementPropsCursor, cursorProps) : /* @__PURE__ */ reactExports.createElement(cursorComp, cursorProps);
}
var _excluded = ["item"], _excluded2 = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u2, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
    o2.__proto__ = p22;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var ORIENT_MAP = {
  xAxis: ["bottom", "top"],
  yAxis: ["left", "right"]
};
var FULL_WIDTH_AND_HEIGHT = {
  width: "100%",
  height: "100%"
};
var originCoordinate = {
  x: 0,
  y: 0
};
function renderAsIs(element) {
  return element;
}
var calculateTooltipPos = function calculateTooltipPos2(rangeObj, layout) {
  if (layout === "horizontal") {
    return rangeObj.x;
  }
  if (layout === "vertical") {
    return rangeObj.y;
  }
  if (layout === "centric") {
    return rangeObj.angle;
  }
  return rangeObj.radius;
};
var getActiveCoordinate = function getActiveCoordinate2(layout, tooltipTicks, activeIndex, rangeObj) {
  var entry = tooltipTicks.find(function(tick) {
    return tick && tick.index === activeIndex;
  });
  if (entry) {
    if (layout === "horizontal") {
      return {
        x: entry.coordinate,
        y: rangeObj.y
      };
    }
    if (layout === "vertical") {
      return {
        x: rangeObj.x,
        y: entry.coordinate
      };
    }
    if (layout === "centric") {
      var _angle = entry.coordinate;
      var _radius = rangeObj.radius;
      return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
        angle: _angle,
        radius: _radius
      });
    }
    var radius = entry.coordinate;
    var angle2 = rangeObj.angle;
    return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle2)), {}, {
      angle: angle2,
      radius
    });
  }
  return originCoordinate;
};
var getDisplayedData = function getDisplayedData2(data, _ref) {
  var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;
  var itemsData = (graphicalItems !== null && graphicalItems !== void 0 ? graphicalItems : []).reduce(function(result, child) {
    var itemData = child.props.data;
    if (itemData && itemData.length) {
      return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));
    }
    return result;
  }, []);
  if (itemsData.length > 0) {
    return itemsData;
  }
  if (data && data.length && isNumber(dataStartIndex) && isNumber(dataEndIndex)) {
    return data.slice(dataStartIndex, dataEndIndex + 1);
  }
  return [];
};
function getDefaultDomainByAxisType(axisType) {
  return axisType === "number" ? [0, "auto"] : void 0;
}
var getTooltipContent = function getTooltipContent2(state, chartData, activeIndex, activeLabel) {
  var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;
  var displayedData = getDisplayedData(chartData, state);
  if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {
    return null;
  }
  return graphicalItems.reduce(function(result, child) {
    var _child$props$data;
    var data = (_child$props$data = child.props.data) !== null && _child$props$data !== void 0 ? _child$props$data : chartData;
    if (data && state.dataStartIndex + state.dataEndIndex !== 0 && // https://github.com/recharts/recharts/issues/4717
    // The data is sliced only when the active index is within the start/end index range.
    state.dataEndIndex - state.dataStartIndex >= activeIndex) {
      data = data.slice(state.dataStartIndex, state.dataEndIndex + 1);
    }
    var payload;
    if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
      var entries = data === void 0 ? displayedData : data;
      payload = findEntryInArray(entries, tooltipAxis.dataKey, activeLabel);
    } else {
      payload = data && data[activeIndex] || displayedData[activeIndex];
    }
    if (!payload) {
      return result;
    }
    return [].concat(_toConsumableArray(result), [getTooltipItem(child, payload)]);
  }, []);
};
var getTooltipData = function getTooltipData2(state, chartData, layout, rangeObj) {
  var rangeData = rangeObj || {
    x: state.chartX,
    y: state.chartY
  };
  var pos = calculateTooltipPos(rangeData, layout);
  var ticks2 = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;
  var activeIndex = calculateActiveTickIndex(pos, ticks2, tooltipTicks, axis);
  if (activeIndex >= 0 && tooltipTicks) {
    var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;
    var activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel);
    var activeCoordinate = getActiveCoordinate(layout, ticks2, activeIndex, rangeData);
    return {
      activeTooltipIndex: activeIndex,
      activeLabel,
      activePayload,
      activeCoordinate
    };
  }
  return null;
};
var getAxisMapByAxes = function getAxisMapByAxes2(props, _ref2) {
  var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;
  var layout = props.layout, children = props.children, stackOffset = props.stackOffset;
  var isCategorical = isCategoricalAxis(layout, axisType);
  return axes.reduce(function(result, child) {
    var _childProps$domain2;
    var childProps = child.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;
    var type = childProps.type, dataKey = childProps.dataKey, allowDataOverflow = childProps.allowDataOverflow, allowDuplicatedCategory = childProps.allowDuplicatedCategory, scale2 = childProps.scale, ticks2 = childProps.ticks, includeHidden = childProps.includeHidden;
    var axisId = childProps[axisIdKey];
    if (result[axisId]) {
      return result;
    }
    var displayedData = getDisplayedData(props.data, {
      graphicalItems: graphicalItems.filter(function(item) {
        var _defaultProps;
        var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps = item.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps[axisIdKey];
        return itemAxisId === axisId;
      }),
      dataStartIndex,
      dataEndIndex
    });
    var len = displayedData.length;
    var domain, duplicateDomain, categoricalDomain;
    if (isDomainSpecifiedByUser(childProps.domain, allowDataOverflow, type)) {
      domain = parseSpecifiedDomain(childProps.domain, null, allowDataOverflow);
      if (isCategorical && (type === "number" || scale2 !== "auto")) {
        categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
      }
    }
    var defaultDomain = getDefaultDomainByAxisType(type);
    if (!domain || domain.length === 0) {
      var _childProps$domain;
      var childDomain = (_childProps$domain = childProps.domain) !== null && _childProps$domain !== void 0 ? _childProps$domain : defaultDomain;
      if (dataKey) {
        domain = getDomainOfDataByKey(displayedData, dataKey, type);
        if (type === "category" && isCategorical) {
          var duplicate = hasDuplicate(domain);
          if (allowDuplicatedCategory && duplicate) {
            duplicateDomain = domain;
            domain = range2(0, len);
          } else if (!allowDuplicatedCategory) {
            domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
              return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
            }, []);
          }
        } else if (type === "category") {
          if (!allowDuplicatedCategory) {
            domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
              return finalDomain.indexOf(entry) >= 0 || entry === "" || isNil(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
            }, []);
          } else {
            domain = domain.filter(function(entry) {
              return entry !== "" && !isNil(entry);
            });
          }
        } else if (type === "number") {
          var errorBarsDomain = parseErrorBarsOfAxis(displayedData, graphicalItems.filter(function(item) {
            var _defaultProps2, _defaultProps3;
            var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps2 = item.type.defaultProps) === null || _defaultProps2 === void 0 ? void 0 : _defaultProps2[axisIdKey];
            var itemHide = "hide" in item.props ? item.props.hide : (_defaultProps3 = item.type.defaultProps) === null || _defaultProps3 === void 0 ? void 0 : _defaultProps3.hide;
            return itemAxisId === axisId && (includeHidden || !itemHide);
          }), dataKey, axisType, layout);
          if (errorBarsDomain) {
            domain = errorBarsDomain;
          }
        }
        if (isCategorical && (type === "number" || scale2 !== "auto")) {
          categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
        }
      } else if (isCategorical) {
        domain = range2(0, len);
      } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === "number") {
        domain = stackOffset === "expand" ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
      } else {
        domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
          var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : item.type.defaultProps[axisIdKey];
          var itemHide = "hide" in item.props ? item.props.hide : item.type.defaultProps.hide;
          return itemAxisId === axisId && (includeHidden || !itemHide);
        }), type, layout, true);
      }
      if (type === "number") {
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType, ticks2);
        if (childDomain) {
          domain = parseSpecifiedDomain(childDomain, domain, allowDataOverflow);
        }
      } else if (type === "category" && childDomain) {
        var axisDomain = childDomain;
        var isDomainValid = domain.every(function(entry) {
          return axisDomain.indexOf(entry) >= 0;
        });
        if (isDomainValid) {
          domain = axisDomain;
        }
      }
    }
    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, childProps), {}, {
      axisType,
      domain,
      categoricalDomain,
      duplicateDomain,
      originalDomain: (_childProps$domain2 = childProps.domain) !== null && _childProps$domain2 !== void 0 ? _childProps$domain2 : defaultDomain,
      isCategorical,
      layout
    })));
  }, {});
};
var getAxisMapByItems = function getAxisMapByItems2(props, _ref3) {
  var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;
  var layout = props.layout, children = props.children;
  var displayedData = getDisplayedData(props.data, {
    graphicalItems,
    dataStartIndex,
    dataEndIndex
  });
  var len = displayedData.length;
  var isCategorical = isCategoricalAxis(layout, axisType);
  var index2 = -1;
  return graphicalItems.reduce(function(result, child) {
    var childProps = child.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;
    var axisId = childProps[axisIdKey];
    var originalDomain = getDefaultDomainByAxisType("number");
    if (!result[axisId]) {
      index2++;
      var domain;
      if (isCategorical) {
        domain = range2(0, len);
      } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {
        domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
      } else {
        domain = parseSpecifiedDomain(originalDomain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
          var _defaultProps4, _defaultProps5;
          var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps4 = item.type.defaultProps) === null || _defaultProps4 === void 0 ? void 0 : _defaultProps4[axisIdKey];
          var itemHide = "hide" in item.props ? item.props.hide : (_defaultProps5 = item.type.defaultProps) === null || _defaultProps5 === void 0 ? void 0 : _defaultProps5.hide;
          return itemAxisId === axisId && !itemHide;
        }), "number", layout), Axis.defaultProps.allowDataOverflow);
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
      }
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({
        axisType
      }, Axis.defaultProps), {}, {
        hide: true,
        orientation: get(ORIENT_MAP, "".concat(axisType, ".").concat(index2 % 2), null),
        domain,
        originalDomain,
        isCategorical,
        layout
        // specify scale when no Axis
        // scale: isCategorical ? 'band' : 'linear',
      })));
    }
    return result;
  }, {});
};
var getAxisMap = function getAxisMap2(props, _ref4) {
  var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? "xAxis" : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;
  var children = props.children;
  var axisIdKey = "".concat(axisType, "Id");
  var axes = findAllByType(children, AxisComp);
  var axisMap = {};
  if (axes && axes.length) {
    axisMap = getAxisMapByAxes(props, {
      axes,
      graphicalItems,
      axisType,
      axisIdKey,
      stackGroups,
      dataStartIndex,
      dataEndIndex
    });
  } else if (graphicalItems && graphicalItems.length) {
    axisMap = getAxisMapByItems(props, {
      Axis: AxisComp,
      graphicalItems,
      axisType,
      axisIdKey,
      stackGroups,
      dataStartIndex,
      dataEndIndex
    });
  }
  return axisMap;
};
var tooltipTicksGenerator = function tooltipTicksGenerator2(axisMap) {
  var axis = getAnyElementOfObject(axisMap);
  var tooltipTicks = getTicksOfAxis(axis, false, true);
  return {
    tooltipTicks,
    orderedTooltipTicks: sortBy(tooltipTicks, function(o) {
      return o.coordinate;
    }),
    tooltipAxis: axis,
    tooltipAxisBandSize: getBandSizeOfAxis(axis, tooltipTicks)
  };
};
var createDefaultState = function createDefaultState2(props) {
  var children = props.children, defaultShowTooltip = props.defaultShowTooltip;
  var brushItem = findChildByType(children, Brush);
  var startIndex = 0;
  var endIndex = 0;
  if (props.data && props.data.length !== 0) {
    endIndex = props.data.length - 1;
  }
  if (brushItem && brushItem.props) {
    if (brushItem.props.startIndex >= 0) {
      startIndex = brushItem.props.startIndex;
    }
    if (brushItem.props.endIndex >= 0) {
      endIndex = brushItem.props.endIndex;
    }
  }
  return {
    chartX: 0,
    chartY: 0,
    dataStartIndex: startIndex,
    dataEndIndex: endIndex,
    activeTooltipIndex: -1,
    isTooltipActive: Boolean(defaultShowTooltip)
  };
};
var hasGraphicalBarItem = function hasGraphicalBarItem2(graphicalItems) {
  if (!graphicalItems || !graphicalItems.length) {
    return false;
  }
  return graphicalItems.some(function(item) {
    var name2 = getDisplayName(item && item.type);
    return name2 && name2.indexOf("Bar") >= 0;
  });
};
var getAxisNameByLayout = function getAxisNameByLayout2(layout) {
  if (layout === "horizontal") {
    return {
      numericAxisName: "yAxis",
      cateAxisName: "xAxis"
    };
  }
  if (layout === "vertical") {
    return {
      numericAxisName: "xAxis",
      cateAxisName: "yAxis"
    };
  }
  if (layout === "centric") {
    return {
      numericAxisName: "radiusAxis",
      cateAxisName: "angleAxis"
    };
  }
  return {
    numericAxisName: "angleAxis",
    cateAxisName: "radiusAxis"
  };
};
var calculateOffset = function calculateOffset2(_ref5, prevLegendBBox) {
  var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;
  var width = props.width, height = props.height, children = props.children;
  var margin = props.margin || {};
  var brushItem = findChildByType(children, Brush);
  var legendItem = findChildByType(children, Legend);
  var offsetH = Object.keys(yAxisMap).reduce(function(result, id) {
    var entry = yAxisMap[id];
    var orientation = entry.orientation;
    if (!entry.mirror && !entry.hide) {
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));
    }
    return result;
  }, {
    left: margin.left || 0,
    right: margin.right || 0
  });
  var offsetV = Object.keys(xAxisMap).reduce(function(result, id) {
    var entry = xAxisMap[id];
    var orientation = entry.orientation;
    if (!entry.mirror && !entry.hide) {
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, get(result, "".concat(orientation)) + entry.height));
    }
    return result;
  }, {
    top: margin.top || 0,
    bottom: margin.bottom || 0
  });
  var offset2 = _objectSpread(_objectSpread({}, offsetV), offsetH);
  var brushBottom = offset2.bottom;
  if (brushItem) {
    offset2.bottom += brushItem.props.height || Brush.defaultProps.height;
  }
  if (legendItem && prevLegendBBox) {
    offset2 = appendOffsetOfLegend(offset2, graphicalItems, props, prevLegendBBox);
  }
  var offsetWidth = width - offset2.left - offset2.right;
  var offsetHeight = height - offset2.top - offset2.bottom;
  return _objectSpread(_objectSpread({
    brushBottom
  }, offset2), {}, {
    // never return negative values for height and width
    width: Math.max(offsetWidth, 0),
    height: Math.max(offsetHeight, 0)
  });
};
var getCartesianAxisSize = function getCartesianAxisSize2(axisObj, axisName) {
  if (axisName === "xAxis") {
    return axisObj[axisName].width;
  }
  if (axisName === "yAxis") {
    return axisObj[axisName].height;
  }
  return void 0;
};
var generateCategoricalChart = function generateCategoricalChart2(_ref6) {
  var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? "axis" : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? ["axis"] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap3 = _ref6.formatAxisMap, defaultProps2 = _ref6.defaultProps;
  var getFormatItems = function getFormatItems2(props, currentState) {
    var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset2 = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;
    var barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize;
    var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;
    var hasBar = hasGraphicalBarItem(graphicalItems);
    var formattedItems = [];
    graphicalItems.forEach(function(item, index2) {
      var displayedData = getDisplayedData(props.data, {
        graphicalItems: [item],
        dataStartIndex,
        dataEndIndex
      });
      var itemProps = item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;
      var dataKey = itemProps.dataKey, childMaxBarSize = itemProps.maxBarSize;
      var numericAxisId = itemProps["".concat(numericAxisName, "Id")];
      var cateAxisId = itemProps["".concat(cateAxisName, "Id")];
      var axisObjInitialValue = {};
      var axisObj = axisComponents.reduce(function(result, entry) {
        var axisMap = currentState["".concat(entry.axisType, "Map")];
        var id = itemProps["".concat(entry.axisType, "Id")];
        !(axisMap && axisMap[id] || entry.axisType === "zAxis") ? invariant() : void 0;
        var axis = axisMap[id];
        return _objectSpread(_objectSpread({}, result), {}, _defineProperty(_defineProperty({}, entry.axisType, axis), "".concat(entry.axisType, "Ticks"), getTicksOfAxis(axis)));
      }, axisObjInitialValue);
      var cateAxis = axisObj[cateAxisName];
      var cateTicks = axisObj["".concat(cateAxisName, "Ticks")];
      var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);
      var itemIsBar = getDisplayName(item.type).indexOf("Bar") >= 0;
      var bandSize = getBandSizeOfAxis(cateAxis, cateTicks);
      var barPosition = [];
      var sizeList = hasBar && getBarSizeList({
        barSize,
        stackGroups,
        totalSize: getCartesianAxisSize(axisObj, cateAxisName)
      });
      if (itemIsBar) {
        var _ref7, _getBandSizeOfAxis;
        var maxBarSize = isNil(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
        var barBandSize = (_ref7 = (_getBandSizeOfAxis = getBandSizeOfAxis(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;
        barPosition = getBarPosition({
          barGap,
          barCategoryGap,
          bandSize: barBandSize !== bandSize ? barBandSize : bandSize,
          sizeList: sizeList[cateAxisId],
          maxBarSize
        });
        if (barBandSize !== bandSize) {
          barPosition = barPosition.map(function(pos) {
            return _objectSpread(_objectSpread({}, pos), {}, {
              position: _objectSpread(_objectSpread({}, pos.position), {}, {
                offset: pos.position.offset - barBandSize / 2
              })
            });
          });
        }
      }
      var composedFn = item && item.type && item.type.getComposedData;
      if (composedFn) {
        formattedItems.push({
          props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {
            displayedData,
            props,
            dataKey,
            item,
            bandSize,
            barPosition,
            offset: offset2,
            stackedData,
            layout,
            dataStartIndex,
            dataEndIndex
          }))), {}, _defineProperty(_defineProperty(_defineProperty({
            key: item.key || "item-".concat(index2)
          }, numericAxisName, axisObj[numericAxisName]), cateAxisName, axisObj[cateAxisName]), "animationId", updateId)),
          childIndex: parseChildIndex(item, props.children),
          item
        });
      }
    });
    return formattedItems;
  };
  var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups2(_ref8, prevState) {
    var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;
    if (!validateWidthHeight({
      props
    })) {
      return null;
    }
    var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder;
    var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;
    var graphicalItems = findAllByType(children, GraphicalChild);
    var stackGroups = getStackGroupsByAxisId(data, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder);
    var axisObj = axisComponents.reduce(function(result, entry) {
      var name2 = "".concat(entry.axisType, "Map");
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name2, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {
        graphicalItems,
        stackGroups: entry.axisType === numericAxisName && stackGroups,
        dataStartIndex,
        dataEndIndex
      }))));
    }, {});
    var offset2 = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {
      props,
      graphicalItems
    }), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);
    Object.keys(axisObj).forEach(function(key) {
      axisObj[key] = formatAxisMap3(props, axisObj[key], offset2, key.replace("Map", ""), chartName);
    });
    var cateAxisMap = axisObj["".concat(cateAxisName, "Map")];
    var ticksObj = tooltipTicksGenerator(cateAxisMap);
    var formattedGraphicalItems = getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {
      dataStartIndex,
      dataEndIndex,
      updateId,
      graphicalItems,
      stackGroups,
      offset: offset2
    }));
    return _objectSpread(_objectSpread({
      formattedGraphicalItems,
      graphicalItems,
      offset: offset2,
      stackGroups
    }, ticksObj), axisObj);
  };
  var CategoricalChartWrapper = /* @__PURE__ */ (function(_Component) {
    function CategoricalChartWrapper2(_props) {
      var _props$id, _props$throttleDelay;
      var _this;
      _classCallCheck(this, CategoricalChartWrapper2);
      _this = _callSuper(this, CategoricalChartWrapper2, [_props]);
      _defineProperty(_this, "eventEmitterSymbol", Symbol("rechartsEventEmitter"));
      _defineProperty(_this, "accessibilityManager", new AccessibilityManager());
      _defineProperty(_this, "handleLegendBBoxUpdate", function(box) {
        if (box) {
          var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;
          _this.setState(_objectSpread({
            legendBBox: box
          }, updateStateOfAxisMapsOffsetAndStackGroups({
            props: _this.props,
            dataStartIndex,
            dataEndIndex,
            updateId
          }, _objectSpread(_objectSpread({}, _this.state), {}, {
            legendBBox: box
          }))));
        }
      });
      _defineProperty(_this, "handleReceiveSyncEvent", function(cId, data, emitter) {
        if (_this.props.syncId === cId) {
          if (emitter === _this.eventEmitterSymbol && typeof _this.props.syncMethod !== "function") {
            return;
          }
          _this.applySyncEvent(data);
        }
      });
      _defineProperty(_this, "handleBrushChange", function(_ref9) {
        var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;
        if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
          var updateId = _this.state.updateId;
          _this.setState(function() {
            return _objectSpread({
              dataStartIndex: startIndex,
              dataEndIndex: endIndex
            }, updateStateOfAxisMapsOffsetAndStackGroups({
              props: _this.props,
              dataStartIndex: startIndex,
              dataEndIndex: endIndex,
              updateId
            }, _this.state));
          });
          _this.triggerSyncEvent({
            dataStartIndex: startIndex,
            dataEndIndex: endIndex
          });
        }
      });
      _defineProperty(_this, "handleMouseEnter", function(e) {
        var mouse = _this.getMouseInfo(e);
        if (mouse) {
          var _nextState = _objectSpread(_objectSpread({}, mouse), {}, {
            isTooltipActive: true
          });
          _this.setState(_nextState);
          _this.triggerSyncEvent(_nextState);
          var onMouseEnter = _this.props.onMouseEnter;
          if (isFunction$2(onMouseEnter)) {
            onMouseEnter(_nextState, e);
          }
        }
      });
      _defineProperty(_this, "triggeredAfterMouseMove", function(e) {
        var mouse = _this.getMouseInfo(e);
        var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, {
          isTooltipActive: true
        }) : {
          isTooltipActive: false
        };
        _this.setState(nextState);
        _this.triggerSyncEvent(nextState);
        var onMouseMove = _this.props.onMouseMove;
        if (isFunction$2(onMouseMove)) {
          onMouseMove(nextState, e);
        }
      });
      _defineProperty(_this, "handleItemMouseEnter", function(el) {
        _this.setState(function() {
          return {
            isTooltipActive: true,
            activeItem: el,
            activePayload: el.tooltipPayload,
            activeCoordinate: el.tooltipPosition || {
              x: el.cx,
              y: el.cy
            }
          };
        });
      });
      _defineProperty(_this, "handleItemMouseLeave", function() {
        _this.setState(function() {
          return {
            isTooltipActive: false
          };
        });
      });
      _defineProperty(_this, "handleMouseMove", function(e) {
        e.persist();
        _this.throttleTriggeredAfterMouseMove(e);
      });
      _defineProperty(_this, "handleMouseLeave", function(e) {
        _this.throttleTriggeredAfterMouseMove.cancel();
        var nextState = {
          isTooltipActive: false
        };
        _this.setState(nextState);
        _this.triggerSyncEvent(nextState);
        var onMouseLeave = _this.props.onMouseLeave;
        if (isFunction$2(onMouseLeave)) {
          onMouseLeave(nextState, e);
        }
      });
      _defineProperty(_this, "handleOuterEvent", function(e) {
        var eventName = getReactEventByType(e);
        var event = get(_this.props, "".concat(eventName));
        if (eventName && isFunction$2(event)) {
          var _mouse;
          var mouse;
          if (/.*touch.*/i.test(eventName)) {
            mouse = _this.getMouseInfo(e.changedTouches[0]);
          } else {
            mouse = _this.getMouseInfo(e);
          }
          event((_mouse = mouse) !== null && _mouse !== void 0 ? _mouse : {}, e);
        }
      });
      _defineProperty(_this, "handleClick", function(e) {
        var mouse = _this.getMouseInfo(e);
        if (mouse) {
          var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, {
            isTooltipActive: true
          });
          _this.setState(_nextState2);
          _this.triggerSyncEvent(_nextState2);
          var onClick = _this.props.onClick;
          if (isFunction$2(onClick)) {
            onClick(_nextState2, e);
          }
        }
      });
      _defineProperty(_this, "handleMouseDown", function(e) {
        var onMouseDown = _this.props.onMouseDown;
        if (isFunction$2(onMouseDown)) {
          var _nextState3 = _this.getMouseInfo(e);
          onMouseDown(_nextState3, e);
        }
      });
      _defineProperty(_this, "handleMouseUp", function(e) {
        var onMouseUp = _this.props.onMouseUp;
        if (isFunction$2(onMouseUp)) {
          var _nextState4 = _this.getMouseInfo(e);
          onMouseUp(_nextState4, e);
        }
      });
      _defineProperty(_this, "handleTouchMove", function(e) {
        if (e.changedTouches != null && e.changedTouches.length > 0) {
          _this.throttleTriggeredAfterMouseMove(e.changedTouches[0]);
        }
      });
      _defineProperty(_this, "handleTouchStart", function(e) {
        if (e.changedTouches != null && e.changedTouches.length > 0) {
          _this.handleMouseDown(e.changedTouches[0]);
        }
      });
      _defineProperty(_this, "handleTouchEnd", function(e) {
        if (e.changedTouches != null && e.changedTouches.length > 0) {
          _this.handleMouseUp(e.changedTouches[0]);
        }
      });
      _defineProperty(_this, "handleDoubleClick", function(e) {
        var onDoubleClick = _this.props.onDoubleClick;
        if (isFunction$2(onDoubleClick)) {
          var _nextState5 = _this.getMouseInfo(e);
          onDoubleClick(_nextState5, e);
        }
      });
      _defineProperty(_this, "handleContextMenu", function(e) {
        var onContextMenu = _this.props.onContextMenu;
        if (isFunction$2(onContextMenu)) {
          var _nextState6 = _this.getMouseInfo(e);
          onContextMenu(_nextState6, e);
        }
      });
      _defineProperty(_this, "triggerSyncEvent", function(data) {
        if (_this.props.syncId !== void 0) {
          eventCenter.emit(SYNC_EVENT, _this.props.syncId, data, _this.eventEmitterSymbol);
        }
      });
      _defineProperty(_this, "applySyncEvent", function(data) {
        var _this$props = _this.props, layout = _this$props.layout, syncMethod = _this$props.syncMethod;
        var updateId = _this.state.updateId;
        var dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;
        if (data.dataStartIndex !== void 0 || data.dataEndIndex !== void 0) {
          _this.setState(_objectSpread({
            dataStartIndex,
            dataEndIndex
          }, updateStateOfAxisMapsOffsetAndStackGroups({
            props: _this.props,
            dataStartIndex,
            dataEndIndex,
            updateId
          }, _this.state)));
        } else if (data.activeTooltipIndex !== void 0) {
          var chartX = data.chartX, chartY = data.chartY;
          var activeTooltipIndex = data.activeTooltipIndex;
          var _this$state2 = _this.state, offset2 = _this$state2.offset, tooltipTicks = _this$state2.tooltipTicks;
          if (!offset2) {
            return;
          }
          if (typeof syncMethod === "function") {
            activeTooltipIndex = syncMethod(tooltipTicks, data);
          } else if (syncMethod === "value") {
            activeTooltipIndex = -1;
            for (var i = 0; i < tooltipTicks.length; i++) {
              if (tooltipTicks[i].value === data.activeLabel) {
                activeTooltipIndex = i;
                break;
              }
            }
          }
          var viewBox = _objectSpread(_objectSpread({}, offset2), {}, {
            x: offset2.left,
            y: offset2.top
          });
          var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);
          var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);
          var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;
          var activePayload = getTooltipContent(_this.state, _this.props.data, activeTooltipIndex);
          var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
            x: layout === "horizontal" ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
            y: layout === "horizontal" ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
          } : originCoordinate;
          _this.setState(_objectSpread(_objectSpread({}, data), {}, {
            activeLabel,
            activeCoordinate,
            activePayload,
            activeTooltipIndex
          }));
        } else {
          _this.setState(data);
        }
      });
      _defineProperty(_this, "renderCursor", function(element) {
        var _element$props$active;
        var _this$state3 = _this.state, isTooltipActive = _this$state3.isTooltipActive, activeCoordinate = _this$state3.activeCoordinate, activePayload = _this$state3.activePayload, offset2 = _this$state3.offset, activeTooltipIndex = _this$state3.activeTooltipIndex, tooltipAxisBandSize = _this$state3.tooltipAxisBandSize;
        var tooltipEventType = _this.getTooltipEventType();
        var isActive = (_element$props$active = element.props.active) !== null && _element$props$active !== void 0 ? _element$props$active : isTooltipActive;
        var layout = _this.props.layout;
        var key = element.key || "_recharts-cursor";
        return /* @__PURE__ */ React.createElement(Cursor, {
          key,
          activeCoordinate,
          activePayload,
          activeTooltipIndex,
          chartName,
          element,
          isActive,
          layout,
          offset: offset2,
          tooltipAxisBandSize,
          tooltipEventType
        });
      });
      _defineProperty(_this, "renderPolarAxis", function(element, displayName, index2) {
        var axisType = get(element, "type.axisType");
        var axisMap = get(_this.state, "".concat(axisType, "Map"));
        var elementDefaultProps = element.type.defaultProps;
        var elementProps = elementDefaultProps !== void 0 ? _objectSpread(_objectSpread({}, elementDefaultProps), element.props) : element.props;
        var axisOption = axisMap && axisMap[elementProps["".concat(axisType, "Id")]];
        return /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({}, axisOption), {}, {
          className: clsx(axisType, axisOption.className),
          key: element.key || "".concat(displayName, "-").concat(index2),
          ticks: getTicksOfAxis(axisOption, true)
        }));
      });
      _defineProperty(_this, "renderPolarGrid", function(element) {
        var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;
        var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;
        var radiusAxis = getAnyElementOfObject(radiusAxisMap);
        var angleAxis = getAnyElementOfObject(angleAxisMap);
        var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          polarAngles: Array.isArray(polarAngles) ? polarAngles : getTicksOfAxis(angleAxis, true).map(function(entry) {
            return entry.coordinate;
          }),
          polarRadius: Array.isArray(polarRadius) ? polarRadius : getTicksOfAxis(radiusAxis, true).map(function(entry) {
            return entry.coordinate;
          }),
          cx,
          cy,
          innerRadius,
          outerRadius,
          key: element.key || "polar-grid",
          radialLines
        });
      });
      _defineProperty(_this, "renderLegend", function() {
        var formattedGraphicalItems = _this.state.formattedGraphicalItems;
        var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;
        var margin = _this.props.margin || {};
        var legendWidth = width - (margin.left || 0) - (margin.right || 0);
        var props = getLegendProps({
          children,
          formattedGraphicalItems,
          legendWidth,
          legendContent
        });
        if (!props) {
          return null;
        }
        var item = props.item, otherProps = _objectWithoutProperties(props, _excluded);
        return /* @__PURE__ */ reactExports.cloneElement(item, _objectSpread(_objectSpread({}, otherProps), {}, {
          chartWidth: width,
          chartHeight: height,
          margin,
          onBBoxUpdate: _this.handleLegendBBoxUpdate
        }));
      });
      _defineProperty(_this, "renderTooltip", function() {
        var _tooltipItem$props$ac;
        var _this$props3 = _this.props, children = _this$props3.children, accessibilityLayer = _this$props3.accessibilityLayer;
        var tooltipItem = findChildByType(children, Tooltip$1);
        if (!tooltipItem) {
          return null;
        }
        var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset2 = _this$state5.offset;
        var isActive = (_tooltipItem$props$ac = tooltipItem.props.active) !== null && _tooltipItem$props$ac !== void 0 ? _tooltipItem$props$ac : isTooltipActive;
        return /* @__PURE__ */ reactExports.cloneElement(tooltipItem, {
          viewBox: _objectSpread(_objectSpread({}, offset2), {}, {
            x: offset2.left,
            y: offset2.top
          }),
          active: isActive,
          label: activeLabel,
          payload: isActive ? activePayload : [],
          coordinate: activeCoordinate,
          accessibilityLayer
        });
      });
      _defineProperty(_this, "renderBrush", function(element) {
        var _this$props4 = _this.props, margin = _this$props4.margin, data = _this$props4.data;
        var _this$state6 = _this.state, offset2 = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "_recharts-brush",
          onChange: combineEventHandlers(_this.handleBrushChange, element.props.onChange),
          data,
          x: isNumber(element.props.x) ? element.props.x : offset2.left,
          y: isNumber(element.props.y) ? element.props.y : offset2.top + offset2.height + offset2.brushBottom - (margin.bottom || 0),
          width: isNumber(element.props.width) ? element.props.width : offset2.width,
          startIndex: dataStartIndex,
          endIndex: dataEndIndex,
          updateId: "brush-".concat(updateId)
        });
      });
      _defineProperty(_this, "renderReferenceElement", function(element, displayName, index2) {
        if (!element) {
          return null;
        }
        var _this2 = _this, clipPathId = _this2.clipPathId;
        var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset2 = _this$state7.offset;
        var elementDefaultProps = element.type.defaultProps || {};
        var _element$props2 = element.props, _element$props2$xAxis = _element$props2.xAxisId, xAxisId = _element$props2$xAxis === void 0 ? elementDefaultProps.xAxisId : _element$props2$xAxis, _element$props2$yAxis = _element$props2.yAxisId, yAxisId = _element$props2$yAxis === void 0 ? elementDefaultProps.yAxisId : _element$props2$yAxis;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "".concat(displayName, "-").concat(index2),
          xAxis: xAxisMap[xAxisId],
          yAxis: yAxisMap[yAxisId],
          viewBox: {
            x: offset2.left,
            y: offset2.top,
            width: offset2.width,
            height: offset2.height
          },
          clipPathId
        });
      });
      _defineProperty(_this, "renderActivePoints", function(_ref10) {
        var item = _ref10.item, activePoint = _ref10.activePoint, basePoint = _ref10.basePoint, childIndex = _ref10.childIndex, isRange = _ref10.isRange;
        var result = [];
        var key = item.props.key;
        var itemItemProps = item.item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;
        var activeDot = itemItemProps.activeDot, dataKey = itemItemProps.dataKey;
        var dotProps = _objectSpread(_objectSpread({
          index: childIndex,
          dataKey,
          cx: activePoint.x,
          cy: activePoint.y,
          r: 4,
          fill: getMainColorOfGraphicItem(item.item),
          strokeWidth: 2,
          stroke: "#fff",
          payload: activePoint.payload,
          value: activePoint.value
        }, filterProps(activeDot, false)), adaptEventHandlers(activeDot));
        result.push(CategoricalChartWrapper2.renderActiveDot(activeDot, dotProps, "".concat(key, "-activePoint-").concat(childIndex)));
        if (basePoint) {
          result.push(CategoricalChartWrapper2.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {
            cx: basePoint.x,
            cy: basePoint.y
          }), "".concat(key, "-basePoint-").concat(childIndex)));
        } else if (isRange) {
          result.push(null);
        }
        return result;
      });
      _defineProperty(_this, "renderGraphicChild", function(element, displayName, index2) {
        var item = _this.filterFormatItem(element, displayName, index2);
        if (!item) {
          return null;
        }
        var tooltipEventType = _this.getTooltipEventType();
        var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;
        var children = _this.props.children;
        var tooltipItem = findChildByType(children, Tooltip$1);
        var _item$props = item.props, points = _item$props.points, isRange = _item$props.isRange, baseLine = _item$props.baseLine;
        var itemItemProps = item.item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;
        var activeDot = itemItemProps.activeDot, hide = itemItemProps.hide, activeBar = itemItemProps.activeBar, activeShape = itemItemProps.activeShape;
        var hasActive = Boolean(!hide && isTooltipActive && tooltipItem && (activeDot || activeBar || activeShape));
        var itemEvents = {};
        if (tooltipEventType !== "axis" && tooltipItem && tooltipItem.props.trigger === "click") {
          itemEvents = {
            onClick: combineEventHandlers(_this.handleItemMouseEnter, element.props.onClick)
          };
        } else if (tooltipEventType !== "axis") {
          itemEvents = {
            onMouseLeave: combineEventHandlers(_this.handleItemMouseLeave, element.props.onMouseLeave),
            onMouseEnter: combineEventHandlers(_this.handleItemMouseEnter, element.props.onMouseEnter)
          };
        }
        var graphicalItem = /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({}, item.props), itemEvents));
        function findWithPayload(entry) {
          return typeof tooltipAxis.dataKey === "function" ? tooltipAxis.dataKey(entry.payload) : null;
        }
        if (hasActive) {
          if (activeTooltipIndex >= 0) {
            var activePoint, basePoint;
            if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
              var specifiedKey = typeof tooltipAxis.dataKey === "function" ? findWithPayload : "payload.".concat(tooltipAxis.dataKey.toString());
              activePoint = findEntryInArray(points, specifiedKey, activeLabel);
              basePoint = isRange && baseLine && findEntryInArray(baseLine, specifiedKey, activeLabel);
            } else {
              activePoint = points === null || points === void 0 ? void 0 : points[activeTooltipIndex];
              basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
            }
            if (activeShape || activeBar) {
              var activeIndex = element.props.activeIndex !== void 0 ? element.props.activeIndex : activeTooltipIndex;
              return [/* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {
                activeIndex
              })), null, null];
            }
            if (!isNil(activePoint)) {
              return [graphicalItem].concat(_toConsumableArray(_this.renderActivePoints({
                item,
                activePoint,
                basePoint,
                childIndex: activeTooltipIndex,
                isRange
              })));
            }
          } else {
            var _this$getItemByXY;
            var _ref11 = (_this$getItemByXY = _this.getItemByXY(_this.state.activeCoordinate)) !== null && _this$getItemByXY !== void 0 ? _this$getItemByXY : {
              graphicalItem
            }, _ref11$graphicalItem = _ref11.graphicalItem, _ref11$graphicalItem$ = _ref11$graphicalItem.item, xyItem = _ref11$graphicalItem$ === void 0 ? element : _ref11$graphicalItem$, childIndex = _ref11$graphicalItem.childIndex;
            var elementProps = _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {
              activeIndex: childIndex
            });
            return [/* @__PURE__ */ reactExports.cloneElement(xyItem, elementProps), null, null];
          }
        }
        if (isRange) {
          return [graphicalItem, null, null];
        }
        return [graphicalItem, null];
      });
      _defineProperty(_this, "renderCustomized", function(element, displayName, index2) {
        return /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({
          key: "recharts-customized-".concat(index2)
        }, _this.props), _this.state));
      });
      _defineProperty(_this, "renderMap", {
        CartesianGrid: {
          handler: renderAsIs,
          once: true
        },
        ReferenceArea: {
          handler: _this.renderReferenceElement
        },
        ReferenceLine: {
          handler: renderAsIs
        },
        ReferenceDot: {
          handler: _this.renderReferenceElement
        },
        XAxis: {
          handler: renderAsIs
        },
        YAxis: {
          handler: renderAsIs
        },
        Brush: {
          handler: _this.renderBrush,
          once: true
        },
        Bar: {
          handler: _this.renderGraphicChild
        },
        Line: {
          handler: _this.renderGraphicChild
        },
        Area: {
          handler: _this.renderGraphicChild
        },
        Radar: {
          handler: _this.renderGraphicChild
        },
        RadialBar: {
          handler: _this.renderGraphicChild
        },
        Scatter: {
          handler: _this.renderGraphicChild
        },
        Pie: {
          handler: _this.renderGraphicChild
        },
        Funnel: {
          handler: _this.renderGraphicChild
        },
        Tooltip: {
          handler: _this.renderCursor,
          once: true
        },
        PolarGrid: {
          handler: _this.renderPolarGrid,
          once: true
        },
        PolarAngleAxis: {
          handler: _this.renderPolarAxis
        },
        PolarRadiusAxis: {
          handler: _this.renderPolarAxis
        },
        Customized: {
          handler: _this.renderCustomized
        }
      });
      _this.clipPathId = "".concat((_props$id = _props.id) !== null && _props$id !== void 0 ? _props$id : uniqueId("recharts"), "-clip");
      _this.throttleTriggeredAfterMouseMove = throttle(_this.triggeredAfterMouseMove, (_props$throttleDelay = _props.throttleDelay) !== null && _props$throttleDelay !== void 0 ? _props$throttleDelay : 1e3 / 60);
      _this.state = {};
      return _this;
    }
    _inherits(CategoricalChartWrapper2, _Component);
    return _createClass(CategoricalChartWrapper2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props$margin$le, _this$props$margin$to;
        this.addListener();
        this.accessibilityManager.setDetails({
          container: this.container,
          offset: {
            left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,
            top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0
          },
          coordinateList: this.state.tooltipTicks,
          mouseHandlerCallback: this.triggeredAfterMouseMove,
          layout: this.props.layout
        });
        this.displayDefaultTooltip();
      }
    }, {
      key: "displayDefaultTooltip",
      value: function displayDefaultTooltip() {
        var _this$props5 = this.props, children = _this$props5.children, data = _this$props5.data, height = _this$props5.height, layout = _this$props5.layout;
        var tooltipElem = findChildByType(children, Tooltip$1);
        if (!tooltipElem) {
          return;
        }
        var defaultIndex = tooltipElem.props.defaultIndex;
        if (typeof defaultIndex !== "number" || defaultIndex < 0 || defaultIndex > this.state.tooltipTicks.length - 1) {
          return;
        }
        var activeLabel = this.state.tooltipTicks[defaultIndex] && this.state.tooltipTicks[defaultIndex].value;
        var activePayload = getTooltipContent(this.state, data, defaultIndex, activeLabel);
        var independentAxisCoord = this.state.tooltipTicks[defaultIndex].coordinate;
        var dependentAxisCoord = (this.state.offset.top + height) / 2;
        var isHorizontal = layout === "horizontal";
        var activeCoordinate = isHorizontal ? {
          x: independentAxisCoord,
          y: dependentAxisCoord
        } : {
          y: independentAxisCoord,
          x: dependentAxisCoord
        };
        var scatterPlotElement = this.state.formattedGraphicalItems.find(function(_ref12) {
          var item = _ref12.item;
          return item.type.name === "Scatter";
        });
        if (scatterPlotElement) {
          activeCoordinate = _objectSpread(_objectSpread({}, activeCoordinate), scatterPlotElement.props.points[defaultIndex].tooltipPosition);
          activePayload = scatterPlotElement.props.points[defaultIndex].tooltipPayload;
        }
        var nextState = {
          activeTooltipIndex: defaultIndex,
          isTooltipActive: true,
          activeLabel,
          activePayload,
          activeCoordinate
        };
        this.setState(nextState);
        this.renderCursor(tooltipElem);
        this.accessibilityManager.setIndex(defaultIndex);
      }
    }, {
      key: "getSnapshotBeforeUpdate",
      value: function getSnapshotBeforeUpdate(prevProps, prevState) {
        if (!this.props.accessibilityLayer) {
          return null;
        }
        if (this.state.tooltipTicks !== prevState.tooltipTicks) {
          this.accessibilityManager.setDetails({
            coordinateList: this.state.tooltipTicks
          });
        }
        if (this.props.layout !== prevProps.layout) {
          this.accessibilityManager.setDetails({
            layout: this.props.layout
          });
        }
        if (this.props.margin !== prevProps.margin) {
          var _this$props$margin$le2, _this$props$margin$to2;
          this.accessibilityManager.setDetails({
            offset: {
              left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,
              top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0
            }
          });
        }
        return null;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (!isChildrenEqual([findChildByType(prevProps.children, Tooltip$1)], [findChildByType(this.props.children, Tooltip$1)])) {
          this.displayDefaultTooltip();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.removeListener();
        this.throttleTriggeredAfterMouseMove.cancel();
      }
    }, {
      key: "getTooltipEventType",
      value: function getTooltipEventType() {
        var tooltipItem = findChildByType(this.props.children, Tooltip$1);
        if (tooltipItem && typeof tooltipItem.props.shared === "boolean") {
          var eventType = tooltipItem.props.shared ? "axis" : "item";
          return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;
        }
        return defaultTooltipEventType;
      }
      /**
       * Get the information of mouse in chart, return null when the mouse is not in the chart
       * @param  {MousePointer} event    The event object
       * @return {Object}          Mouse data
       */
    }, {
      key: "getMouseInfo",
      value: function getMouseInfo(event) {
        if (!this.container) {
          return null;
        }
        var element = this.container;
        var boundingRect = element.getBoundingClientRect();
        var containerOffset = getOffset(boundingRect);
        var e = {
          chartX: Math.round(event.pageX - containerOffset.left),
          chartY: Math.round(event.pageY - containerOffset.top)
        };
        var scale2 = boundingRect.width / element.offsetWidth || 1;
        var rangeObj = this.inRange(e.chartX, e.chartY, scale2);
        if (!rangeObj) {
          return null;
        }
        var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;
        var tooltipEventType = this.getTooltipEventType();
        var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);
        if (tooltipEventType !== "axis" && xAxisMap && yAxisMap) {
          var xScale = getAnyElementOfObject(xAxisMap).scale;
          var yScale = getAnyElementOfObject(yAxisMap).scale;
          var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;
          var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;
          return _objectSpread(_objectSpread({}, e), {}, {
            xValue,
            yValue
          }, toolTipData);
        }
        if (toolTipData) {
          return _objectSpread(_objectSpread({}, e), toolTipData);
        }
        return null;
      }
    }, {
      key: "inRange",
      value: function inRange(x2, y2) {
        var scale2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var layout = this.props.layout;
        var scaledX = x2 / scale2, scaledY = y2 / scale2;
        if (layout === "horizontal" || layout === "vertical") {
          var offset2 = this.state.offset;
          var isInRange = scaledX >= offset2.left && scaledX <= offset2.left + offset2.width && scaledY >= offset2.top && scaledY <= offset2.top + offset2.height;
          return isInRange ? {
            x: scaledX,
            y: scaledY
          } : null;
        }
        var _this$state10 = this.state, angleAxisMap = _this$state10.angleAxisMap, radiusAxisMap = _this$state10.radiusAxisMap;
        if (angleAxisMap && radiusAxisMap) {
          var angleAxis = getAnyElementOfObject(angleAxisMap);
          return inRangeOfSector({
            x: scaledX,
            y: scaledY
          }, angleAxis);
        }
        return null;
      }
    }, {
      key: "parseEventsOfWrapper",
      value: function parseEventsOfWrapper() {
        var children = this.props.children;
        var tooltipEventType = this.getTooltipEventType();
        var tooltipItem = findChildByType(children, Tooltip$1);
        var tooltipEvents = {};
        if (tooltipItem && tooltipEventType === "axis") {
          if (tooltipItem.props.trigger === "click") {
            tooltipEvents = {
              onClick: this.handleClick
            };
          } else {
            tooltipEvents = {
              onMouseEnter: this.handleMouseEnter,
              onDoubleClick: this.handleDoubleClick,
              onMouseMove: this.handleMouseMove,
              onMouseLeave: this.handleMouseLeave,
              onTouchMove: this.handleTouchMove,
              onTouchStart: this.handleTouchStart,
              onTouchEnd: this.handleTouchEnd,
              onContextMenu: this.handleContextMenu
            };
          }
        }
        var outerEvents = adaptEventHandlers(this.props, this.handleOuterEvent);
        return _objectSpread(_objectSpread({}, outerEvents), tooltipEvents);
      }
    }, {
      key: "addListener",
      value: function addListener() {
        eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);
      }
    }, {
      key: "removeListener",
      value: function removeListener() {
        eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);
      }
    }, {
      key: "filterFormatItem",
      value: function filterFormatItem(item, displayName, childIndex) {
        var formattedGraphicalItems = this.state.formattedGraphicalItems;
        for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
          var entry = formattedGraphicalItems[i];
          if (entry.item === item || entry.props.key === item.key || displayName === getDisplayName(entry.item.type) && childIndex === entry.childIndex) {
            return entry;
          }
        }
        return null;
      }
    }, {
      key: "renderClipPath",
      value: function renderClipPath() {
        var clipPathId = this.clipPathId;
        var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;
        return /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
          id: clipPathId
        }, /* @__PURE__ */ React.createElement("rect", {
          x: left,
          y: top,
          height,
          width
        })));
      }
    }, {
      key: "getXScales",
      value: function getXScales() {
        var xAxisMap = this.state.xAxisMap;
        return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {
          var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];
          return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
        }, {}) : null;
      }
    }, {
      key: "getYScales",
      value: function getYScales() {
        var yAxisMap = this.state.yAxisMap;
        return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {
          var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];
          return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
        }, {}) : null;
      }
    }, {
      key: "getXScaleByAxisId",
      value: function getXScaleByAxisId(axisId) {
        var _this$state$xAxisMap;
        return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap === void 0 ? void 0 : _this$state$xAxisMap.scale;
      }
    }, {
      key: "getYScaleByAxisId",
      value: function getYScaleByAxisId(axisId) {
        var _this$state$yAxisMap;
        return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap === void 0 ? void 0 : _this$state$yAxisMap.scale;
      }
    }, {
      key: "getItemByXY",
      value: function getItemByXY(chartXY) {
        var _this$state11 = this.state, formattedGraphicalItems = _this$state11.formattedGraphicalItems, activeItem = _this$state11.activeItem;
        if (formattedGraphicalItems && formattedGraphicalItems.length) {
          for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
            var graphicalItem = formattedGraphicalItems[i];
            var props = graphicalItem.props, item = graphicalItem.item;
            var itemProps = item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;
            var itemDisplayName = getDisplayName(item.type);
            if (itemDisplayName === "Bar") {
              var activeBarItem = (props.data || []).find(function(entry) {
                return isInRectangle(chartXY, entry);
              });
              if (activeBarItem) {
                return {
                  graphicalItem,
                  payload: activeBarItem
                };
              }
            } else if (itemDisplayName === "RadialBar") {
              var _activeBarItem = (props.data || []).find(function(entry) {
                return inRangeOfSector(chartXY, entry);
              });
              if (_activeBarItem) {
                return {
                  graphicalItem,
                  payload: _activeBarItem
                };
              }
            } else if (isFunnel(graphicalItem, activeItem) || isPie(graphicalItem, activeItem) || isScatter(graphicalItem, activeItem)) {
              var activeIndex = getActiveShapeIndexForTooltip({
                graphicalItem,
                activeTooltipItem: activeItem,
                itemData: itemProps.data
              });
              var childIndex = itemProps.activeIndex === void 0 ? activeIndex : itemProps.activeIndex;
              return {
                graphicalItem: _objectSpread(_objectSpread({}, graphicalItem), {}, {
                  childIndex
                }),
                payload: isScatter(graphicalItem, activeItem) ? itemProps.data[activeIndex] : graphicalItem.props.data[activeIndex]
              };
            }
          }
        }
        return null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;
        if (!validateWidthHeight(this)) {
          return null;
        }
        var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc, others = _objectWithoutProperties(_this$props6, _excluded2);
        var attrs = filterProps(others, false);
        if (compact) {
          return /* @__PURE__ */ React.createElement(ChartLayoutContextProvider, {
            state: this.state,
            width: this.props.width,
            height: this.props.height,
            clipPathId: this.clipPathId
          }, /* @__PURE__ */ React.createElement(Surface, _extends({}, attrs, {
            width,
            height,
            title,
            desc
          }), this.renderClipPath(), renderByOrder(children, this.renderMap)));
        }
        if (this.props.accessibilityLayer) {
          var _this$props$tabIndex, _this$props$role;
          attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;
          attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : "application";
          attrs.onKeyDown = function(e) {
            _this3.accessibilityManager.keyboardEvent(e);
          };
          attrs.onFocus = function() {
            _this3.accessibilityManager.focus();
          };
        }
        var events = this.parseEventsOfWrapper();
        return /* @__PURE__ */ React.createElement(ChartLayoutContextProvider, {
          state: this.state,
          width: this.props.width,
          height: this.props.height,
          clipPathId: this.clipPathId
        }, /* @__PURE__ */ React.createElement("div", _extends({
          className: clsx("recharts-wrapper", className),
          style: _objectSpread({
            position: "relative",
            cursor: "default",
            width,
            height
          }, style)
        }, events, {
          ref: function ref(node) {
            _this3.container = node;
          }
        }), /* @__PURE__ */ React.createElement(Surface, _extends({}, attrs, {
          width,
          height,
          title,
          desc,
          style: FULL_WIDTH_AND_HEIGHT
        }), this.renderClipPath(), renderByOrder(children, this.renderMap)), this.renderLegend(), this.renderTooltip()));
      }
    }]);
  })(reactExports.Component);
  _defineProperty(CategoricalChartWrapper, "displayName", chartName);
  _defineProperty(CategoricalChartWrapper, "defaultProps", _objectSpread({
    layout: "horizontal",
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    reverseStackOrder: false,
    syncMethod: "index"
  }, defaultProps2));
  _defineProperty(CategoricalChartWrapper, "getDerivedStateFromProps", function(nextProps, prevState) {
    var dataKey = nextProps.dataKey, data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;
    var dataStartIndex = prevState.dataStartIndex, dataEndIndex = prevState.dataEndIndex;
    if (prevState.updateId === void 0) {
      var defaultState = createDefaultState(nextProps);
      return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {
        updateId: 0
      }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
        props: nextProps
      }, defaultState), {}, {
        updateId: 0
      }), prevState)), {}, {
        prevDataKey: dataKey,
        prevData: data,
        prevWidth: width,
        prevHeight: height,
        prevLayout: layout,
        prevStackOffset: stackOffset,
        prevMargin: margin,
        prevChildren: children
      });
    }
    if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !shallowEqual(margin, prevState.prevMargin)) {
      var _defaultState = createDefaultState(nextProps);
      var keepFromPrevState = {
        // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid
        // any flickering
        chartX: prevState.chartX,
        chartY: prevState.chartY,
        // The tooltip should stay active when it was active in the previous render. If this is not
        // the case, the tooltip disappears and immediately re-appears, causing a flickering effect
        isTooltipActive: prevState.isTooltipActive
      };
      var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, {
        updateId: prevState.updateId + 1
      });
      var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);
      return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({
        props: nextProps
      }, newState), prevState)), {}, {
        prevDataKey: dataKey,
        prevData: data,
        prevWidth: width,
        prevHeight: height,
        prevLayout: layout,
        prevStackOffset: stackOffset,
        prevMargin: margin,
        prevChildren: children
      });
    }
    if (!isChildrenEqual(children, prevState.prevChildren)) {
      var _brush$props$startInd, _brush$props, _brush$props$endIndex, _brush$props2;
      var brush = findChildByType(children, Brush);
      var startIndex = brush ? (_brush$props$startInd = (_brush$props = brush.props) === null || _brush$props === void 0 ? void 0 : _brush$props.startIndex) !== null && _brush$props$startInd !== void 0 ? _brush$props$startInd : dataStartIndex : dataStartIndex;
      var endIndex = brush ? (_brush$props$endIndex = (_brush$props2 = brush.props) === null || _brush$props2 === void 0 ? void 0 : _brush$props2.endIndex) !== null && _brush$props$endIndex !== void 0 ? _brush$props$endIndex : dataEndIndex : dataEndIndex;
      var hasDifferentStartOrEndIndex = startIndex !== dataStartIndex || endIndex !== dataEndIndex;
      var hasGlobalData = !isNil(data);
      var newUpdateId = hasGlobalData && !hasDifferentStartOrEndIndex ? prevState.updateId : prevState.updateId + 1;
      return _objectSpread(_objectSpread({
        updateId: newUpdateId
      }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
        props: nextProps
      }, prevState), {}, {
        updateId: newUpdateId,
        dataStartIndex: startIndex,
        dataEndIndex: endIndex
      }), prevState)), {}, {
        prevChildren: children,
        dataStartIndex: startIndex,
        dataEndIndex: endIndex
      });
    }
    return null;
  });
  _defineProperty(CategoricalChartWrapper, "renderActiveDot", function(option, props, key) {
    var dot2;
    if (/* @__PURE__ */ reactExports.isValidElement(option)) {
      dot2 = /* @__PURE__ */ reactExports.cloneElement(option, props);
    } else if (isFunction$2(option)) {
      dot2 = option(props);
    } else {
      dot2 = /* @__PURE__ */ React.createElement(Dot, props);
    }
    return /* @__PURE__ */ React.createElement(Layer$1, {
      className: "recharts-active-dot",
      key
    }, dot2);
  });
  var CategoricalChart = /* @__PURE__ */ reactExports.forwardRef(function CategoricalChart2(props, ref) {
    return /* @__PURE__ */ React.createElement(CategoricalChartWrapper, _extends({}, props, {
      ref
    }));
  });
  CategoricalChart.displayName = CategoricalChartWrapper.displayName;
  return CategoricalChart;
};
var LineChart = generateCategoricalChart({
  chartName: "LineChart",
  GraphicalChild: Line,
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: XAxis
  }, {
    axisType: "yAxis",
    AxisComp: YAxis
  }],
  formatAxisMap
});
var BarChart$1 = generateCategoricalChart({
  chartName: "BarChart",
  GraphicalChild: Bar,
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: ["axis", "item"],
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: XAxis
  }, {
    axisType: "yAxis",
    AxisComp: YAxis
  }],
  formatAxisMap
});
const THEMES = { light: "", dark: ".dark" };
const ChartContext = reactExports.createContext(null);
function useChart() {
  const context = reactExports.useContext(ChartContext);
  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />");
  }
  return context;
}
const ChartContainer = reactExports.forwardRef(({ id, className, children, config: config2, ...props }, ref) => {
  const uniqueId3 = reactExports.useId();
  const chartId = `chart-${id || uniqueId3.replace(/:/g, "")}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartContext.Provider, { value: { config: config2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      "data-chart": chartId,
      ref,
      className: cn(
        "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ChartStyle, { id: chartId, config: config2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { children })
      ]
    }
  ) });
});
ChartContainer.displayName = "Chart";
const ChartStyle = ({ id, config: config2 }) => {
  const colorConfig = Object.entries(config2).filter(([_, config22]) => config22.theme || config22.color);
  if (!colorConfig.length) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "style",
    {
      dangerouslySetInnerHTML: {
        __html: Object.entries(THEMES).map(
          ([theme, prefix2]) => `
${prefix2} [data-chart=${id}] {
${colorConfig.map(([key, itemConfig]) => {
            const color2 = itemConfig.theme?.[theme] || itemConfig.color;
            return color2 ? `  --color-${key}: ${color2};` : null;
          }).join("\n")}
}
`
        ).join("\n")
      }
    }
  );
};
const ChartTooltip = Tooltip$1;
const ChartTooltipContent = reactExports.forwardRef(
  ({
    active,
    payload,
    className,
    indicator = "dot",
    hideLabel = false,
    hideIndicator = false,
    label,
    labelFormatter,
    labelClassName,
    formatter,
    color: color2,
    nameKey,
    labelKey
  }, ref) => {
    const { config: config2 } = useChart();
    const tooltipLabel = reactExports.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }
      const [item] = payload;
      const key = `${labelKey || item.dataKey || item.name || "value"}`;
      const itemConfig = getPayloadConfigFromPayload(config2, item, key);
      const value = !labelKey && typeof label === "string" ? config2[label]?.label || label : itemConfig?.label;
      if (labelFormatter) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("font-medium", labelClassName), children: labelFormatter(value, payload) });
      }
      if (!value) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("font-medium", labelClassName), children: value });
    }, [label, labelFormatter, payload, hideLabel, labelClassName, config2, labelKey]);
    if (!active || !payload?.length) {
      return null;
    }
    const nestLabel = payload.length === 1 && indicator !== "dot";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref,
        className: cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        ),
        children: [
          !nestLabel ? tooltipLabel : null,
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid gap-1.5", children: payload.map((item, index2) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config2, item, key);
            const indicatorColor = color2 || item.payload.fill || item.color;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                ),
                children: formatter && item?.value !== void 0 && item.name ? formatter(item.value, item.name, item, index2, item.payload) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  itemConfig?.icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(itemConfig.icon, {}) : !hideIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: cn(
                        "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                        {
                          "h-2.5 w-2.5": indicator === "dot",
                          "w-1": indicator === "line",
                          "w-0 border-[1.5px] border-dashed bg-transparent": indicator === "dashed",
                          "my-0.5": nestLabel && indicator === "dashed"
                        }
                      ),
                      style: {
                        "--color-bg": indicatorColor,
                        "--color-border": indicatorColor
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      className: cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      ),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-1.5", children: [
                          nestLabel ? tooltipLabel : null,
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: itemConfig?.label || item.name })
                        ] }),
                        item.value && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-mono font-medium tabular-nums text-foreground", children: item.value.toLocaleString() })
                      ]
                    }
                  )
                ] })
              },
              item.dataKey
            );
          }) })
        ]
      }
    );
  }
);
ChartTooltipContent.displayName = "ChartTooltip";
const ChartLegendContent = reactExports.forwardRef(({ className, hideIcon = false, payload, verticalAlign = "bottom", nameKey }, ref) => {
  const { config: config2 } = useChart();
  if (!payload?.length) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      ),
      children: payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`;
        const itemConfig = getPayloadConfigFromPayload(config2, item, key);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: cn(
              "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
            ),
            children: [
              itemConfig?.icon && !hideIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(itemConfig.icon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "h-2 w-2 shrink-0 rounded-[2px]",
                  style: {
                    backgroundColor: item.color
                  }
                }
              ),
              itemConfig?.label
            ]
          },
          item.value
        );
      })
    }
  );
});
ChartLegendContent.displayName = "ChartLegend";
function getPayloadConfigFromPayload(config2, payload, key) {
  if (typeof payload !== "object" || payload === null) {
    return void 0;
  }
  const payloadPayload = "payload" in payload && typeof payload.payload === "object" && payload.payload !== null ? payload.payload : void 0;
  let configLabelKey = key;
  if (key in payload && typeof payload[key] === "string") {
    configLabelKey = payload[key];
  } else if (payloadPayload && key in payloadPayload && typeof payloadPayload[key] === "string") {
    configLabelKey = payloadPayload[key];
  }
  return configLabelKey in config2 ? config2[configLabelKey] : config2[key];
}
const Table = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("table", { ref, className: cn("w-full caption-bottom text-sm", className), ...props }) })
);
Table.displayName = "Table";
const TableHeader = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { ref, className: cn("[&_tr]:border-b", className), ...props })
);
TableHeader.displayName = "TableHeader";
const TableBody = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { ref, className: cn("[&_tr:last-child]:border-0", className), ...props })
);
TableBody.displayName = "TableBody";
const TableFooter = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "tfoot",
    {
      ref,
      className: cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className),
      ...props
    }
  )
);
TableFooter.displayName = "TableFooter";
const TableRow = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "tr",
    {
      ref,
      className: cn("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className),
      ...props
    }
  )
);
TableRow.displayName = "TableRow";
const TableHead = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "th",
    {
      ref,
      className: cn(
        "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
        className
      ),
      ...props
    }
  )
);
TableHead.displayName = "TableHead";
const TableCell = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("td", { ref, className: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className), ...props })
);
TableCell.displayName = "TableCell";
const TableCaption = reactExports.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("caption", { ref, className: cn("mt-4 text-sm text-muted-foreground", className), ...props })
);
TableCaption.displayName = "TableCaption";
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: TABS_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId$1(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$2 = "TabsTrigger";
var TabsTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME$2, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$2;
var CONTENT_NAME$1 = "TabsContent";
var TabsContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME$1, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
    reactExports.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$1;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2$1 = Tabs$1;
var List = TabsList$1;
var Trigger$1 = TabsTrigger$1;
var Content = TabsContent$1;
const Tabs = Root2$1;
const TabsList = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  List,
  {
    ref,
    className: cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    ),
    ...props
  }
));
TabsList.displayName = List.displayName;
const TabsTrigger = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Trigger$1,
  {
    ref,
    className: cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    ),
    ...props
  }
));
TabsTrigger.displayName = Trigger$1.displayName;
const TabsContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content,
  {
    ref,
    className: cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    ),
    ...props
  }
));
TabsContent.displayName = Content.displayName;
const revenueColor = "hsl(142, 69%, 58%)";
const expenseColor = "hsl(0, 84%, 60%)";
const balanceColor = "hsl(221, 83%, 53%)";
const chartConfig = {
  revenue: {
    label: "Revenue",
    color: revenueColor
  },
  expenses: {
    label: "Expenses",
    color: expenseColor
  },
  balance: {
    label: "Balance",
    color: balanceColor
  },
  trainOperational: {
    label: "Train Operations",
    color: "hsl(25, 95%, 53%)"
    // Orange
  },
  trainPurchase: {
    label: "Train Purchases",
    color: "hsl(45, 93%, 47%)"
    // Gold
  },
  construction: {
    label: "Construction",
    color: "hsl(280, 61%, 50%)"
    // Purple
  },
  other: {
    label: "Other",
    color: "hsl(200, 70%, 50%)"
    // Light Blue
  }
};
function FinancialDashboard({ open, onOpenChange }) {
  const { t } = useTranslation("game");
  const money = useMoney();
  const financialHistory = useFinancialHistory();
  const transitCost = useTransitCost();
  const setTransitCost = useMainStore((state) => state.setTransitCost);
  const gameMode = useMainStore((state) => state.gameMode);
  const [timeFrame, setTimeFrame] = reactExports.useState("hourly");
  const LABEL_MAP = {
    revenue: " " + t("financialDashboard.totalRevenue"),
    expenses: " " + t("financialDashboard.totalExpenses"),
    balance: " " + t("financialDashboard.currentBalance"),
    profit: " " + t("financialDashboard.operationalProfit"),
    trainOperational: " " + t("financialDashboard.trainOperations"),
    trainPurchase: " " + t("financialDashboard.trainPurchases"),
    construction: " " + t("financialDashboard.construction"),
    other: " " + t("financialDashboard.other")
  };
  const processedData = reactExports.useMemo(() => {
    const entries = [...financialHistory.entries];
    if (financialHistory.currentHourRevenue > 0 || financialHistory.currentHourExpenses > 0) {
      entries.push({
        timestamp: financialHistory.lastHourTimestamp + 3600,
        balance: money,
        hourlyRevenue: financialHistory.currentHourRevenue,
        hourlyExpenses: financialHistory.currentHourExpenses,
        expenseCategories: financialHistory.currentHourExpenseCategories || {
          trainOperational: 0,
          trainPurchase: 0,
          construction: 0,
          other: 0
        }
      });
    }
    if (timeFrame === "hourly") {
      return entries.slice(-24).map((entry) => {
        const time2 = formatClockTime(entry.timestamp);
        const operationalExpenses = (entry.expenseCategories?.trainOperational || 0) + (entry.expenseCategories?.other || 0);
        return {
          time: `${time2.hours}:${time2.minutes}`,
          revenue: entry.hourlyRevenue,
          expenses: operationalExpenses,
          totalExpenses: entry.hourlyExpenses,
          balance: entry.balance,
          profit: entry.hourlyRevenue - operationalExpenses,
          trainOperational: entry.expenseCategories?.trainOperational || 0,
          trainPurchase: entry.expenseCategories?.trainPurchase || 0,
          construction: entry.expenseCategories?.construction || 0,
          other: entry.expenseCategories?.other || 0
        };
      });
    } else {
      const dayInSeconds = 24 * 3600;
      const startTimestamp = entries[0]?.timestamp || 0;
      const dailyData = /* @__PURE__ */ new Map();
      entries.forEach((entry) => {
        const dayNumber = Math.floor((entry.timestamp - startTimestamp) / dayInSeconds) + 1;
        const existing = dailyData.get(dayNumber) || {
          revenue: 0,
          expenses: 0,
          balance: entry.balance,
          trainOperational: 0,
          trainPurchase: 0,
          construction: 0,
          other: 0
        };
        dailyData.set(dayNumber, {
          revenue: existing.revenue + entry.hourlyRevenue,
          expenses: existing.expenses + entry.hourlyExpenses,
          balance: entry.balance,
          // Use latest balance for the day
          dayNumber,
          trainOperational: existing.trainOperational + (entry.expenseCategories?.trainOperational || 0),
          trainPurchase: existing.trainPurchase + (entry.expenseCategories?.trainPurchase || 0),
          construction: existing.construction + (entry.expenseCategories?.construction || 0),
          other: existing.other + (entry.expenseCategories?.other || 0)
        });
      });
      const sortedDailyData = Array.from(dailyData.values()).sort((a2, b) => a2.dayNumber - b.dayNumber);
      const displayData = timeFrame === "daily" ? sortedDailyData.slice(-14) : sortedDailyData;
      return displayData.map((day) => ({
        time: `Day ${day.dayNumber}`,
        revenue: day.revenue,
        expenses: day.expenses - day.construction - day.trainPurchase,
        totalExpenses: day.expenses,
        balance: day.balance,
        profit: day.revenue - (day.expenses - day.construction - day.trainPurchase),
        trainOperational: day.trainOperational,
        trainPurchase: day.trainPurchase,
        construction: day.construction,
        other: day.other
      }));
    }
  }, [financialHistory, money, timeFrame]);
  const totals = reactExports.useMemo(() => {
    const data = processedData;
    return {
      revenue: data.reduce((sum, item) => sum + item.revenue, 0),
      expenses: data.reduce((sum, item) => sum + item.totalExpenses, 0),
      profit: data.reduce((sum, item) => sum + item.profit, 0),
      trainOperational: data.reduce((sum, item) => sum + item.trainOperational, 0),
      trainPurchase: data.reduce((sum, item) => sum + item.trainPurchase, 0),
      construction: data.reduce((sum, item) => sum + item.construction, 0),
      other: data.reduce((sum, item) => sum + item.other, 0)
    };
  }, [processedData]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "max-w-[95vw] w-full h-[95vh] p-0 overflow-hidden", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { className: "px-6 py-4 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: t("financialDashboard.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-6 py-4 overflow-y-auto h-[calc(95vh-80px)]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: t("financialDashboard.transitCost") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mb-1", children: t("financialDashboard.currentFarePrice") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-2xl font-bold", children: [
              "$",
              transitCost.toFixed(2)
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                size: "icon",
                onClick: () => {
                  const newPrice = Math.max(0.25, transitCost - 0.25);
                  setTransitCost(newPrice);
                },
                disabled: transitCost <= 0.25,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-4 w-4" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "w-20 text-center font-mono", children: [
              "$",
              transitCost.toFixed(2)
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                size: "icon",
                onClick: () => {
                  const newPrice = Math.min(10, transitCost + 0.25);
                  setTransitCost(newPrice);
                },
                disabled: transitCost >= 10,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4" })
              }
            )
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: t("financialDashboard.financialSummary") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardDescription, { children: [
            timeFrame === "hourly" ? t("financialDashboard.last24Hours") : timeFrame === "daily" ? t("financialDashboard.last14Days") : t("financialDashboard.allTime"),
            " ",
            t("financialDashboard.overview")
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: t("financialDashboard.metric") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "text-right", children: t("financialDashboard.amount") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "text-right", children: t("financialDashboard.percentOfTotal") })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TableBody, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "font-medium", children: t("financialDashboard.currentBalance") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right font-bold", children: gameMode === "sandbox" ? "∞" : formatCurrency(money) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right text-muted-foreground", children: gameMode === "sandbox" ? t("financialDashboard.sandbox") : "-" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "font-medium text-green-600", children: t("financialDashboard.totalRevenue") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right font-bold text-green-600", children: formatCurrency(totals.revenue) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right text-muted-foreground", children: "100%" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "font-medium text-red-600", children: t("financialDashboard.totalExpenses") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right font-bold text-red-600", children: formatCurrency(totals.expenses) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right text-muted-foreground", children: "100%" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { className: "font-medium pl-8", children: [
                "• ",
                t("financialDashboard.trainOperations")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right font-bold", children: formatCurrency(totals.trainOperational) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { className: "text-right text-muted-foreground", children: [
                totals.expenses > 0 ? Math.round(totals.trainOperational / totals.expenses * 100) : 0,
                "%"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { className: "font-medium pl-8", children: [
                "• ",
                t("financialDashboard.trainPurchases")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right font-bold", children: formatCurrency(totals.trainPurchase) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { className: "text-right text-muted-foreground", children: [
                totals.expenses > 0 ? Math.round(totals.trainPurchase / totals.expenses * 100) : 0,
                "%"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { className: "font-medium pl-8", children: [
                "• ",
                t("financialDashboard.construction")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "text-right font-bold", children: formatCurrency(totals.construction) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { className: "text-right text-muted-foreground", children: [
                totals.expenses > 0 ? Math.round(totals.construction / totals.expenses * 100) : 0,
                "%"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { className: "border-t-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "font-medium", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: totals.profit >= 0 ? "text-green-600" : "text-red-600", children: t("financialDashboard.operationalProfit") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TableCell,
                {
                  className: `text-right font-bold ${totals.profit >= 0 ? "text-green-600" : "text-red-600"}`,
                  children: formatCurrency(totals.profit)
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { className: "text-right text-muted-foreground", children: [
                totals.revenue > 0 ? Math.round(totals.profit / totals.revenue * 100) : 0,
                "%"
              ] })
            ] })
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tabs,
        {
          value: timeFrame,
          onValueChange: (v) => setTimeFrame(v),
          className: "mb-6",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-[300px] grid-cols-3 mx-auto", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "hourly", children: t("financialDashboard.hourly") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "daily", children: t("financialDashboard.daily") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "all-time", children: t("financialDashboard.allTime") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: t("financialDashboard.operationalRevenueVsExpenses") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: t("financialDashboard.comparingIncomeSpending", {
              timeframe: timeFrame === "hourly" ? t("financialDashboard.theLast24Hours") : timeFrame === "daily" ? t("financialDashboard.theLast14Days") : t("financialDashboard.allTime")
            }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartContainer, { config: chartConfig, className: "h-[300px] w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart$1, { data: processedData, width: void 0, height: void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "time", tickLine: false, axisLine: false }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              YAxis,
              {
                tickLine: false,
                axisLine: false,
                tickFormatter: (value) => formatBigMoney(value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChartTooltip,
              {
                content: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ChartTooltipContent,
                  {
                    labelFormatter: (value) => value,
                    formatter: (value, name2) => {
                      const formattedValue = formatCurrency(value);
                      return [formattedValue, LABEL_MAP[name2] || name2];
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "revenue", fill: revenueColor, radius: [4, 4, 0, 0] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "expenses", fill: expenseColor, radius: [4, 4, 0, 0] })
          ] }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: t("financialDashboard.balanceOverTime") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: timeFrame === "hourly" ? t("financialDashboard.balanceHourByHour") : t("financialDashboard.balanceDayByDay") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartContainer, { config: chartConfig, className: "h-[300px] w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LineChart, { data: processedData, width: void 0, height: void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "time", tickLine: false, axisLine: false }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              YAxis,
              {
                tickLine: false,
                axisLine: false,
                tickFormatter: (value) => formatBigMoney(value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChartTooltip,
              {
                content: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ChartTooltipContent,
                  {
                    labelFormatter: (value) => value,
                    formatter: (value, name2) => {
                      const formattedValue = formatCurrency(value);
                      return [formattedValue, LABEL_MAP[name2] || name2];
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Line,
              {
                type: "monotone",
                dataKey: "balance",
                stroke: balanceColor,
                strokeWidth: 2,
                dot: { r: 4 },
                activeDot: { r: 6 }
              }
            )
          ] }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: t("financialDashboard.operationalProfitChart") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: t("financialDashboard.operationalProfitDesc", {
              timeframe: timeFrame === "hourly" ? t("financialDashboard.theLast24Hours") : timeFrame === "daily" ? t("financialDashboard.theLast14Days") : t("financialDashboard.allTime")
            }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartContainer, { config: chartConfig, className: "h-[300px] w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart$1, { data: processedData, width: void 0, height: void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "time", tickLine: false, axisLine: false }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              YAxis,
              {
                tickLine: false,
                axisLine: false,
                tickFormatter: (value) => formatBigMoney(value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChartTooltip,
              {
                content: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ChartTooltipContent,
                  {
                    labelFormatter: (value) => value,
                    formatter: (value, name2) => {
                      const formattedValue = formatCurrency(value);
                      return [formattedValue, LABEL_MAP[name2] || name2];
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "profit", fill: revenueColor, radius: [4, 4, 0, 0] })
          ] }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: t("financialDashboard.expenseBreakdown") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: t("financialDashboard.expenseBreakdownDesc", {
              timeframe: timeFrame === "hourly" ? t("financialDashboard.overTheLast24Hours") : timeFrame === "daily" ? t("financialDashboard.overTheLast14Days") : t("financialDashboard.overAllTime")
            }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartContainer, { config: chartConfig, className: "h-[300px] w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart$1, { data: processedData, width: void 0, height: void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "time", tickLine: false, axisLine: false }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              YAxis,
              {
                tickLine: false,
                axisLine: false,
                tickFormatter: (value) => formatBigMoney(value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChartTooltip,
              {
                content: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ChartTooltipContent,
                  {
                    labelFormatter: (value) => value,
                    formatter: (value, name2) => {
                      const formattedValue = formatCurrency(value);
                      return [formattedValue, LABEL_MAP[name2] || name2];
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Bar,
              {
                dataKey: "trainOperational",
                stackId: "expense",
                fill: chartConfig.trainOperational.color,
                radius: [4, 4, 0, 0]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Bar,
              {
                dataKey: "trainPurchase",
                stackId: "expense",
                fill: chartConfig.trainPurchase.color,
                radius: [0, 0, 0, 0]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Bar,
              {
                dataKey: "construction",
                stackId: "expense",
                fill: chartConfig.construction.color,
                radius: [0, 0, 0, 0]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Bar,
              {
                dataKey: "other",
                stackId: "expense",
                fill: chartConfig.other.color,
                radius: [0, 0, 0, 0]
              }
            )
          ] }) }) })
        ] })
      ] })
    ] })
  ] }) });
}
function formatBigMoney(value) {
  const isNegative = value < 0;
  const absValue = Math.abs(value);
  let formatted;
  if (absValue < 1e3) {
    formatted = `$${absValue.toFixed(0).toLocaleString()}`;
  } else if (absValue < 1e6) {
    formatted = `$${(absValue / 1e3).toFixed(0).toLocaleString()}k`;
  } else if (absValue < 1e9) {
    formatted = `$${(absValue / 1e6).toFixed(0).toLocaleString()}m`;
  } else {
    formatted = `$${(absValue / 1e9).toFixed(0).toLocaleString()}b`;
  }
  return isNegative ? `-${formatted}` : formatted;
}
function MoneyCounter() {
  const money = useMainStore((state) => state.money);
  const gameMode = useMainStore((state) => state.gameMode);
  const financialHistory = useFinancialHistory();
  const [showDashboard, setShowDashboard] = reactExports.useState(false);
  const hourlyIncomeChange = reactExports.useMemo(() => {
    const currentRevenue = financialHistory.currentHourRevenue;
    const currentExpenses = financialHistory.currentHourExpenses;
    const currentNetIncome = currentRevenue - currentExpenses;
    return currentNetIncome;
  }, [financialHistory]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      BottomBarItemWrapper,
      {
        className: "px-2 min-w-64 cursor-pointer hover:bg-accent/50 transition-colors",
        onClick: () => setShowDashboard(true),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Banknote, { className: "h-full text-green-600 dark:text-green-400 stroke-[2]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "text-sm font-medium mr-auto font-mono flex items-center gap-2",
              title: gameMode === "sandbox" ? "Sandbox Mode: Unlimited Money" : `${formatCurrency(money, { showToCent: true })}`,
              children: gameMode === "sandbox" ? "∞" : formatCurrency(money, { showToDollar: true })
            }
          ),
          gameMode !== "sandbox" && /* @__PURE__ */ jsxRuntimeExports.jsx(HourlyIncomeIndicator, { hourlyIncomeChange })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FinancialDashboard, { open: showDashboard, onOpenChange: setShowDashboard })
  ] });
}
function HourlyIncomeIndicator({ hourlyIncomeChange }) {
  function formatIncomeChange(change) {
    const sign2 = change >= 0 ? "+" : "";
    return `${sign2}${formatCurrency(change)}`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, className: "hover:cursor-help", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: cn(
          "text-sm font-mono hover:cursor-help",
          hourlyIncomeChange > 0 ? "text-green-600 dark:text-green-400" : hourlyIncomeChange === 0 ? "text-muted-foreground" : "text-red-600 dark:text-red-400"
        ),
        children: formatIncomeChange(hourlyIncomeChange)
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: "The change in your bank balance over the past hour" }) })
  ] }) });
}
function TrainCounter() {
  const { pushNavigationState } = useUi();
  const { trains, ownedTrainCount } = useMainStore();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    BottomBarItemWrapper,
    {
      className: "px-2 pl-1.5 py-1.5 items-center min-w-20 cursor-pointer hover:bg-accent/50",
      onClick: () => {
        pushNavigationState({
          type: "trains-list",
          itemId: null,
          view: null
        });
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TramFront, { className: "h-full stroke-[2]" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium ml-auto", children: trains.length })
      ]
    }
  );
}
function BottomBar() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full mt-auto h-12 p-2 bg-primary-foreground/70 backdrop-blur-sm pointer-events-auto flex items-center gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MoneyCounter, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TrainCounter, {})
  ] });
}
function BottomBarItemWrapper({
  children,
  className,
  altText,
  onClick
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: cn(
        "flex items-center justify-start gap-2 bg-primary-foreground/50 rounded-sm h-full overflow-hidden border-primary/15 border",
        className
      ),
      title: altText,
      onClick,
      children
    }
  );
}
class GameCrashBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Game crashed:", error, errorInfo);
    let gameState = null;
    try {
      gameState = useMainStore.getState();
    } catch (e) {
      console.error("Could not get game state for crash report");
    }
    telemetry.trackCrash(error, () => gameState);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-screen w-full items-center justify-center bg-background", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-md text-center space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold text-destructive", children: "Game Crashed" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: "An unexpected error occurred. The error has been reported." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 bg-muted rounded-lg text-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "text-xs overflow-auto max-h-40", children: this.state.error?.stack || this.state.error?.message }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => window.location.reload(),
            className: "px-4 py-2 bg-primary text-primary-foreground rounded hover:bg-primary/90",
            children: "Reload Game"
          }
        )
      ] }) });
    }
    return this.props.children;
  }
}
function useStateMachine(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeScrollArea,
      type = "hover",
      dir,
      scrollHideDelay = 600,
      ...scrollAreaProps
    } = props;
    const [scrollArea, setScrollArea] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const [content, setContent] = reactExports.useState(null);
    const [scrollbarX, setScrollbarX] = reactExports.useState(null);
    const [scrollbarY, setScrollbarY] = reactExports.useState(null);
    const [cornerWidth, setCornerWidth] = reactExports.useState(0);
    const [cornerHeight, setCornerHeight] = reactExports.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = reactExports.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = reactExports.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            ...scrollAreaProps,
            ref: composedRefs,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
              ...props.style
            }
          }
        )
      }
    );
  }
);
ScrollArea$1.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME = "ScrollAreaViewport";
var ScrollAreaViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, children, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          ref: composedRefs,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: context.onContentChange, style: { minWidth: "100%", display: "table" }, children })
        }
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    reactExports.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarAuto,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarScroll = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  reactExports.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  reactExports.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll);
      return () => viewport.removeEventListener("scroll", handleScroll);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || state !== "hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
    }
  ) });
});
var ScrollAreaScrollbarAuto = reactExports.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = reactExports.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver(context.viewport, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarVisible = reactExports.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = reactExports.useRef(null);
  const pointerOffsetRef = reactExports.useRef(0);
  const [sizes, setSizes] = reactExports.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarX,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      }
    );
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarY,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      }
    );
  }
  return null;
});
var ScrollAreaScrollbarX = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    }
  );
});
var ScrollAreaScrollbarY = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    }
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = reactExports.useState(null);
  const composeRefs2 = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
  const rectRef = reactExports.useRef(null);
  const prevWebkitUserSelectRef = reactExports.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left;
      const y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  }
  reactExports.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar?.contains(element);
      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  reactExports.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver(scrollbar, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef(onThumbChange),
      onThumbPointerUp: useCallbackRef(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef(onThumbPointerDown),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...scrollbarProps,
          ref: composeRefs2,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport) context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport) context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        }
      )
    }
  );
});
var THUMB_NAME = "ScrollAreaThumb";
var ScrollAreaThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || scrollbarContext.hasThumb, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
  }
);
var ScrollAreaThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, style, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node) => scrollbarContext.onThumbChange(node)
    );
    const removeUnlinkedScrollListenerRef = reactExports.useRef(void 0);
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    reactExports.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll);
        return () => viewport.removeEventListener("scroll", handleScroll);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
        ...thumbProps,
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x2 = event.clientX - thumbRect.left;
          const y2 = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = reactExports.useState(0);
  const [height, setHeight] = reactExports.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver(context.scrollbarX, () => {
    const height2 = context.scrollbarX?.offsetHeight || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver(context.scrollbarY, () => {
    const width2 = context.scrollbarY?.offsetWidth || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }
  ) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate2 = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate2(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp$2(scrollPos, scrollClampRange);
  const interpolate2 = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate2(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {
}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef(callback);
  const debounceTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return reactExports.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
var Root$1 = ScrollArea$1;
var Viewport$1 = ScrollAreaViewport;
var Corner = ScrollAreaCorner;
const ScrollArea = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Root$1, { ref, className: cn("relative overflow-hidden", className), ...props, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport$1, { className: "h-full w-full rounded-[inherit]", children }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Corner, {})
] }));
ScrollArea.displayName = Root$1.displayName;
const ScrollBar = reactExports.forwardRef(({ className, orientation = "vertical", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollAreaScrollbar,
  {
    ref,
    orientation,
    className: cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumb, { className: "relative flex-1 rounded-full bg-border" })
  }
));
ScrollBar.displayName = ScrollAreaScrollbar.displayName;
function NewspaperArchiveButton({ onClick }) {
  const { t } = useTranslation("game");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubwayButton,
    {
      text: t("newspaper.newsArchive"),
      className: "w-full h-fit",
      size: "4xl",
      arrowBearing: 315,
      reverseArrow: true,
      onClick
    }
  );
}
const getRandomWeatherKey = (seed) => {
  const weatherKeys = [
    "sunny",
    "partlyCloudy",
    "cloudy",
    "overcast",
    "lightRain",
    "scatteredShowers",
    "fog",
    "clearSkies",
    "windy",
    "breezy",
    "humid",
    "fair",
    "mild",
    "thunderstorms",
    "lightDrizzle",
    "hazy"
  ];
  const index2 = seed % weatherKeys.length;
  return weatherKeys[index2];
};
let showNewspaperArticle = null;
let pendingArticle = null;
function NewspaperModal() {
  const { t } = useTranslation("game");
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [article, setArticle] = reactExports.useState(null);
  const [isGenerating, setIsGenerating] = reactExports.useState(false);
  const { autoShowNewspapers } = useSettings();
  const elapsedSeconds = useMainStore((state) => state.timeConfig.elapsedSeconds);
  const dayNumber = Math.floor(elapsedSeconds / 86400);
  reactExports.useEffect(() => {
    showNewspaperArticle = (newArticle) => {
      setArticle(newArticle);
      setIsOpen(true);
    };
    if (pendingArticle) {
      setArticle(pendingArticle);
      setIsOpen(true);
      pendingArticle = null;
    }
    return () => {
      showNewspaperArticle = null;
    };
  }, []);
  reactExports.useEffect(() => {
    if (newspaperService.shouldGenerateArticle(dayNumber) && !isGenerating) {
      setIsGenerating(true);
      const freshState = useMainStore.getState();
      newspaperService.generateArticle(freshState).then((newArticle) => {
        if (newArticle) {
          setArticle(newArticle);
          if (autoShowNewspapers) {
            setIsOpen(true);
          }
        }
      }).catch((err) => {
        console.error("Failed to generate newspaper:", err);
      }).finally(() => {
        setIsGenerating(false);
      });
    }
  }, [dayNumber, isGenerating, autoShowNewspapers]);
  if (!article) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: setIsOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "max-w-3xl bg-white text-black p-0 overflow-hidden", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "hidden", children: t("newspaper.transitTimes") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-8", style: { fontFamily: "Georgia, serif" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center border-b-4 border-black pb-4 mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "h1",
          {
            className: "text-5xl font-bold tracking-tight",
            style: { fontFamily: "Times New Roman, serif" },
            children: t("newspaper.transitTimes")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mt-2 text-xs uppercase tracking-wider", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: article.date }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: t("newspaper.volume", {
            volume: Math.floor(article.dayNumber / 365) + 1,
            number: article.dayNumber % 365 + 1
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t("newspaper.weather", {
            weather: t(`weather.${getRandomWeatherKey(article.dayNumber)}`)
          }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "h2",
          {
            className: "text-3xl font-bold mb-4 leading-tight",
            style: { fontFamily: "Georgia, serif" },
            dangerouslySetInnerHTML: { __html: article.headline }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[400px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "text-base leading-relaxed columns-2 gap-6 first-letter:text-5xl first-letter:font-bold first-letter:float-left first-letter:mr-2",
            style: { fontFamily: "Georgia, serif", textAlign: "justify" },
            children: article?.content ? article.content.split("\n").map((paragraph, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                className: "mb-3",
                dangerouslySetInnerHTML: { __html: paragraph }
              },
              i
            )) : ""
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mt-6 pt-4 border-t-2 border-black", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs italic", children: t("newspaper.dayEdition", { dayNumber: article.dayNumber }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            className: "bg-black text-white hover:bg-gray-800",
            size: "sm",
            onClick: () => setIsOpen(false),
            children: t("newspaper.backToBusiness")
          }
        )
      ] })
    ] })
  ] }) });
}
function triggerNewspaperModal(article) {
  if (showNewspaperArticle) {
    showNewspaperArticle(article);
  } else {
    pendingArticle = article;
  }
}
function NewspaperArchive() {
  const { t } = useTranslation("game");
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const articles = newspaperService.getArticles();
  const [selectedArticle, setSelectedArticle] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cursor-pointer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NewspaperArchiveButton, { onClick: () => setIsOpen(true) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: setIsOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { className: "max-w-5xl max-h-[90vh] bg-white text-black p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6", style: { fontFamily: "Georgia, serif" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { className: "border-b-4 border-black pb-4 mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { className: "text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold", style: { fontFamily: "Times New Roman, serif" }, children: t("newspaper.transitTimesArchive") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm mt-2 font-normal italic", children: t("newspaper.allTheNewsFit") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2 border-r-2 border-black pr-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold mb-3 uppercase tracking-wide border-b border-black pb-1", children: t("newspaper.pastEditions") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[500px]", children: articles.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm italic", children: t("newspaper.noArticlesYet") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: articles.map((a2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setSelectedArticle(a2),
              className: `w-full text-left p-2 transition-all ${selectedArticle?.id === a2.id ? "bg-gray-200 border-l-4 border-black pl-3" : "hover:bg-gray-100 border-l-4 border-transparent"}`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs uppercase tracking-wider text-gray-600", children: a2.date }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "text-sm font-bold leading-tight mt-1",
                    dangerouslySetInnerHTML: { __html: a2.headline }
                  }
                )
              ]
            },
            a2.id
          )) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3 pl-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[500px]", children: selectedArticle ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs uppercase tracking-wider text-gray-600", children: [
              selectedArticle.date,
              " • Edition #",
              selectedArticle.dayNumber
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h2",
              {
                className: "text-2xl font-bold mt-2 leading-tight",
                style: { fontFamily: "Georgia, serif" },
                dangerouslySetInnerHTML: { __html: selectedArticle.headline }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "text-sm leading-relaxed columns-2 gap-4 first-letter:text-4xl first-letter:font-bold first-letter:float-left first-letter:mr-1",
              style: { textAlign: "justify" },
              children: selectedArticle.content.split("\n").map((paragraph, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  className: "mb-3",
                  dangerouslySetInnerHTML: { __html: paragraph }
                },
                i
              ))
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center text-gray-500 italic mt-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg", children: t("newspaper.selectArticleToRead") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm mt-2", children: t("newspaper.browseArchive") })
        ] }) }) })
      ] })
    ] }) }) })
  ] });
}
function TweetFeed() {
  const { t } = useTranslation("game");
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [tweets, setTweets] = reactExports.useState([]);
  const [isGenerating, setIsGenerating] = reactExports.useState(false);
  const [metrics, setMetrics] = reactExports.useState(tweetService.getMetrics());
  const elapsedSeconds = useMainStore((state) => state.timeConfig.elapsedSeconds);
  const dayNumber = Math.floor(elapsedSeconds / 86400);
  reactExports.useEffect(() => {
    setTweets(tweetService.getRecentTweets(20));
    setMetrics(tweetService.getMetrics());
  }, []);
  reactExports.useEffect(() => {
    if (tweetService.shouldGenerateBatch(dayNumber) && !isGenerating) {
      generateTweets();
    }
  }, [dayNumber, isGenerating]);
  const generateTweets = async () => {
    setIsGenerating(true);
    const state = useMainStore.getState();
    try {
      const batch = await tweetService.generateTweetBatch(state, true);
      if (batch) {
        setTweets(tweetService.getRecentTweets(20));
        setMetrics(tweetService.getMetrics());
      }
    } catch (error) {
      console.error("Failed to generate tweets:", error);
    } finally {
      setIsGenerating(false);
    }
  };
  const formatTimestamp = (dayNum) => {
    const baseDate = /* @__PURE__ */ new Date("2024-01-01");
    baseDate.setDate(baseDate.getDate() + dayNum);
    return baseDate.toLocaleDateString("en-US", { month: "short", day: "numeric" });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubwayButton,
      {
        text: t("tweetFeed.transitFeed"),
        className: "w-full h-fit",
        size: "4xl",
        arrowBearing: 135,
        reverseArrow: true,
        onClick: () => setIsOpen(true)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: setIsOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "max-w-2xl max-h-[80vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "flex items-center justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Twitter, { className: "w-5 h-5" }),
        t("tweetFeed.transitSocialFeed")
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[400px] pr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: tweets.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-muted-foreground py-8", children: t("tweetFeed.noTweetsYet") }) : tweets.map((tweet) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Card,
        {
          className: `p-3 hover:bg-accent/50 transition-colors ${tweet.replyTo ? "ml-8 border-l-2 border-muted" : ""}`,
          children: [
            tweet.author && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 mb-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-semibold text-blue-600", children: [
                "@",
                tweet.author
              ] }),
              tweet.replyTo && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-muted-foreground", children: [
                "· ",
                t("tweetFeed.replying")
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm flex-1", children: tweet.content }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-muted-foreground whitespace-nowrap", children: formatTimestamp(tweet.dayNumber) })
            ] })
          ]
        },
        tweet.id
      )) }) }) })
    ] }) })
  ] });
}
function DebugInfo() {
  const {
    trains,
    trainTest,
    updateTrainTestPosition,
    trainWindowCoordsTest,
    updateTrainWindowCoordsTest,
    handleIncrementGameState,
    generateTrain,
    resetTrains,
    routes,
    startPoint,
    hoveredPoint,
    tracks
  } = useMainStore();
  const gamePerformanceMetrics = useGamePerformanceMetrics();
  const { isDebugInfoOpen } = useUi();
  const handleGenerateTweets = async () => {
    const freshState = useMainStore.getState();
    toast({
      title: "Generating tweets...",
      description: "Creating batch of 15 tweets"
    });
    try {
      const batch = await tweetService.generateTweetBatch(freshState, true);
      if (batch) {
        toast({
          title: "Tweets generated!",
          description: `Created ${batch.tweets.length} tweets for $${batch.estimatedCost.toFixed(3)}`
        });
      } else {
        toast({
          title: "Failed to generate",
          description: "Check console for errors",
          variant: "destructive"
        });
      }
    } catch (err) {
      console.error("Tweet generation failed:", err);
      toast({
        title: "Generation error",
        description: "Check console for details",
        variant: "destructive"
      });
    }
  };
  const handlePreGenerateTweets = async () => {
    const freshState = useMainStore.getState();
    toast({
      title: "Pre-generating tweets...",
      description: "This will generate 500 tweets (100 days worth)"
    });
    try {
      await tweetService.preGenerateTweets(freshState, 100, 5);
      const metrics = tweetService.getMetrics();
      toast({
        title: "Pre-generation complete!",
        description: `Generated ${metrics.totalTweetsGenerated} tweets for $${metrics.totalEstimatedCost.toFixed(2)}`
      });
    } catch (err) {
      console.error("Pre-generation failed:", err);
      toast({
        title: "Pre-generation error",
        description: "Check console for details",
        variant: "destructive"
      });
    }
  };
  const handleGenerateTweetTemplates = async () => {
    const freshState = useMainStore.getState();
    toast({
      title: "Generating tweet templates...",
      description: "Creating 100 templates with metadata (additive)"
    });
    try {
      const newTemplates = await tweetService.generateTweetTemplates(freshState, 100);
      const stats = tweetService.getTemplateStats();
      toast({
        title: "Templates generated!",
        description: `Added ${newTemplates.length} templates. Total library: ${stats?.total || 0} templates`
      });
      const reviews = tweetService.reviewTemplates(12);
      console.log("🐦 Most interesting templates from this batch:");
      reviews.forEach((r, i) => {
        console.log(`
${i + 1}. [${r.template.metadata.category}/${r.template.metadata.tone}]`);
        console.log(`   Template: ${r.template.template}`);
        console.log(`   Preview: ${r.preview}`);
        if (r.template.metadata.requiredGameState) {
          console.log(`   Requirements:`, r.template.metadata.requiredGameState);
        }
      });
      if (stats) {
        console.log("\n📊 Template Library Stats:");
        console.log(`Total: ${stats.total}`);
        console.log("By category:", stats.byCategory);
        console.log("By tone:", stats.byTone);
        console.log(`With requirements: ${stats.withRequirements}`);
        console.log(`Replies: ${stats.replies}`);
      }
    } catch (err) {
      console.error("Template generation failed:", err);
      toast({
        title: "Template generation error",
        description: "Check console for details",
        variant: "destructive"
      });
    }
  };
  const handleGenerateNewspaperTemplates = async () => {
    const freshState = useMainStore.getState();
    toast({
      title: "Generating newspaper templates...",
      description: "Creating 50 article templates (additive)"
    });
    try {
      const newTemplates = await newspaperService.generateNewspaperTemplates(freshState, 50);
      const stats = newspaperService.getTemplateStats();
      toast({
        title: "Newspaper templates generated!",
        description: `Added ${newTemplates.length} templates. Total library: ${stats?.total || 0} articles`
      });
      console.log("📰 Generated newspaper templates:");
      newTemplates.slice(0, 5).forEach((t, i) => {
        console.log(`
${i + 1}. [${t.metadata.category}/${t.metadata.tone}]`);
        console.log(`   Headline: ${t.headline}`);
        console.log(`   Content preview: ${t.content.substring(0, 100)}...`);
        if (t.metadata.requiredGameState) {
          console.log(`   Requirements:`, t.metadata.requiredGameState);
        }
      });
      if (stats) {
        console.log("\n📊 Newspaper Template Library Stats:");
        console.log(`Total: ${stats.total}`);
        console.log("By category:", stats.byCategory);
        console.log("By tone:", stats.byTone);
        console.log("By weight:", stats.byWeight);
        console.log(`With requirements: ${stats.withRequirements}`);
        console.log("\n📋 Scenario Coverage:");
        console.log(stats.scenarioCoverage);
      }
      const coverage = newspaperService.analyzeTemplateCoverage();
      console.log("\n🎯 Template Coverage Analysis:");
      console.log(`Status: ${coverage.coverage}`);
      if (coverage.suggestions.length > 0) {
        console.log("\nSuggestions to improve coverage:");
        coverage.suggestions.forEach((s2, i) => console.log(`${i + 1}. ${s2}`));
      } else {
        console.log("✅ Excellent coverage across all scenarios!");
      }
    } catch (err) {
      console.error("Newspaper template generation failed:", err);
      toast({
        title: "Template generation error",
        description: "Check console for details",
        variant: "destructive"
      });
    }
  };
  const handleGenerateNewspaper = () => {
    const freshState = useMainStore.getState();
    console.log("📰 Getting fresh state for newspaper:", {
      stations: freshState.stations?.length || 0,
      routes: freshState.routes?.length || 0,
      money: freshState.money || 0,
      trains: freshState.trains?.length || 0,
      timestamp: Date.now()
    });
    toast({
      title: "Generating newspaper...",
      description: "Running in background"
    });
    newspaperService.generateArticle(freshState, true).then((article) => {
      if (article) {
        triggerNewspaperModal(article);
      } else {
        toast({
          title: "Failed to generate",
          description: "Check console for errors",
          variant: "destructive"
        });
      }
    }).catch((err) => {
      console.error("Newspaper generation failed:", err);
      toast({
        title: "Generation error",
        description: "Check console for details",
        variant: "destructive"
      });
    });
  };
  if (!isDebugInfoOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background p-2 text-[8px] max-h-full h-fit overflow-y-auto max-w-60 pointer-events-auto flex flex-col gap-1 ml-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 text-xs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          className: "w-full text-xs p-0 h-7",
          variant: "outline",
          onClick: () => generateTrain(routes[0].id),
          children: "Generate Train"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full text-xs p-0 h-7", variant: "outline", onClick: resetTrains, children: "Reset Trains" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full text-xs p-0 h-7", variant: "outline", onClick: handleIncrementGameState, children: "Update Game State" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full text-xs p-0 h-7", variant: "outline", onClick: handleGenerateNewspaper, children: "Generate Newspaper Now" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full text-xs p-0 h-7", variant: "outline", onClick: handleGenerateTweets, children: "Generate Tweet Batch" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full text-xs p-0 h-7", variant: "outline", onClick: handleGenerateTweetTemplates, children: "Generate 100 Tweet Templates" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full text-xs p-0 h-7", variant: "outline", onClick: handleGenerateNewspaperTemplates, children: "Generate 50 Newspaper Templates" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full text-xs p-0 h-7", variant: "outline", onClick: handlePreGenerateTweets, children: "Pre-Generate 500 Tweets" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TweetFeed, {}),
      DEBUG_TIMES && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 p-2 bg-secondary/50 rounded text-xs space-y-1 w-40", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold", children: "Performance Monitor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "Target ms/update: ",
          gamePerformanceMetrics.targetMsPerUpdate.toFixed(1)
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "Actual ms/update: ",
          gamePerformanceMetrics.actualMsPerUpdate.toFixed(1)
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: gamePerformanceMetrics.performanceRatio >= 0.95 ? "text-green-500" : "text-yellow-500",
            children: [
              "Performance: ",
              (gamePerformanceMetrics.performanceRatio * 100).toFixed(0),
              "%"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "Game minute takes: ",
          gamePerformanceMetrics.msPerGameMinute.toFixed(0),
          "ms"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "Target: ",
          gamePerformanceMetrics.targetMsPerGameMinute.toFixed(0),
          "ms"
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "range",
        min: 0,
        max: 1,
        step: 5e-3,
        value: trainTest.progress,
        onChange: (e) => updateTrainTestPosition(Number(e.target.value))
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "range",
        min: 0,
        max: 1,
        step: 5e-3,
        value: trainWindowCoordsTest.progress,
        onChange: (e) => updateTrainWindowCoordsTest(Number(e.target.value))
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 overflow-y-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("pre", { children: [
        "Tracks (not preview): ",
        tracks.length
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("pre", { children: [
        "Start Point: ",
        JSON.stringify(startPoint, null, 2)
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("pre", { children: [
        "Hovered Node: ",
        JSON.stringify(hoveredPoint, null, 2)
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("pre", { children: [
        "Train 0: ",
        JSON.stringify(trains[0], null, 2)
      ] })
    ] })
  ] });
}
(function(_0x3b0bdf, _0x555963) {
  const _0x3aec78 = _0x2c0d, _0x5616c8 = _0x3b0bdf();
  while (!![]) {
    try {
      const _0x587709 = parseInt(_0x3aec78(163)) / 1 * (-parseInt(_0x3aec78(188)) / 2) + parseInt(_0x3aec78(154)) / 3 * (parseInt(_0x3aec78(161)) / 4) + parseInt(_0x3aec78(155)) / 5 * (-parseInt(_0x3aec78(172)) / 6) + -parseInt(_0x3aec78(160)) / 7 * (-parseInt(_0x3aec78(178)) / 8) + -parseInt(_0x3aec78(186)) / 9 * (-parseInt(_0x3aec78(151)) / 10) + -parseInt(_0x3aec78(157)) / 11 * (parseInt(_0x3aec78(159)) / 12) + parseInt(_0x3aec78(185)) / 13 * (-parseInt(_0x3aec78(180)) / 14);
      if (_0x587709 === _0x555963) break;
      else _0x5616c8["push"](_0x5616c8["shift"]());
    } catch (_0x22d61f) {
      _0x5616c8["push"](_0x5616c8["shift"]());
    }
  }
})(_0x3654, 441206);
const _0x23f456 = /* @__PURE__ */ (function() {
  let _0x3d214e = !![];
  return function(_0x108e31, _0x1d7299) {
    const _0x176ab9 = _0x3d214e ? function() {
      const _0x5ae75f = _0x2c0d;
      if (_0x1d7299) {
        const _0x85442d = _0x1d7299[_0x5ae75f(150)](_0x108e31, arguments);
        return _0x1d7299 = null, _0x85442d;
      }
    } : function() {
    };
    return _0x3d214e = ![], _0x176ab9;
  };
})(), _0x3e6de3 = _0x23f456(void 0, function() {
  const _0x394718 = _0x2c0d, _0x2a1467 = function() {
    const _0x56c0e2 = _0x2c0d;
    let _0xf371d;
    try {
      _0xf371d = Function(_0x56c0e2(149) + _0x56c0e2(183) + ");")();
    } catch (_0x981683) {
      _0xf371d = window;
    }
    return _0xf371d;
  }, _0x3b5dd9 = _0x2a1467(), _0x4e7b1b = _0x3b5dd9[_0x394718(169)] = _0x3b5dd9[_0x394718(169)] || {}, _0x18e61d = ["log", "warn", _0x394718(182), _0x394718(152), _0x394718(165), _0x394718(171), _0x394718(174)];
  for (let _0x50a2f3 = 0; _0x50a2f3 < _0x18e61d["length"]; _0x50a2f3++) {
    const _0x267902 = _0x23f456[_0x394718(175)][_0x394718(168)][_0x394718(158)](_0x23f456), _0x4f6193 = _0x18e61d[_0x50a2f3], _0x45fe15 = _0x4e7b1b[_0x4f6193] || _0x267902;
    _0x267902["__proto__"] = _0x23f456[_0x394718(158)](_0x23f456), _0x267902[_0x394718(181)] = _0x45fe15[_0x394718(181)][_0x394718(158)](_0x45fe15), _0x4e7b1b[_0x4f6193] = _0x267902;
  }
});
_0x3e6de3();
function _0x2c0d(_0x125c4b, _0x2da7f8) {
  const _0x5b3335 = _0x3654();
  return _0x2c0d = function(_0x3e6de32, _0x23f4562) {
    _0x3e6de32 = _0x3e6de32 - 148;
    let _0x44801f = _0x5b3335[_0x3e6de32];
    return _0x44801f;
  }, _0x2c0d(_0x125c4b, _0x2da7f8);
}
function _0x3654() {
  const _0x39df7c = ["subscribe", "17373DdCWBj", "14165VbwJRt", "trains", "2992uLZLaj", "bind", "3096UwNceM", "47201RWtRJw", "276nawRNu", "Unknown City", "114986MZJrqf", "length", "exception", "find", "name", "prototype", "console", "updateDiscordActivity", "table", "726SkFNwE", " stations, ", "trace", "constructor", "catch", "code", "472UqCrpI", "Playing in ", "156086JBfbiY", "toString", "info", '{}.constructor("return this")( )', "routes", "13QwjHJq", "396ynsrQN", "current", "4lYsUHQ", "stations", "return (function() ", "apply", "67700UFbLbV", "error"];
  _0x3654 = function() {
    return _0x39df7c;
  };
  return _0x3654();
}
function useDiscordActivity() {
  const _0x2fdba4 = _0x2c0d, { cityCode: _0x99b4e5 } = useCity(), _0x1ad3f0 = cities[_0x2fdba4(166)]((_0x1b2ee9) => _0x1b2ee9[_0x2fdba4(177)] === _0x99b4e5)?.[_0x2fdba4(167)] || _0x2fdba4(162), _0x3cd531 = reactExports.useRef(useMainStore["getState"]());
  reactExports.useEffect(() => {
    const _0x1d612b = _0x2fdba4, _0x45fe26 = useMainStore[_0x1d612b(153)]((_0x3ee37d) => {
      const _0x65a240 = _0x1d612b;
      _0x3cd531[_0x65a240(187)] = _0x3ee37d;
    });
    return _0x45fe26;
  }, []), reactExports.useEffect(() => {
    const _0x279b11 = _0x2fdba4;
    if (!window["electron"]?.[_0x279b11(170)]) return;
    const _0x1dbc48 = () => {
      const _0x5e135c = _0x279b11, _0x362069 = _0x3cd531["current"], _0x1054b7 = _0x362069[_0x5e135c(156)][_0x5e135c(164)], _0x588e8e = _0x362069[_0x5e135c(184)][_0x5e135c(164)], _0x325abc = _0x362069[_0x5e135c(148)][_0x5e135c(164)], _0x518cf5 = _0x5e135c(179) + _0x1ad3f0, _0x5bbf24 = _0x325abc + _0x5e135c(173) + _0x588e8e + " routes, " + _0x1054b7 + " trains";
      window["electron"]?.[_0x5e135c(170)](_0x518cf5, _0x5bbf24)[_0x5e135c(176)](console[_0x5e135c(152)]);
    };
    _0x1dbc48();
    const _0x31ee8a = setInterval(_0x1dbc48, 30 * 1e3);
    return () => clearInterval(_0x31ee8a);
  }, [_0x1ad3f0]);
}
function DiscordActivity() {
  useDiscordActivity();
  return null;
}
function ErrorMessage() {
  const { previewTracks } = useMainStore();
  const errorMessage = previewTracks.validation.errorMessage;
  if (!errorMessage) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-28 left-1/2 transform -translate-x-1/2 z-40 bg-destructive text-destructive-foreground p-2 rounded-md shadow-md", children: errorMessage });
}
const initialState = {
  isActive: false,
  currentStep: 0,
  totalSteps: 0
};
function tutorialReducer(state, action) {
  switch (action.type) {
    case "START_TUTORIAL":
      return {
        isActive: true,
        currentStep: 1,
        totalSteps: action.payload.totalSteps
      };
    case "NEXT_STEP":
      return {
        ...state,
        currentStep: Math.min(state.currentStep + 1, state.totalSteps)
      };
    case "PREVIOUS_STEP":
      return {
        ...state,
        currentStep: Math.max(state.currentStep - 1, 1)
      };
    case "END_TUTORIAL":
      return {
        isActive: false,
        currentStep: 0,
        totalSteps: 0
      };
    default:
      return state;
  }
}
const TutorialContext = reactExports.createContext(void 0);
function TutorialProvider({ children }) {
  const [state, dispatch] = reactExports.useReducer(tutorialReducer, initialState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TutorialContext.Provider,
    {
      value: {
        tutorial: state,
        startTutorial: (totalSteps) => {
          telemetry.trackTutorial("start", 1);
          dispatch({ type: "START_TUTORIAL", payload: { totalSteps } });
        },
        nextStep: () => {
          const newStep = Math.min(state.currentStep + 1, state.totalSteps);
          if (newStep === state.totalSteps) {
            telemetry.trackTutorial("complete", newStep);
          }
          dispatch({ type: "NEXT_STEP" });
        },
        previousStep: () => dispatch({ type: "PREVIOUS_STEP" }),
        endTutorial: () => {
          if (state.currentStep < state.totalSteps) {
            telemetry.trackTutorial("skip", state.currentStep);
          }
          dispatch({ type: "END_TUTORIAL" });
        }
      },
      children
    }
  );
}
function useTutorial() {
  const context = reactExports.useContext(TutorialContext);
  if (!context) {
    throw new Error("useTutorial must be used within a TutorialProvider");
  }
  return context;
}
function Menu({ setOpenDialog }) {
  const { t } = useTranslation("common");
  const { toggleEscapeMenu } = useUi();
  const { startTutorial } = useTutorial();
  const navigate = useNavigate();
  const isElectron2 = window.navigator.userAgent.includes("Electron");
  function handleLoadSave() {
    setOpenDialog("save");
  }
  function handleStartTutorial() {
    toggleEscapeMenu();
    localStorage.removeItem("tutorialDismissed");
    startTutorial(29);
  }
  function handleExitToMenu() {
    navigate("/");
  }
  function handleExitToDesktop() {
    if (!window.electron?.quit) {
      console.error("Electron quit function not found");
      return;
    }
    window.electron.quit();
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 overflow-x-visible", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubwayButton,
      {
        text: t("menu.resume"),
        onClick: toggleEscapeMenu,
        arrowBearing: 270,
        size: "4xl",
        className: "h-fit w-full",
        reverseArrow: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubwayButton,
      {
        text: t("menu.loadSave"),
        onClick: handleLoadSave,
        className: "w-full h-fit",
        size: "4xl",
        arrowBearing: 0,
        reverseArrow: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NewspaperArchive, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TweetFeed, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubwayButton,
      {
        text: t("menu.tutorial"),
        onClick: handleStartTutorial,
        className: "w-full h-fit",
        size: "4xl",
        arrowBearing: 45,
        reverseArrow: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubwayButton,
      {
        text: t("menu.settings"),
        onClick: () => setOpenDialog("settings"),
        className: "w-full h-fit",
        size: "4xl",
        arrowBearing: 90,
        reverseArrow: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubwayButton,
      {
        text: t("menu.exit"),
        sideText: t("menu.exitToMenu"),
        onClick: handleExitToMenu,
        variant: "exit",
        className: "w-full h-fit",
        size: "4xl",
        reverseArrow: true,
        arrowBearing: 180
      }
    ),
    isElectron2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubwayButton,
      {
        text: t("menu.exit"),
        sideText: t("menu.exitToDesktop"),
        onClick: handleExitToDesktop,
        arrowBearing: 90,
        variant: "exit",
        className: "w-full h-fit",
        size: "4xl",
        reverseArrow: true
      }
    )
  ] });
}
function MenuViewWrapper({ children, onClose }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4 overflow-x-visible px-2 -mx-2 max-h-full mb-5", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(BackButton, { onClick: onClose }),
    children
  ] });
}
function SaveListItem({
  save,
  onLoad,
  onOverwrite,
  onExport,
  onDelete
}) {
  const { t } = useTranslation("common");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2 p-3 border rounded-lg bg-secondary/30 hover:bg-secondary/60 transition-colors", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium truncate", children: save.name }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-muted-foreground", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cursor-help", children: formatRelativeTime(save.timestamp) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: new Date(save.timestamp).toLocaleString() })
        ] }),
        save.cityCode && ` • ${save.cityCode}`
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 shrink-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", className: "h-8 w-8", onClick: () => onLoad(save), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "h-4 w-4" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: t("saveMenu.loadSave") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", className: "h-8 w-8", onClick: () => onOverwrite(save), children: /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCw, { className: "h-4 w-4" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: t("saveMenu.overwriteSave") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", className: "h-8 w-8", onClick: () => onExport(save), children: /* @__PURE__ */ jsxRuntimeExports.jsx(FileDown, { className: "h-4 w-4" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: t("saveMenu.exportSave") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "ghost",
            size: "icon",
            className: "h-8 w-8 hover:bg-destructive hover:text-destructive-foreground",
            onClick: () => onDelete(save.id),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: t("saveMenu.deleteSave") })
      ] })
    ] })
  ] }) });
}
(function(_0x125b3f, _0x4fd85d) {
  const _0x11af89 = _0x3c24, _0xdf742d = _0x125b3f();
  while (!![]) {
    try {
      const _0x3a6432 = parseInt(_0x11af89(447)) / 1 * (-parseInt(_0x11af89(414)) / 2) + parseInt(_0x11af89(436)) / 3 * (-parseInt(_0x11af89(453)) / 4) + parseInt(_0x11af89(417)) / 5 * (-parseInt(_0x11af89(419)) / 6) + -parseInt(_0x11af89(404)) / 7 + parseInt(_0x11af89(455)) / 8 + -parseInt(_0x11af89(438)) / 9 + parseInt(_0x11af89(412)) / 10;
      if (_0x3a6432 === _0x4fd85d) break;
      else _0xdf742d["push"](_0xdf742d["shift"]());
    } catch (_0x456110) {
      _0xdf742d["push"](_0xdf742d["shift"]());
    }
  }
})(_0x1210, 343142);
const _0x3ce752 = /* @__PURE__ */ (function() {
  let _0xd0674a = !![];
  return function(_0x26aa0a, _0x5d358c) {
    const _0x42635a = _0xd0674a ? function() {
      const _0x5d02ef = _0x3c24;
      if (_0x5d358c) {
        const _0x8c588a = _0x5d358c[_0x5d02ef(451)](_0x26aa0a, arguments);
        return _0x5d358c = null, _0x8c588a;
      }
    } : function() {
    };
    return _0xd0674a = ![], _0x42635a;
  };
})(), _0x27bad8 = _0x3ce752(void 0, function() {
  const _0x4f389a = _0x3c24, _0x9c9b5d = function() {
    const _0x234e79 = _0x3c24;
    let _0x527aa1;
    try {
      _0x527aa1 = Function(_0x234e79(416) + _0x234e79(405) + ");")();
    } catch (_0x3bdfd4) {
      _0x527aa1 = window;
    }
    return _0x527aa1;
  }, _0x2c9bbb = _0x9c9b5d(), _0x526533 = _0x2c9bbb[_0x4f389a(427)] = _0x2c9bbb["console"] || {}, _0x2aa1c2 = [_0x4f389a(454), "warn", _0x4f389a(437), _0x4f389a(406), "exception", "table", _0x4f389a(399)];
  for (let _0xcafdc0 = 0; _0xcafdc0 < _0x2aa1c2[_0x4f389a(403)]; _0xcafdc0++) {
    const _0x45c44f = _0x3ce752[_0x4f389a(441)][_0x4f389a(452)][_0x4f389a(432)](_0x3ce752), _0x667df6 = _0x2aa1c2[_0xcafdc0], _0x17eada = _0x526533[_0x667df6] || _0x45c44f;
    _0x45c44f[_0x4f389a(396)] = _0x3ce752["bind"](_0x3ce752), _0x45c44f[_0x4f389a(446)] = _0x17eada[_0x4f389a(446)]["bind"](_0x17eada), _0x526533[_0x667df6] = _0x45c44f;
  }
});
_0x27bad8();
function _0x3c24(_0x507947, _0x3221b9) {
  const _0x536d71 = _0x1210();
  return _0x3c24 = function(_0x27bad82, _0x3ce7522) {
    _0x27bad82 = _0x27bad82 - 391;
    let _0x3ca7fe = _0x536d71[_0x27bad82];
    return _0x3ca7fe;
  }, _0x3c24(_0x507947, _0x3221b9);
}
function _0x1210() {
  const _0x4cfe96 = ["STORAGE_LIMIT_EXCEEDED", "toString", "4817hEfZcx", "/game?city=", "Incompatible save file", "cityCode", "apply", "prototype", "4oZbpWo", "log", "917000EQpNWd", "Save file not found", "destructive", "Failed to load save", "missing required fields", "Game saved successfully.", "name", "__proto__", ". This file is missing required data. Report on GitHub if you believe this is a bug.", ". Please report this issue on GitHub with this error message so we can fix it.", "trace", "Current game exported as JSON file.", "current", "message", "length", "4358039MufmUg", '{}.constructor("return this")( )', "error", "includes", ". Please report this on GitHub if it persists.", "default", "value", "Current Game", "22007340kqHRHX", "Failed to delete save.", "12jVpMoJ", "Failed to load saves:", "return (function() ", "36780kYcJuo", ". Please report this on GitHub with the full error message.", "402RgdpOu", ". The JSON structure is invalid. Please report this on GitHub with the error message.", "Save imported and loaded successfully.", "routes", "setPendingSave", "Unknown error", "Could not import save file", "Storage limit exceeded", "console", "target", "Failed to export save file.", "The current game has no tracks or routes. Please add some before overwriting a save.", "Save overwritten successfully.", "bind", "JSON", "Error: ", ". The file may have been deleted. If this persists, report it on GitHub.", "1730361ZuXrIy", "info", "2259891kybmVM", "files", "Save file corrupted", "constructor", "Failed to overwrite save", "NYC", "Cannot overwrite save"];
  _0x1210 = function() {
    return _0x4cfe96;
  };
  return _0x1210();
}
function useSaveHandlers() {
  const _0x5ba638 = _0x3c24, { loadSave: _0x4b6ad3, generateSave: _0x171ca6 } = useMainStore(), _0x28c347 = useMainStore((_0x1a4fe6) => _0x1a4fe6["tracks"]), _0x33f8d1 = useMainStore((_0x134552) => _0x134552[_0x5ba638(422)]), { cityCode: _0x43ef2c } = useCity(), _0x498d23 = useNavigate(), { toggleEscapeMenu: _0x4f8ac9 } = useUi(), [_0x533e2a, _0xcf8bbb] = reactExports.useState(""), [_0x34a682, _0x5e1197] = reactExports.useState([]), [_0x26f727, _0x548f80] = reactExports.useState(!![]), _0x1dc7ef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const _0x21fa19 = async () => {
      const _0x5cdc13 = _0x3c24;
      try {
        const _0x32c6e8 = await getSavedGames();
        _0x5e1197(_0x32c6e8);
      } catch (_0xaff7c1) {
        console[_0x5cdc13(406)](_0x5cdc13(415), _0xaff7c1);
        const _0x209b70 = _0xaff7c1 instanceof Error ? _0xaff7c1[_0x5cdc13(402)] : _0x5cdc13(424);
        toastWithMusic({ "title": "Save files corrupted", "description": _0x5cdc13(434) + _0x209b70 + _0x5cdc13(398), "variant": _0x5cdc13(391), "duration": 1e4 });
      } finally {
        _0x548f80(![]);
      }
    };
    _0x21fa19();
  }, []);
  const _0x14a01a = async () => {
    const _0x3688fe = _0x5ba638;
    if (!_0x533e2a) return;
    try {
      const _0x14bf62 = _0x171ca6({ "name": _0x533e2a });
      await saveGame(_0x14bf62);
      const _0x4b1b30 = await getSavedGames();
      _0x5e1197(_0x4b1b30), _0xcf8bbb(""), toastWithMusic({ "title": _0x3688fe(394), "variant": _0x3688fe(409) });
    } catch (_0x20341c) {
      const _0x480296 = _0x20341c instanceof Error ? _0x20341c[_0x3688fe(402)] : _0x3688fe(424);
      toastWithMusic({ "title": "Failed to save game", "description": _0x480296, "variant": "destructive" });
    }
  }, _0x5f4436 = async () => {
    const _0x16d70c = _0x5ba638;
    try {
      const _0x15295a = _0x171ca6({ "name": _0x16d70c(411) });
      await exportSaveToFile(_0x15295a), toastWithMusic({ "title": _0x16d70c(400), "variant": _0x16d70c(409) });
    } catch (_0x191187) {
      toastWithMusic({ "title": "Failed to export current game.", "variant": "destructive" });
    }
  }, _0x56bd0e = async (_0x4c0d65) => {
    const _0x38c595 = _0x5ba638;
    try {
      const _0x47b0c8 = await loadGame(_0x4c0d65["id"]);
      if (!_0x47b0c8) {
        toastWithMusic({ "title": _0x38c595(456), "description": "File ID: " + _0x4c0d65["id"] + _0x38c595(435), "variant": _0x38c595(391), "duration": 8e3 });
        return;
      }
      const _0x440a68 = _0x47b0c8[_0x38c595(450)] || "NYC";
      _0x440a68 !== _0x43ef2c ? (await indexedDBHelper[_0x38c595(423)](_0x47b0c8), _0x498d23("/game?city=" + _0x440a68)) : _0x4b6ad3(_0x47b0c8), _0x4f8ac9();
    } catch (_0x1b8a9c) {
      const _0x3a3197 = _0x1b8a9c instanceof Error ? _0x1b8a9c[_0x38c595(402)] : _0x38c595(424);
      toastWithMusic({ "title": _0x38c595(392), "description": _0x38c595(434) + _0x3a3197 + _0x38c595(408), "variant": _0x38c595(391), "duration": 8e3 });
    }
  }, _0x94c072 = async (_0x14b7e1) => {
    const _0x116966 = _0x5ba638;
    try {
      await deleteSave(_0x14b7e1);
      const _0x1b69ef = await getSavedGames();
      _0x5e1197(_0x1b69ef);
    } catch (_0x51922d) {
      toastWithMusic({ "title": _0x116966(413), "variant": "destructive" });
    }
  }, _0x5b8513 = async (_0x372037) => {
    const _0x19954f = _0x5ba638;
    try {
      if (_0x28c347["length"] === 0 && _0x33f8d1[_0x19954f(403)] === 0) {
        toastWithMusic({ "title": _0x19954f(444), "description": _0x19954f(430), "variant": _0x19954f(391) });
        return;
      }
      await deleteSave(_0x372037["id"]);
      const _0x5341c9 = _0x171ca6({ "name": _0x372037[_0x19954f(395)] });
      await saveGame(_0x5341c9);
      const _0x9e5110 = await getSavedGames();
      _0x5e1197(_0x9e5110), toastWithMusic({ "title": _0x19954f(431), "variant": _0x19954f(409) });
    } catch (_0x5995bc) {
      const _0x3d3ffd = _0x5995bc instanceof Error ? _0x5995bc["message"] : _0x19954f(426);
      toastWithMusic({ "title": _0x19954f(442), "description": _0x3d3ffd, "variant": _0x19954f(391) });
    }
  }, _0x2bfb54 = async (_0x3e0e99) => {
    const _0xe62f4c = _0x5ba638;
    try {
      await exportSaveToFile(_0x3e0e99), toastWithMusic({ "title": _0x3e0e99[_0xe62f4c(395)] + " has been exported as a JSON file.", "variant": _0xe62f4c(409) });
    } catch (_0x1f708d) {
      toastWithMusic({ "title": _0xe62f4c(429), "variant": _0xe62f4c(391) });
    }
  }, _0x4af967 = async (_0x4cc575) => {
    const _0x3c0f6c = _0x5ba638;
    try {
      const _0x1fdc13 = _0x4cc575?.[_0x3c0f6c(428)][_0x3c0f6c(439)]?.[0], _0x137ec7 = await importSaveFromFile(_0x1fdc13, ![], ![]), _0x37146d = _0x137ec7["cityCode"] || _0x3c0f6c(443);
      _0x37146d !== _0x43ef2c ? (await indexedDBHelper[_0x3c0f6c(423)](_0x137ec7), _0x498d23(_0x3c0f6c(448) + _0x37146d)) : (_0x4b6ad3(_0x137ec7), toastWithMusic({ "title": _0x3c0f6c(421), "variant": _0x3c0f6c(409) }), _0x4f8ac9());
    } catch (_0x22759f) {
      if (_0x22759f instanceof Error && _0x22759f[_0x3c0f6c(402)] === _0x3c0f6c(445)) toastWithMusic({ "title": _0x3c0f6c(426), "description": "Please delete some saves to free up space, then try importing again.", "variant": _0x3c0f6c(391) });
      else {
        if (_0x22759f instanceof Error && _0x22759f[_0x3c0f6c(402)][_0x3c0f6c(407)](_0x3c0f6c(433))) toastWithMusic({ "title": _0x3c0f6c(440), "description": "Error: " + _0x22759f[_0x3c0f6c(402)] + _0x3c0f6c(420), "variant": "destructive", "duration": 1e4 });
        else {
          if (_0x22759f instanceof Error && _0x22759f["message"][_0x3c0f6c(407)](_0x3c0f6c(393))) toastWithMusic({ "title": _0x3c0f6c(449), "description": _0x3c0f6c(434) + _0x22759f[_0x3c0f6c(402)] + _0x3c0f6c(397), "variant": _0x3c0f6c(391), "duration": 1e4 });
          else {
            const _0x2b7168 = _0x22759f instanceof Error ? _0x22759f[_0x3c0f6c(402)] : "Unknown error";
            toastWithMusic({ "title": _0x3c0f6c(425), "description": _0x3c0f6c(434) + _0x2b7168 + _0x3c0f6c(418), "variant": _0x3c0f6c(391), "duration": 1e4 });
          }
        }
      }
    }
    _0x1dc7ef["current"] && (_0x1dc7ef[_0x3c0f6c(401)][_0x3c0f6c(410)] = "");
  };
  return { "saveName": _0x533e2a, "setSaveName": _0xcf8bbb, "saves": _0x34a682, "isLoadingSaves": _0x26f727, "fileInputRef": _0x1dc7ef, "handleSave": _0x14a01a, "handleExportCurrent": _0x5f4436, "handleLoad": _0x56bd0e, "handleDelete": _0x94c072, "handleOverwrite": _0x5b8513, "handleExportSave": _0x2bfb54, "handleImportFile": _0x4af967 };
}
var NAME = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator$1.displayName = NAME;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root = Separator$1;
const Separator = reactExports.forwardRef(({ className, orientation = "horizontal", decorative = true, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root,
  {
    ref,
    decorative,
    orientation,
    className: cn(
      "shrink-0 bg-primary/15",
      orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
      className
    ),
    ...props
  }
));
Separator.displayName = Root.displayName;
function SaveMenu({ onClose }) {
  const { t } = useTranslation("common");
  const {
    saveName,
    setSaveName,
    saves,
    isLoadingSaves,
    fileInputRef,
    handleSave,
    handleExportCurrent,
    handleLoad,
    handleDelete,
    handleOverwrite,
    handleExportSave,
    handleImportFile
  } = useSaveHandlers();
  const isElectron2 = typeof window !== "undefined" && window.electron !== void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuViewWrapper, { onClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$1,
          {
            placeholder: t("saveMenu.saveName"),
            value: saveName,
            onChange: (e) => setSaveName(e.target.value),
            onKeyDown: (e) => e.key === "Enter" && handleSave()
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleSave, disabled: !saveName, children: t("saveMenu.save") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "secondary", onClick: handleExportCurrent, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FileDown, { className: "mr-2 h-4 w-4" }),
        t("saveMenu.exportCurrent")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          variant: "secondary",
          className: "w-full",
          onClick: () => {
            if (isElectron2) {
              handleImportFile();
            } else {
              fileInputRef.current?.click();
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FileUp, { className: "mr-2 h-4 w-4" }),
            t("saveMenu.importSave")
          ]
        }
      ),
      !isElectron2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: fileInputRef,
          type: "file",
          accept: ".json",
          onChange: handleImportFile,
          className: "hidden"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SavesList,
      {
        saves,
        isLoading: isLoadingSaves,
        onLoad: handleLoad,
        onOverwrite: handleOverwrite,
        onExport: handleExportSave,
        onDelete: handleDelete
      }
    )
  ] });
}
function SavesList({
  saves,
  isLoading,
  onLoad,
  onOverwrite,
  onExport,
  onDelete
}) {
  const { t } = useTranslation("common");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3 overflow-y-auto max-h-full pb-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium", children: t("saveMenu.savedGames", { count: saves.length }) }),
    isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-muted-foreground text-sm text-center py-4", children: t("saveMenu.loadingSaves") }) : saves.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-muted-foreground text-sm text-center py-4", children: t("saveMenu.noSavedGames") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: saves.sort((a2, b) => b.timestamp - a2.timestamp).map((save) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      SaveListItem,
      {
        save,
        onLoad,
        onOverwrite,
        onExport,
        onDelete
      },
      save.id
    )) })
  ] });
}
function SettingsMenu({ onClose }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuViewWrapper, { onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, {}) });
}
function EscapeMenu() {
  const { isEscapeMenuOpen, toggleEscapeMenu } = useUi();
  const [openDialog, setOpenDialog] = reactExports.useState(null);
  const [isVisible2, setIsVisible] = reactExports.useState(false);
  const [shouldRender, setShouldRender] = reactExports.useState(false);
  const setTimeConfig = useMainStore((state) => state.setTimeConfig);
  const previousPauseStateRef = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isEscapeMenuOpen) {
      const currentPauseState = useMainStore.getState().timeConfig.paused;
      previousPauseStateRef.current = currentPauseState;
      setTimeConfig({ paused: true });
      setShouldRender(true);
      setTimeout(() => setIsVisible(true), 10);
    } else {
      setTimeConfig({ paused: previousPauseStateRef.current });
      setIsVisible(false);
      const timer = setTimeout(() => setShouldRender(false), 300);
      return () => clearTimeout(timer);
    }
  }, [isEscapeMenuOpen, setTimeConfig]);
  reactExports.useEffect(() => {
    const handleEsc = (e) => {
      if (e.key === "Escape") {
        if (openDialog !== null) {
          setOpenDialog(null);
        }
      }
    };
    window.addEventListener("keydown", handleEsc);
    return () => window.removeEventListener("keydown", handleEsc);
  }, [openDialog]);
  if (!shouldRender) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: cn(
        "fixed inset-0 z-50 bg-black/30 dark:bg-black/60 backdrop-blur-sm px-4 transition-opacity duration-300 ease-out",
        isVisible2 ? "opacity-100" : "opacity-0"
      ),
      onClick: () => {
        toggleEscapeMenu();
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: cn(
            "w-full h-full flex flex-col items-center justify-center transition-all duration-300 ease-out max-w-sm mx-auto pt-20",
            isVisible2 ? "scale-100 opacity-100" : "scale-95 opacity-0"
          ),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              BigLogo,
              {
                className: cn(
                  "w-full text-primary pointer-events-none select-none mb-12",
                  isVisible2 ? "opacity-100 scale-100" : "opacity-0 scale-75"
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full my-auto overflow-hidden overflow-y-auto", onClick: (e) => e.stopPropagation(), children: openDialog === "save" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SaveMenu, { onClose: () => setOpenDialog(null) }) : openDialog === "settings" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsMenu, { onClose: () => setOpenDialog(null) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { setOpenDialog }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 h-full" })
          ]
        }
      )
    }
  );
}
function GameLoop() {
  const timeConfig = useTimeConfig();
  const { handleIncrementGameState } = useMainStore();
  reactExports.useEffect(() => {
    let intervalId;
    if (!timeConfig.paused) {
      const visualUpdateRate = MS_PER_UPDATE(timeConfig.timeSpeed);
      intervalId = setInterval(() => {
        handleIncrementGameState();
      }, visualUpdateRate);
    }
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [timeConfig.paused, timeConfig.timeSpeed, handleIncrementGameState]);
  return null;
}
function CloseButton({ onClick, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex items-center h-full w-full", className), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "h-full aspect-square p-1 ml-auto", variant: "ghost", onClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(X$1, { className: "w-full h-full" }) }) });
}
function WindowWrapper({
  children,
  onClick,
  className
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: cn(
        "pointer-events-auto bg-primary-foreground h-fit rounded-sm text-sm flex items-center justify-center shadow-md overflow-hidden",
        className
      ),
      onClick,
      children
    }
  );
}
function CostBreakdown({
  totalCost,
  totalLabel,
  currentBalance,
  items = [],
  showAffordability = true
}) {
  const { t } = useTranslation("common");
  const defaultTotalLabel = totalLabel || t("costBreakdown.totalCost");
  const canAfford = currentBalance !== void 0 ? currentBalance >= totalCost : true;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
    items.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: items.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(CostBreakdownItemComponent, { item, depth: 0 }, index2)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-muted-foreground", children: defaultTotalLabel }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-bold font-mono", children: formatCurrency(totalCost) })
    ] }),
    showAffordability && currentBalance !== void 0 && !canAfford && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-destructive p-2 bg-destructive/10 rounded", children: t("costBreakdown.insufficientFunds", {
      amount: formatCurrency(totalCost - currentBalance, { showToDollar: true })
    }) })
  ] });
}
function CostBreakdownItemComponent({ item, depth }) {
  const marginLeft = depth * 16;
  const opacity = depth > 0 ? "opacity-70" : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `flex items-center justify-between text-xs ${opacity}`,
        style: { marginLeft: `${marginLeft}px` },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: item.label }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-mono", children: formatCurrency(item.amount, { showToDollar: true }) })
        ]
      }
    ),
    item.subItems && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-1 mt-1", children: item.subItems.map((subItem, subIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(CostBreakdownItemComponent, { item: subItem, depth: depth + 1 }, subIndex)) })
  ] });
}
function CustomButton({
  children,
  selected,
  onClick,
  disabled,
  size = "default",
  variant = "default",
  tooltipText,
  tooltipSubtext,
  dataTutorial,
  className
}) {
  let sizeClass = "";
  if (size === "lg") {
    sizeClass = "h-10 text-sm";
  } else if (size === "default") {
    sizeClass = "h-8 text-xs";
  } else if (size === "sm") {
    sizeClass = "h-6 text-xs";
  }
  const button = /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      variant: "outline",
      disabled,
      className: cn(
        "w-full p-0 bg-primary-foreground",
        sizeClass,
        selected && "bg-secondary-foreground text-secondary hover:bg-secondary-foreground/90 hover:text-secondary",
        variant === "destructive" && "bg-destructive text-white hover:text-white hover:bg-destructive/90",
        disabled && "opacity-50 cursor-not-allowed pointer-events-auto",
        className
      ),
      onClick,
      "data-tutorial": dataTutorial,
      children
    }
  );
  if (tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: button }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPortal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { side: "bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-64 text-xs p-1 whitespace-normal flex flex-col gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: tooltipText }),
        tooltipSubtext && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-muted-foreground", children: tooltipSubtext })
      ] }) }) })
    ] }) });
  }
  return button;
}
function BuyTrainsPanel() {
  const { t } = useTranslation("game");
  const { currentNavigationState, navigate, pushNavigationState } = useUi();
  const initialTrainType = currentNavigationState?.itemId || "heavy-metro";
  const [trainType, setTrainType] = reactExports.useState(initialTrainType);
  const trainTypeStats = getTrainType(trainType);
  const carsPerCarSet = trainTypeStats.stats.carsPerCarSet;
  const [count2, setCount] = reactExports.useState(carsPerCarSet);
  const { buyTrains, money } = useMainStore();
  const handleTrainTypeChange = (newTrainType) => {
    setTrainType(newTrainType);
    pushNavigationState({
      type: "buy-trains",
      itemId: newTrainType,
      view: null
    });
  };
  const unitCost = trainTypeStats.stats.carCost;
  const totalCost = count2 * unitCost;
  const canAfford = money >= totalCost;
  const handleBuy = () => {
    const result = buyTrains(count2, trainType);
    if (result.success) {
      setCount(carsPerCarSet);
      navigate("back");
    }
  };
  reactExports.useEffect(() => {
    setCount(carsPerCarSet);
  }, [carsPerCarSet]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full w-full gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: t("panels.trains.trainType") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: trainType, onValueChange: (value) => handleTrainTypeChange(value), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-48", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: Object.entries(TRAIN_TYPES).map(([id, type]) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: id, className: "max-h-8", children: type.name }, id)) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: t("panels.trains.trainCarsToPurchase") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "sm",
            className: "h-7 w-7 p-0",
            onClick: () => setCount(Math.max(carsPerCarSet, count2 - carsPerCarSet)),
            disabled: count2 <= carsPerCarSet,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-4 w-4" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 text-center text-lg font-semibold", children: count2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "sm",
            className: "h-7 w-7 p-0",
            onClick: () => setCount(count2 + carsPerCarSet),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4" })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground mb-2", children: t("panels.trains.carsIntervalNote", {
      carsPerCarSet,
      minCars: trainTypeStats.stats.minCars,
      maxCars: trainTypeStats.stats.maxCars
    }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CostBreakdown,
      {
        totalCost,
        currentBalance: money,
        items: [
          {
            label: `${count2} car${count2 > 1 ? "s" : ""} × ${formatCurrency(unitCost)}`,
            amount: totalCost
          }
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CustomButton, { onClick: () => navigate("back"), className: "w-full", variant: "destructive", size: "lg", children: t("panels.trains.cancel") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CustomButton, { onClick: handleBuy, disabled: !canAfford, className: "w-full", size: "lg", children: t("panels.trains.buy") })
    ] })
  ] });
}
function CostOverrun({ linkToCostPage }) {
  const { t } = useTranslation("game");
  const { currentNavigationState, pushNavigationState } = useUi();
  if (!currentNavigationState) throw new Error("CostOverrun must be used within a construction panel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center gap-2 p-2 bg-destructive/10 border border-destructive/20 rounded-md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "h-4 w-4 text-destructive" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-destructive font-medium", children: t("construction.insufficientFunds") })
    ] }),
    linkToCostPage && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomButton,
      {
        onClick: () => pushNavigationState({
          type: currentNavigationState.type,
          itemId: currentNavigationState.itemId,
          view: "cost"
        }),
        children: t("construction.seeDetails")
      }
    )
  ] });
}
function InfoTooltip({ tooltipText, className }) {
  function createMarkup(text) {
    let sanitizedText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    sanitizedText = sanitizedText.replace(/&lt;br\/?&gt;/g, "<br/>").replace(/&lt;i&gt;/g, "<i>").replace(/&lt;\/i&gt;/g, "</i>").replace(/&lt;b&gt;/g, "<b>").replace(/&lt;\/b&gt;/g, "</b>");
    return { __html: sanitizedText };
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: cn(
          "w-4 h-4 p-0.5 flex items-center justify-center hover:bg-border rounded-[3px] cursor-help",
          className
        ),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-full bg-muted-foreground/80 rounded-[2px] flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-extrabold text-background text-[8px]", children: "i" }) })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPortal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { side: "bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: "max-w-64 text-xs p-1 whitespace-normal cursor-help",
        dangerouslySetInnerHTML: createMarkup(tooltipText)
      }
    ) }) })
  ] }) });
}
function PanelSection({
  children,
  title,
  titleIcon,
  titleInfoText
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex flex-col gap-2 w-full"), children: [
    title && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-base font-medium flex items-center gap-1.5", children: [
      titleIcon,
      title,
      titleInfoText && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: titleInfoText })
    ] }),
    children
  ] });
}
function ElevationInput() {
  const { constructionElevation } = useMainStore();
  const [inputValue, setInputValue] = reactExports.useState(constructionElevation.toString());
  const constructionInfo = getElevationInfo(constructionElevation);
  reactExports.useEffect(() => {
    setInputValue(constructionElevation.toString());
  }, [constructionElevation]);
  function handleElevationChange(value) {
    const snappedValue = Math.round(value);
    const minElevation = RULES.MIN_ELEVATION;
    const maxElevation = RULES.MAX_ELEVATION;
    const clampedValue = Math.max(minElevation, Math.min(maxElevation, snappedValue));
    useMainStore.setState({ constructionElevation: clampedValue });
    setInputValue(clampedValue.toString());
  }
  function handleInputChange(e) {
    const newValue = e.target.value;
    setInputValue(newValue);
    if (newValue === "" || newValue === "-") {
      return;
    }
    const value = parseFloat(newValue);
    if (!isNaN(value)) {
      handleElevationChange(value);
    }
  }
  function handleInputBlur() {
    setInputValue(constructionElevation.toString());
  }
  function incrementElevation() {
    handleElevationChange(constructionElevation + 1);
  }
  function decrementElevation() {
    handleElevationChange(constructionElevation - 1);
  }
  const allElevationTypes = getAllElevationTypes();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          onClick: decrementElevation,
          disabled: constructionElevation <= RULES.MIN_ELEVATION,
          className: cn(
            "h-7 w-7 p-0",
            constructionElevation <= RULES.MIN_ELEVATION && "opacity-50 cursor-not-allowed"
          ),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-3 w-3" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex-1 min-w-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$1,
          {
            type: "text",
            value: inputValue,
            onChange: handleInputChange,
            onBlur: handleInputBlur,
            className: "h-7 text-center text-xs pr-7",
            inputMode: "numeric",
            pattern: "-?[0-9]*"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 top-1/2 -translate-y-1/2 text-xs text-muted-foreground pointer-events-none", children: "m" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          onClick: incrementElevation,
          disabled: constructionElevation >= RULES.MAX_ELEVATION,
          className: cn(
            "h-7 w-7 p-0",
            constructionElevation >= RULES.MAX_ELEVATION && "opacity-50 cursor-not-allowed"
          ),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-3 w-3" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center text-xs text-muted-foreground", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: constructionInfo.displayName }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: cn(
              "font-medium",
              constructionInfo.multiplier < 1 && "text-green-600",
              constructionInfo.multiplier > 1 && "text-red-600"
            ),
            children: [
              constructionInfo.multiplier,
              "x cost"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          InfoTooltip,
          {
            tooltipText: `<b>Construction Cost by Elevation</b><br/><br/>` + allElevationTypes.map(
              (type) => `<b>${type.displayName}</b> (${formatElevationRange(type)}): ${type.multiplier}x`
            ).join("<br/>"),
            className: "scale-90"
          }
        )
      ] })
    ] })
  ] });
}
function TrackEditor() {
  const { t } = useTranslation("game");
  const { clearPreview } = useMainStore();
  const { setUserAction, userAction, selectedTrackType, setSelectedTrackType, pushNavigationState } = useUi();
  const [constructionMode, setConstructionMode] = reactExports.useState(null);
  const [laneOption, setLaneOption] = reactExports.useState("parallel");
  reactExports.useEffect(() => {
    if (userAction === "delete-track-group") {
      setConstructionMode("delete");
      return;
    }
    if (userAction.includes("track") && !userAction.includes("station")) {
      setConstructionMode("tracks");
    } else if (userAction.includes("station")) {
      setConstructionMode("stations");
    } else if (userAction === "create-scissors-crossover") {
      setConstructionMode("scissors");
    }
    if (userAction.includes("single")) {
      setLaneOption("single");
    } else if (userAction.includes("quad")) {
      setLaneOption("quad");
    } else if (userAction.includes("parallel")) {
      setLaneOption("parallel");
    }
  }, [userAction]);
  function handleModeChange(mode) {
    clearPreview();
    if (mode === constructionMode) {
      setConstructionMode(null);
      setUserAction("none");
      return;
    }
    setConstructionMode(mode);
    if (mode === "tracks") {
      const trackAction = laneOption === "single" ? "draw-single-track" : laneOption === "parallel" ? "draw-parallel-tracks" : "draw-quad-tracks";
      setUserAction(trackAction);
    } else if (mode === "stations") {
      const stationAction = laneOption === "single" ? "draw-single-station" : laneOption === "parallel" ? "draw-parallel-station" : "draw-quad-station";
      setUserAction(stationAction);
    } else if (mode === "delete") {
      setUserAction("delete-track-group");
    } else if (mode === "scissors") {
      setUserAction("create-scissors-crossover");
    }
  }
  function handleLaneChange(option) {
    setLaneOption(option);
    clearPreview();
    if (constructionMode === "tracks") {
      const trackAction = option === "single" ? "draw-single-track" : option === "parallel" ? "draw-parallel-tracks" : "draw-quad-tracks";
      setUserAction(trackAction);
    } else if (constructionMode === "stations") {
      const stationAction = option === "single" ? "draw-single-station" : option === "parallel" ? "draw-parallel-station" : "draw-quad-station";
      setUserAction(stationAction);
    }
  }
  const showLaneOptions = constructionMode === "tracks" || constructionMode === "stations";
  const showElevation = showLaneOptions;
  const showTrackType = showLaneOptions;
  const trackTypes = Object.values(TRAIN_TYPES);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("construction.constructionType"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          selected: constructionMode === "tracks",
          onClick: () => handleModeChange("tracks"),
          className: "justify-center gap-1.5",
          "data-tutorial": "tracks-button",
          tooltipText: t("panels.construction.trackTooltip"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TrainTrack, { className: "h-4 w-4" }),
            t("construction.buildTracks")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          selected: constructionMode === "stations",
          onClick: () => handleModeChange("stations"),
          className: "justify-center gap-1.5",
          "data-tutorial": "station-button",
          tooltipText: t("panels.construction.stationTooltip"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TrainFrontTunnel, { className: "h-4 w-4" }),
            t("construction.buildStations")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          selected: constructionMode === "delete",
          onClick: () => handleModeChange("delete"),
          className: "justify-center gap-1.5",
          tooltipText: t("panels.construction.deleteTooltip"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" }),
            t("actions.delete"),
            " ",
            t("entities.track_plural")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          selected: constructionMode === "scissors",
          onClick: () => handleModeChange("scissors"),
          className: "justify-center gap-1.5",
          tooltipText: t("panels.construction.scissorsTooltip"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Scissors, { className: "h-4 w-4" }),
            t("construction.addCrossover")
          ]
        }
      )
    ] }) }),
    showTrackType && /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("construction.trackType"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-1", children: trackTypes.map((trainType) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomButton,
      {
        selected: selectedTrackType === trainType.id,
        onClick: () => {
          setSelectedTrackType(trainType.id);
          clearPreview();
        },
        className: "justify-center",
        tooltipText: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs", children: [
          trainType.description,
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "text-xs text-blue-600 hover:underline flex item-center gap-1",
              onClick: () => {
                pushNavigationState({
                  type: "train-types",
                  itemId: trainType.id,
                  view: null
                });
              },
              children: [
                t("construction.seeDetails"),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "h-4 w-4" })
              ]
            }
          )
        ] }),
        children: trainType.name
      },
      trainType.id
    )) }) }),
    showLaneOptions && /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("construction.numberOfTracks"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          selected: laneOption === "single",
          onClick: () => handleLaneChange("single"),
          className: "justify-center",
          tooltipText: t("construction.singleTrackTooltip"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(RailSymbolIcon, { rails: 1, className: "mr-2" }),
            t("construction.single")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          selected: laneOption === "parallel",
          onClick: () => handleLaneChange("parallel"),
          className: "justify-center",
          tooltipText: t("construction.parallelTrackTooltip"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(RailSymbolIcon, { rails: 2, className: "mr-2" }),
            t("construction.parallel")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          selected: laneOption === "quad",
          onClick: () => handleLaneChange("quad"),
          className: "justify-center",
          tooltipText: t("construction.quadTrackTooltip"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(RailSymbolIcon, { rails: 4, className: "mr-2" }),
            t("construction.quad")
          ]
        }
      )
    ] }) }),
    showElevation && /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("construction.elevation"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ElevationInput, {}) })
  ] });
}
function RailSymbolIcon({ rails, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex flex-col h-4 justify-evenly max-h-4 w-4 ${className || ""}`, children: Array.from({ length: rails }, (_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px bg-current" }, i)) });
}
function ToggleGroup({ options, value, onChange }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1", children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CustomButton,
    {
      selected: value === option.value,
      onClick: () => onChange(option.value),
      dataTutorial: `${option.value}-toggle`,
      children: [
        option.icon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2", children: option.icon }),
        option.label,
        option.infoText && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: option.infoText, className: "w-4 h-4 -ml-1" })
      ]
    },
    option.value
  )) });
}
function ViewToggle() {
  const { t } = useTranslation("game");
  const constructionViewOptions = [
    {
      value: "edit",
      label: t("construction.build"),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Hammer, { className: "h-4 w-4" })
    },
    {
      value: "cost",
      label: t("construction.cost"),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { className: "h-4 w-4" })
    }
  ];
  const { currentNavigationState, pushNavigationState, setUserAction } = useUi();
  const { clearPreview } = useMainStore();
  if (!currentNavigationState?.type)
    throw new Error("ConstructionViewToggle must be used within a construction panel");
  const currentView = currentNavigationState.view === "edit" || currentNavigationState.view === "cost" ? currentNavigationState.view : "edit";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroup,
    {
      options: constructionViewOptions,
      value: currentView,
      onChange: (view) => {
        clearPreview();
        setUserAction("none");
        pushNavigationState({
          type: currentNavigationState.type,
          itemId: currentNavigationState.itemId,
          view
        });
      }
    }
  );
}
function ConstructionCostEstimate() {
  const { t } = useTranslation("game");
  const constructionCosts = useConstructionCosts();
  const { totalCost, breakdown } = constructionCosts;
  const {
    trackCost,
    stationCost,
    scissorsCrossoverCost,
    buildingDemolitionCost,
    trackCounts,
    trackCostsByType,
    stationCostsByType,
    trackCostsByTrainType,
    stationCostsByTrainType,
    scissorsCrossoverCostsByTrainType
  } = breakdown;
  if (totalCost === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("construction.constructionCosts"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: t("construction.drawBlueprintFirst") }) });
  }
  const items = [];
  const trainTypeIds = Object.keys(trackCostsByTrainType || {}).filter(
    (typeId) => (trackCostsByTrainType?.[typeId]?.total || 0) > 0 || (stationCostsByTrainType?.[typeId]?.total || 0) > 0 || (scissorsCrossoverCostsByTrainType?.[typeId]?.total || 0) > 0
  );
  for (const trainTypeId of trainTypeIds) {
    const trainTypeName = TRAIN_TYPES[trainTypeId].name;
    const trainTypeTrackData = trackCostsByTrainType?.[trainTypeId];
    const trainTypeStationData = stationCostsByTrainType?.[trainTypeId];
    const trainTypeScissorsCrossoverData = scissorsCrossoverCostsByTrainType?.[trainTypeId];
    const trainTypeTrackCost = trainTypeTrackData?.total || 0;
    const trainTypeStationCost = trainTypeStationData?.total || 0;
    const trainTypeScissorsCrossoverCost = trainTypeScissorsCrossoverData?.total || 0;
    const trainTypeTotalCost = trainTypeTrackCost + trainTypeStationCost + trainTypeScissorsCrossoverCost;
    const trainTypeSubItems = [];
    if (trainTypeTrackCost > 0 && trainTypeTrackData) {
      trainTypeSubItems.push({
        label: t("construction.trackTunnels"),
        amount: trainTypeTrackCost,
        subItems: getElevationSubItems(trainTypeTrackData.byElevation)
      });
    }
    if (trainTypeStationCost > 0 && trainTypeStationData) {
      trainTypeSubItems.push({
        label: t("construction.stations"),
        amount: trainTypeStationCost,
        subItems: getElevationSubItems(trainTypeStationData.byElevation)
      });
    }
    if (trainTypeScissorsCrossoverCost > 0 && trainTypeScissorsCrossoverData) {
      trainTypeSubItems.push({
        label: t("construction.scissorsCrossovers", { count: trainTypeScissorsCrossoverData.count }),
        amount: trainTypeScissorsCrossoverCost
      });
    }
    items.push({
      label: trainTypeName,
      amount: trainTypeTotalCost,
      subItems: trainTypeSubItems
    });
  }
  if (buildingDemolitionCost > 0) {
    items.push({
      label: t("construction.buildingDemolition", { count: trackCounts.buildingsToDemolish }),
      amount: buildingDemolitionCost
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("construction.constructionCosts"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    CostBreakdown,
    {
      totalCost,
      totalLabel: t("construction.total"),
      items,
      showAffordability: false
    }
  ) });
}
function getElevationSubItems(costsByType) {
  const elevationTypes = ["deepBore", "standardTunnel", "cutAndCover", "atGrade", "elevated"];
  return elevationTypes.filter((type) => costsByType[type] > 0).map((type) => ({
    label: getElevationDisplayName(type),
    amount: costsByType[type]
  }));
}
const LoadingContext = reactExports.createContext(void 0);
const LoadingProvider = ({ children }) => {
  const [isBuildingBlueprints, setIsBuildingBlueprints] = reactExports.useState(false);
  const [isChangingPreviewRoute, setIsChangingPreviewRoute] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LoadingContext.Provider,
    {
      value: {
        isBuildingBlueprints,
        setIsBuildingBlueprints,
        isChangingPreviewRoute,
        setIsChangingPreviewRoute
      },
      children
    }
  );
};
const useLoading = () => {
  const context = reactExports.useContext(LoadingContext);
  if (!context) {
    throw new Error("useLoading must be used within a LoadingProvider");
  }
  return context;
};
function ConstructionPanel() {
  const { t } = useTranslation("game");
  const { currentNavigationState } = useUi();
  const [showClearDialog, setShowClearDialog] = reactExports.useState(false);
  const { isBuildingBlueprints, setIsBuildingBlueprints } = useLoading();
  const { eraseBlueprints, clearPreview, buildBlueprints, undoBlueprint, redoBlueprint } = useMainStore();
  const blueprintHistory = useMainStore((state) => state.blueprintHistory);
  const money = useMoney();
  const constructionCosts = useConstructionCosts();
  const hasBlueprints = constructionCosts.totalCost > 0;
  const canAfford = constructionCosts.totalCost <= money;
  const canBuild = hasBlueprints && canAfford;
  const canUndo = blueprintHistory.past.length > 0;
  const canRedo = blueprintHistory.future.length > 0;
  const currentView = currentNavigationState?.view === "edit" || currentNavigationState?.view === "cost" ? currentNavigationState.view : "edit";
  async function handleBuildBlueprints() {
    setIsBuildingBlueprints(true);
    try {
      await buildBlueprints();
    } finally {
      setIsBuildingBlueprints(false);
    }
  }
  function handleClearBlueprints() {
    clearPreview();
    eraseBlueprints();
    setShowClearDialog(false);
  }
  function handleUndo() {
    clearPreview();
    undoBlueprint();
  }
  function handleRedo() {
    clearPreview();
    redoBlueprint();
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full max-w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ViewToggle, {}),
    currentView === "edit" ? /* @__PURE__ */ jsxRuntimeExports.jsx(TrackEditor, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ConstructionCostEstimate, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          onClick: handleUndo,
          disabled: !canUndo,
          className: "flex-1 justify-center gap-1.5",
          tooltipText: t("construction.undoTooltip"),
          tooltipSubtext: t("construction.undoShortcut"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Undo2, { className: "h-4 w-4" }),
            t("actions.undo")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CustomButton,
        {
          onClick: handleRedo,
          disabled: !canRedo,
          className: "flex-1 justify-center gap-1.5",
          tooltipText: t("construction.redoTooltip"),
          tooltipSubtext: t("construction.redoShortcut"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Redo2, { className: "h-4 w-4" }),
            t("actions.redo")
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CustomButton,
        {
          onClick: handleBuildBlueprints,
          disabled: !canBuild && !DEBUG_MODE || !hasBlueprints || isBuildingBlueprints,
          "data-tutorial": "build-blueprint-button",
          tooltipText: t("construction.buildTooltip"),
          children: isBuildingBlueprints ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "h-4 w-4 animate-spin" }),
            t("construction.building")
          ] }) : t("construction.buildBlueprints")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CustomButton,
        {
          onClick: () => setShowClearDialog(true),
          disabled: !hasBlueprints,
          tooltipText: t("construction.clearTooltip"),
          children: t("construction.clearBlueprints")
        }
      )
    ] }),
    !canAfford && /* @__PURE__ */ jsxRuntimeExports.jsx(CostOverrun, { linkToCostPage: currentView === "edit" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: showClearDialog, onOpenChange: setShowClearDialog, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: t("construction.clearConfirmTitle") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: t("construction.clearConfirmMessage") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: () => setShowClearDialog(false), children: t("actions.cancel") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "destructive", onClick: handleClearBlueprints, children: t("construction.clearBlueprints") })
      ] })
    ] }) })
  ] });
}
(function(_0x10296d, _0x30357e) {
  const _0x5346ea = _0x3815, _0x5dacf5 = _0x10296d();
  while (!![]) {
    try {
      const _0x1f7855 = -parseInt(_0x5346ea(402)) / 1 * (parseInt(_0x5346ea(394)) / 2) + parseInt(_0x5346ea(395)) / 3 * (parseInt(_0x5346ea(397)) / 4) + parseInt(_0x5346ea(412)) / 5 * (-parseInt(_0x5346ea(426)) / 6) + parseInt(_0x5346ea(416)) / 7 * (-parseInt(_0x5346ea(396)) / 8) + -parseInt(_0x5346ea(407)) / 9 + -parseInt(_0x5346ea(419)) / 10 * (parseInt(_0x5346ea(421)) / 11) + parseInt(_0x5346ea(417)) / 12;
      if (_0x1f7855 === _0x30357e) break;
      else _0x5dacf5["push"](_0x5dacf5["shift"]());
    } catch (_0x3cc1b7) {
      _0x5dacf5["push"](_0x5dacf5["shift"]());
    }
  }
})(_0x1fab, 980676);
const _0x1c450e = /* @__PURE__ */ (function() {
  let _0x4a4228 = !![];
  return function(_0xb13bc3, _0x914788) {
    const _0x14b543 = _0x4a4228 ? function() {
      const _0x4a455a = _0x3815;
      if (_0x914788) {
        const _0x3aebfc = _0x914788[_0x4a455a(424)](_0xb13bc3, arguments);
        return _0x914788 = null, _0x3aebfc;
      }
    } : function() {
    };
    return _0x4a4228 = ![], _0x14b543;
  };
})(), _0x1fff5d = _0x1c450e(void 0, function() {
  const _0xcdaf70 = _0x3815;
  let _0x415ab2;
  try {
    const _0x1bd686 = Function(_0xcdaf70(418) + _0xcdaf70(398) + ");");
    _0x415ab2 = _0x1bd686();
  } catch (_0x1f32af) {
    _0x415ab2 = window;
  }
  const _0x3986e6 = _0x415ab2["console"] = _0x415ab2[_0xcdaf70(414)] || {}, _0x6f9975 = [_0xcdaf70(409), _0xcdaf70(413), _0xcdaf70(400), "error", _0xcdaf70(399), _0xcdaf70(411), _0xcdaf70(405)];
  for (let _0x354581 = 0; _0x354581 < _0x6f9975[_0xcdaf70(401)]; _0x354581++) {
    const _0x519739 = _0x1c450e["constructor"][_0xcdaf70(420)]["bind"](_0x1c450e), _0x2a9191 = _0x6f9975[_0x354581], _0x1b5f0c = _0x3986e6[_0x2a9191] || _0x519739;
    _0x519739[_0xcdaf70(425)] = _0x1c450e[_0xcdaf70(406)](_0x1c450e), _0x519739[_0xcdaf70(422)] = _0x1b5f0c[_0xcdaf70(422)][_0xcdaf70(406)](_0x1b5f0c), _0x3986e6[_0x2a9191] = _0x519739;
  }
});
_0x1fff5d();
const METERS_PER_SECOND_TO_KMH = 3.6, METERS_PER_SECOND_TO_MPH = 2.23694, METERS_TO_FEET = 3.28084, METERS_TO_MILES = 621371e-9;
function formatSpeed(_0x3a8ca5, _0x37d7e6, _0x4689ae = 1) {
  const _0x2ef1fe = _0x3815;
  if (_0x37d7e6) {
    const _0x244957 = _0x3a8ca5 * METERS_PER_SECOND_TO_MPH;
    return _0x244957[_0x2ef1fe(408)](_0x4689ae) + _0x2ef1fe(423);
  } else {
    const _0x1d85e8 = _0x3a8ca5 * METERS_PER_SECOND_TO_KMH;
    return _0x1d85e8[_0x2ef1fe(408)](_0x4689ae) + _0x2ef1fe(410);
  }
}
function formatDistance(_0x65c4a6, _0x1d9168, _0x2de6a7 = 1) {
  const _0x3ca29a = _0x3815;
  if (_0x1d9168) {
    if (_0x65c4a6 < 1609.34) {
      const _0x5957fc = _0x65c4a6 * METERS_TO_FEET;
      return _0x5957fc[_0x3ca29a(408)](_0x2de6a7) + _0x3ca29a(403);
    } else {
      const _0x353426 = _0x65c4a6 * METERS_TO_MILES;
      return _0x353426[_0x3ca29a(408)](_0x2de6a7) + _0x3ca29a(415);
    }
  } else {
    if (_0x65c4a6 < 1e3) return _0x65c4a6[_0x3ca29a(408)](_0x2de6a7) + " m";
    else {
      const _0x2df998 = _0x65c4a6 / 1e3;
      return _0x2df998["toFixed"](_0x2de6a7) + _0x3ca29a(404);
    }
  }
}
function formatElevation(_0x196ca4, _0x281f24, _0x1fd3df = 1) {
  const _0x565345 = _0x3815;
  if (_0x281f24) {
    const _0x20473f = _0x196ca4 * METERS_TO_FEET;
    return _0x20473f[_0x565345(408)](_0x1fd3df) + _0x565345(403);
  } else return _0x196ca4[_0x565345(408)](_0x1fd3df) + " m";
}
function _0x3815(_0x192fda, _0x15c46a) {
  const _0x311382 = _0x1fab();
  return _0x3815 = function(_0x1fff5d2, _0x1c450e2) {
    _0x1fff5d2 = _0x1fff5d2 - 394;
    let _0x4c9204 = _0x311382[_0x1fff5d2];
    return _0x4c9204;
  }, _0x3815(_0x192fda, _0x15c46a);
}
function convertSpeed(_0x29ab37, _0x3079eb) {
  return _0x3079eb ? _0x29ab37 * METERS_PER_SECOND_TO_MPH : _0x29ab37 * METERS_PER_SECOND_TO_KMH;
}
function getSpeedUnit(_0xd65d40) {
  return _0xd65d40 ? "mph" : "km/h";
}
function _0x1fab() {
  const _0x4e38f9 = ["prototype", "3208007qryDQU", "toString", " mph", "apply", "__proto__", "639978ZHMBNH", "6wHvMGd", "57mHJLxZ", "223560fmuCYw", "179468vISrmf", '{}.constructor("return this")( )', "exception", "info", "length", "219465PqjWUS", " ft", " km", "trace", "bind", "10461051IzdPPA", "toFixed", "log", " km/h", "table", "85EykAiO", "warn", "console", " mi", "476EnwNhr", "74948904buqMsK", "return (function() ", "20kutCpV"];
  _0x1fab = function() {
    return _0x4e38f9;
  };
  return _0x1fab();
}
function RouteIcon({
  route,
  onClick,
  isSelected,
  size,
  sizeUnit = "rem",
  textSizeMultiplier = 0.6,
  yTranslate = 0.02,
  ignoreHover = false,
  className
}) {
  if (!DEBUG_MODE && route.tempParentId !== null) return null;
  const isSingleCharacter = route.bullet.length < 2;
  const DIAMOND_SCALE = 0.70710678;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: route.shape === "diamond" ? "overflow-hidden" : "",
      style: {
        height: `${size}${sizeUnit}`,
        maxHeight: `${size}${sizeUnit}`
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: cn(
            "flex items-center justify-center font-bold select-none overflow-hidden font-mta",
            route.shape === "circle" || route.shape === void 0 ? "rounded-full" : "",
            route.shape === "triangle" ? "[clip-path:polygon(50%_0%,0%_100%,100%_100%)]" : "",
            onClick ? "cursor-pointer hover:opacity-80" : "cursor-default",
            isSelected && "border-2 border-foreground",
            className
          ),
          style: {
            backgroundColor: route.color,
            WebkitUserSelect: "none",
            minWidth: `${size}${sizeUnit}`,
            // width: route.shape === 'diamond' && !isSingleCharacter ? 'auto' : undefined,
            height: `${size}${sizeUnit}`,
            fontSize: `${size * textSizeMultiplier}${sizeUnit}`,
            color: route.textColor || "white",
            paddingLeft: isSingleCharacter && route.shape !== "diamond" ? 0 : `${size * 0.25}${sizeUnit}`,
            paddingRight: isSingleCharacter && route.shape !== "diamond" ? 0 : `${size * 0.25}${sizeUnit}`,
            transform: route.shape === "diamond" ? `rotate(45deg) scale(${DIAMOND_SCALE})` : ""
          },
          onClick,
          onMouseOver: ignoreHover ? void 0 : (e) => {
            e.stopPropagation();
            e.preventDefault();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: cn("flex items-center justify-center leading-none"),
              style: {
                lineHeight: 0,
                transform: route.shape === "diamond" ? (
                  // To make diamond text the same add scale(${1 / DIAMOND_SCALE})
                  `rotate(-45deg) translateY(${-size * yTranslate}${sizeUnit})`
                ) : route.shape === "triangle" ? `translateY(${size * 0.1}${sizeUnit})` : `translateY(${-size * yTranslate}${sizeUnit})`
              },
              children: route.bullet === "" || route.bullet === void 0 ? " " : route.bullet
            }
          )
        }
      )
    }
  );
}
function ShowMoreToggle({
  children,
  initialItemCount = 3,
  expandable = true
}) {
  const { t } = useTranslation("game");
  const [isExpanded, setIsExpanded] = reactExports.useState(false);
  const shouldShowToggle = expandable && children.length > initialItemCount;
  const displayItems = shouldShowToggle && !isExpanded ? children.slice(0, initialItemCount) : children;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    displayItems,
    shouldShowToggle && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "ghost",
        size: "sm",
        className: "mt-1 h-7 text-xs text-muted-foreground hover:text-foreground",
        onClick: () => setIsExpanded(!isExpanded),
        children: isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          t("showMore.showLess"),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "ml-1 h-3 w-3" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          t("showMore.showMore", { count: children.length - initialItemCount }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "ml-1 h-3 w-3" })
        ] })
      }
    )
  ] });
}
function NearbyStations({
  originCoords,
  originId,
  maxWalkingTime
}) {
  const { t } = useTranslation("game");
  const { pushNavigationState } = useUi();
  const { useImperialUnits } = useSettings();
  const stations = useStations();
  const routes = useRoutes();
  const nearbyStations = stations.filter((s2) => !originId || s2.id !== originId).map((s2) => {
    const { time: time2, distance: distance2 } = getWalkingTimeAndDistanceBetweenPoints(originCoords, s2.coords);
    return { station: s2, walkingTime: time2, walkingDistance: distance2 };
  }).filter(({ walkingTime }) => walkingTime <= maxWalkingTime).sort((a2, b) => a2.walkingDistance - b.walkingDistance);
  if (nearbyStations.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.nearbyStations.nearbyStations"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMoreToggle, { initialItemCount: 3, children: nearbyStations.map(({ station: nearbyStation, walkingTime, walkingDistance }) => {
    const walkingMinutes = Math.round(walkingTime / 60);
    const distanceStr = formatDistance(walkingDistance, useImperialUnits);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center justify-between p-2 rounded-md bg-secondary/20 hover:bg-secondary/30 cursor-pointer transition-colors",
        onClick: () => pushNavigationState({
          type: "station-details",
          itemId: nearbyStation.id,
          view: null
        }),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "w-4 h-4 text-muted-foreground" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: nearbyStation.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-muted-foreground", children: t("panels.nearbyStations.minWalk", { distance: distanceStr, minutes: walkingMinutes }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1 items-center", children: nearbyStation.routeIds.map((routeId) => {
            const route = routes.find((r) => r.id === routeId);
            if (!route) return null;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                onClick: (e) => {
                  e.stopPropagation();
                  pushNavigationState({
                    type: "route-details",
                    itemId: route.id,
                    view: null
                  });
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  RouteIcon,
                  {
                    route,
                    size: 1,
                    yTranslate: -0.02,
                    onClick: () => {
                    }
                  }
                )
              },
              routeId
            );
          }) })
        ]
      },
      nearbyStation.id
    );
  }) }) }) });
}
const _0x427bbb = _0x2fa2;
function _0x48bc() {
  const _0x3793e6 = ["COLLEGE_INCOME_MULTIPLIER", "constructor", "__proto__", "console", "\nCollege commuters:\n<br/><br/>\n- Have ", "log", "\nAirport commuters:\n<br/><br/>\n- Don't cluster and are distributed throughout the city\n<br/><br/>\n- Are more likely to travel during off-peak hours\n<br/><br/>\n- Walk ", "bind", "% lower incomes\n- Travel slighly more in off-peak hours", "3fKRPhI", "x the parking costs", "table", "444376ZNlUzO", "651520krXfnZ", "AIRPORT_PARKING_COST_MULTIPLIER", "toString", "542552lfoRpa", "2831364uxwQUO", "31584LMKjIu", "52166otAaTo", "warn", "abs", "return (function() ", "error", "28OsYFVE", "length", "exception", "22gQCpyG", "4hzcicP", "apply", "AIRPORT_INCOME_MULTIPLIER", "75WhyhvK", "1081953ZPTpYC"];
  _0x48bc = function() {
    return _0x3793e6;
  };
  return _0x48bc();
}
function _0x2fa2(_0x94c772, _0x41f14f) {
  const _0x5c1ad4 = _0x48bc();
  return _0x2fa2 = function(_0x309c182, _0x2158e12) {
    _0x309c182 = _0x309c182 - 291;
    let _0x3adb0f = _0x5c1ad4[_0x309c182];
    return _0x3adb0f;
  }, _0x2fa2(_0x94c772, _0x41f14f);
}
(function(_0x9346bb, _0x5bbc51) {
  const _0x489b4f = _0x2fa2, _0x550b81 = _0x9346bb();
  while (!![]) {
    try {
      const _0x5ad53f = parseInt(_0x489b4f(301)) / 1 * (parseInt(_0x489b4f(310)) / 2) + parseInt(_0x489b4f(291)) / 3 * (parseInt(_0x489b4f(298)) / 4) + -parseInt(_0x489b4f(313)) / 5 * (-parseInt(_0x489b4f(300)) / 6) + -parseInt(_0x489b4f(306)) / 7 * (parseInt(_0x489b4f(294)) / 8) + parseInt(_0x489b4f(314)) / 9 + parseInt(_0x489b4f(295)) / 10 * (parseInt(_0x489b4f(309)) / 11) + -parseInt(_0x489b4f(299)) / 12;
      if (_0x5ad53f === _0x5bbc51) break;
      else _0x550b81["push"](_0x550b81["shift"]());
    } catch (_0x56e21e) {
      _0x550b81["push"](_0x550b81["shift"]());
    }
  }
})(_0x48bc, 111316);
const _0x2158e1 = /* @__PURE__ */ (function() {
  let _0x24905e = !![];
  return function(_0x29e7c4, _0x46148f) {
    const _0x4f71a3 = _0x24905e ? function() {
      const _0x351291 = _0x2fa2;
      if (_0x46148f) {
        const _0x1806e6 = _0x46148f[_0x351291(311)](_0x29e7c4, arguments);
        return _0x46148f = null, _0x1806e6;
      }
    } : function() {
    };
    return _0x24905e = ![], _0x4f71a3;
  };
})(), _0x309c18 = _0x2158e1(void 0, function() {
  const _0x2a7547 = _0x2fa2, _0x5860c3 = function() {
    const _0x541f26 = _0x2fa2;
    let _0x9bb1d8;
    try {
      _0x9bb1d8 = Function(_0x541f26(304) + '{}.constructor("return this")( ));')();
    } catch (_0x2e1241) {
      _0x9bb1d8 = window;
    }
    return _0x9bb1d8;
  }, _0x13b69d = _0x5860c3(), _0x312096 = _0x13b69d[_0x2a7547(318)] = _0x13b69d[_0x2a7547(318)] || {}, _0x1925a3 = [_0x2a7547(320), _0x2a7547(302), "info", _0x2a7547(305), _0x2a7547(308), _0x2a7547(293), "trace"];
  for (let _0x8ec814 = 0; _0x8ec814 < _0x1925a3[_0x2a7547(307)]; _0x8ec814++) {
    const _0x5282a4 = _0x2158e1[_0x2a7547(316)]["prototype"][_0x2a7547(322)](_0x2158e1), _0x26cf0a = _0x1925a3[_0x8ec814], _0x47dd33 = _0x312096[_0x26cf0a] || _0x5282a4;
    _0x5282a4[_0x2a7547(317)] = _0x2158e1["bind"](_0x2158e1), _0x5282a4[_0x2a7547(297)] = _0x47dd33[_0x2a7547(297)][_0x2a7547(322)](_0x47dd33), _0x312096[_0x26cf0a] = _0x5282a4;
  }
});
_0x309c18();
const AIRPORT_WORKER_TEXT = _0x427bbb(321) + (RULES["AIRPORT_WALKING_SPEED_MULTIPLIER"] - 1) * 100 + "% slower due to luggage\n<br/><br/>\n- Have " + (PATHFINDING_RULES[_0x427bbb(312)] - 1) * 100 + "% higher incomes\n<br/><br/>\n- Pay " + PATHFINDING_RULES[_0x427bbb(296)] + _0x427bbb(292);
const COLLEGE_WORKER_TEXT = _0x427bbb(319) + Math[_0x427bbb(303)]((PATHFINDING_RULES[_0x427bbb(315)] - 1) * 100) + _0x427bbb(323);
function CommuteTimeChart({ pops, type, size = "sm" }) {
  if (!pops.length) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-muted-foreground", children: "No commute data available" });
  }
  const hourBins = Array(24).fill(0);
  const totalCommuters = pops.reduce((sum, pop) => sum + pop.size, 0);
  pops.forEach((pop) => {
    const time2 = type === "workToHome" ? pop.homeDepartureTime : pop.workDepartureTime;
    const hour = Math.floor(time2 / 3600);
    if (hour >= 0 && hour < 24) {
      hourBins[hour] += pop.size;
    }
  });
  const maxCount = Math.max(...hourBins);
  const heightMap = { sm: 60, md: 80, lg: 120 };
  const height = heightMap[size];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full", style: { height: `${height}px` }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: `0 0 100 ${height}`, preserveAspectRatio: "none", className: "w-full h-full", children: hourBins.map((count2, hour) => {
      const barHeight = maxCount > 0 ? count2 / maxCount * height : 0;
      const barWidthPercent = 100 / 24 * 0.8;
      const gapPercent = 100 / 24 * 0.2;
      const x2 = hour * 100 / 24 + gapPercent / 2;
      const y2 = height - barHeight;
      const percentage = (count2 / totalCommuters * 100).toFixed(1);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: x2,
            y: y2,
            width: barWidthPercent,
            height: barHeight,
            className: type === "homeToWork" ? "fill-blue-500" : "fill-green-500",
            opacity: 0.8
          }
        ),
        count2 > 0 && size !== "sm" && /* @__PURE__ */ jsxRuntimeExports.jsxs("title", { children: [
          hour.toString().padStart(2, "0"),
          ":00: ",
          count2.toLocaleString(),
          " (",
          percentage,
          "%)"
        ] })
      ] }, hour);
    }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-xs text-muted-foreground w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "12am" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "6am" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "12pm" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "6pm" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "12am" })
    ] })
  ] });
}
function JobHomeToggle() {
  const { t } = useTranslation("game");
  const { currentNavigationState, pushNavigationState } = useUi();
  const jobHomeOptions2 = [
    {
      value: "homes",
      label: t("jobHomeToggle.residents"),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(House, { className: "h-4 w-4" })
    },
    {
      value: "jobs",
      label: t("jobHomeToggle.workers"),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { className: "h-4 w-4" })
    }
  ];
  if (!currentNavigationState?.type) throw new Error("JobHomeToggle must be used within a demand stats panel");
  const currentView = currentNavigationState.view === "homes" || currentNavigationState.view === "jobs" ? currentNavigationState.view : "homes";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-tutorial": "job-home-toggle", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroup,
    {
      options: jobHomeOptions2,
      value: currentView,
      onChange: (view) => {
        pushNavigationState({
          type: currentNavigationState.type,
          itemId: currentNavigationState.itemId,
          view
        });
      }
    }
  ) });
}
const BsPersonWalking = ({ className, style }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 16 16",
    height: "1em",
    width: "1em",
    className,
    style,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5 1.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0M6.44 3.752A.75.75 0 0 1 7 3.5h1.445c.742 0 1.32.643 1.243 1.38l-.43 4.083a1.8 1.8 0 0 1-.088.395l-.318.906.213.242a.8.8 0 0 1 .114.175l2 4.25a.75.75 0 1 1-1.357.638l-1.956-4.154-1.68-1.921A.75.75 0 0 1 6 8.96l.138-2.613-.435.489-.464 2.786a.75.75 0 1 1-1.48-.246l.5-3a.75.75 0 0 1 .18-.375l2-2.25Z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.25 11.745v-1.418l1.204 1.375.261.524a.8.8 0 0 1-.12.231l-2.5 3.25a.75.75 0 1 1-1.19-.914zm4.22-4.215-.494-.494.205-1.843.006-.067 1.124 1.124h1.44a.75.75 0 0 1 0 1.5H11a.75.75 0 0 1-.531-.22Z" })
    ]
  }
);
const BsFillQuestionCircleFill = ({ className, style }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 16 16",
    height: "1em",
    width: "1em",
    className,
    style,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M5.496 6.033h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286a.237.237 0 0 0 .241.247m2.325 6.443c.61 0 1.029-.394 1.029-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94 0 .533.425.927 1.01.927z" })
  }
);
const PiBulldozer = ({ className, style }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 256 256",
    height: "1em",
    width: "1em",
    className,
    style,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M248,200h-8a8,8,0,0,1-8-8V160a8,8,0,0,1,8-8h8a8,8,0,0,0,0-16h-8a24,24,0,0,0-24,24v8H199.2a40.09,40.09,0,0,0-33.71-31.61L129.44,49.85A16,16,0,0,0,114.67,40H24A16,16,0,0,0,8,56v96a40,40,0,0,0,32,64H160a40.07,40.07,0,0,0,39.2-32H216v8a24,24,0,0,0,24,24h8a8,8,0,0,0,0-16ZM148,136H64V56h50.67ZM48,56v80H40a39.72,39.72,0,0,0-16,3.35V56ZM160,200H40a24,24,0,0,1,0-48H160a24,24,0,0,1,0,48Zm8-24a8,8,0,0,1-8,8H40a8,8,0,0,1,0-16H160A8,8,0,0,1,168,176Z" })
  }
);
function DataTable({ rows, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("grid grid-cols-2 gap-1 items-center font-medium text-xs whitespace-nowrap", className), children: rows.map((row) => {
    const valueElement = typeof row.value === "string" || typeof row.value === "number" ? /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { valueInfoTooltip: row.valueInfoTooltip, children: row.value }) : row.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: row.label }),
      valueElement
    ] }, row.label);
  }) });
}
function DataTableRow({
  children,
  valueInfoTooltip,
  className,
  onClick
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "font-mono font-bold justify-self-end flex items-center gap-1",
        onClick && "cursor-pointer hover:underline",
        className
      ),
      onClick,
      children: [
        children,
        valueInfoTooltip && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: valueInfoTooltip })
      ]
    }
  );
}
function ModeChoiceChart({
  modeChoice,
  size,
  className
}) {
  const { walking, driving, transit, unknown } = modeChoice;
  const total = walking + driving + transit + unknown;
  const walkingPercentage = walking / total;
  const drivingPercentage = driving / total;
  const transitPercentage = transit / total;
  const unknownPercentage = unknown / total;
  if (size == "md") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ModeRow,
        {
          mode: "transit",
          percentage: transitPercentage * 100,
          total: transit,
          color: MODE_COLORS.transit
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ModeRow,
        {
          mode: "driving",
          percentage: drivingPercentage * 100,
          total: driving,
          color: MODE_COLORS.driving
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ModeRow,
        {
          mode: "walking",
          percentage: walkingPercentage * 100,
          total: walking,
          color: MODE_COLORS.walking
        }
      ),
      unknown > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ModeRow,
        {
          mode: "unknown",
          percentage: unknownPercentage * 100,
          total: unknown,
          color: MODE_COLORS.unknown
        }
      )
    ] });
  }
  if (size === "sm") {
    const dataTableRows = [
      { label: "Transit", value: `${(transitPercentage * 100).toFixed(1)}%` },
      { label: "Driving", value: `${(drivingPercentage * 100).toFixed(1)}%` },
      { label: "Walking", value: `${(walkingPercentage * 100).toFixed(1)}%` }
    ];
    if (unknown > 0) {
      dataTableRows.push({ label: "Unknown", value: `${(unknownPercentage * 100).toFixed(1)}%` });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("w-full h-1 overflow-hidden flex rounded-sm bg-background", className), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: { width: `${transitPercentage * 100}%`, backgroundColor: MODE_COLORS.transit },
            className: "h-full"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: { width: `${drivingPercentage * 100}%`, backgroundColor: MODE_COLORS.driving },
            className: "h-full"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: { width: `${walkingPercentage * 100}%`, backgroundColor: MODE_COLORS.walking },
            className: "h-full"
          }
        ),
        unknown > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              width: `${unknownPercentage * 100}%`,
              backgroundColor: MODE_COLORS.unknown
            },
            className: "h-full"
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: dataTableRows, className: "text-xs justify-between" }) })
    ] }) });
  }
}
function ModeRow({
  mode,
  percentage,
  total,
  color: color2
}) {
  const icon = mode === "transit" ? /* @__PURE__ */ jsxRuntimeExports.jsx(TramFront, { className: "w-4 h-4" }) : mode === "driving" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Car, { className: "w-4 h-4" }) : mode === "walking" ? /* @__PURE__ */ jsxRuntimeExports.jsx(BsPersonWalking, { className: "w-4 h-4" }) : mode === "unknown" ? /* @__PURE__ */ jsxRuntimeExports.jsx(BsFillQuestionCircleFill, { className: "w-4 h-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BsPersonWalking, { className: "w-4 h-4" });
  const modeName = mode === "unknown" ? "Uncalculated" : upperCaseFirstLetter(mode);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5 w-full", children: [
      icon,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between w-full ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: modeName }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex font-mono", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: total.toLocaleString() }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "w-14 text-right", children: [
            percentage.toFixed(1),
            "%"
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModeProgressBar, { percentage, color: color2 })
  ] });
}
function upperCaseFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function ModeProgressBar({ percentage, color: color2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-1.5 bg-secondary-foreground/10 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "h-full rounded-full transition-all",
      style: {
        width: `${percentage}%`,
        backgroundColor: color2
      }
    }
  ) });
}
function PreviewCard({
  children,
  onClick,
  className
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: cn(
        "bg-muted-foreground/30 hover:bg-muted-foreground/20 rounded-sm p-1 cursor-pointer",
        className
      ),
      onClick,
      children
    }
  );
}
function PopPreviewCard({ pop }) {
  const { pushNavigationState } = useUi();
  const isAirportCommuter = pop.jobId.startsWith("AIR_");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    PreviewCard,
    {
      className: "w-full p-1 px-2 flex items-center justify-between",
      onClick: () => pushNavigationState({ type: "pop-details", itemId: pop.id, view: null }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 w-16", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { className: "w-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: pop.size.toLocaleString() })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipProvider, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "w-5" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPortal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                "This pop leaves for work at ",
                formatTimeHHMM(pop.workDepartureTime),
                " and returns at",
                " ",
                formatTimeHHMM(pop.homeDepartureTime)
              ] }) }) })
            ] }),
            isAirportCommuter && /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plane, { className: "w-5 -ml-1" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPortal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "This pop commutes to an airport" }) }) })
            ] }) })
          ] }),
          pop.lastCommute && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ModeChoiceChart,
            {
              modeChoice: pop.lastCommute.modeChoice,
              size: "sm",
              className: "opacity-50 hover:opacity-40 h-5"
            }
          )
        ] })
      ]
    },
    pop.id
  );
}
function DemandPointDetailsPanel() {
  const { t } = useTranslation("game");
  const { demandData } = useMainStore();
  const { currentNavigationState } = useUi();
  if (currentNavigationState?.type !== "demand-point-details") return null;
  const selectedDemandPointId = currentNavigationState.itemId;
  if (!selectedDemandPointId) return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t("demandPoint.errorNoSelected") });
  const demandPoint = demandData.points.get(selectedDemandPointId);
  if (!demandPoint) return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t("demandPoint.errorNotFound") });
  const pops = demandPoint.popIds.map((popId) => demandData.popsMap.get(popId)).filter((pop) => pop !== void 0);
  const homePops = pops.filter((pop) => pop.residenceId === demandPoint.id).sort((a2, b) => b.size - a2.size);
  const jobPops = pops.filter((pop) => pop.jobId === demandPoint.id).sort((a2, b) => b.size - a2.size);
  const modeChoice = currentNavigationState?.view === "homes" ? demandPoint.residentModeShare : demandPoint.workerModeShare;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4 w-full", children: [
    DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-mono text-xs", children: [
        t("demandPoint.debugId"),
        ": ",
        demandPoint.id
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "sm", onClick: () => console.log(demandPoint), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, { className: "w-4 h-4" }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(JobHomeToggle, {}),
    demandPoint.id.startsWith("AIR_") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Plane, { className: "w-4 h-4" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium text-base", children: [
          demandPoint.id.split("AIR_")[1].split("_T")[0],
          " ",
          t("demandPoint.terminal"),
          " ",
          demandPoint.id.split("AIR_")[1].split("_T")[1]
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: AIRPORT_WORKER_TEXT })
      ] })
    ] }),
    demandPoint.id.startsWith("UNI_") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-base", children: t("demandPoint.collegeCampus") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: COLLEGE_WORKER_TEXT })
    ] }),
    currentNavigationState?.view === "homes" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("demandPoint.residentModeShare"), titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartBar, { className: "w-4 h-4" }), children: modeChoice ? /* @__PURE__ */ jsxRuntimeExports.jsx(ModeChoiceChart, { modeChoice, size: "md" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: t("demandPoint.commutesNotCalculated") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PanelSection,
        {
          title: `${homePops.reduce((acc, pop) => acc + pop.size, 0).toLocaleString()} ${t("demandPoint.residents")} (${homePops.length.toLocaleString()} ${t("demandPoint.pops")})`,
          titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(House, { className: "w-4 h-4" }),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMoreToggle, { initialItemCount: 5, children: homePops.map((pop) => /* @__PURE__ */ jsxRuntimeExports.jsx(PopPreviewCard, { pop }, pop.id)) }) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PanelSection,
        {
          title: t("demandPoint.departureTimes"),
          titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "w-4 h-4" }),
          titleInfoText: t("demandPoint.departureTimesInfo"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommuteTimeChart, { pops: homePops, type: "workToHome", size: "md" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PanelSection,
        {
          title: t("demandPoint.arrivalTimes"),
          titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "w-4 h-4" }),
          titleInfoText: t("demandPoint.arrivalTimesInfo"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommuteTimeChart, { pops: homePops, type: "homeToWork", size: "md" })
        }
      )
    ] }),
    currentNavigationState?.view === "jobs" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("demandPoint.workerModeShare"), titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartBar, { className: "w-4 h-4" }), children: modeChoice ? /* @__PURE__ */ jsxRuntimeExports.jsx(ModeChoiceChart, { modeChoice, size: "md" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: t("demandPoint.commutesNotCalculated") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PanelSection,
        {
          title: `${jobPops.reduce((acc, pop) => acc + pop.size, 0).toLocaleString()} ${t("demandPoint.workers")} (${jobPops.length.toLocaleString()} ${t("demandPoint.pops")})`,
          titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { className: "w-4 h-4" }),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMoreToggle, { initialItemCount: 5, children: jobPops.map((pop) => /* @__PURE__ */ jsxRuntimeExports.jsx(PopPreviewCard, { pop }, pop.id)) }) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PanelSection,
        {
          title: t("demandPoint.arrivalTimes"),
          titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "w-4 h-4" }),
          titleInfoText: t("demandPoint.arrivalTimesInfo"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommuteTimeChart, { pops: jobPops, type: "workToHome", size: "md" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PanelSection,
        {
          title: t("demandPoint.departureTimes"),
          titleIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { className: "w-4 h-4" }),
          titleInfoText: t("demandPoint.departureTimesInfo"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CommuteTimeChart, { pops: jobPops, type: "homeToWork", size: "md" })
        }
      )
    ] }),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NearbyStations,
      {
        originCoords: demandPoint.location,
        maxWalkingTime: PATHFINDING_RULES.MAX_WALK_TO_FROM_STATION
      }
    )
  ] });
}
const _0x3fdef8 = _0x5c88;
(function(_0x490441, _0x28f403) {
  const _0x3b93c5 = _0x5c88, _0x3e0309 = _0x490441();
  while (!![]) {
    try {
      const _0x4e39ca = -parseInt(_0x3b93c5(289)) / 1 * (-parseInt(_0x3b93c5(303)) / 2) + parseInt(_0x3b93c5(288)) / 3 * (-parseInt(_0x3b93c5(335)) / 4) + parseInt(_0x3b93c5(302)) / 5 + -parseInt(_0x3b93c5(309)) / 6 + parseInt(_0x3b93c5(336)) / 7 + parseInt(_0x3b93c5(286)) / 8 + -parseInt(_0x3b93c5(285)) / 9;
      if (_0x4e39ca === _0x28f403) break;
      else _0x3e0309["push"](_0x3e0309["shift"]());
    } catch (_0x5f46dc) {
      _0x3e0309["push"](_0x3e0309["shift"]());
    }
  }
})(_0x42b9, 302135);
const _0x44ad52 = /* @__PURE__ */ (function() {
  let _0x2d74bc = !![];
  return function(_0x230cbb, _0x3abfe3) {
    const _0x9f2a23 = _0x2d74bc ? function() {
      const _0x7bb676 = _0x5c88;
      if (_0x3abfe3) {
        const _0xc1daa4 = _0x3abfe3[_0x7bb676(301)](_0x230cbb, arguments);
        return _0x3abfe3 = null, _0xc1daa4;
      }
    } : function() {
    };
    return _0x2d74bc = ![], _0x9f2a23;
  };
})(), _0x2182b1 = _0x44ad52(void 0, function() {
  const _0x17ad0f = _0x5c88, _0x430902 = function() {
    const _0x50c301 = _0x5c88;
    let _0x360da0;
    try {
      _0x360da0 = Function("return (function() " + _0x50c301(325) + ");")();
    } catch (_0x244c43) {
      _0x360da0 = window;
    }
    return _0x360da0;
  }, _0x1f6a39 = _0x430902(), _0x101088 = _0x1f6a39[_0x17ad0f(279)] = _0x1f6a39[_0x17ad0f(279)] || {}, _0x1eaa1 = [_0x17ad0f(310), _0x17ad0f(281), "info", _0x17ad0f(299), "exception", _0x17ad0f(314), _0x17ad0f(305)];
  for (let _0x4dcf1f = 0; _0x4dcf1f < _0x1eaa1[_0x17ad0f(334)]; _0x4dcf1f++) {
    const _0x3361cf = _0x44ad52["constructor"][_0x17ad0f(297)][_0x17ad0f(327)](_0x44ad52), _0x459c7e = _0x1eaa1[_0x4dcf1f], _0x3d116d = _0x101088[_0x459c7e] || _0x3361cf;
    _0x3361cf[_0x17ad0f(319)] = _0x44ad52["bind"](_0x44ad52), _0x3361cf[_0x17ad0f(333)] = _0x3d116d[_0x17ad0f(333)][_0x17ad0f(327)](_0x3d116d), _0x101088[_0x459c7e] = _0x3361cf;
  }
});
_0x2182b1();
function _0x42b9() {
  const _0x164f07 = ["stationRoutes", "unknown", "origin", "values", "toString", "length", "13528NFyJFd", "2379272CdMpjf", "console", "get", "warn", "size", "from", "add", "1388241uWrNoX", "2244080OCrLJY", "filter", "477ISVNvC", "4tYMZdx", "sort", "stationIds", "popCount", "transit", "walking", "reduce", "home-origin", "prototype", "has", "error", "map", "apply", "2593370nWocvB", "8480xjtOdp", "work", "trace", "count", "work-origin", "entries", "971508kZXdwC", "log", "home", "origin-destination", "modeChoice", "table", "routeId", "includes", "find", "name", "__proto__", "all", "transfers", "indexOf", "lastCommute", "driving", '{}.constructor("return this")( )', "set", "bind", "some"];
  _0x42b9 = function() {
    return _0x164f07;
  };
  return _0x42b9();
}
function getStationStats({ completedCommutes: _0x3e76d3, stationId: _0x39c337, ridershipType = _0x3fdef8(320), originFilter = _0x3fdef8(320) }) {
  const _0x35097e = _0x3fdef8;
  let _0x17ec79 = 0, _0x296e83 = 0;
  const _0x21b1c4 = /* @__PURE__ */ new Map();
  for (const _0x4d2e59 of _0x3e76d3) {
    if (_0x39c337 && !_0x4d2e59[_0x35097e(329)][_0x35097e(328)]((_0x49265f) => _0x49265f[_0x35097e(291)][_0x35097e(316)](_0x39c337))) continue;
    let _0x22da0b = ![];
    if (_0x39c337 && _0x4d2e59[_0x35097e(329)][_0x35097e(334)] > 1) {
      const _0x29078b = _0x4d2e59["stationRoutes"][_0x35097e(287)]((_0x1fabba) => _0x1fabba["stationIds"][_0x35097e(316)](_0x39c337));
      if (_0x29078b["length"] > 1) _0x22da0b = !![];
      else {
        if (_0x29078b[_0x35097e(334)] === 1) {
          const _0x4ad26e = _0x4d2e59[_0x35097e(329)][_0x35097e(322)](_0x29078b[0]), _0x17ee89 = _0x4ad26e > 0 && _0x4d2e59[_0x35097e(329)][_0x4ad26e][_0x35097e(291)][0] === _0x39c337 || _0x4ad26e < _0x4d2e59[_0x35097e(329)][_0x35097e(334)] - 1 && _0x4d2e59[_0x35097e(329)][_0x4ad26e]["stationIds"][1] === _0x39c337;
          _0x17ee89 && (_0x22da0b = !![]);
        }
      }
    }
    if (ridershipType === "transfers" && !_0x22da0b) continue;
    if (ridershipType === _0x35097e(312) && _0x22da0b) continue;
    if (ridershipType === "origin-destination" && originFilter !== _0x35097e(320)) {
      const _0x19bbd4 = _0x4d2e59[_0x35097e(329)][0][_0x35097e(291)][0] === _0x39c337, _0x5cbad2 = _0x4d2e59[_0x35097e(329)][_0x4d2e59[_0x35097e(329)]["length"] - 1][_0x35097e(291)][1] === _0x39c337;
      if (!_0x19bbd4 && !_0x5cbad2) continue;
      if (originFilter === _0x35097e(307)) {
        if (_0x4d2e59[_0x35097e(331)] === _0x35097e(304) && !_0x19bbd4) continue;
        if (_0x4d2e59[_0x35097e(331)] === _0x35097e(311) && !_0x5cbad2) continue;
      } else {
        if (originFilter === _0x35097e(296)) {
          if (_0x4d2e59[_0x35097e(331)] === _0x35097e(311) && !_0x19bbd4) continue;
          if (_0x4d2e59[_0x35097e(331)] === _0x35097e(304) && !_0x5cbad2) continue;
        }
      }
    }
    _0x17ec79 += _0x4d2e59[_0x35097e(282)];
    _0x22da0b && (_0x296e83 += _0x4d2e59[_0x35097e(282)]);
    for (const _0x4a4b63 of _0x4d2e59[_0x35097e(329)]) {
      if (_0x39c337 && !_0x4a4b63["stationIds"][_0x35097e(316)](_0x39c337)) continue;
      _0x21b1c4[_0x35097e(326)](_0x4a4b63[_0x35097e(315)], (_0x21b1c4[_0x35097e(280)](_0x4a4b63[_0x35097e(315)]) || 0) + _0x4d2e59[_0x35097e(282)]);
      break;
    }
  }
  const _0x3b1dbc = Array["from"](_0x21b1c4["entries"]())["map"](([_0x575ae1, _0x567b7d]) => ({ "routeId": _0x575ae1, "popCount": _0x567b7d, "percent": _0x567b7d / _0x17ec79 * 100 }))[_0x35097e(290)]((_0x579cbb, _0x520f64) => _0x520f64[_0x35097e(292)] - _0x579cbb[_0x35097e(292)]);
  return { "total": _0x17ec79, "transfers": _0x296e83, "byRoute": _0x3b1dbc };
}
function getRouteStats({ completedCommutes: _0x4ba9a8, routeId: _0x4031ab, ridershipType = _0x3fdef8(320), originFilter = "all" }) {
  const _0x31ab46 = _0x3fdef8;
  let _0x5c6d56 = 0;
  const _0x181050 = /* @__PURE__ */ new Map();
  for (const _0x39ad7e of _0x4ba9a8) {
    const _0x468624 = _0x39ad7e[_0x31ab46(329)]["filter"]((_0x3a7a0f) => {
      const _0x260f52 = _0x31ab46;
      if (_0x4031ab) return _0x3a7a0f[_0x260f52(315)] === _0x4031ab;
      return !![];
    });
    if (_0x468624[_0x31ab46(334)] === 0) continue;
    const _0x5d1dab = /* @__PURE__ */ new Set();
    if (_0x39ad7e[_0x31ab46(329)][_0x31ab46(334)] > 1) for (const _0x21bbe7 of _0x468624) {
      for (const _0x3159fb of _0x21bbe7["stationIds"]) {
        const _0x2ca313 = _0x39ad7e["stationRoutes"][_0x31ab46(287)]((_0x217ff8) => _0x217ff8[_0x31ab46(291)]["includes"](_0x3159fb));
        if (_0x2ca313[_0x31ab46(334)] > 1) _0x5d1dab[_0x31ab46(284)](_0x3159fb);
        else {
          if (_0x2ca313[_0x31ab46(334)] === 1) {
            const _0x17d626 = _0x39ad7e[_0x31ab46(329)][_0x31ab46(322)](_0x2ca313[0]), _0x3c1270 = _0x17d626 > 0 && _0x39ad7e[_0x31ab46(329)][_0x17d626][_0x31ab46(291)][0] === _0x3159fb || _0x17d626 < _0x39ad7e["stationRoutes"][_0x31ab46(334)] - 1 && _0x39ad7e[_0x31ab46(329)][_0x17d626][_0x31ab46(291)][1] === _0x3159fb;
            _0x3c1270 && _0x5d1dab[_0x31ab46(284)](_0x3159fb);
          }
        }
      }
    }
    for (const _0x1d8b17 of _0x468624) {
      for (const _0xa7f5e7 of _0x1d8b17[_0x31ab46(291)]) {
        const _0x298784 = _0x5d1dab[_0x31ab46(298)](_0xa7f5e7);
        if (ridershipType === _0x31ab46(321) && !_0x298784) continue;
        if (ridershipType === _0x31ab46(312) && _0x298784) continue;
        if (ridershipType === _0x31ab46(312) && originFilter !== _0x31ab46(320)) {
          const _0x50e8ad = _0x39ad7e[_0x31ab46(329)][0][_0x31ab46(291)][0] === _0xa7f5e7, _0x2a6f5b = _0x39ad7e[_0x31ab46(329)][_0x39ad7e["stationRoutes"]["length"] - 1][_0x31ab46(291)][1] === _0xa7f5e7;
          if (!_0x50e8ad && !_0x2a6f5b) continue;
          if (originFilter === _0x31ab46(307)) {
            if (_0x39ad7e["origin"] === _0x31ab46(304) && !_0x50e8ad) continue;
            if (_0x39ad7e[_0x31ab46(331)] === _0x31ab46(311) && !_0x2a6f5b) continue;
          } else {
            if (originFilter === _0x31ab46(296)) {
              if (_0x39ad7e[_0x31ab46(331)] === _0x31ab46(311) && !_0x50e8ad) continue;
              if (_0x39ad7e["origin"] === "work" && !_0x2a6f5b) continue;
            }
          }
        }
        _0x181050[_0x31ab46(326)](_0xa7f5e7, (_0x181050[_0x31ab46(280)](_0xa7f5e7) || 0) + _0x39ad7e[_0x31ab46(282)]);
      }
    }
    _0x5c6d56 += _0x39ad7e[_0x31ab46(282)];
  }
  const _0x43b271 = Array[_0x31ab46(283)](_0x181050["entries"]())["map"](([_0x26f0fd, _0x3c82fa]) => ({ "stationId": _0x26f0fd, "popCount": _0x3c82fa, "percent": _0x3c82fa / _0x5c6d56 * 100 }))["sort"]((_0x4ba12e, _0x30fd7e) => _0x30fd7e[_0x31ab46(292)] - _0x4ba12e[_0x31ab46(292)]);
  return { "total": _0x5c6d56, "byStation": _0x43b271 };
}
function _0x5c88(_0x1503bc, _0x11408a) {
  const _0x2d5b19 = _0x42b9();
  return _0x5c88 = function(_0x2182b12, _0x44ad522) {
    _0x2182b12 = _0x2182b12 - 279;
    let _0x4a8d38 = _0x2d5b19[_0x2182b12];
    return _0x4a8d38;
  }, _0x5c88(_0x1503bc, _0x11408a);
}
function getTotalCommuteModes(_0x17229e) {
  const _0x5c35d8 = _0x3fdef8, _0x3527cf = { "walking": 0, "driving": 0, "transit": 0, "unknown": 0 };
  for (const _0x560d11 of Array[_0x5c35d8(283)](_0x17229e[_0x5c35d8(332)]())) {
    _0x560d11[_0x5c35d8(323)]?.[_0x5c35d8(313)] ? (_0x3527cf[_0x5c35d8(294)] += _0x560d11[_0x5c35d8(323)][_0x5c35d8(313)][_0x5c35d8(294)], _0x3527cf[_0x5c35d8(324)] += _0x560d11[_0x5c35d8(323)][_0x5c35d8(313)][_0x5c35d8(324)], _0x3527cf[_0x5c35d8(293)] += _0x560d11[_0x5c35d8(323)][_0x5c35d8(313)][_0x5c35d8(293)], _0x3527cf[_0x5c35d8(330)] += _0x560d11[_0x5c35d8(323)][_0x5c35d8(313)]["unknown"]) : _0x3527cf["unknown"] += _0x560d11[_0x5c35d8(282)];
  }
  return _0x3527cf;
}
function getStationGroupStats({ completedCommutes: _0x5272ec, stationGroups: _0x4da810, ridershipType = _0x3fdef8(320), originFilter = _0x3fdef8(320) }) {
  const _0xeba0d0 = _0x3fdef8, _0x4ffc31 = /* @__PURE__ */ new Map();
  for (const _0x49811c of _0x4da810) {
    _0x4ffc31[_0xeba0d0(326)](_0x49811c["id"], { "name": _0x49811c[_0xeba0d0(318)], "count": 0 });
  }
  for (const _0x78536 of _0x5272ec) {
    const _0x128561 = /* @__PURE__ */ new Set(), _0x1550f7 = /* @__PURE__ */ new Set();
    if (_0x78536[_0xeba0d0(329)][_0xeba0d0(334)] > 1) for (const _0x2de895 of _0x4da810) {
      for (const _0x1455ba of _0x2de895[_0xeba0d0(291)]) {
        const _0x2d3ba1 = _0x78536[_0xeba0d0(329)][_0xeba0d0(287)]((_0x181afe) => _0x181afe[_0xeba0d0(291)]["includes"](_0x1455ba));
        if (_0x2d3ba1[_0xeba0d0(334)] > 1) _0x1550f7["add"](_0x2de895["id"]);
        else {
          if (_0x2d3ba1[_0xeba0d0(334)] === 1) {
            const _0x4033fe = _0x78536[_0xeba0d0(329)][_0xeba0d0(322)](_0x2d3ba1[0]), _0x4fb7db = _0x4033fe > 0 && _0x78536[_0xeba0d0(329)][_0x4033fe]["stationIds"][0] === _0x1455ba || _0x4033fe < _0x78536["stationRoutes"]["length"] - 1 && _0x78536[_0xeba0d0(329)][_0x4033fe][_0xeba0d0(291)][1] === _0x1455ba;
            _0x4fb7db && _0x1550f7[_0xeba0d0(284)](_0x2de895["id"]);
          }
        }
      }
    }
    for (const _0x27fe20 of _0x78536[_0xeba0d0(329)]) {
      for (const _0x5c026f of _0x27fe20["stationIds"]) {
        const _0x19a8eb = _0x4da810[_0xeba0d0(317)]((_0x285ec5) => _0x285ec5[_0xeba0d0(291)][_0xeba0d0(316)](_0x5c026f));
        if (_0x19a8eb && !_0x128561[_0xeba0d0(298)](_0x19a8eb["id"])) {
          const _0x22bd6e = _0x1550f7[_0xeba0d0(298)](_0x19a8eb["id"]);
          if (ridershipType === _0xeba0d0(321) && !_0x22bd6e) continue;
          if (ridershipType === "origin-destination" && _0x22bd6e) continue;
          if (ridershipType === "origin-destination" && originFilter !== _0xeba0d0(320)) {
            const _0x18b554 = _0x78536[_0xeba0d0(329)][0][_0xeba0d0(291)][0], _0xad477f = _0x78536[_0xeba0d0(329)][_0x78536[_0xeba0d0(329)][_0xeba0d0(334)] - 1][_0xeba0d0(291)][1], _0x19b037 = _0x19a8eb[_0xeba0d0(291)]["includes"](_0x18b554), _0x327b6c = _0x19a8eb[_0xeba0d0(291)]["includes"](_0xad477f);
            if (!_0x19b037 && !_0x327b6c) continue;
            if (originFilter === _0xeba0d0(307)) {
              if (_0x78536[_0xeba0d0(331)] === "work" && !_0x19b037) continue;
              if (_0x78536[_0xeba0d0(331)] === _0xeba0d0(311) && !_0x327b6c) continue;
            } else {
              if (originFilter === _0xeba0d0(296)) {
                if (_0x78536[_0xeba0d0(331)] === _0xeba0d0(311) && !_0x19b037) continue;
                if (_0x78536[_0xeba0d0(331)] === _0xeba0d0(304) && !_0x327b6c) continue;
              }
            }
          }
          const _0xf07fce = _0x4ffc31[_0xeba0d0(280)](_0x19a8eb["id"]);
          _0xf07fce && _0x4ffc31[_0xeba0d0(326)](_0x19a8eb["id"], { "name": _0xf07fce[_0xeba0d0(318)], "count": _0xf07fce["count"] + _0x78536[_0xeba0d0(282)] }), _0x128561["add"](_0x19a8eb["id"]);
        }
      }
    }
  }
  const _0x1dce8a = Array[_0xeba0d0(283)](_0x4ffc31[_0xeba0d0(332)]())[_0xeba0d0(295)]((_0x2764bd, _0x1c9be3) => _0x2764bd + _0x1c9be3[_0xeba0d0(306)], 0), _0x394f2b = Array[_0xeba0d0(283)](_0x4ffc31[_0xeba0d0(308)]())[_0xeba0d0(300)](([_0x54a727, _0x3046fb]) => ({ "stationGroupId": _0x54a727, "stationGroupName": _0x3046fb[_0xeba0d0(318)], "popCount": _0x3046fb[_0xeba0d0(306)], "percent": _0x1dce8a > 0 ? _0x3046fb[_0xeba0d0(306)] / _0x1dce8a * 100 : 0 }))[_0xeba0d0(290)]((_0x29cb58, _0x29751b) => _0x29751b[_0xeba0d0(292)] - _0x29cb58[_0xeba0d0(292)]);
  return { "total": _0x1dce8a, "byStationGroup": _0x394f2b };
}
function DemandStatsPanel() {
  const { t } = useTranslation("game");
  const { demandData, simulateCommutes } = useMainStore();
  function simulateAllCommutes(startMovements) {
    const allPopIds = Array.from(demandData.popsMap.keys());
    const popCommutes = allPopIds.map((popId) => ({ popId }));
    simulateCommutes({ popCommutes, startMovements });
  }
  const modeChoices = getTotalCommuteModes(demandData.popsMap);
  const isEmpty = Object.values(modeChoices).every((value) => value === 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 w-full h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(JobHomeToggle, {}),
    isEmpty ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: t("panels.demandStats.noCommutesYet") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.demandStats.todaysDemandStats"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModeChoiceChart, { modeChoice: modeChoices, size: "md" }) }),
    DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "sm", onClick: () => simulateAllCommutes(false), children: t("panels.demandStats.simCommutes") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "sm", onClick: () => simulateAllCommutes(true), children: t("panels.demandStats.simCommutesMovements") })
    ] })
  ] });
}
(function(_0x532b8d, _0x41b403) {
  const _0x1dfd58 = _0x7bdb, _0x2ebc98 = _0x532b8d();
  while (!![]) {
    try {
      const _0x1766aa = -parseInt(_0x1dfd58(241)) / 1 * (-parseInt(_0x1dfd58(237)) / 2) + parseInt(_0x1dfd58(233)) / 3 + parseInt(_0x1dfd58(230)) / 4 * (-parseInt(_0x1dfd58(227)) / 5) + parseInt(_0x1dfd58(229)) / 6 * (parseInt(_0x1dfd58(234)) / 7) + -parseInt(_0x1dfd58(220)) / 8 * (parseInt(_0x1dfd58(239)) / 9) + parseInt(_0x1dfd58(232)) / 10 + parseInt(_0x1dfd58(228)) / 11;
      if (_0x1766aa === _0x41b403) break;
      else _0x2ebc98["push"](_0x2ebc98["shift"]());
    } catch (_0x32c689) {
      _0x2ebc98["push"](_0x2ebc98["shift"]());
    }
  }
})(_0x144a, 135965);
function _0x7bdb(_0x21e230, _0x114b8d) {
  const _0xefdb91 = _0x144a();
  return _0x7bdb = function(_0x317f2f2, _0x456e972) {
    _0x317f2f2 = _0x317f2f2 - 217;
    let _0x326894 = _0xefdb91[_0x317f2f2];
    return _0x326894;
  }, _0x7bdb(_0x21e230, _0x114b8d);
}
const _0x456e97 = /* @__PURE__ */ (function() {
  let _0x3d5cc8 = !![];
  return function(_0x4511e4, _0x1c6409) {
    const _0x445bdf = _0x3d5cc8 ? function() {
      const _0x25169f = _0x7bdb;
      if (_0x1c6409) {
        const _0xef9da6 = _0x1c6409[_0x25169f(240)](_0x4511e4, arguments);
        return _0x1c6409 = null, _0xef9da6;
      }
    } : function() {
    };
    return _0x3d5cc8 = ![], _0x445bdf;
  };
})(), _0x317f2f = _0x456e97(void 0, function() {
  const _0x5da278 = _0x7bdb, _0x173653 = function() {
    const _0x1d996b = _0x7bdb;
    let _0x44f357;
    try {
      _0x44f357 = Function(_0x1d996b(222) + _0x1d996b(221) + ");")();
    } catch (_0xfeba3c) {
      _0x44f357 = window;
    }
    return _0x44f357;
  }, _0x14cabf = _0x173653(), _0x51d930 = _0x14cabf["console"] = _0x14cabf["console"] || {}, _0x4bbfc8 = ["log", _0x5da278(235), _0x5da278(238), _0x5da278(231), _0x5da278(218), _0x5da278(225), "trace"];
  for (let _0x366a27 = 0; _0x366a27 < _0x4bbfc8[_0x5da278(224)]; _0x366a27++) {
    const _0x5d6d7a = _0x456e97[_0x5da278(217)][_0x5da278(223)][_0x5da278(226)](_0x456e97), _0x1d17a2 = _0x4bbfc8[_0x366a27], _0x48bd5f = _0x51d930[_0x1d17a2] || _0x5d6d7a;
    _0x5d6d7a[_0x5da278(219)] = _0x456e97["bind"](_0x456e97), _0x5d6d7a[_0x5da278(236)] = _0x48bd5f[_0x5da278(236)][_0x5da278(226)](_0x48bd5f), _0x51d930[_0x1d17a2] = _0x5d6d7a;
  }
});
function _0x144a() {
  const _0x1f409b = ["5115JUKwmh", "3372160MfPcaa", "78xQaiLL", "964VfNGQF", "error", "480700vtIIOQ", "90039ksPVOe", "6006RRvReE", "warn", "toString", "27034DpVJIC", "info", "2871HAHsEn", "apply", "17EOkISC", "constructor", "exception", "__proto__", "6096ySxgUF", '{}.constructor("return this")( )', "return (function() ", "prototype", "length", "table", "bind"];
  _0x144a = function() {
    return _0x1f409b;
  };
  return _0x144a();
}
_0x317f2f();
let journeyPlannerPlaces = { "fromPlace": null, "toPlace": null };
function setJourneyPlannerPlaces(_0x30f963) {
  journeyPlannerPlaces = _0x30f963;
}
function getJourneyPlannerPlaces() {
  return journeyPlannerPlaces;
}
let journeyCoordinateCallback = null;
function setJourneyCoordinateCallback(callback) {
  journeyCoordinateCallback = callback;
}
function getJourneyCoordinateCallback() {
  return journeyCoordinateCallback;
}
const JourneyPlannerContext = reactExports.createContext(void 0);
function useJourneyPlanner() {
  const context = reactExports.useContext(JourneyPlannerContext);
  if (!context) {
    throw new Error("useJourneyPlanner must be used within JourneyPlannerProvider");
  }
  return context;
}
function JourneyPlannerProvider({ children }) {
  const [fromPlace, setFromPlace] = reactExports.useState(null);
  const [toPlace, setToPlace] = reactExports.useState(null);
  const [selectingCoordinate, setSelectingCoordinate] = reactExports.useState(null);
  const [addedDepartureTime, setAddedDepartureTime] = reactExports.useState(0);
  const [maxTransfers, setMaxTransfers] = reactExports.useState(PATHFINDING_RULES.MAX_TRANSFERS);
  const [searchResults, setSearchResults] = reactExports.useState([]);
  const { calculatePaths } = useMainStore();
  const { setUserAction } = useUi();
  reactExports.useEffect(() => {
    setJourneyPlannerPlaces({ fromPlace, toPlace });
  }, [fromPlace, toPlace]);
  reactExports.useEffect(() => {
    if (fromPlace && toPlace) {
      const query = {
        origin: fromPlace,
        destination: toPlace,
        departureTime: 0,
        maxTransfers
      };
      const result = calculatePaths({ query, addedDepartureTime });
      setSearchResults(result.paths);
    } else {
      setSearchResults([]);
    }
  }, [fromPlace, toPlace, addedDepartureTime, maxTransfers, calculatePaths]);
  const handleCoordinateSelection = reactExports.useCallback(
    (coords) => {
      if (selectingCoordinate === "from") {
        setFromPlace({ type: "coords", coords });
      } else if (selectingCoordinate === "to") {
        setToPlace({ type: "coords", coords });
      }
      setSelectingCoordinate(null);
      setUserAction("none");
      setJourneyCoordinateCallback(null);
    },
    [selectingCoordinate, setUserAction]
  );
  reactExports.useEffect(() => {
    if (selectingCoordinate) {
      setJourneyCoordinateCallback(handleCoordinateSelection);
    }
    return () => {
      setJourneyCoordinateCallback(null);
    };
  }, [selectingCoordinate, handleCoordinateSelection]);
  const reverseStations = reactExports.useCallback(() => {
    const tempFrom = fromPlace;
    setFromPlace(toPlace);
    setToPlace(tempFrom);
  }, [fromPlace, toPlace]);
  const handlePlaceChange = reactExports.useCallback(
    (type, value) => {
      const place = value === "coords" ? { type: "coords", coords: [0, 0] } : { type: "station", stationId: value };
      if (value === "coords") {
        setSelectingCoordinate(type);
        setUserAction("select-journey-location");
        return;
      }
      if (type === "from") {
        setFromPlace(place);
      } else {
        setToPlace(place);
      }
    },
    [setUserAction]
  );
  const contextValue = {
    fromPlace,
    toPlace,
    selectingCoordinate,
    addedDepartureTime,
    maxTransfers,
    searchResults,
    setFromPlace,
    setToPlace,
    setSelectingCoordinate,
    setAddedDepartureTime,
    setMaxTransfers,
    reverseStations,
    handlePlaceChange,
    handleCoordinateSelection
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyPlannerContext.Provider, { value: contextValue, children });
}
function JourneySettings() {
  const { t } = useTranslation("game");
  const { addedDepartureTime, setAddedDepartureTime, maxTransfers, setMaxTransfers } = useJourneyPlanner();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "departure-time", children: t("panels.journeyPlanner.departureTime") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Select,
        {
          value: addedDepartureTime?.toString() || "0",
          onValueChange: (value) => setAddedDepartureTime(Number(value)),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "0", children: t("panels.journeyPlanner.now") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "300", children: t("panels.journeyPlanner.in5Minutes") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "600", children: t("panels.journeyPlanner.in10Minutes") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "1800", children: t("panels.journeyPlanner.in30Minutes") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "3600", children: t("panels.journeyPlanner.in1Hour") })
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "max-transfers", children: t("panels.journeyPlanner.maxTransfers") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: maxTransfers.toString(), onValueChange: (value) => setMaxTransfers(Number(value)), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: [0, 1, 2, 3, 4, 5].map((num) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: num.toString(), children: num }, num)) })
      ] })
    ] })
  ] });
}
var U = 1, Y$1 = 0.9, H = 0.8, J = 0.17, p = 0.1, u = 0.999, $ = 0.9999;
var k$1 = 0.99, m = /[\\\/_+.#"@\[\(\{&]/, B$1 = /[\\\/_+.#"@\[\(\{&]/g, K$1 = /[\s-]/, X = /[\s-]/g;
function G(_, C, h, P2, A, f, O) {
  if (f === C.length) return A === _.length ? U : k$1;
  var T2 = `${A},${f}`;
  if (O[T2] !== void 0) return O[T2];
  for (var L2 = P2.charAt(f), c2 = h.indexOf(L2, A), S = 0, E, N2, R, M; c2 >= 0; ) E = G(_, C, h, P2, c2 + 1, f + 1, O), E > S && (c2 === A ? E *= U : m.test(_.charAt(c2 - 1)) ? (E *= H, R = _.slice(A, c2 - 1).match(B$1), R && A > 0 && (E *= Math.pow(u, R.length))) : K$1.test(_.charAt(c2 - 1)) ? (E *= Y$1, M = _.slice(A, c2 - 1).match(X), M && A > 0 && (E *= Math.pow(u, M.length))) : (E *= J, A > 0 && (E *= Math.pow(u, c2 - A))), _.charAt(c2) !== C.charAt(f) && (E *= $)), (E < p && h.charAt(c2 - 1) === P2.charAt(f + 1) || P2.charAt(f + 1) === P2.charAt(f) && h.charAt(c2 - 1) !== P2.charAt(f)) && (N2 = G(_, C, h, P2, c2 + 1, f + 2, O), N2 * p > E && (E = N2 * p)), E > S && (S = E), c2 = h.indexOf(L2, c2 + 1);
  return O[T2] = S, S;
}
function D(_) {
  return _.toLowerCase().replace(X, " ");
}
function W(_, C, h) {
  return _ = h && h.length > 0 ? `${_ + " " + h.join(" ")}` : _, G(_, C, D(_), D(C), 0, 0, {});
}
var N = '[cmdk-group=""]', Y = '[cmdk-group-items=""]', be = '[cmdk-group-heading=""]', le = '[cmdk-item=""]', ce = `${le}:not([aria-disabled="true"])`, Z = "cmdk-item-select", T = "data-value", Re = (r, o, n) => W(r, o, n), ue = reactExports.createContext(void 0), K = () => reactExports.useContext(ue), de = reactExports.createContext(void 0), ee = () => reactExports.useContext(de), fe = reactExports.createContext(void 0), me = reactExports.forwardRef((r, o) => {
  let n = L(() => {
    var e, a2;
    return { search: "", value: (a2 = (e = r.value) != null ? e : r.defaultValue) != null ? a2 : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), u2 = L(() => /* @__PURE__ */ new Set()), c2 = L(() => /* @__PURE__ */ new Map()), d = L(() => /* @__PURE__ */ new Map()), f = L(() => /* @__PURE__ */ new Set()), p2 = pe(r), { label: b, children: m2, value: R, onValueChange: x2, filter: C, shouldFilter: S, loop: A, disablePointerSelection: ge = false, vimBindings: j = true, ...O } = r, $2 = useId$1(), q = useId$1(), _ = useId$1(), I = reactExports.useRef(null), v = ke();
  k(() => {
    if (R !== void 0) {
      let e = R.trim();
      n.current.value = e, E.emit();
    }
  }, [R]), k(() => {
    v(6, ne);
  }, []);
  let E = reactExports.useMemo(() => ({ subscribe: (e) => (f.current.add(e), () => f.current.delete(e)), snapshot: () => n.current, setState: (e, a2, s2) => {
    var i, l, g, y2;
    if (!Object.is(n.current[e], a2)) {
      if (n.current[e] = a2, e === "search") J2(), z(), v(1, W2);
      else if (e === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let h = document.getElementById(_);
          h ? h.focus() : (i = document.getElementById($2)) == null || i.focus();
        }
        if (v(7, () => {
          var h;
          n.current.selectedItemId = (h = M()) == null ? void 0 : h.id, E.emit();
        }), s2 || v(5, ne), ((l = p2.current) == null ? void 0 : l.value) !== void 0) {
          let h = a2 != null ? a2 : "";
          (y2 = (g = p2.current).onValueChange) == null || y2.call(g, h);
          return;
        }
      }
      E.emit();
    }
  }, emit: () => {
    f.current.forEach((e) => e());
  } }), []), U2 = reactExports.useMemo(() => ({ value: (e, a2, s2) => {
    var i;
    a2 !== ((i = d.current.get(e)) == null ? void 0 : i.value) && (d.current.set(e, { value: a2, keywords: s2 }), n.current.filtered.items.set(e, te(a2, s2)), v(2, () => {
      z(), E.emit();
    }));
  }, item: (e, a2) => (u2.current.add(e), a2 && (c2.current.has(a2) ? c2.current.get(a2).add(e) : c2.current.set(a2, /* @__PURE__ */ new Set([e]))), v(3, () => {
    J2(), z(), n.current.value || W2(), E.emit();
  }), () => {
    d.current.delete(e), u2.current.delete(e), n.current.filtered.items.delete(e);
    let s2 = M();
    v(4, () => {
      J2(), (s2 == null ? void 0 : s2.getAttribute("id")) === e && W2(), E.emit();
    });
  }), group: (e) => (c2.current.has(e) || c2.current.set(e, /* @__PURE__ */ new Set()), () => {
    d.current.delete(e), c2.current.delete(e);
  }), filter: () => p2.current.shouldFilter, label: b || r["aria-label"], getDisablePointerSelection: () => p2.current.disablePointerSelection, listId: $2, inputId: _, labelId: q, listInnerRef: I }), []);
  function te(e, a2) {
    var i, l;
    let s2 = (l = (i = p2.current) == null ? void 0 : i.filter) != null ? l : Re;
    return e ? s2(e, n.current.search, a2) : 0;
  }
  function z() {
    if (!n.current.search || p2.current.shouldFilter === false) return;
    let e = n.current.filtered.items, a2 = [];
    n.current.filtered.groups.forEach((i) => {
      let l = c2.current.get(i), g = 0;
      l.forEach((y2) => {
        let h = e.get(y2);
        g = Math.max(h, g);
      }), a2.push([i, g]);
    });
    let s2 = I.current;
    V().sort((i, l) => {
      var h, F;
      let g = i.getAttribute("id"), y2 = l.getAttribute("id");
      return ((h = e.get(y2)) != null ? h : 0) - ((F = e.get(g)) != null ? F : 0);
    }).forEach((i) => {
      let l = i.closest(Y);
      l ? l.appendChild(i.parentElement === l ? i : i.closest(`${Y} > *`)) : s2.appendChild(i.parentElement === s2 ? i : i.closest(`${Y} > *`));
    }), a2.sort((i, l) => l[1] - i[1]).forEach((i) => {
      var g;
      let l = (g = I.current) == null ? void 0 : g.querySelector(`${N}[${T}="${encodeURIComponent(i[0])}"]`);
      l == null || l.parentElement.appendChild(l);
    });
  }
  function W2() {
    let e = V().find((s2) => s2.getAttribute("aria-disabled") !== "true"), a2 = e == null ? void 0 : e.getAttribute(T);
    E.setState("value", a2 || void 0);
  }
  function J2() {
    var a2, s2, i, l;
    if (!n.current.search || p2.current.shouldFilter === false) {
      n.current.filtered.count = u2.current.size;
      return;
    }
    n.current.filtered.groups = /* @__PURE__ */ new Set();
    let e = 0;
    for (let g of u2.current) {
      let y2 = (s2 = (a2 = d.current.get(g)) == null ? void 0 : a2.value) != null ? s2 : "", h = (l = (i = d.current.get(g)) == null ? void 0 : i.keywords) != null ? l : [], F = te(y2, h);
      n.current.filtered.items.set(g, F), F > 0 && e++;
    }
    for (let [g, y2] of c2.current) for (let h of y2) if (n.current.filtered.items.get(h) > 0) {
      n.current.filtered.groups.add(g);
      break;
    }
    n.current.filtered.count = e;
  }
  function ne() {
    var a2, s2, i;
    let e = M();
    e && (((a2 = e.parentElement) == null ? void 0 : a2.firstChild) === e && ((i = (s2 = e.closest(N)) == null ? void 0 : s2.querySelector(be)) == null || i.scrollIntoView({ block: "nearest" })), e.scrollIntoView({ block: "nearest" }));
  }
  function M() {
    var e;
    return (e = I.current) == null ? void 0 : e.querySelector(`${le}[aria-selected="true"]`);
  }
  function V() {
    var e;
    return Array.from(((e = I.current) == null ? void 0 : e.querySelectorAll(ce)) || []);
  }
  function X2(e) {
    let s2 = V()[e];
    s2 && E.setState("value", s2.getAttribute(T));
  }
  function Q(e) {
    var g;
    let a2 = M(), s2 = V(), i = s2.findIndex((y2) => y2 === a2), l = s2[i + e];
    (g = p2.current) != null && g.loop && (l = i + e < 0 ? s2[s2.length - 1] : i + e === s2.length ? s2[0] : s2[i + e]), l && E.setState("value", l.getAttribute(T));
  }
  function re2(e) {
    let a2 = M(), s2 = a2 == null ? void 0 : a2.closest(N), i;
    for (; s2 && !i; ) s2 = e > 0 ? we(s2, N) : De(s2, N), i = s2 == null ? void 0 : s2.querySelector(ce);
    i ? E.setState("value", i.getAttribute(T)) : Q(e);
  }
  let oe = () => X2(V().length - 1), ie = (e) => {
    e.preventDefault(), e.metaKey ? oe() : e.altKey ? re2(1) : Q(1);
  }, se = (e) => {
    e.preventDefault(), e.metaKey ? X2(0) : e.altKey ? re2(-1) : Q(-1);
  };
  return reactExports.createElement(Primitive.div, { ref: o, tabIndex: -1, ...O, "cmdk-root": "", onKeyDown: (e) => {
    var s2;
    (s2 = O.onKeyDown) == null || s2.call(O, e);
    let a2 = e.nativeEvent.isComposing || e.keyCode === 229;
    if (!(e.defaultPrevented || a2)) switch (e.key) {
      case "n":
      case "j": {
        j && e.ctrlKey && ie(e);
        break;
      }
      case "ArrowDown": {
        ie(e);
        break;
      }
      case "p":
      case "k": {
        j && e.ctrlKey && se(e);
        break;
      }
      case "ArrowUp": {
        se(e);
        break;
      }
      case "Home": {
        e.preventDefault(), X2(0);
        break;
      }
      case "End": {
        e.preventDefault(), oe();
        break;
      }
      case "Enter": {
        e.preventDefault();
        let i = M();
        if (i) {
          let l = new Event(Z);
          i.dispatchEvent(l);
        }
      }
    }
  } }, reactExports.createElement("label", { "cmdk-label": "", htmlFor: U2.inputId, id: U2.labelId, style: Te }, b), B(r, (e) => reactExports.createElement(de.Provider, { value: E }, reactExports.createElement(ue.Provider, { value: U2 }, e))));
}), he = reactExports.forwardRef((r, o) => {
  var _, I;
  let n = useId$1(), u2 = reactExports.useRef(null), c2 = reactExports.useContext(fe), d = K(), f = pe(r), p2 = (I = (_ = f.current) == null ? void 0 : _.forceMount) != null ? I : c2 == null ? void 0 : c2.forceMount;
  k(() => {
    if (!p2) return d.item(n, c2 == null ? void 0 : c2.id);
  }, [p2]);
  let b = ve(n, u2, [r.value, r.children, u2], r.keywords), m2 = ee(), R = P((v) => v.value && v.value === b.current), x2 = P((v) => p2 || d.filter() === false ? true : v.search ? v.filtered.items.get(n) > 0 : true);
  reactExports.useEffect(() => {
    let v = u2.current;
    if (!(!v || r.disabled)) return v.addEventListener(Z, C), () => v.removeEventListener(Z, C);
  }, [x2, r.onSelect, r.disabled]);
  function C() {
    var v, E;
    S(), (E = (v = f.current).onSelect) == null || E.call(v, b.current);
  }
  function S() {
    m2.setState("value", b.current, true);
  }
  if (!x2) return null;
  let { disabled: A, value: ge, onSelect: j, forceMount: O, keywords: $2, ...q } = r;
  return reactExports.createElement(Primitive.div, { ref: composeRefs(u2, o), ...q, id: n, "cmdk-item": "", role: "option", "aria-disabled": !!A, "aria-selected": !!R, "data-disabled": !!A, "data-selected": !!R, onPointerMove: A || d.getDisablePointerSelection() ? void 0 : S, onClick: A ? void 0 : C }, r.children);
}), Ee = reactExports.forwardRef((r, o) => {
  let { heading: n, children: u2, forceMount: c2, ...d } = r, f = useId$1(), p2 = reactExports.useRef(null), b = reactExports.useRef(null), m2 = useId$1(), R = K(), x2 = P((S) => c2 || R.filter() === false ? true : S.search ? S.filtered.groups.has(f) : true);
  k(() => R.group(f), []), ve(f, p2, [r.value, r.heading, b]);
  let C = reactExports.useMemo(() => ({ id: f, forceMount: c2 }), [c2]);
  return reactExports.createElement(Primitive.div, { ref: composeRefs(p2, o), ...d, "cmdk-group": "", role: "presentation", hidden: x2 ? void 0 : true }, n && reactExports.createElement("div", { ref: b, "cmdk-group-heading": "", "aria-hidden": true, id: m2 }, n), B(r, (S) => reactExports.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? m2 : void 0 }, reactExports.createElement(fe.Provider, { value: C }, S))));
}), ye = reactExports.forwardRef((r, o) => {
  let { alwaysRender: n, ...u2 } = r, c2 = reactExports.useRef(null), d = P((f) => !f.search);
  return !n && !d ? null : reactExports.createElement(Primitive.div, { ref: composeRefs(c2, o), ...u2, "cmdk-separator": "", role: "separator" });
}), Se = reactExports.forwardRef((r, o) => {
  let { onValueChange: n, ...u2 } = r, c2 = r.value != null, d = ee(), f = P((m2) => m2.search), p2 = P((m2) => m2.selectedItemId), b = K();
  return reactExports.useEffect(() => {
    r.value != null && d.setState("search", r.value);
  }, [r.value]), reactExports.createElement(Primitive.input, { ref: o, ...u2, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: false, "aria-autocomplete": "list", role: "combobox", "aria-expanded": true, "aria-controls": b.listId, "aria-labelledby": b.labelId, "aria-activedescendant": p2, id: b.inputId, type: "text", value: c2 ? r.value : f, onChange: (m2) => {
    c2 || d.setState("search", m2.target.value), n == null || n(m2.target.value);
  } });
}), Ce = reactExports.forwardRef((r, o) => {
  let { children: n, label: u2 = "Suggestions", ...c2 } = r, d = reactExports.useRef(null), f = reactExports.useRef(null), p2 = P((m2) => m2.selectedItemId), b = K();
  return reactExports.useEffect(() => {
    if (f.current && d.current) {
      let m2 = f.current, R = d.current, x2, C = new ResizeObserver(() => {
        x2 = requestAnimationFrame(() => {
          let S = m2.offsetHeight;
          R.style.setProperty("--cmdk-list-height", S.toFixed(1) + "px");
        });
      });
      return C.observe(m2), () => {
        cancelAnimationFrame(x2), C.unobserve(m2);
      };
    }
  }, []), reactExports.createElement(Primitive.div, { ref: composeRefs(d, o), ...c2, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": p2, "aria-label": u2, id: b.listId }, B(r, (m2) => reactExports.createElement("div", { ref: composeRefs(f, b.listInnerRef), "cmdk-list-sizer": "" }, m2)));
}), xe = reactExports.forwardRef((r, o) => {
  let { open: n, onOpenChange: u2, overlayClassName: c2, contentClassName: d, container: f, ...p2 } = r;
  return reactExports.createElement(Root$3, { open: n, onOpenChange: u2 }, reactExports.createElement(Portal$1, { container: f }, reactExports.createElement(Overlay, { "cmdk-overlay": "", className: c2 }), reactExports.createElement(Content$1, { "aria-label": r.label, "cmdk-dialog": "", className: d }, reactExports.createElement(me, { ref: o, ...p2 }))));
}), Ie = reactExports.forwardRef((r, o) => P((u2) => u2.filtered.count === 0) ? reactExports.createElement(Primitive.div, { ref: o, ...r, "cmdk-empty": "", role: "presentation" }) : null), Pe = reactExports.forwardRef((r, o) => {
  let { progress: n, children: u2, label: c2 = "Loading...", ...d } = r;
  return reactExports.createElement(Primitive.div, { ref: o, ...d, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": c2 }, B(r, (f) => reactExports.createElement("div", { "aria-hidden": true }, f)));
}), _e = Object.assign(me, { List: Ce, Item: he, Input: Se, Group: Ee, Separator: ye, Dialog: xe, Empty: Ie, Loading: Pe });
function we(r, o) {
  let n = r.nextElementSibling;
  for (; n; ) {
    if (n.matches(o)) return n;
    n = n.nextElementSibling;
  }
}
function De(r, o) {
  let n = r.previousElementSibling;
  for (; n; ) {
    if (n.matches(o)) return n;
    n = n.previousElementSibling;
  }
}
function pe(r) {
  let o = reactExports.useRef(r);
  return k(() => {
    o.current = r;
  }), o;
}
var k = typeof window == "undefined" ? reactExports.useEffect : reactExports.useLayoutEffect;
function L(r) {
  let o = reactExports.useRef();
  return o.current === void 0 && (o.current = r()), o;
}
function P(r) {
  let o = ee(), n = () => r(o.snapshot());
  return reactExports.useSyncExternalStore(o.subscribe, n, n);
}
function ve(r, o, n, u2 = []) {
  let c2 = reactExports.useRef(), d = K();
  return k(() => {
    var b;
    let f = (() => {
      var m2;
      for (let R of n) {
        if (typeof R == "string") return R.trim();
        if (typeof R == "object" && "current" in R) return R.current ? (m2 = R.current.textContent) == null ? void 0 : m2.trim() : c2.current;
      }
    })(), p2 = u2.map((m2) => m2.trim());
    d.value(r, f, p2), (b = o.current) == null || b.setAttribute(T, f), c2.current = f;
  }), c2;
}
var ke = () => {
  let [r, o] = reactExports.useState(), n = L(() => /* @__PURE__ */ new Map());
  return k(() => {
    n.current.forEach((u2) => u2()), n.current = /* @__PURE__ */ new Map();
  }, [r]), (u2, c2) => {
    n.current.set(u2, c2), o({});
  };
};
function Me(r) {
  let o = r.type;
  return typeof o == "function" ? o(r.props) : "render" in o ? o.render(r.props) : r;
}
function B({ asChild: r, children: o }, n) {
  return r && reactExports.isValidElement(o) ? reactExports.cloneElement(Me(o), { ref: o.ref }, n(o.props.children)) : n(o);
}
var Te = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };
const Command = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e,
  {
    ref,
    className: cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    ),
    ...props
  }
));
Command.displayName = _e.displayName;
const CommandInput = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center border-b px-3", "data-cmdk-input-wrapper": "", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    _e.Input,
    {
      ref,
      className: cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      ),
      ...props
    }
  )
] }));
CommandInput.displayName = _e.Input.displayName;
const CommandList = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.List,
  {
    ref,
    className: cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className),
    ...props
  }
));
CommandList.displayName = _e.List.displayName;
const CommandEmpty = reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(_e.Empty, { ref, className: "py-6 text-center text-sm", ...props }));
CommandEmpty.displayName = _e.Empty.displayName;
const CommandGroup = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.Group,
  {
    ref,
    className: cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    ),
    ...props
  }
));
CommandGroup.displayName = _e.Group.displayName;
const CommandSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(_e.Separator, { ref, className: cn("-mx-1 h-px bg-border", className), ...props }));
CommandSeparator.displayName = _e.Separator.displayName;
const CommandItem = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.Item,
  {
    ref,
    className: cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    ),
    ...props
  }
));
CommandItem.displayName = _e.Item.displayName;
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover$1 = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId$1(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: reactExports.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: reactExports.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover$1.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    reactExports.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME$1 = "PopoverTrigger";
var PopoverTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME$1, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$1(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger$1.displayName = TRIGGER_NAME$1;
var PORTAL_NAME = "PopoverPortal";
var [PortalProvider, usePortalContext] = createPopoverContext(PORTAL_NAME, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "PopoverContent";
var PopoverContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent$1.displayName = CONTENT_NAME;
var Slot = createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          if (!isRightClickOutsideRef.current) context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content$2,
              {
                "data-state": getState$1(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME = "PopoverArrow";
var PopoverArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME;
function getState$1(open) {
  return open ? "open" : "closed";
}
var Root2 = Popover$1;
var Trigger = PopoverTrigger$1;
var Portal = PopoverPortal;
var Content2 = PopoverContent$1;
const Popover = Root2;
const PopoverTrigger = Trigger;
const PopoverContent = reactExports.forwardRef(({ className, align = "center", sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content2,
  {
    ref,
    align,
    sideOffset,
    className: cn(
      "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
      className
    ),
    ...props
  }
) }));
PopoverContent.displayName = Content2.displayName;
function PlaceSelector({ type }) {
  const { t } = useTranslation("game");
  const { fromPlace, toPlace, selectingCoordinate, setSelectingCoordinate, handlePlaceChange } = useJourneyPlanner();
  const [open, setOpen] = reactExports.useState(false);
  const [searchValue, setSearchValue] = reactExports.useState("");
  const stations = useStations();
  const routes = useRoutes();
  const { setUserAction } = useUi();
  const currentPlace = type === "from" ? fromPlace : toPlace;
  const isSelectingThis = selectingCoordinate === type;
  const selectedStation = currentPlace?.type === "station" ? stations.find((s2) => s2.id === currentPlace.stationId) : null;
  const handleReselect = () => {
    setSelectingCoordinate(type);
    setUserAction("select-journey-location");
  };
  const handleSelect = (value) => {
    handlePlaceChange(type, value);
    setOpen(false);
    setSearchValue("");
  };
  const placeHolderText = type === "from" ? t("panels.journeyPlanner.selectOrigin") : t("panels.journeyPlanner.selectDestination");
  const filteredStations = stations.filter((station) => {
    const searchTerms = searchValue.toLowerCase().trim().split(/\s+/).filter((term) => term.length > 0);
    if (searchTerms.length === 0) {
      return true;
    }
    return searchTerms.every((term) => {
      if (!station.name) return false;
      const nameMatch = station.name.toLowerCase().includes(term);
      const routeMatch = station.routeIds.some((routeId) => {
        const route = routes.find((r) => r.id === routeId);
        return route?.bullet.toLowerCase().includes(term);
      });
      return nameMatch || routeMatch;
    });
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1 flex-1 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { open, onOpenChange: setOpen, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "outline",
            role: "combobox",
            "aria-expanded": open,
            className: cn(
              "w-full justify-between",
              isSelectingThis && "border-primary",
              !currentPlace && "text-muted-foreground"
            ),
            children: [
              currentPlace?.type === "coords" && /* @__PURE__ */ jsxRuntimeExports.jsx(CoordinateDisplay, {}),
              selectedStation && /* @__PURE__ */ jsxRuntimeExports.jsx(StationDisplay, { station: selectedStation, routes }),
              !currentPlace && placeHolderText,
              /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronsUpDown, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent, { className: "w-[300px] p-0", align: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Command, { filter: () => 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CommandInput,
            {
              placeholder: t("panels.journeyPlanner.searchStationsOrRoutes"),
              value: searchValue,
              onValueChange: setSearchValue
            }
          ),
          searchValue && filteredStations.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(CommandEmpty, { children: t("panels.journeyPlanner.noStationFound") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CommandGroup, { className: "max-h-[300px] overflow-y-auto", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CommandItem, { value: "coords", onSelect: () => handleSelect("coords"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Crosshair, { className: "h-4 w-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t("panels.journeyPlanner.selectOnMap") })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CommandSeparator, { className: "my-1" }),
            filteredStations.map((station) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              CommandItem,
              {
                value: station.id,
                onSelect: () => handleSelect(station.id),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Check,
                    {
                      className: cn(
                        "mr-1 h-4 w-4",
                        selectedStation?.id === station.id ? "opacity-100" : "opacity-0"
                      )
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(StationItem, { station, routes })
                ]
              },
              station.id
            ))
          ] })
        ] }) })
      ] }),
      currentPlace?.type === "coords" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "ghost",
          size: "icon",
          onClick: handleReselect,
          className: "h-9 aspect-square rounded-full",
          title: t("panels.journeyPlanner.reselectLocation"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Crosshair, { className: "h-4 w-4" })
        }
      )
    ] }),
    isSelectingThis && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: t("panels.journeyPlanner.clickMapToSelect") })
  ] });
}
function StationItem({ station, routes }) {
  const { t } = useTranslation("game");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 flex-1", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: station.name || t("panels.journeyPlanner.unnamedStation") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-0.5 ml-auto", children: routes.filter((route) => station.routeIds.includes(route.id)).map((route) => /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route, size: 1, ignoreHover: true, yTranslate: -0.01 }, route.id)) })
  ] });
}
function CoordinateDisplay() {
  const { t } = useTranslation("game");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Crosshair, { className: "h-4 w-4" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t("panels.journeyPlanner.customLocation") })
  ] });
}
function StationDisplay({
  station,
  routes,
  ...props
}) {
  const { t } = useTranslation("game");
  const stationRoutes = routes.filter((route) => station.routeIds.includes(route.id));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 flex-1 min-w-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate", children: station.name || t("panels.journeyPlanner.unnamedStation") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-0.5 flex-shrink-0", children: stationRoutes.map((route) => /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route, size: 1, ignoreHover: true, yTranslate: -0.01 }, route.id)) })
  ] });
}
function JourneyForm() {
  const { fromPlace, toPlace, reverseStations } = useJourneyPlanner();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(LocationIcons, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center gap-1 w-56", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(PlaceSelector, { type: "from" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(PlaceSelector, { type: "to" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReverseButton, { disabled: !fromPlace || !toPlace, onClick: reverseStations })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(JourneySettings, {})
  ] });
}
function LocationIcons() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-fit flex flex-col justify-evenly self-stretch px-0.5", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "h-4 w-4 text-muted-foreground" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDown, { className: "h-4 w-4 text-muted-foreground" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "h-4 w-4 text-muted-foreground" })
  ] });
}
function ReverseButton({ disabled, onClick }) {
  const { t } = useTranslation("game");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-end justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      variant: "ghost",
      size: "icon",
      onClick,
      disabled,
      className: "h-10 w-10 rounded-full p-3",
      title: t("panels.journeyPlanner.reverseLocations"),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpDown, { className: "h-full w-full" })
    }
  ) });
}
function JourneyOptionCard({ path }) {
  const { t } = useTranslation("game");
  const timeConfig = useTimeConfig();
  const { use24HourTime } = useSettings();
  const [isExpanded, setIsExpanded] = reactExports.useState(false);
  if (path.segments.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.journeyPlanner.noPathFound") });
  }
  const tableRows = [
    {
      label: t("panels.journeyPlanner.transfersDebug"),
      value: path.transfers.toString()
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col gap-1.5 border rounded-lg p-2 py-1.5 dark:bg-input/30 dark:hover:bg-muted/50 cursor-pointer backdrop-blur-sm",
      onClick: () => setIsExpanded(!isExpanded),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: formatMinutes$1(path.totalTime) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CircleChevronDown,
            {
              className: cn(
                "w-4 h-4 text-muted-foreground transition-all duration-800 ease-in-out",
                !isExpanded ? "-rotate-90" : ""
              )
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-muted-foreground whitespace-nowrap", children: [
          t("panels.journeyPlanner.leave"),
          " ",
          formatTimeToLeave({
            departureTime: path.segments[0].departureTime,
            currentTime: timeConfig.elapsedSeconds,
            use24Hour: use24HourTime,
            t
          })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-1.5", children: path.segments.map((segment, segIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5", children: [
          segIndex > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Triangle, { className: "w-1.5 aspect-square fill-primary stroke-primary rotate-90" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SmallJourneySegment, { segment }, segIndex)
        ] }, segIndex)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: cn(
              "overflow-hidden transition-all duration-800 ease-in-out",
              isExpanded ? "max-h-96 opacity-100 mt-2" : "-mt-1 h-0 opacity-0"
            ),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 overflow-y-auto h-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col", children: path.segments.map((segment, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(BigJourneySegment, { segment }, i)) }),
              DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: tableRows })
            ] })
          }
        )
      ]
    }
  );
}
function SmallJourneySegment({ segment }) {
  const { t } = useTranslation("game");
  const routes = useRoutes();
  if (segment.isWalking) {
    const time2 = formatMinutes$1(segment.arrivalTime - segment.departureTime, { suffix: "m" });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BsPersonWalking, { className: "w-fit h-4 -ml-[0.2rem]" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs whitespace-nowrap", children: time2 })
    ] });
  }
  const route = routes.find((r) => r.id === segment.routeId);
  if (!route) return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t("panels.journeyPlanner.routeNotFound") });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route, size: 1, yTranslate: 0.01, className: "cursor-pointer" });
}
function BigJourneySegment({ segment }) {
  const { t } = useTranslation("game");
  const routes = useRoutes();
  const stations = useStations();
  const timeConfig = useTimeConfig();
  const { use24HourTime } = useSettings();
  if (segment.isWalking) {
    const time22 = formatMinutes$1(segment.arrivalTime - segment.departureTime);
    let stationName = t("panels.journeyPlanner.unknown");
    if (segment.toStopId === "origin") {
      stationName = t("panels.journeyPlanner.origin");
    } else if (segment.toStopId === "destination") {
      stationName = t("panels.journeyPlanner.destination");
    } else {
      const station = stations.find((s2) => s2.id === segment.toStopId);
      stationName = station?.name + " " + t("panels.journeyPlanner.station") || t("panels.journeyPlanner.unknownStation");
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-3 py-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center pt-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(BsPersonWalking, { className: "w-5 h-5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full w-0.5 bg-muted/50 mx-auto flex-1" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-medium", children: [
          t("panels.journeyPlanner.walkTo"),
          " ",
          stationName
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground", children: [
          time22,
          " ",
          t("panels.journeyPlanner.walk")
        ] })
      ] })
    ] });
  }
  const route = routes.find((r) => r.id === segment.routeId);
  if (!route) return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t("panels.journeyPlanner.routeNotFound") });
  const time2 = formatMinutes$1(segment.arrivalTime - segment.departureTime);
  let routeText;
  if (route.bullet.length < 1 || route.bullet === " ") {
    routeText = t("panels.journeyPlanner.rideFor", { time: time2 });
  } else {
    routeText = t("panels.journeyPlanner.rideThe", { route: route.bullet, time: time2 });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-3 py-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center pt-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route, size: 1.2, yTranslate: 0.01, className: "cursor-pointer" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full w-0.5 bg-muted/50 mx-auto flex-1" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: routeText }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground", children: [
        t("panels.journeyPlanner.from"),
        " ",
        stations.find((s2) => s2.id === segment.fromStopId)?.name || t("panels.journeyPlanner.unknown"),
        " ",
        t("panels.journeyPlanner.to"),
        " ",
        stations.find((s2) => s2.id === segment.toStopId)?.name || t("panels.journeyPlanner.unknown")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground", children: [
        t("panels.journeyPlanner.departs"),
        " ",
        formatTimeToLeave({
          departureTime: segment.departureTime,
          currentTime: timeConfig.elapsedSeconds,
          use24Hour: use24HourTime,
          t
        })
      ] })
    ] })
  ] });
}
function formatTimeToLeave({ departureTime, currentTime, use24Hour, t }) {
  const timeToLeave = departureTime - currentTime;
  if (timeToLeave < 60 && timeToLeave > 0) {
    return t("panels.journeyPlanner.now").toLowerCase();
  }
  if (timeToLeave > 2 * 60 * 60 || timeToLeave < 0) {
    const time2 = formatClockTime(departureTime, use24Hour);
    return `${t("panels.journeyPlanner.at")} ${time2.hours}:${time2.minutes}${time2.period ? " " + time2.period : ""}`;
  }
  const hours = Math.floor(timeToLeave / 3600);
  const minutes = Math.floor(timeToLeave % 3600 / 60);
  if (hours > 0) {
    return `in ${hours}h ${minutes}m`;
  }
  return `in ${minutes}m`;
}
function JourneyResults() {
  const { t } = useTranslation("game");
  const { searchResults, fromPlace, toPlace } = useJourneyPlanner();
  if (!fromPlace || !toPlace) {
    return null;
  }
  if (searchResults.length > 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyCard, { title: t("panels.journeyPlanner.options"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: searchResults.map((path, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyOptionCard, { path }, index2)) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyCard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center pb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: t("panels.journeyPlanner.noTransitPathFound") }) }) });
}
function JourneyCard({ title, children, className }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex flex-col gap-2", className), children: [
    title && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold", children: title }),
    children
  ] });
}
function JourneyPlannerPanel() {
  const stations = useStations();
  const routes = useRoutes();
  if (stations.length === 0 || routes.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyPlannerProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyForm, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyResults, {})
  ] }) });
}
function EmptyState() {
  const { t } = useTranslation("game");
  const stations = useStations();
  const routes = useRoutes();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-start gap-2 flex flex-col text-muted-foreground p-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t("panels.journeyPlanner.addStationsPrompt") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t("panels.journeyPlanner.currentStats", { stations: stations.length, routes: routes.length }) })
  ] });
}
function ColorPicker({ value = "#000000", onChange, className }) {
  const [localValue, setLocalValue] = reactExports.useState(value);
  const handleInputChange = (e) => {
    const val = e.target.value;
    setLocalValue(val);
    try {
      const testColor = Color$1(val);
      onChange?.(testColor.hex());
    } catch {
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", className: cn("w-full justify-start text-xs h-8", className), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-4 rounded border flex-shrink-0", style: { backgroundColor: localValue } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1 text-left", children: "Custom Color" })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent, { className: "w-56 p-3", align: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-16 w-full rounded border", style: { backgroundColor: localValue } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$1,
        {
          value: localValue,
          onChange: handleInputChange,
          placeholder: "#000000",
          className: "font-mono text-sm h-8"
        }
      )
    ] }) })
  ] });
}
function NewRouteForm() {
  const { t } = useTranslation("game");
  const routes = useRoutes();
  const { generateRoute: handleGenerateRoute, setRoutes } = useMainStore();
  const { navigate, currentNavigationState } = useUi();
  const [selectedColor, setSelectedColor] = reactExports.useState("");
  const [routeName, setRouteName] = reactExports.useState("");
  const [selectedShape, setSelectedShape] = reactExports.useState("circle");
  const [selectedTrainType, setSelectedTrainType] = reactExports.useState("heavy-metro");
  const editingRouteId = currentNavigationState?.itemId;
  const editingRoute = editingRouteId ? routes.find((r) => r.id === editingRouteId) : null;
  const isEditing = !!editingRoute;
  reactExports.useEffect(() => {
    if (editingRoute) {
      setRouteName(editingRoute.bullet);
      setSelectedColor(editingRoute.color);
      setSelectedShape(editingRoute.shape || "circle");
      setSelectedTrainType(editingRoute.trainType || "heavy-metro");
    }
  }, [editingRoute]);
  reactExports.useEffect(() => {
    if (!isEditing) {
      const availableColor = ROUTE_COLORS.find((color2) => !routes.some((route) => route.color === color2.bgColor));
      if (availableColor) {
        setSelectedColor(availableColor.bgColor);
      }
    }
  }, [routes, isEditing]);
  function handleSaveRoute() {
    if (!selectedColor) return;
    const getTextColor = (bgColor) => {
      try {
        const color2 = Color$1(bgColor);
        return color2.isLight() ? "#000000" : "#ffffff";
      } catch {
        return "#ffffff";
      }
    };
    if (isEditing && editingRoute) {
      const colorInfo = ROUTE_COLORS.find((c2) => c2.bgColor === selectedColor);
      const textColor = colorInfo ? colorInfo.textColor : getTextColor(selectedColor);
      const updatedRoutes = routes.map(
        (route) => route.id === editingRoute.id ? {
          ...route,
          bullet: routeName,
          color: selectedColor,
          textColor,
          shape: selectedShape
        } : route
      );
      setRoutes(updatedRoutes, true);
    } else {
      handleGenerateRoute({
        customBullet: routeName,
        customColor: selectedColor,
        customShape: selectedShape,
        trainType: selectedTrainType
      });
    }
    setRouteName("");
    setSelectedColor("");
    setSelectedShape("circle");
    setSelectedTrainType("heavy-metro");
    navigate("back");
  }
  function handleCancel() {
    setRouteName("");
    setSelectedColor("");
    setSelectedShape("circle");
    setSelectedTrainType("heavy-metro");
    navigate("back");
  }
  const routeForIcon = generateRoute({
    routes: [],
    customBullet: routeName,
    existingColor: selectedColor || "#a7a9ac",
    customColor: selectedColor || "#a7a9ac",
    customShape: selectedShape
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-full space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route: routeForIcon, size: 2, className: "w-fit mx-auto" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormSection, { title: t("panels.routes.routeNameOptional"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$1,
      {
        id: "route-name",
        value: routeName,
        onChange: (e) => setRouteName(e.target.value),
        placeholder: t("panels.routes.routeNamePlaceholder"),
        maxLength: MAX_ROUTE_NAME_LENGTH,
        className: "h-8"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormSection, { title: t("panels.routes.color"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-5 gap-2", children: ROUTE_COLORS.map((color2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: cn(
              "h-8 w-8 rounded-md border-2 transition-all",
              selectedColor === color2.bgColor ? "border-primary scale-110" : "border-transparent hover:border-gray-300"
            ),
            style: { backgroundColor: color2.bgColor },
            onClick: () => {
              setSelectedColor(color2.bgColor);
            }
          },
          color2.bgColor
        );
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColorPicker,
        {
          value: selectedColor || "#000000",
          onChange: (color2) => {
            setSelectedColor(color2);
          },
          className: "h-8"
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormSection, { title: t("panels.routes.shape"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: cn(
          "flex gap-2 justify-between",
          routeName.length > 7 ? "flex-col items-center" : "flex-wrap"
        ),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteIcon,
            {
              route: { ...routeForIcon, shape: "circle" },
              size: 2,
              className: cn(
                "cursor-pointer transition-all w-fit",
                selectedShape === "circle" ? "border-primary border-2 scale-105" : "border-transparent hover:border-gray-300"
              ),
              onClick: () => setSelectedShape("circle")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteIcon,
            {
              route: { ...routeForIcon, shape: "diamond" },
              size: 2,
              className: cn(
                "cursor-pointer transition-all w-fit",
                selectedShape === "diamond" ? "border-primary border-2 scale-105" : "border-transparent hover:border-gray-300"
              ),
              onClick: () => setSelectedShape("diamond")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteIcon,
            {
              route: { ...routeForIcon, shape: "square" },
              size: 2,
              className: cn(
                "cursor-pointer transition-all w-fit",
                selectedShape === "square" ? "border-primary border-2 scale-105" : "border-transparent hover:border-gray-300"
              ),
              onClick: () => setSelectedShape("square")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteIcon,
            {
              route: { ...routeForIcon, shape: "triangle" },
              size: 2,
              className: cn(
                "cursor-pointer transition-all w-fit",
                selectedShape === "triangle" ? "border-primary border-2 scale-105" : "border-transparent hover:border-gray-300"
              ),
              onClick: () => setSelectedShape("triangle")
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(FormSection, { title: t("panels.routes.trainType"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Select,
        {
          value: selectedTrainType,
          onValueChange: (value) => setSelectedTrainType(value),
          disabled: isEditing,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "max-h-8 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: Object.entries(TRAIN_TYPES).map(([id, type]) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: id, children: type.name }, id)) })
          ]
        }
      ),
      isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: t("panels.routes.trainTypeCannotChange") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CustomButton,
        {
          size: "lg",
          className: "w-full",
          onClick: handleSaveRoute,
          disabled: !selectedColor,
          "data-tutorial": "create-route-button",
          children: isEditing ? t("panels.routes.saveChanges") : t("panels.routes.createRoute")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CustomButton, { size: "lg", variant: "destructive", className: "w-full", onClick: handleCancel, children: t("actions.cancel") })
    ] })
  ] });
}
function FormSection({ title, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "text-xs", children: title }),
    children
  ] });
}
function PopDetailsPanel() {
  const { t } = useTranslation("game");
  const demandData = useDemandData();
  const { simulateCommutes } = useMainStore();
  const { currentNavigationState, pushNavigationState } = useUi();
  const selectedPopId = currentNavigationState.itemId;
  if (!selectedPopId) return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Error: Pop ID not found" });
  const pop = demandData.popsMap.get(selectedPopId);
  if (!pop) return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Error: Pop not found" });
  const isAirportWorker = pop.jobId.startsWith("AIR_");
  const isCollegeWorker = pop.jobId.startsWith("UNI_");
  const commuteTimeTableRows = [
    {
      label: t("panels.popDetails.homeDepartureTime"),
      value: formatTimeHHMM(pop.homeDepartureTime)
    },
    {
      label: t("panels.popDetails.workDepartureTime"),
      value: formatTimeHHMM(pop.workDepartureTime)
    }
  ];
  const walkingTableRows = [
    {
      label: t("panels.popDetails.walkingTime"),
      value: formatTime$1(pop.lastCommute?.walking.time || 0, {
        options: { forceMinutes: true, roundSeconds: true }
      }) + (isAirportWorker ? " (50% slower)" : "")
    },
    { label: t("panels.popDetails.walkingDistance"), value: formatDistance$1(pop.lastCommute?.walking.distance || 0) }
  ];
  const parkingCost = isAirportWorker ? PATHFINDING_RULES.PARKING_COST * PATHFINDING_RULES.AIRPORT_PARKING_COST_MULTIPLIER : PATHFINDING_RULES.PARKING_COST;
  const homeToWorkHour = Math.floor(pop.homeDepartureTime / 3600);
  const workToHomeHour = Math.floor(pop.workDepartureTime / 3600);
  const homeToWorkMultiplier = getDrivingTimeMultiplier(getTimeOfDay(homeToWorkHour));
  const workToHomeMultiplier = getDrivingTimeMultiplier(getTimeOfDay(workToHomeHour));
  const homeToWorkDrivingSeconds = pop.drivingSeconds * homeToWorkMultiplier;
  const workToHomeDrivingSeconds = pop.drivingSeconds * workToHomeMultiplier;
  const drivingTableRows = [
    {
      label: t("panels.popDetails.drivingTimeHomeWork"),
      value: `${formatTime$1(homeToWorkDrivingSeconds, { options: { roundSeconds: true } })}`,
      valueInfoTooltip: t("panels.popDetails.trafficMultiplier", { percent: (homeToWorkMultiplier * 100).toFixed(0) })
    },
    {
      label: t("panels.popDetails.drivingTimeWorkHome"),
      value: `${formatTime$1(workToHomeDrivingSeconds, { options: { roundSeconds: true } })}`,
      valueInfoTooltip: t("panels.popDetails.trafficMultiplier", { percent: (workToHomeMultiplier * 100).toFixed(0) })
    },
    { label: t("panels.popDetails.drivingDistance"), value: formatDistance$1(pop.drivingDistance) },
    {
      label: t("panels.popDetails.drivingCost"),
      value: formatCurrency(pop.drivingDistance / 1e3 * PATHFINDING_RULES.DRIVING_COST_PER_KM)
    },
    {
      label: t("panels.popDetails.parkingCost"),
      value: formatCurrency(parkingCost) + (isAirportWorker ? ` (${PATHFINDING_RULES.AIRPORT_PARKING_COST_MULTIPLIER}x)` : "")
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4 w-full max-w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { style: { strokeWidth: 2.5 }, className: "w-4" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-base", children: t("panels.popDetails.commuters", { count: pop.size }) }),
      isAirportWorker && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: AIRPORT_WORKER_TEXT }),
      isCollegeWorker && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: COLLEGE_WORKER_TEXT })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.popDetails.transportationChoices"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ModeChoiceChart,
      {
        modeChoice: pop.lastCommute?.modeChoice || { walking: 0, driving: 0, transit: 0, unknown: 0 },
        size: "md"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.popDetails.transitPaths"), children: pop.lastCommute ? pop.lastCommute.transitPaths.length > 0 ? pop.lastCommute.transitPaths.map((path, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyOptionCard, { path }, index2)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: t("panels.popDetails.noTransitPaths") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: t("panels.popDetails.commuteNotCalculated") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.popDetails.driving"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: drivingTableRows }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.popDetails.walking"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: walkingTableRows }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          className: "text-xs w-full gap-2 h-fit justify-start pl-0",
          variant: "link",
          size: "sm",
          onClick: () => {
            pushNavigationState({
              type: "demand-point-details",
              itemId: pop.residenceId,
              view: null
            });
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(House, { className: "h-2.5 w-2.5" }),
            t("panels.popDetails.homePoint"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { className: "h-2.5 w-2.5" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          className: "text-xs w-full gap-2 justify-start pl-0 h-fit",
          variant: "link",
          size: "sm",
          onClick: () => {
            pushNavigationState({
              type: "demand-point-details",
              itemId: pop.jobId,
              view: null
            });
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { className: "h-2.5 w-2.5" }),
            t("panels.popDetails.workPoint"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { className: "h-2.5 w-2.5" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: commuteTimeTableRows }),
    DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          onClick: () => simulateCommutes({ popCommutes: [{ popId: pop.id }] }),
          children: t("panels.popDetails.debugSimCommute")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "sm", onClick: () => console.log(pop), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, { className: "w-4 h-4" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "ID: ",
        pop.id
      ] })
    ] })
  ] });
}
function PopMovementPanel() {
  const { selectedPopMovementIds } = useUi();
  const demandData = useDemandData();
  if (!selectedPopMovementIds || selectedPopMovementIds.length === 0) return null;
  let totalPopSize = 0;
  const popPreviewCards = [];
  for (const selectedPopMovementId of selectedPopMovementIds) {
    const pop = demandData.popsMap.get(selectedPopMovementId);
    if (!pop) continue;
    popPreviewCards.push(/* @__PURE__ */ jsxRuntimeExports.jsx(PopPreviewCard, { pop }, selectedPopMovementId));
    totalPopSize += pop.size;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: `${totalPopSize} people`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 w-full", children: popPreviewCards }) });
}
function RouteStationsView({ route }) {
  const { t } = useTranslation("game");
  const { setUserAction, userAction } = useUi();
  const setPreviewRoute = useMainStore((state) => state.setPreviewRoute);
  const confirmRouteChange = useMainStore((state) => state.confirmRouteChange);
  const previewRoute = usePreviewRoute();
  const stations = useStations();
  const [activeRaptorRouteIndex, setActiveRaptorRouteIndex] = reactExports.useState(0);
  const usePreviewRouteStations = previewRoute?.stComboTimings?.length && previewRoute.stComboTimings.length > 0;
  const routeToUse = usePreviewRouteStations ? previewRoute : route;
  const raptorRoutes = convertToRaptorFormat({
    routes: [routeToUse],
    stations,
    trains: [],
    includeRoutesWithoutTrains: true
  });
  const isEditing = userAction === "draw-line-track";
  function handleEditRoute() {
    if (isEditing) {
      setUserAction("none");
      setPreviewRoute(null);
      return;
    }
    setUserAction("draw-line-track");
    setPreviewRoute(route);
  }
  function handleConfirmRouteChange() {
    const { success } = confirmRouteChange();
    if (success) {
      setUserAction("none");
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
    raptorRoutes && raptorRoutes.raptorRoutes.length > 0 && raptorRoutes.raptorRoutes[0].stops.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        RouteDirectionToggle,
        {
          raptorRouteOptions: raptorRoutes.raptorRoutes.length,
          activeRaptorRouteIndex,
          setActiveRaptorRouteIndex
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StationsList,
        {
          raptorRoutes: raptorRoutes.raptorRoutes,
          activeRaptorRouteIndex,
          route: routeToUse
        }
      )
    ] }),
    isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "outline",
        size: "sm",
        onClick: () => {
          handleConfirmRouteChange();
        },
        "data-tutorial": "confirm-route-button",
        children: t("panels.routeDetails.confirmChanges")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: isEditing ? "destructive" : "outline",
        size: "sm",
        onClick: handleEditRoute,
        "data-tutorial": "edit-route-button",
        children: isEditing ? t("panels.routeDetails.cancelEdit") : t("panels.routeDetails.editRoute")
      }
    )
  ] });
}
function StationsList({
  raptorRoutes,
  activeRaptorRouteIndex,
  route
}) {
  const { t } = useTranslation("game");
  if (raptorRoutes.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-muted-foreground", children: t("panels.routeDetails.noRouteStationsFound") });
  }
  const arrivalTimes = getArrivalTimes({ route, raptorRoutes, activeRaptorRouteIndex });
  const selectedRaptorRoute = raptorRoutes[activeRaptorRouteIndex];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col", children: selectedRaptorRoute.stops.map((stop, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      StationPreviewCard$1,
      {
        stop,
        arrivalTime: arrivalTimes[index2],
        index: index2,
        route,
        isLastStation: index2 === selectedRaptorRoute.stops.length - 1
      },
      index2
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: t("panels.routeDetails.timingAssumesNoDelays") })
  ] });
}
function getArrivalTimes({
  route,
  raptorRoutes,
  activeRaptorRouteIndex
}) {
  let stNodeIndexToStart = 0;
  let currentRaptorRouteIndex = 0;
  for (const raptorRoute of raptorRoutes) {
    if (currentRaptorRouteIndex === activeRaptorRouteIndex) {
      break;
    }
    stNodeIndexToStart += raptorRoute.stops.length - 1;
    currentRaptorRouteIndex++;
  }
  const arrivalTimes = [];
  for (let i = 0; i < raptorRoutes[activeRaptorRouteIndex].stops.length; i++) {
    arrivalTimes.push(
      route.stComboTimings.find((timing) => timing.stNodeIndex === i + stNodeIndexToStart)?.arrivalTime || null
    );
  }
  const firstArrivalTime = arrivalTimes[0];
  for (let i = 0; i < arrivalTimes.length; i++) {
    if (arrivalTimes[i] === null) continue;
    if (firstArrivalTime === null) continue;
    arrivalTimes[i] = arrivalTimes[i] - firstArrivalTime;
  }
  return arrivalTimes;
}
function StationPreviewCard$1({
  stop,
  index: index2,
  arrivalTime,
  route,
  isLastStation
}) {
  const { t } = useTranslation("game");
  const { pushNavigationState } = useUi();
  const stations = useStations();
  const routes = useRoutes();
  const station = stations.find((station2) => station2.id === stop.stationId);
  if (!station) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PreviewCard, { className: "bg-transparent", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t("panels.routeDetails.stationNotFound") }) }, index2);
  }
  const routesInStation = station.routeIds.filter((routeId) => routeId !== route.id);
  const routeIcons = routesInStation.map((routeId) => {
    const route2 = routes.find((route3) => route3.id === routeId);
    if (!route2) {
      console.warn(`Route not found for route in station: ${routeId}`);
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route: route2, size: 0.75, className: "cursor-pointer" }, route2.id);
  });
  const isFirstStation = index2 === 0;
  const trainAtPlatform = false;
  const grayOutStation = false;
  const solidFillDot = !isLastStation && !isFirstStation;
  const formattedArrivalTime = arrivalTime === void 0 ? "N/A" : arrivalTime === null ? formatTime$1(0, {
    options: { forceMinutes: true, roundSeconds: true, leadingZeroSeconds: true }
  }) : formatTime$1(arrivalTime, {
    options: { forceMinutes: true, roundSeconds: true, leadingZeroSeconds: true }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PreviewCard,
    {
      onClick: () => pushNavigationState({ type: "station-details", itemId: station.id, view: null }),
      className: "bg-transparent flex items-center h-10 text-xs",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full justify-between text-xs relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 h-10", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-5 h-5 flex items-center justify-center aspect-square z-20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: cn(
                  "aspect-square rounded-full flex items-center justify-center",
                  "w-3"
                ),
                style: {
                  backgroundColor: route.color
                },
                children: [
                  solidFillDot && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute w-1.5 aspect-square rounded-full bg-secondary" }),
                  trainAtPlatform
                ]
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-2.5 h-full w-5 flex flex-col items-center z-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: cn("w-1 h-full", isFirstStation && "opacity-0"),
                  style: {
                    backgroundColor: route.color
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: cn("w-1 h-full", isLastStation && "opacity-0"),
                  style: {
                    backgroundColor: route.color
                  }
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full justify-start gap-0.5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: cn("pt-0.5 font-mta font-bold items-center"), children: station.name || t("panels.routeDetails.unnamedStation") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1", children: routeIcons })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("pt-0.5 pr-1 font-mono", grayOutStation), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: formattedArrivalTime }) })
      ] })
    },
    index2
  );
}
function RouteDirectionToggle({
  raptorRouteOptions,
  activeRaptorRouteIndex,
  setActiveRaptorRouteIndex
}) {
  const { t } = useTranslation("game");
  if (raptorRouteOptions < 2) return null;
  if (raptorRouteOptions === 2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "outline",
        className: "h-7",
        onClick: () => setActiveRaptorRouteIndex(activeRaptorRouteIndex === 0 ? 1 : 0),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ArrowUpDown,
          {
            className: cn("h-4 w-4 transition-transform", activeRaptorRouteIndex === 0 && "rotate-180")
          }
        )
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2", children: Array.from({ length: raptorRouteOptions }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      variant: index2 === activeRaptorRouteIndex ? "default" : "outline",
      className: "h-7 w-full",
      onClick: () => setActiveRaptorRouteIndex(index2),
      children: t("panels.routeDetails.section", { number: index2 + 1 })
    },
    index2
  )) });
}
function BarChart({
  items,
  renderLabel,
  className = "",
  expandable = true,
  initialItemCount = 10
}) {
  const chartRows = items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center bg-transparent h-6 relative pl-1", children: [
    renderLabel(item),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "bg-primary/20 absolute left-0 top-0 h-full rounded-r-md transition-transform duration-30 -z-10",
        style: { width: `${item.percent}%` }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs ml-auto font-mono font-semibold pr-1", children: item.value.toLocaleString() })
  ] }, item.id));
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex flex-col gap-1", className), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMoreToggle, { initialItemCount, expandable, children: chartRows }) });
}
function StationRidershipBarChart({
  stationRidership,
  filterRouteIdIcon
}) {
  const stations = useStations();
  const routes = useRoutes();
  const { pushNavigationState } = useUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    BarChart,
    {
      items: stationRidership.map((item) => ({
        id: item.stationId,
        value: item.popCount,
        percent: item.percent
      })),
      renderLabel: (item) => {
        const station = stations.find((station2) => station2.id === item.id);
        if (!station) {
          console.warn("Station not found: ", item.id);
          return null;
        }
        const sortedRouteIds = [...station.routeIds].sort();
        const routeIcons = sortedRouteIds.map((routeId) => {
          const route = routes.find((route2) => route2.id === routeId);
          if (!route) {
            return null;
          }
          if (filterRouteIdIcon && routeId === filterRouteIdIcon) {
            return null;
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteIcon,
            {
              route,
              size: 1,
              onClick: () => pushNavigationState({ type: "route-details", itemId: route.id, view: null })
            },
            routeId
          );
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "text-xs font-medium truncate w-24 cursor-pointer hover:text-primary transition-colors hover:opacity-80",
              onClick: () => pushNavigationState({ type: "station-details", itemId: station.id, view: null }),
              children: station.name
            }
          ),
          routeIcons
        ] });
      }
    }
  );
}
function RouteRidershipBarChart({ routeRidership }) {
  const routes = useRoutes();
  const { pushNavigationState } = useUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    BarChart,
    {
      items: routeRidership.map((item) => ({
        id: item.routeId,
        value: item.popCount,
        percent: item.percent
      })),
      renderLabel: (item) => {
        const route = routes.find((route2) => route2.id === item.id);
        if (!route) {
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          RouteIcon,
          {
            route,
            size: 1,
            onClick: () => pushNavigationState({ type: "route-details", itemId: route.id, view: null }),
            yTranslate: -0.02
          }
        );
      }
    }
  );
}
function StationGroupRidershipBarChart({
  stationGroupRidership
}) {
  const stationGroups = useStationGroups();
  const stations = useStations();
  const routes = useRoutes();
  const { pushNavigationState } = useUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    BarChart,
    {
      items: stationGroupRidership.map((item) => ({
        id: item.stationGroupId,
        value: item.popCount,
        percent: item.percent
      })),
      renderLabel: (item) => {
        const stationGroup = stationGroups.find((group) => group.id === item.id);
        if (!stationGroup) {
          console.warn("Station group not found: ", item.id);
          return null;
        }
        const groupRouteIds = /* @__PURE__ */ new Set();
        stationGroup.stationIds.forEach((stationId) => {
          const station = stations.find((s2) => s2.id === stationId);
          if (station) {
            station.routeIds.forEach((routeId) => groupRouteIds.add(routeId));
          }
        });
        const routeIcons = Array.from(groupRouteIds).sort((a2, b) => a2.localeCompare(b)).map((routeId) => {
          const route = routes.find((route2) => route2.id === routeId);
          if (!route) return null;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteIcon,
            {
              route,
              size: 1,
              onClick: () => pushNavigationState({ type: "route-details", itemId: route.id, view: null })
            },
            routeId
          );
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "text-xs font-medium truncate w-24 cursor-pointer hover:text-primary transition-colors hover:opacity-80",
              onClick: () => pushNavigationState({
                type: "station-group-details",
                itemId: stationGroup.id,
                view: null
              }),
              children: stationGroup.name
            }
          ),
          routeIcons
        ] });
      }
    }
  );
}
function RouteStatsView({ routeId }) {
  const { t } = useTranslation("game");
  const ridershipTypeOptions = [
    {
      value: "all",
      label: t("panels.routeDetails.all"),
      icon: null
    },
    {
      value: "origin-destination",
      label: t("panels.routeDetails.originDestination"),
      icon: null,
      infoText: t("panels.routeDetails.originDestinationInfo")
    },
    {
      value: "transfers",
      label: t("panels.routeDetails.transfers"),
      icon: null
    }
  ];
  const originOptions = [
    {
      value: "all",
      label: t("panels.routeDetails.all"),
      icon: null
    },
    {
      value: "work-origin",
      label: t("panels.routeDetails.work"),
      icon: null,
      infoText: t("panels.routeDetails.workInfo")
    },
    {
      value: "home-origin",
      label: t("panels.routeDetails.home"),
      icon: null,
      infoText: t("panels.routeDetails.homeInfo")
    }
  ];
  const completedCommutes = useMainStore((state) => state.completedCommutes);
  const { currentNavigationState, pushNavigationState } = useUi();
  const ridershipType = currentNavigationState?.type === "route-details" && currentNavigationState.ridershipType && ["all", "origin-destination", "transfers"].includes(currentNavigationState.ridershipType) ? currentNavigationState.ridershipType : "all";
  const originFilter = currentNavigationState?.type === "route-details" && currentNavigationState.originFilter && ["all", "work-origin", "home-origin"].includes(currentNavigationState.originFilter) ? currentNavigationState.originFilter : "all";
  const routeStats = getRouteStats({ completedCommutes, routeId, ridershipType, originFilter });
  if (!routeStats) return null;
  const dataTableRows = [
    { label: t("panels.routeDetails.total"), value: routeStats.total.toLocaleString() }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToggleGroup,
      {
        options: ridershipTypeOptions,
        value: ridershipType,
        onChange: (type) => {
          if (currentNavigationState?.type === "route-details") {
            pushNavigationState(
              {
                ...currentNavigationState,
                ridershipType: type,
                // Reset origin filter when changing ridership type
                originFilter: type === "origin-destination" ? originFilter : "all"
              },
              { ignoreLastItemIfSameType: true }
            );
          }
        }
      }
    ),
    ridershipType === "origin-destination" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToggleGroup,
      {
        options: originOptions,
        value: originFilter,
        onChange: (filter) => {
          if (currentNavigationState?.type === "route-details") {
            pushNavigationState(
              {
                ...currentNavigationState,
                originFilter: filter
              },
              { ignoreLastItemIfSameType: true }
            );
          }
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(PanelSection, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(StationRidershipBarChart, { stationRidership: routeStats.byStation, filterRouteIdIcon: routeId }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: dataTableRows, className: "pr-1" })
    ] })
  ] }) });
}
function TrainPreview({
  train,
  index: index2,
  hideRouteIcon,
  className
}) {
  const { pushNavigationState } = useUi();
  const routes = useRoutes();
  const allStationTrainPopMovements = useAllStationTrainPopMovements();
  if (!train) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: cn(
          "flex gap-2 items-center h-7 border border-border border-dashed rounded-sm px-2 py-1 bg-muted/30 opacity-50",
          className
        ),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TramFront, { className: "h-4 w-4 text-muted-foreground" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium w-6 text-muted-foreground", children: [
            "#",
            index2 + 1
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground ml-auto", children: "Not in service" })
        ]
      }
    );
  }
  const route = routes.find((route2) => route2.id === train.routeId);
  const trainPopMovement = allStationTrainPopMovements.trains.get(train.id);
  if (!route) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "flex gap-2 items-center h-7 border border-border rounded-sm px-2 py-1 hover:bg-muted-foreground/20 cursor-pointer",
        className
      ),
      onClick: () => pushNavigationState({ type: "train-details", itemId: train.id, view: null }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TramFront, { className: "h-4 w-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium w-8", children: [
          "#",
          index2 + 1
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CapacityRing,
          {
            passengers: trainPopMovement?.size || 0,
            capacity: train.specs.maxCapacity,
            radius: 8,
            className: "mr-auto"
          }
        ),
        !hideRouteIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route, size: 1, className: "ml-auto", yTranslate: -0.01 })
      ]
    },
    train.id
  );
}
function CapacityRing({
  passengers,
  capacity,
  radius,
  className
}) {
  const percentage = passengers / capacity * 100;
  const circumference = 2 * Math.PI * radius;
  const strokeDasharray = `${circumference} ${circumference}`;
  const strokeDashoffset = circumference - percentage / 100 * circumference;
  const getColor2 = () => {
    if (percentage >= 90) return "stroke-destructive";
    if (percentage >= 75) return "stroke-yellow-500";
    return "stroke-green-500";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn("flex gap-1 items-center", className),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-6 w-6 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-full h-full -rotate-90", viewBox: "0 0 28 28", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              cx: "14",
              cy: "14",
              r: radius,
              strokeWidth: radius / 3,
              fill: "none",
              className: "stroke-muted-foreground/20"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              cx: "14",
              cy: "14",
              r: radius,
              strokeWidth: radius / 3,
              fill: "none",
              className: cn("transition-all", getColor2()),
              style: {
                strokeDasharray,
                strokeDashoffset
              }
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground", children: [
          passengers,
          "/",
          capacity
        ] })
      ]
    }
  );
}
function OutOfCarsWarning({
  text,
  subtext,
  trainType
}) {
  const { t } = useTranslation("game");
  const { pushNavigationState } = useUi();
  const displayText = text || t("panels.routeDetails.outOfTrainCars");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground bg-destructive/10 border-destructive border p-2 rounded flex items-center justify-between gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "h-4 w-4 text-destructive" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "break-words w-36", children: displayText }),
        subtext && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: subtext })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        className: "hover:underline inline-flex items-center text-blue-600 cursor-pointer whitespace-nowrap",
        onClick: () => pushNavigationState({
          type: "buy-trains",
          itemId: trainType || null,
          view: null
        }),
        children: [
          t("panels.routeDetails.buyMore"),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "h-4 w-4" })
        ]
      }
    )
  ] });
}
function _0xf3d3() {
  const _0x58d531 = ["25383640KqkJzL", "3766833dvyLAe", "round", "warn", "apply", "log", " sec", "length", "return (function() ", "bind", "departureTime", "6WuyQcW", "8100894buiDTc", "4879053cCjWTK", "4136195kVmtRS", "16CDRuHo", "3099302QVjpZf", "toString", "prototype", "1nJbZgb", "__proto__", "console", "stComboTimings", "1434152xQhhXN", '{}.constructor("return this")( )'];
  _0xf3d3 = function() {
    return _0x58d531;
  };
  return _0xf3d3();
}
(function(_0x1aa699, _0x1da5c0) {
  const _0x41dc6b = _0x40bc, _0x4dcad7 = _0x1aa699();
  while (!![]) {
    try {
      const _0x17877b = parseInt(_0x41dc6b(484)) / 1 * (parseInt(_0x41dc6b(481)) / 2) + parseInt(_0x41dc6b(476)) / 3 * (parseInt(_0x41dc6b(488)) / 4) + -parseInt(_0x41dc6b(479)) / 5 + parseInt(_0x41dc6b(477)) / 6 + -parseInt(_0x41dc6b(491)) / 7 + parseInt(_0x41dc6b(480)) / 8 * (parseInt(_0x41dc6b(478)) / 9) + -parseInt(_0x41dc6b(490)) / 10;
      if (_0x17877b === _0x1da5c0) break;
      else _0x4dcad7["push"](_0x4dcad7["shift"]());
    } catch (_0x43785f) {
      _0x4dcad7["push"](_0x4dcad7["shift"]());
    }
  }
})(_0xf3d3, 797388);
function _0x40bc(_0x1e0cdf, _0x188462) {
  const _0x41cdf6 = _0xf3d3();
  return _0x40bc = function(_0x5d85882, _0x20cf8a2) {
    _0x5d85882 = _0x5d85882 - 470;
    let _0x2254f2 = _0x41cdf6[_0x5d85882];
    return _0x2254f2;
  }, _0x40bc(_0x1e0cdf, _0x188462);
}
const _0x20cf8a = /* @__PURE__ */ (function() {
  let _0x12071 = !![];
  return function(_0x2f232f, _0x141a6b) {
    const _0x15d128 = _0x12071 ? function() {
      const _0x11f3d3 = _0x40bc;
      if (_0x141a6b) {
        const _0x143095 = _0x141a6b[_0x11f3d3(494)](_0x2f232f, arguments);
        return _0x141a6b = null, _0x143095;
      }
    } : function() {
    };
    return _0x12071 = ![], _0x15d128;
  };
})(), _0x5d8588 = _0x20cf8a(void 0, function() {
  const _0xd4fd25 = _0x40bc;
  let _0x11c016;
  try {
    const _0x2ed939 = Function(_0xd4fd25(473) + _0xd4fd25(489) + ");");
    _0x11c016 = _0x2ed939();
  } catch (_0x282f5d) {
    _0x11c016 = window;
  }
  const _0x166686 = _0x11c016[_0xd4fd25(486)] = _0x11c016["console"] || {}, _0x2a1764 = [_0xd4fd25(470), _0xd4fd25(493), "info", "error", "exception", "table", "trace"];
  for (let _0xac5d1c = 0; _0xac5d1c < _0x2a1764["length"]; _0xac5d1c++) {
    const _0x25c240 = _0x20cf8a["constructor"][_0xd4fd25(483)][_0xd4fd25(474)](_0x20cf8a), _0x2f9549 = _0x2a1764[_0xac5d1c], _0x304ba0 = _0x166686[_0x2f9549] || _0x25c240;
    _0x25c240[_0xd4fd25(485)] = _0x20cf8a[_0xd4fd25(474)](_0x20cf8a), _0x25c240[_0xd4fd25(482)] = _0x304ba0[_0xd4fd25(482)][_0xd4fd25(474)](_0x304ba0), _0x166686[_0x2f9549] = _0x25c240;
  }
});
_0x5d8588();
function calculateRouteFrequency(_0x389ef1, _0x1b9f26) {
  const _0xe51a38 = _0x40bc;
  if (_0x1b9f26 === 0 || !_0x389ef1[_0xe51a38(487)][_0xe51a38(472)]) return null;
  const _0x4a0b18 = _0x389ef1[_0xe51a38(487)][_0x389ef1[_0xe51a38(487)][_0xe51a38(472)] - 1];
  if (!_0x4a0b18 || !_0x4a0b18[_0xe51a38(475)]) return null;
  const _0x521ac9 = _0x4a0b18[_0xe51a38(475)], _0x537a01 = _0x521ac9 / _0x1b9f26;
  return _0x537a01;
}
function formatFrequency(_0x1bd25f) {
  const _0x232ecf = _0x40bc;
  if (_0x1bd25f === null) return "N/A";
  if (_0x1bd25f >= 60) {
    const _0x140d23 = Math[_0x232ecf(492)](_0x1bd25f / 60);
    return _0x140d23 + " min";
  } else {
    const _0x536112 = Math[_0x232ecf(492)](_0x1bd25f);
    return _0x536112 + _0x232ecf(471);
  }
}
function TrainScheduler({ route }) {
  const { t } = useTranslation("game");
  const setRoutes = useMainStore((state) => state.setRoutes);
  const routes = useMainStore((state) => state.routes);
  const ownedCarsByType = useMainStore((state) => state.ownedCarsByType);
  const hoursByDemand = getHoursByDemandLevel();
  const updateTrainSchedule = (demandLevel, newCount) => {
    if (newCount < 0) return;
    const currentSchedule = route.trainSchedule || {
      highDemand: 0,
      mediumDemand: 0,
      lowDemand: 0
    };
    const updatedSchedule = { ...currentSchedule, [`${demandLevel}Demand`]: newCount };
    const updatedRoutes = routes.map((r) => r.id === route.id ? { ...r, trainSchedule: updatedSchedule } : r);
    setRoutes(updatedRoutes, false);
  };
  const canIncreaseTrain = (demandLevel) => {
    const currentSchedule = route.trainSchedule || {
      highDemand: 0,
      mediumDemand: 0,
      lowDemand: 0
    };
    const currentCount = currentSchedule[`${demandLevel}Demand`];
    const updatedSchedule = { ...currentSchedule, [`${demandLevel}Demand`]: currentCount + 1 };
    const routeTrainType = route.trainType || DEFAULT_TRAIN_TYPE_ID;
    const maxCarsNeeded = getMaxCarsNeededByTypeWithUpdate(routes, route.id, updatedSchedule, routeTrainType);
    const ownedCars = ownedCarsByType[routeTrainType] || 0;
    return maxCarsNeeded <= ownedCars;
  };
  const getTrainCountForDemand = (demandLevel) => {
    if (!route.trainSchedule) return 0;
    switch (demandLevel) {
      case "high":
        return route.trainSchedule.highDemand;
      case "medium":
        return route.trainSchedule.mediumDemand;
      case "low":
        return route.trainSchedule.lowDemand;
      default:
        return 0;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    ["high", "medium", "low"].map((demandLevel) => {
      const trainCount = getTrainCountForDemand(demandLevel);
      const hours = hoursByDemand[demandLevel];
      const frequency = trainCount > 0 ? calculateRouteFrequency(route, trainCount) : null;
      const canIncrease = canIncreaseTrain(demandLevel);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DemandLevelRow,
          {
            demandLevel,
            trainCount,
            hours,
            frequency,
            canIncrease,
            onUpdateTrainCount: (newCount) => updateTrainSchedule(demandLevel, newCount)
          }
        ),
        !canIncrease && /* @__PURE__ */ jsxRuntimeExports.jsx(OutOfCarsWarning, { trainType: route.trainType })
      ] }, demandLevel);
    }),
    route.trainSchedule && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "outline",
        size: "sm",
        className: "w-full",
        onClick: () => {
          const updatedRoutes = routes.map(
            (r) => r.id === route.id ? {
              ...r,
              trainSchedule: {
                highDemand: 0,
                mediumDemand: 0,
                lowDemand: 0
              }
            } : r
          );
          setRoutes(updatedRoutes, false);
        },
        children: t("panels.routeDetails.clearSchedule")
      }
    )
  ] }) });
}
function DemandLevelRow({
  demandLevel,
  trainCount,
  hours,
  frequency,
  canIncrease,
  onUpdateTrainCount
}) {
  const { t } = useTranslation("game");
  const formatHourRanges = (hours2) => {
    const ranges = [];
    let start2 = hours2[0];
    let end = hours2[0];
    for (let i = 1; i <= hours2.length; i++) {
      if (i === hours2.length || hours2[i] !== end + 1) {
        if (start2 === end) {
          ranges.push(`${start2}:00`);
        } else {
          ranges.push(`${start2}:00-${end + 1}:00`);
        }
        if (i < hours2.length) {
          start2 = hours2[i];
          end = hours2[i];
        }
      } else {
        end = hours2[i];
      }
    }
    return ranges.join(", ");
  };
  const demandColors = {
    high: "text-red-600 dark:text-red-400",
    medium: "text-yellow-600 dark:text-yellow-400",
    low: "text-green-600 dark:text-green-400"
  };
  const demandLevelText = demandLevel === "high" ? t("panels.routeDetails.highDemand") : demandLevel === "medium" ? t("panels.routeDetails.mediumDemand") : t("panels.routeDetails.lowDemand");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 justify-between", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Label$1,
        {
          className: cn(
            "text-xs font-semibold capitalize flex items-center gap-1 mb-auto",
            demandColors[demandLevel]
          ),
          children: [
            demandLevelText,
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              InfoTooltip,
              {
                tooltipText: t("panels.routeDetails.effectiveAtHours", { hours: formatHourRanges(hours) })
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-left", children: trainCount > 0 && frequency ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: t("panels.routeDetails.frequency", { frequency: formatFrequency(frequency) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: t("panels.routeDetails.noService") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-end justify-center gap-0.5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          className: "h-6 w-6 p-0",
          onClick: () => onUpdateTrainCount(trainCount - 1),
          disabled: trainCount === 0,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-3 w-3" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 text-center text-sm font-medium", children: trainCount }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          className: "h-6 w-6 p-0",
          onClick: () => onUpdateTrainCount(trainCount + 1),
          disabled: !canIncrease,
          "data-tutorial": demandLevel === "high" ? "add-train-button" : void 0,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-3 w-3" })
        }
      )
    ] }) })
  ] });
}
function RouteTrainsView({ route }) {
  const { t } = useTranslation("game");
  const trains = useTrains();
  const routes = useMainStore((state) => state.routes);
  const deleteTrain = useMainStore((state) => state.deleteTrain);
  const generateTrain = useMainStore((state) => state.generateTrain);
  const setRoutes = useMainStore((state) => state.setRoutes);
  const ownedTrainCount = useMainStore((state) => state.ownedCarsByType[route.trainType || DEFAULT_TRAIN_TYPE_ID]);
  const timeConfig = useTimeConfig();
  const trainsInRoute = trains.filter((train) => train.routeId === route.id);
  const tempRouteIds = routes.filter((r) => r.tempParentId === route.id).map((r) => r.id);
  const trainsInTempRoutes = trains.filter((train) => tempRouteIds.includes(train.routeId));
  const currentTrainCount = trainsInRoute.length + trainsInTempRoutes.length;
  const currentIdealCount = getIdealTrainCountByTime(route, timeConfig.elapsedSeconds);
  const isScheduleComplete$1 = isScheduleComplete(route);
  const trainTypeStats = getTrainType(route.trainType);
  const carsPerCarSet = trainTypeStats.stats.carsPerCarSet;
  const carsPerTrain = route.carsPerTrain || carsPerCarSet;
  const capacityPerTrain = carsPerTrain * trainTypeStats.stats.capacityPerCar;
  const canIncreaseCars = () => {
    const newCarsPerTrain2 = carsPerTrain + carsPerCarSet;
    const maxNeeded = getMaxTrainsNeededWithCarsUpdate(
      routes,
      route.id,
      newCarsPerTrain2,
      route.trainType || DEFAULT_TRAIN_TYPE_ID
    );
    return maxNeeded <= ownedTrainCount;
  };
  const canIncrease = canIncreaseCars();
  const newCarsPerTrain = carsPerTrain + carsPerCarSet;
  const carsNeededForIncrease = getMaxTrainsNeededWithCarsUpdate(
    routes,
    route.id,
    newCarsPerTrain,
    route.trainType || DEFAULT_TRAIN_TYPE_ID
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: t("panels.routeDetails.currentTrains", { count: currentTrainCount }) }),
      isScheduleComplete$1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-muted-foreground", children: t("panels.routeDetails.targetTrains", { count: currentIdealCount }) })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-1 h-px bg-border" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PanelSection,
      {
        title: t("panels.routeDetails.trainConfiguration"),
        titleInfoText: t("panels.routeDetails.trainConfigurationInfo"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: t("panels.routeDetails.carsPerTrain") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  size: "sm",
                  className: "h-6 w-6 p-0",
                  onClick: () => {
                    const updatedRoute = routes.find((r) => r.id === route.id);
                    if (updatedRoute) {
                      updatedRoute.carsPerTrain = carsPerCarSet;
                      setRoutes([...routes], false);
                    }
                  },
                  disabled: carsPerTrain === trainTypeStats.stats.minCars,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-3 w-3" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 text-center text-sm font-medium", children: carsPerTrain }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  size: "sm",
                  className: "h-6 w-6 p-0",
                  onClick: () => {
                    const updatedRoute = routes.find((r) => r.id === route.id);
                    if (updatedRoute) {
                      updatedRoute.carsPerTrain = carsPerTrain + carsPerCarSet;
                      setRoutes([...routes], false);
                    }
                  },
                  disabled: carsPerTrain === trainTypeStats.stats.maxCars || !canIncrease,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-3 w-3" })
                }
              )
            ] })
          ] }),
          !canIncrease && carsPerTrain !== trainTypeStats.stats.maxCars && /* @__PURE__ */ jsxRuntimeExports.jsx(
            OutOfCarsWarning,
            {
              text: t("panels.routeDetails.notEnoughCarsToIncrease"),
              subtext: t("panels.routeDetails.carsNeeded", {
                needed: carsNeededForIncrease,
                owned: ownedTrainCount
              }),
              trainType: route.trainType
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground space-y-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "•",
              " ",
              t("panels.routeDetails.capacityPerTrain", {
                capacity: capacityPerTrain.toLocaleString()
              })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "•",
              " ",
              t("panels.routeDetails.operationalCost", {
                cost: getTrainCost(carsPerTrain, route.trainType).toLocaleString()
              })
            ] })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-1 h-px bg-border" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PanelSection,
      {
        title: t("panels.routeDetails.serviceFrequency"),
        titleInfoText: t("panels.routeDetails.serviceFrequencyInfo"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TrainScheduler, { route })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-1 h-px bg-border" }),
    trainsInRoute.map((train, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TrainPreview, { train, index: index2, hideRouteIcon: true, className: "w-full" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          className: "h-7 px-2 bg-destructive hover:bg-destructive/90 text-destructive-foreground",
          onClick: () => {
            deleteTrain(train.id);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, { className: "h-4 w-4" })
        }
      )
    ] }, train.id)),
    trainsInTempRoutes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground", children: t("panels.routeDetails.trainsBeingRerouted") }),
      trainsInTempRoutes.map((train, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center justify-between opacity-60", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TrainPreview,
          {
            train,
            index: trainsInRoute.length + index2,
            hideRouteIcon: true,
            className: "w-full"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "sm",
            className: "h-7 px-2 bg-destructive hover:bg-destructive/90 text-destructive-foreground",
            disabled: true,
            title: t("panels.routeDetails.cannotDeleteTrainsOnTempRoutes"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, { className: "h-4 w-4" })
          }
        )
      ] }, train.id))
    ] }),
    DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "outline",
        size: "sm",
        onClick: () => {
          generateTrain(route.id);
        },
        children: t("panels.routeDetails.generateTrain")
      }
    )
  ] });
}
(function(_0x158162, _0x49f95a) {
  const _0x3a239b = _0x4466, _0x3c0072 = _0x158162();
  while (!![]) {
    try {
      const _0x993d0d = parseInt(_0x3a239b(420)) / 1 + parseInt(_0x3a239b(385)) / 2 * (-parseInt(_0x3a239b(432)) / 3) + parseInt(_0x3a239b(379)) / 4 + -parseInt(_0x3a239b(436)) / 5 + -parseInt(_0x3a239b(383)) / 6 * (parseInt(_0x3a239b(400)) / 7) + -parseInt(_0x3a239b(359)) / 8 + parseInt(_0x3a239b(381)) / 9;
      if (_0x993d0d === _0x49f95a) break;
      else _0x3c0072["push"](_0x3c0072["shift"]());
    } catch (_0x34e810) {
      _0x3c0072["push"](_0x3c0072["shift"]());
    }
  }
})(_0x2e31, 219175);
const _0x26f2ec = /* @__PURE__ */ (function() {
  let _0x3e3340 = !![];
  return function(_0x502ee2, _0x50749d) {
    const _0x574780 = _0x3e3340 ? function() {
      const _0x2dd487 = _0x4466;
      if (_0x50749d) {
        const _0x5296b3 = _0x50749d[_0x2dd487(362)](_0x502ee2, arguments);
        return _0x50749d = null, _0x5296b3;
      }
    } : function() {
    };
    return _0x3e3340 = ![], _0x574780;
  };
})(), _0x57a002 = _0x26f2ec(void 0, function() {
  const _0x182965 = _0x4466, _0x2a5925 = function() {
    const _0xa1f7d2 = _0x4466;
    let _0x86a619;
    try {
      _0x86a619 = Function(_0xa1f7d2(430) + _0xa1f7d2(378) + ");")();
    } catch (_0x4ec022) {
      _0x86a619 = window;
    }
    return _0x86a619;
  }, _0x4e9602 = _0x2a5925(), _0x2bd1b0 = _0x4e9602[_0x182965(424)] = _0x4e9602[_0x182965(424)] || {}, _0x12c312 = ["log", _0x182965(386), _0x182965(349), _0x182965(416), _0x182965(418), _0x182965(390), _0x182965(403)];
  for (let _0x531eee = 0; _0x531eee < _0x12c312[_0x182965(399)]; _0x531eee++) {
    const _0x31e00b = _0x26f2ec[_0x182965(431)][_0x182965(347)][_0x182965(398)](_0x26f2ec), _0x41b95f = _0x12c312[_0x531eee], _0xee26fe = _0x2bd1b0[_0x41b95f] || _0x31e00b;
    _0x31e00b[_0x182965(421)] = _0x26f2ec[_0x182965(398)](_0x26f2ec), _0x31e00b[_0x182965(415)] = _0xee26fe[_0x182965(415)][_0x182965(398)](_0xee26fe), _0x2bd1b0[_0x41b95f] = _0x31e00b;
  }
});
function _0x2e31() {
  const _0x5a2d0b = ["Interpolating up from ", "remove", " complete per 10-min interval)", " to ", "filter", "Schedule: High=", "floor", "  Note: Capped at 60 minutes (route cycle time is ", "toString", "error", "toFixed", "exception", " trains", "71023FUILpu", "__proto__", "TRAIN SCHEDULING SIMULATION - Route ", "bullet", "console", "forEach", " | ", "high", ", Low=", "Steady at ", "return (function() ", "constructor", "3vwvXaP", " min apart)", "all day", "log", "220955LhPioc", "repeat", "prototype", "action", "info", "trainsCompletingInInterval", "highDemand", "minute", " trains (demand changed to ", "Route Loop Time: ", ": Remove ", "demandLevel", "\n10-Minute Interval Breakdown:", "• Total addition events: ", "1458760FcweHf", "Interpolating down from ", "  Train ", "apply", "Total trains needed: ", "Route ", "idealCount", "padEnd", " minutes (only ", " minutes)", "reduce", "  -  ", " trains (spacing: ", "push", "• Total trains to remove: ", "trainDelta", "• Total trains to add: ", " min after demand changes)", "lowDemand", '{}.constructor("return this")( )', "1331908qRVrLy", "min", "3574170jqgIOG", "round", "84oGSvel", "trainSchedule", "306826EvaxmP", "warn", "max", "ceil", ": Operates during ", "table", " will complete in this 10-min interval - stagger removal)", "abs", " trains (", "medium", ": Add ", "add", "padStart", "bind", "length", "101003vaKNPE", " minutes (", " seconds)", "trace", " loops/hour", " demand only", "\nRecommended Removal Strategy:"];
  _0x2e31 = function() {
    return _0x5a2d0b;
  };
  return _0x2e31();
}
_0x57a002();
function _0x4466(_0x54a741, _0x37cd7b) {
  const _0x293e56 = _0x2e31();
  return _0x4466 = function(_0x57a0022, _0x26f2ec2) {
    _0x57a0022 = _0x57a0022 - 347;
    let _0x48c490 = _0x293e56[_0x57a0022];
    return _0x48c490;
  }, _0x4466(_0x54a741, _0x37cd7b);
}
function simulateTrainSchedulingForRoute(_0x4333e0, _0x986a63, _0x4d4f14 = {}) {
  const _0x5ecd99 = _0x4466;
  if (!_0x4333e0[_0x5ecd99(384)]) {
    console[_0x5ecd99(435)](_0x5ecd99(364) + _0x4333e0[_0x5ecd99(423)] + " has no schedule configured");
    return;
  }
  const _0x4d3ee4 = Math[_0x5ecd99(380)](_0x986a63, 60 * 90), _0x329a10 = Math[_0x5ecd99(382)](_0x4d3ee4 / 60);
  console["log"]("="["repeat"](80)), console[_0x5ecd99(435)](_0x5ecd99(422) + _0x4333e0["bullet"]), console[_0x5ecd99(435)](_0x5ecd99(354) + Math["round"](_0x986a63 / 60) + _0x5ecd99(401) + Math[_0x5ecd99(382)](_0x986a63) + _0x5ecd99(402)), console[_0x5ecd99(435)]("Transition Window: " + _0x329a10 + _0x5ecd99(401) + _0x329a10 / 2 + " min before + " + _0x329a10 / 2 + _0x5ecd99(376));
  _0x986a63 > 60 * 60 && console[_0x5ecd99(435)](_0x5ecd99(414) + Math[_0x5ecd99(382)](_0x986a63 / 60) + _0x5ecd99(368));
  console[_0x5ecd99(435)](_0x5ecd99(412) + _0x4333e0["trainSchedule"][_0x5ecd99(351)] + ", Medium=" + _0x4333e0[_0x5ecd99(384)]["mediumDemand"] + _0x5ecd99(428) + _0x4333e0["trainSchedule"][_0x5ecd99(377)]), console[_0x5ecd99(435)]("="[_0x5ecd99(437)](80));
  const _0x553a72 = [], _0x50760d = 10, _0x1e7840 = 24 * 60 / _0x50760d;
  for (let _0x15b6c5 = 0; _0x15b6c5 < _0x1e7840; _0x15b6c5++) {
    const _0x45ac4a = _0x15b6c5 * _0x50760d, _0x10345f = _0x45ac4a * 60, _0x3b55d9 = Math[_0x5ecd99(413)](_0x45ac4a / 60), _0x1e41b4 = getHourDemandLevel(_0x3b55d9), _0x1ed200 = getIdealTrainCountByTime(_0x4333e0, _0x10345f), _0x51d0af = calculateTrainsCompletingInInterval(_0x1ed200, _0x986a63, _0x50760d);
    let _0x50421b = "maintain", _0x19e2ae = 0, _0x2397d3 = "";
    if (_0x15b6c5 > 0) {
      const _0x11354d = (_0x15b6c5 - 1) * _0x50760d * 60, _0x1b059d = getIdealTrainCountByTime(_0x4333e0, _0x11354d);
      if (_0x1ed200 > _0x1b059d) _0x50421b = _0x5ecd99(396), _0x19e2ae = _0x1ed200 - _0x1b059d, _0x2397d3 = _0x5ecd99(407) + _0x1b059d + _0x5ecd99(410) + _0x1ed200 + _0x5ecd99(419);
      else {
        if (_0x1ed200 < _0x1b059d) _0x50421b = _0x5ecd99(408), _0x19e2ae = _0x1b059d - _0x1ed200, _0x2397d3 = _0x5ecd99(360) + _0x1b059d + " to " + _0x1ed200 + _0x5ecd99(419);
        else {
          const _0x282a84 = Math[_0x5ecd99(413)](_0x11354d / 3600);
          _0x1e41b4 !== getHourDemandLevel(_0x282a84) ? _0x2397d3 = _0x5ecd99(429) + _0x1ed200 + _0x5ecd99(353) + _0x1e41b4 + ")" : _0x2397d3 = "Steady at " + _0x1ed200 + _0x5ecd99(419);
        }
      }
    } else _0x2397d3 = "Starting with " + _0x1ed200 + _0x5ecd99(419);
    _0x553a72["push"]({ "minute": _0x45ac4a, "demandLevel": _0x1e41b4, "idealCount": _0x1ed200, "trainsCompletingInInterval": _0x51d0af, "action": _0x50421b, "trainDelta": Math[_0x5ecd99(392)](_0x19e2ae), "reasoning": _0x2397d3 });
  }
  console[_0x5ecd99(435)](_0x5ecd99(357)), console["log"]("-"[_0x5ecd99(437)](130)), console["log"]("Time  | Demand | Ideal | Completing | Action   | Delta | Reasoning"), console["log"]("-"["repeat"](130)), _0x553a72[_0x5ecd99(425)]((_0x20efb3) => {
    const _0x398dfe = _0x5ecd99, _0x136402 = Math[_0x398dfe(413)](_0x20efb3[_0x398dfe(352)] / 60), _0x54194c = _0x20efb3[_0x398dfe(352)] % 60, _0x87ade6 = String(_0x136402)[_0x398dfe(397)](2, "0") + ":" + String(_0x54194c)["padStart"](2, "0"), _0xa30311 = _0x20efb3[_0x398dfe(356)][_0x398dfe(366)](6), _0x49269b = String(_0x20efb3[_0x398dfe(365)])[_0x398dfe(397)](5), _0xdf305f = String(_0x20efb3[_0x398dfe(350)])[_0x398dfe(397)](10), _0x556176 = _0x20efb3[_0x398dfe(348)][_0x398dfe(366)](8), _0x2df8ef = _0x20efb3[_0x398dfe(374)] > 0 ? ("±" + _0x20efb3[_0x398dfe(374)])[_0x398dfe(397)](5) : _0x398dfe(370);
    console[_0x398dfe(435)](_0x87ade6 + " | " + _0xa30311 + _0x398dfe(426) + _0x49269b + _0x398dfe(426) + _0xdf305f + " | " + _0x556176 + _0x398dfe(426) + _0x2df8ef + _0x398dfe(426) + _0x20efb3["reasoning"]);
  }), console[_0x5ecd99(435)]("-"[_0x5ecd99(437)](130)), console[_0x5ecd99(435)]("\nScheduling Strategy Analysis:"), console[_0x5ecd99(435)]("• Loop time: " + Math[_0x5ecd99(382)](_0x986a63 / 60) + " min = " + (60 / (_0x986a63 / 60))[_0x5ecd99(417)](1) + _0x5ecd99(404));
  const _0x25e6cb = _0x553a72["filter"]((_0x1ae521) => _0x1ae521[_0x5ecd99(348)] === _0x5ecd99(396)), _0x379e97 = _0x553a72[_0x5ecd99(411)]((_0x20796e) => _0x20796e[_0x5ecd99(348)] === _0x5ecd99(408));
  console[_0x5ecd99(435)](_0x5ecd99(358) + _0x25e6cb["length"]), console[_0x5ecd99(435)]("• Total removal events: " + _0x379e97[_0x5ecd99(399)]), console["log"](_0x5ecd99(375) + _0x25e6cb[_0x5ecd99(369)]((_0x133360, _0x310a06) => _0x133360 + _0x310a06["trainDelta"], 0)), console["log"](_0x5ecd99(373) + _0x379e97["reduce"]((_0x1ec0cc, _0x4ffc07) => _0x1ec0cc + _0x4ffc07[_0x5ecd99(374)], 0)), console[_0x5ecd99(435)]("\nTrain Assignment Strategy:");
  const _0xfd850a = _0x4333e0[_0x5ecd99(384)][_0x5ecd99(351)];
  console[_0x5ecd99(435)](_0x5ecd99(363) + _0xfd850a + " (during high demand)"), console["log"]("\nEach train's operating schedule:");
  for (let _0x38d553 = 0; _0x38d553 < _0xfd850a; _0x38d553++) {
    const _0x1b129a = getTrainOperatingSchedule(_0x38d553, _0x4333e0[_0x5ecd99(384)]), _0x5958b5 = [];
    if (_0x1b129a["lowDemand"]) _0x5958b5[_0x5ecd99(372)]("low");
    if (_0x1b129a["mediumDemand"]) _0x5958b5[_0x5ecd99(372)](_0x5ecd99(394));
    if (_0x1b129a[_0x5ecd99(351)]) _0x5958b5[_0x5ecd99(372)](_0x5ecd99(427));
    const _0x4d9670 = _0x5958b5[_0x5ecd99(399)] === 3 ? _0x5ecd99(434) : _0x5958b5["join"](", ") + _0x5ecd99(405);
    console["log"](_0x5ecd99(361) + (_0x38d553 + 1) + _0x5ecd99(389) + _0x4d9670);
  }
  console["log"](_0x5ecd99(406)), _0x379e97[_0x5ecd99(425)]((_0x417f11) => {
    const _0x4dc02c = _0x5ecd99, _0x11fe9a = Math["floor"](_0x417f11[_0x4dc02c(352)] / 60), _0x222f67 = _0x417f11[_0x4dc02c(352)] % 60, _0x5ea225 = String(_0x11fe9a)[_0x4dc02c(397)](2, "0") + ":" + String(_0x222f67)[_0x4dc02c(397)](2, "0"), _0xd96c1 = _0x417f11[_0x4dc02c(374)], _0x2ce785 = _0x417f11["trainsCompletingInInterval"];
    if (_0x2ce785 >= _0xd96c1) console[_0x4dc02c(435)]("  " + _0x5ea225 + _0x4dc02c(355) + _0xd96c1 + _0x4dc02c(393) + _0x2ce785 + _0x4dc02c(391));
    else {
      const _0x4880d4 = Math[_0x4dc02c(388)](_0xd96c1 / Math[_0x4dc02c(387)](1, _0x2ce785));
      console[_0x4dc02c(435)]("  " + _0x5ea225 + _0x4dc02c(355) + _0xd96c1 + " trains over ~" + _0x4880d4 * _0x50760d + _0x4dc02c(367) + _0x2ce785 + _0x4dc02c(409));
    }
  }), console["log"]("\nRecommended Addition Strategy:"), _0x25e6cb[_0x5ecd99(425)]((_0x1713bc) => {
    const _0x3ae2be = _0x5ecd99, _0x535168 = Math[_0x3ae2be(413)](_0x1713bc["minute"] / 60), _0x572c75 = _0x1713bc[_0x3ae2be(352)] % 60, _0x368e1a = String(_0x535168)[_0x3ae2be(397)](2, "0") + ":" + String(_0x572c75)["padStart"](2, "0"), _0x4c4ad3 = _0x1713bc["trainDelta"], _0x1996a2 = _0x986a63 / 60 / (_0x1713bc[_0x3ae2be(365)] || 1);
    console["log"]("  " + _0x368e1a + _0x3ae2be(395) + _0x4c4ad3 + _0x3ae2be(371) + _0x1996a2["toFixed"](1) + _0x3ae2be(433));
  }), console[_0x5ecd99(435)]("="[_0x5ecd99(437)](80) + "\n");
}
function calculateTrainsCompletingInInterval(_0x2a7fb8, _0x40c405, _0x248dc7) {
  if (_0x2a7fb8 === 0) return 0;
  const _0x396a2d = _0x40c405 / 60, _0x14c6a6 = _0x248dc7 / _0x396a2d, _0x5917b9 = Math["round"](_0x2a7fb8 * _0x14c6a6);
  return _0x5917b9;
}
function RouteDetailsPanel() {
  const { t } = useTranslation("game");
  const { currentNavigationState, pushNavigationState, setUserAction, navigate } = useUi();
  const routes = useRoutes();
  const trains = useTrains();
  const setRoutes = useMainStore((state) => state.setRoutes);
  const deleteRoute = useMainStore((state) => state.deleteRoute);
  const currentView = currentNavigationState?.view;
  function updateRouteBullet(routeId, newBullet) {
    const route2 = routes.find((route3) => route3.id === routeId);
    if (!route2) throw new Error("Route not found");
    route2.bullet = newBullet;
    setRoutes([...routes]);
  }
  function handleViewChange(view) {
    if (!currentNavigationState) throw new Error("Current navigation state not found");
    setUserAction("none");
    pushNavigationState({
      type: currentNavigationState.type,
      itemId: currentNavigationState.itemId,
      view
    });
  }
  const route = routes.find((route2) => route2.id === currentNavigationState?.itemId);
  if (!route) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.routeDetails.routeNotFound") });
  }
  const trainsOnRoute = trains.filter((train) => train.routeId === route.id);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 justify-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-[2rem]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route, size: 2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "icon",
            className: "h-5 w-5 p-0 rounded-full absolute -top-1 -right-1",
            onClick: () => pushNavigationState({ type: "new-route-form", itemId: route.id, view: null }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pencil, { className: "max-h-3 max-w-3" })
          }
        )
      ] }),
      DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "icon", onClick: () => console.log(route), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "icon",
            onClick: () => {
              const lastTiming = route.stComboTimings[route.stComboTimings.length - 1];
              const routeLoopTime = lastTiming ? lastTiming.departureTime : 0;
              simulateTrainSchedulingForRoute(route, routeLoopTime);
            },
            title: "Simulate train scheduling",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(CalendarClock, { className: "h-4 w-4" })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$1,
        {
          value: route.bullet,
          onChange: (e) => updateRouteBullet(route.id, e.target.value),
          maxLength: MAX_ROUTE_NAME_LENGTH,
          placeholder: t("panels.routeDetails.lineBullet"),
          className: "h-7 flex-1"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CustomButton,
        {
          variant: "destructive",
          size: "sm",
          className: cn("h-7 px-2 w-fit", trainsOnRoute.length > 0 && "opacity-50 cursor-not-allowed"),
          tooltipText: trainsOnRoute.length > 0 ? t("panels.routeDetails.cannotDeleteRouteWithTrains") : void 0,
          onClick: () => {
            if (trainsOnRoute.length > 0) return;
            deleteRoute(route.id);
            navigate("back");
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, { className: "h-4 w-4" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-muted-foreground", children: t("panels.routeDetails.trainType") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-xs cursor-pointer hover:underline",
          onClick: () => pushNavigationState({
            type: "train-types",
            itemId: route.trainType || "heavy-metro",
            view: null
          }),
          children: TRAIN_TYPES[route.trainType || "heavy-metro"].name
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 w-full justify-between mb-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          className: cn(
            "hover:bg-muted-foreground/10 w-full h-8",
            (currentView === "stations" || currentView === null) && "bg-secondary-foreground/20"
          ),
          onClick: () => handleViewChange("stations"),
          children: t("panels.routeDetails.stations")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          className: cn(
            "hover:bg-muted-foreground/10 w-full h-8",
            currentView === "trains" && "bg-secondary-foreground/20"
          ),
          onClick: () => handleViewChange("trains"),
          "data-tutorial": "trains-tab",
          children: t("panels.routeDetails.trains")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          className: cn(
            "hover:bg-muted-foreground/10 w-auto py-0 px-2 h-8",
            currentView === "stats" && "bg-secondary-foreground/20"
          ),
          onClick: () => handleViewChange("stats"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartNoAxesColumnIncreasing, { className: "h-4 w-4" })
        }
      )
    ] }),
    (currentView === "stations" || currentView === null) && /* @__PURE__ */ jsxRuntimeExports.jsx(RouteStationsView, { route }),
    currentView === "trains" && /* @__PURE__ */ jsxRuntimeExports.jsx(RouteTrainsView, { route }),
    currentView === "stats" && /* @__PURE__ */ jsxRuntimeExports.jsx(RouteStatsView, { routeId: route.id })
  ] });
}
function RouteListPanel() {
  const { t } = useTranslation("game");
  const routes = useRoutes();
  const { setRoutes } = useMainStore();
  const { pushNavigationState } = useUi();
  const [draggedRoute, setDraggedRoute] = reactExports.useState(null);
  const [dropTargetColor, setDropTargetColor] = reactExports.useState(null);
  const routeGroups = routes.reduce(
    (acc, route) => {
      const color2 = route.color;
      if (!acc[color2]) {
        acc[color2] = [];
      }
      acc[color2].push(route);
      return acc;
    },
    {}
  );
  const sortedRouteGroups = Object.keys(routeGroups).sort().reduce(
    (acc, color2) => {
      acc[color2] = routeGroups[color2].sort((a2, b) => a2.bullet.localeCompare(b.bullet));
      return acc;
    },
    {}
  );
  const handleShowForm = () => {
    pushNavigationState({ type: "new-route-form", itemId: null, view: null });
  };
  const handleDrop = (targetColor) => {
    if (!draggedRoute || draggedRoute.color === targetColor) return;
    const targetColorInfo = ROUTE_COLORS.find((c2) => c2.bgColor === targetColor);
    if (!targetColorInfo) return;
    const updatedRoutes = routes.map(
      (route) => route.id === draggedRoute.id ? {
        ...route,
        color: targetColorInfo.bgColor,
        textColor: targetColorInfo.textColor
      } : route
    );
    setRoutes(updatedRoutes, true);
    setDraggedRoute(null);
    setDropTargetColor(null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full", children: [
    routes.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-center", children: t("panels.routes.noRoutesYet") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col -mb-2", children: Object.entries(sortedRouteGroups).map(([color2, routes2], index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      RouteGroupRow,
      {
        routes: routes2,
        isLast: index2 === Object.keys(sortedRouteGroups).length - 1,
        onDragStart: setDraggedRoute,
        onDrop: () => handleDrop(color2),
        isDragOver: dropTargetColor === color2,
        onDragOver: () => setDropTargetColor(color2),
        onDragLeave: () => setDropTargetColor(null)
      },
      color2
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CustomButton, { size: "lg", onClick: handleShowForm, "data-tutorial": "make-new-route-button", children: t("panels.routes.newRoute") })
  ] });
}
function RouteGroupRow({
  routes,
  isLast,
  onDragStart,
  onDrop,
  isDragOver,
  onDragOver,
  onDragLeave
}) {
  const { generateRoute: generateRoute2 } = useMainStore();
  const { pushNavigationState } = useUi();
  const canMakeMoreRoutes = routes.length < 12;
  const handleDragOver = (e) => {
    e.preventDefault();
    onDragOver();
  };
  const handleDrop = (e) => {
    e.preventDefault();
    onDrop();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex flex-col gap-2 pb-2 justify-center h-full transition-colors ${isDragOver ? "bg-primary/10" : ""}`,
      onDragOver: handleDragOver,
      onDrop: handleDrop,
      onDragLeave,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap items-center gap-2 h-auto", style: { maxWidth: "18rem" }, children: [
          routes.map((route) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              draggable: true,
              onDragStart: () => onDragStart(route),
              onDragEnd: () => onDragStart(null),
              className: "cursor-move",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                RouteIcon,
                {
                  route,
                  size: 2,
                  onClick: () => pushNavigationState({ type: "route-details", itemId: route.id, view: null })
                }
              )
            },
            route.id
          )),
          canMakeMoreRoutes && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              size: "icon",
              className: "h-[2rem] w-[2rem] rounded-full",
              onClick: () => generateRoute2({
                existingColor: routes[0].color,
                customColor: routes[0].color,
                trainType: routes[0].trainType
              }),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4" })
            }
          )
        ] }),
        !isLast && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px w-full bg-primary/15" })
      ]
    },
    routes[0].color
  );
}
function RouteRidershipPanel() {
  const { t } = useTranslation("game");
  const completedCommutes = useMainStore((state) => state.completedCommutes);
  const stationStats = getStationStats({ completedCommutes, stationId: null });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 w-full h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PanelSection,
    {
      title: t("navigation.routeRidership"),
      titleInfoText: `The number of people who rode each route in the last 24 hours.<br/><br/>
If a person took multiple routes in the same commute, the ridership of each route is increased.`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RouteRidershipBarChart, { routeRidership: stationStats.byRoute })
    }
  ) });
}
function SignalDetailsPanel() {
  const { currentNavigationState, pushNavigationState } = useUi();
  const signals = useSignals();
  const trains = useTrains();
  const signal = signals.find((signal2) => signal2.id === currentNavigationState?.itemId);
  if (!signal) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Signal not found" });
  }
  function clickTrain(trainId) {
    pushNavigationState({
      type: "train-details",
      itemId: trainId,
      view: null
    });
  }
  function getStatus(signal2) {
    if (signal2.status.occupations.length > 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: "Occupied" });
    }
    if (signal2.status.reservedBy) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { onClick: () => clickTrain(signal2.status.reservedBy?.trainId || ""), children: "Reserved" });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: "Free" });
  }
  function getSignalOccupations(signal2) {
    const trainIdsUsed = /* @__PURE__ */ new Set();
    const occupations = signal2.status.occupations.map((occupation, index2) => {
      const train = trains.find((train2) => train2.id === occupation.trainId);
      if (!train) {
        return null;
      }
      if (trainIdsUsed.has(train.id)) {
        return null;
      }
      trainIdsUsed.add(train.id);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TrainPreview, { train, index: index2 }, index2);
    });
    return occupations.filter(Boolean);
  }
  function getSignalReservations(signal2) {
    if (!signal2.status.reservedBy) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "No train is reserved by this signal" });
    }
    const train = trains.find((train2) => train2.id === signal2.status.reservedBy?.trainId || "");
    if (!train) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TrainPreview, { train, index: 0 }, 0);
  }
  const tableRows = [
    { label: "Type", value: SIGNAL_TYPES.find((type) => type.key === signal.type)?.name },
    { label: "Status", value: getStatus(signal) },
    { label: "Tracks", value: signal.signalTracks.length }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: tableRows }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(PanelSection, { title: "Occupations", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "The trains that are currently occupying this signal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: getSignalOccupations(signal) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(PanelSection, { title: "Reserved By", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "The trains that are currently reserved by this signal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: getSignalReservations(signal) })
    ] }),
    DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "icon", onClick: () => console.log(signal), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, {}) })
  ] });
}
function DeparturesBoard({
  routeArrivals,
  onRouteClick,
  onTrainClick
}) {
  if (routeArrivals.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-muted-foreground text-center py-4", children: "No upcoming departures" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 w-full max-w-full", children: routeArrivals.map(({ route, arrivals }, routeIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    RouteSection,
    {
      route,
      arrivals,
      onRouteClick,
      onTrainClick
    },
    route.id + routeIndex
  )) });
}
function RouteSection({
  route,
  arrivals,
  onRouteClick,
  onTrainClick
}) {
  const destinationGroups = arrivals.reduce((acc, arrival) => {
    const key = arrival.destinationStationId;
    if (!acc[key]) {
      acc[key] = {
        destinationStationId: arrival.destinationStationId,
        destinationStationName: arrival.destinationStationName,
        arrivals: []
      };
    }
    acc[key].arrivals.push(arrival);
    return acc;
  }, {});
  const groupedDestinations = Object.values(destinationGroups);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col bg-primary-foreground p-2 rounded-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(RouteHeader, { route, onClick: () => onRouteClick?.(route.id) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px bg-border -mx-2 mt-2" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col", children: groupedDestinations.map((destination, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      DestinationRow,
      {
        destination,
        isLast: index2 === groupedDestinations.length - 1,
        onTrainClick
      },
      destination.destinationStationId + index2
    )) })
  ] });
}
function DestinationRow({
  destination,
  isLast,
  onTrainClick
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between py-1.5 rounded-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm whitespace-nowrap w-14", children: destination.destinationStationName }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-0 text-sm", children: destination.arrivals.map((arrival, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        index2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: ", " }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ArrivalTime,
          {
            arrival,
            isLast: index2 === destination.arrivals.length - 1,
            onClick: () => onTrainClick?.(arrival.trainId)
          }
        )
      ] }, arrival.trainId + index2)) })
    ] }),
    !isLast && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px bg-border" })
  ] });
}
function RouteHeader({ route, onClick }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 cursor-pointer hover:opacity-80 transition-opacity", onClick, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(RouteIcon, { route, size: 1.25, yTranslate: -0.01, onClick: () => {
    } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", children: [
      route.bullet,
      " Train"
    ] })
  ] });
}
function ArrivalTime({ arrival, isLast, onClick }) {
  const text = arrival.minutesUntilArrival <= 0 ? "Now" : `${arrival.minutesUntilArrival}`;
  const showMinutes = arrival.minutesUntilArrival > 0 && isLast && text !== "Now";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "cursor-pointer hover:opacity-70", onClick, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text }),
    showMinutes && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " min" })
  ] });
}
function StationStats({ stationId }) {
  const { t } = useTranslation("game");
  const completedCommutes = useMainStore((state) => state.completedCommutes);
  const stationStats = getStationStats({ completedCommutes, stationId });
  if (!stationStats) return null;
  const dataTableRows = [
    stationStats.transfers > 0 && {
      label: t("stats.transfers"),
      value: stationStats.transfers.toLocaleString()
    },
    { label: t("stats.total"), value: stationStats.total.toLocaleString() }
  ].filter(Boolean);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PanelSection, { title: t("stats.ridership"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(RouteRidershipBarChart, { routeRidership: stationStats.byRoute }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: dataTableRows, className: "pr-1 gap-3" })
  ] });
}
function _0x3fe1() {
  const _0x563d8d = ["map", "pause", "start", "table", "gain", "createMediaElementSource", "exception", "37956aYPtND", "./sounds/PLACEHOLDER-crowd-loud.mp3", "console", "createBufferSource", "currentAudio", "onended", "warn", "7RECljH", "/presets/", "./sounds/letters/r.mp3", "./sounds/presets/This_is_a2.m4a", "./sounds/presets/Stand_clear2.m4a", "buffer", "./sounds/effects/background.mp3", "random", "volume", "setUint32", "download", "./sounds/presets/The_next_stop_is2.m4a", "AudioContext", "bind", "backgroundAudios", "webkitAudioContext", "153dndYVy", "duration", "getChannelData", "info", "2503710ljgcij", "./sounds/effects/background2.mp3", "push", "toString", "apply", "return (function() ", "value", "613112TXMPIb", "forEach", "createElement", "revokeObjectURL", "./sounds/presets/Train_to2.m4a", "loop", "decodeAudioData", "createConvolver", "createGain", "./sounds/stations/courtSquare.mp3", "startRendering", "currentTime", "trace", "1731490tUdrMI", "close", "numberOfChannels", "file", "click", "sampleRate", "arrayBuffer", "audioContext", "createObjectURL", "playing", "2540433bCGfeR", "error", "3306192LCWtnr", "constructor", "station-announcement.wav", "destination", "1063615ijtzam", "./sounds/stations/42ndSt.mp3", "length", "./sounds/presets/An_accessible_station.m4a", "1145UODPek", "play", "connect"];
  _0x3fe1 = function() {
    return _0x563d8d;
  };
  return _0x3fe1();
}
const _0x74c317 = _0x1d3d;
(function(_0x10cb90, _0x50efcb) {
  const _0x246ecc = _0x1d3d, _0x4328db = _0x10cb90();
  while (!![]) {
    try {
      const _0x306ebc = -parseInt(_0x246ecc(227)) / 1 + -parseInt(_0x246ecc(191)) / 2 + parseInt(_0x246ecc(221)) / 3 + parseInt(_0x246ecc(223)) / 4 + parseInt(_0x246ecc(231)) / 5 * (-parseInt(_0x246ecc(241)) / 6) + parseInt(_0x246ecc(248)) / 7 * (-parseInt(_0x246ecc(198)) / 8) + -parseInt(_0x246ecc(187)) / 9 * (-parseInt(_0x246ecc(211)) / 10);
      if (_0x306ebc === _0x50efcb) break;
      else _0x4328db["push"](_0x4328db["shift"]());
    } catch (_0x3121a6) {
      _0x4328db["push"](_0x4328db["shift"]());
    }
  }
})(_0x3fe1, 776129);
const _0x508de0 = /* @__PURE__ */ (function() {
  let _0x3848ee = !![];
  return function(_0x7558eb, _0x2019e5) {
    const _0x2cb335 = _0x3848ee ? function() {
      const _0x48efd7 = _0x1d3d;
      if (_0x2019e5) {
        const _0x2c5417 = _0x2019e5[_0x48efd7(195)](_0x7558eb, arguments);
        return _0x2019e5 = null, _0x2c5417;
      }
    } : function() {
    };
    return _0x3848ee = ![], _0x2cb335;
  };
})(), _0x303adf = _0x508de0(void 0, function() {
  const _0x56bf6d = _0x1d3d, _0x130bc3 = function() {
    const _0x3380b9 = _0x1d3d;
    let _0x1db864;
    try {
      _0x1db864 = Function(_0x3380b9(196) + '{}.constructor("return this")( ));')();
    } catch (_0x58139d) {
      _0x1db864 = window;
    }
    return _0x1db864;
  }, _0x276933 = _0x130bc3(), _0x4bc518 = _0x276933[_0x56bf6d(243)] = _0x276933["console"] || {}, _0x54b4ca = ["log", _0x56bf6d(247), _0x56bf6d(190), _0x56bf6d(222), _0x56bf6d(240), _0x56bf6d(237), _0x56bf6d(210)];
  for (let _0x565b17 = 0; _0x565b17 < _0x54b4ca["length"]; _0x565b17++) {
    const _0x3206b5 = _0x508de0[_0x56bf6d(224)]["prototype"][_0x56bf6d(261)](_0x508de0), _0x44edcc = _0x54b4ca[_0x565b17], _0x47eecf = _0x4bc518[_0x44edcc] || _0x3206b5;
    _0x3206b5["__proto__"] = _0x508de0[_0x56bf6d(261)](_0x508de0), _0x3206b5[_0x56bf6d(194)] = _0x47eecf[_0x56bf6d(194)]["bind"](_0x47eecf), _0x4bc518[_0x44edcc] = _0x3206b5;
  }
});
_0x303adf();
const ANNOUNCEMENT_FILES = [_0x74c317(251), _0x74c317(250), _0x74c317(202), _0x74c317(207), _0x74c317(259), _0x74c317(228), _0x74c317(230), _0x74c317(252), "./sounds/effects/dingDong.m4a"][_0x74c317(234)](getFilePath), BACKGROUND_SOUNDS = [{ "file": _0x74c317(254), "volume": 0.4 }, { "file": _0x74c317(192), "volume": 0.3 }, { "file": _0x74c317(242), "volume": 0.15 }]["map"]((_0x3e0ea5) => ({ ..._0x3e0ea5, "file": getFilePath(_0x3e0ea5["file"]) })), PRESET_VOLUME_MULTIPLIER = 1.6, REVERB_DURATION = 2, ECHO_DELAY = 0.4;
function _0x1d3d(_0x3308a3, _0xb18520) {
  const _0x20999b = _0x3fe1();
  return _0x1d3d = function(_0x303adf2, _0x508de02) {
    _0x303adf2 = _0x303adf2 - 185;
    let _0x37ba96 = _0x20999b[_0x303adf2];
    return _0x37ba96;
  }, _0x1d3d(_0x3308a3, _0xb18520);
}
const initialAudioState = { "playing": ![], "audioContext": null, "backgroundAudios": [], "currentAudio": null };
function createEchoImpulse(_0x56ca18) {
  const _0x48f5ac = _0x74c317, _0x4c8a10 = _0x56ca18["sampleRate"] * REVERB_DURATION, _0x4ba216 = _0x56ca18["createBuffer"](2, _0x4c8a10, _0x56ca18[_0x48f5ac(216)]);
  for (let _0x4b5432 = 0; _0x4b5432 < 2; _0x4b5432++) {
    const _0x5e37d6 = _0x4ba216[_0x48f5ac(189)](_0x4b5432);
    for (let _0x37fce5 = 0; _0x37fce5 < _0x4c8a10; _0x37fce5++) {
      _0x37fce5 % (_0x56ca18[_0x48f5ac(216)] * ECHO_DELAY) === 0 ? _0x5e37d6[_0x37fce5] = Math["pow"](0.6, _0x37fce5 / (_0x56ca18[_0x48f5ac(216)] * 0.2)) * (Math["random"]() * 2 - 1) : _0x5e37d6[_0x37fce5] = (Math[_0x48f5ac(255)]() * 2 - 1) * Math["pow"](0.95, _0x37fce5 / 1e3);
    }
  }
  return _0x4ba216;
}
async function playVoiceAnnouncements(_0x737cda, _0x915273) {
  const _0x2a5d15 = _0x74c317;
  if (_0x737cda[_0x2a5d15(220)]) return;
  const _0x240a57 = new (window[_0x2a5d15(260)] || window[_0x2a5d15(186)])(), _0x1dab35 = [];
  for (const _0x32c986 of BACKGROUND_SOUNDS) {
    const _0x45a07 = new Audio(_0x32c986[_0x2a5d15(214)]);
    _0x45a07[_0x2a5d15(203)] = !![];
    const _0x3b0337 = _0x240a57[_0x2a5d15(239)](_0x45a07), _0xdc9d63 = _0x240a57[_0x2a5d15(206)]();
    _0xdc9d63[_0x2a5d15(238)][_0x2a5d15(197)] = _0x32c986["volume"], _0x3b0337[_0x2a5d15(233)](_0xdc9d63), _0xdc9d63[_0x2a5d15(233)](_0x240a57["destination"]), _0x1dab35[_0x2a5d15(193)](_0x45a07), await _0x45a07[_0x2a5d15(232)]();
  }
  _0x915273({ "playing": !![], "audioContext": _0x240a57, "backgroundAudios": _0x1dab35, "currentAudio": null });
  const _0x464bc3 = _0x240a57[_0x2a5d15(205)]();
  _0x464bc3[_0x2a5d15(253)] = createEchoImpulse(_0x240a57);
  for (const _0x358813 of ANNOUNCEMENT_FILES) {
    const _0x4ee9d7 = await new Promise((_0x2fc2e7) => {
      _0x915273((_0x264f3c) => {
        return _0x2fc2e7(_0x264f3c), _0x264f3c;
      });
    });
    if (!_0x4ee9d7["playing"]) break;
    const _0x4eb624 = new Audio(_0x358813);
    _0x915273((_0x146022) => ({ ..._0x146022, "currentAudio": _0x4eb624 }));
    const _0x2e823c = _0x240a57["createMediaElementSource"](_0x4eb624), _0x437772 = _0x240a57[_0x2a5d15(206)]();
    _0x437772[_0x2a5d15(238)][_0x2a5d15(197)] = _0x358813["includes"](_0x2a5d15(249)) ? PRESET_VOLUME_MULTIPLIER : 1, _0x2e823c[_0x2a5d15(233)](_0x437772), _0x437772[_0x2a5d15(233)](_0x464bc3), _0x464bc3[_0x2a5d15(233)](_0x240a57[_0x2a5d15(226)]), _0x437772[_0x2a5d15(233)](_0x240a57[_0x2a5d15(226)]), await _0x4eb624["play"](), await new Promise((_0x23a495) => {
      const _0x236e05 = _0x2a5d15;
      _0x4eb624[_0x236e05(246)] = _0x23a495;
    });
  }
  _0x1dab35[_0x2a5d15(199)]((_0x5db0d4) => {
    const _0x90407c = _0x2a5d15;
    _0x5db0d4[_0x90407c(235)](), _0x5db0d4[_0x90407c(209)] = 0;
  }), _0x915273(initialAudioState);
}
function stopAllAudio(_0x2f4cd0, _0x96f604) {
  const _0x2a27cb = _0x74c317;
  _0x2f4cd0[_0x2a27cb(185)] && _0x2f4cd0["backgroundAudios"][_0x2a27cb(229)] > 0 && _0x2f4cd0["backgroundAudios"][_0x2a27cb(199)]((_0x20c082) => {
    const _0x5b770c = _0x2a27cb;
    _0x20c082[_0x5b770c(235)](), _0x20c082[_0x5b770c(209)] = 0;
  }), _0x2f4cd0[_0x2a27cb(245)] && (_0x2f4cd0[_0x2a27cb(245)][_0x2a27cb(235)](), _0x2f4cd0[_0x2a27cb(245)]["currentTime"] = 0), _0x2f4cd0["audioContext"] && _0x2f4cd0[_0x2a27cb(218)][_0x2a27cb(212)](), _0x96f604(initialAudioState);
}
async function downloadCombinedAudio() {
  const _0x3c43c2 = _0x74c317, _0xefaf4b = new (window[_0x3c43c2(260)] || window[_0x3c43c2(186)])(), _0x526f43 = ANNOUNCEMENT_FILES[_0x3c43c2(229)] * 2 + 5, _0x52119c = _0xefaf4b["sampleRate"], _0x1b9509 = 2, _0xe8f08b = _0x52119c * _0x526f43, _0x6fee0f = new OfflineAudioContext(_0x1b9509, _0xe8f08b, _0x52119c), _0x436518 = _0x6fee0f[_0x3c43c2(205)]();
  _0x436518[_0x3c43c2(253)] = createEchoImpulse(_0x6fee0f);
  const _0x13c48c = [];
  for (const _0x5825b5 of ANNOUNCEMENT_FILES) {
    const _0x569119 = await fetch(_0x5825b5), _0x43939b = await _0x569119[_0x3c43c2(217)](), _0x1361e8 = await _0x6fee0f[_0x3c43c2(204)](_0x43939b);
    _0x13c48c[_0x3c43c2(193)](_0x1361e8);
  }
  for (const _0x1ec01f of BACKGROUND_SOUNDS) {
    const _0x4d52fe = await fetch(_0x1ec01f[_0x3c43c2(214)]), _0x339e72 = await _0x4d52fe[_0x3c43c2(217)](), _0x32cade = await _0x6fee0f["decodeAudioData"](_0x339e72), _0xaaa994 = _0x6fee0f[_0x3c43c2(206)]();
    _0xaaa994[_0x3c43c2(238)]["value"] = _0x1ec01f[_0x3c43c2(256)];
    let _0x5b1551 = 0;
    while (_0x5b1551 < _0x526f43) {
      const _0x372145 = _0x6fee0f[_0x3c43c2(244)]();
      _0x372145[_0x3c43c2(253)] = _0x32cade, _0x372145[_0x3c43c2(233)](_0xaaa994), _0xaaa994[_0x3c43c2(233)](_0x6fee0f[_0x3c43c2(226)]), _0x372145[_0x3c43c2(236)](_0x5b1551), _0x5b1551 += _0x32cade[_0x3c43c2(188)];
    }
  }
  let _0x550cab = 0;
  for (let _0x3399f8 = 0; _0x3399f8 < _0x13c48c["length"]; _0x3399f8++) {
    const _0x311e7e = _0x13c48c[_0x3399f8], _0x213fab = _0x6fee0f["createBufferSource"]();
    _0x213fab[_0x3c43c2(253)] = _0x311e7e;
    const _0x3ec97c = _0x6fee0f[_0x3c43c2(206)](), _0x5589ed = ANNOUNCEMENT_FILES[_0x3399f8]["includes"](_0x3c43c2(249));
    _0x3ec97c[_0x3c43c2(238)][_0x3c43c2(197)] = _0x5589ed ? PRESET_VOLUME_MULTIPLIER : 1, _0x213fab[_0x3c43c2(233)](_0x3ec97c), _0x3ec97c[_0x3c43c2(233)](_0x436518), _0x436518[_0x3c43c2(233)](_0x6fee0f["destination"]), _0x3ec97c[_0x3c43c2(233)](_0x6fee0f[_0x3c43c2(226)]), _0x213fab[_0x3c43c2(236)](_0x550cab), _0x550cab += _0x311e7e[_0x3c43c2(188)] + 0.1;
  }
  const _0x5ab1dd = await _0x6fee0f[_0x3c43c2(208)](), _0x2951a4 = audioBufferToWav(_0x5ab1dd), _0x15e3aa = new Blob([_0x2951a4], { "type": "audio/wav" }), _0x54bd58 = URL[_0x3c43c2(219)](_0x15e3aa), _0x24b6c5 = document[_0x3c43c2(200)]("a");
  _0x24b6c5["href"] = _0x54bd58, _0x24b6c5[_0x3c43c2(258)] = _0x3c43c2(225), _0x24b6c5[_0x3c43c2(215)](), URL[_0x3c43c2(201)](_0x54bd58);
}
function audioBufferToWav(_0x5bdcf5) {
  const _0x57b2f5 = _0x74c317, _0x14eee3 = _0x5bdcf5["numberOfChannels"], _0x1c68d0 = _0x5bdcf5["length"] * _0x14eee3 * 2 + 44, _0x1b5756 = new ArrayBuffer(_0x1c68d0), _0x5b77f2 = new DataView(_0x1b5756), _0x306402 = [];
  let _0x89d698 = 0, _0x49f22a = 0;
  const _0x466902 = (_0x4dac10) => {
    _0x5b77f2["setUint16"](_0x49f22a, _0x4dac10, !![]), _0x49f22a += 2;
  }, _0x24b61c = (_0x2454e9) => {
    const _0x3cc031 = _0x1d3d;
    _0x5b77f2[_0x3cc031(257)](_0x49f22a, _0x2454e9, !![]), _0x49f22a += 4;
  };
  _0x24b61c(1179011410), _0x24b61c(_0x1c68d0 - 8), _0x24b61c(1163280727), _0x24b61c(544501094), _0x24b61c(16), _0x466902(1), _0x466902(_0x14eee3), _0x24b61c(_0x5bdcf5[_0x57b2f5(216)]), _0x24b61c(_0x5bdcf5[_0x57b2f5(216)] * 2 * _0x14eee3), _0x466902(_0x14eee3 * 2), _0x466902(16), _0x24b61c(1635017060), _0x24b61c(_0x1c68d0 - _0x49f22a - 4);
  for (let _0x32abab = 0; _0x32abab < _0x5bdcf5[_0x57b2f5(213)]; _0x32abab++) {
    _0x306402[_0x57b2f5(193)](_0x5bdcf5["getChannelData"](_0x32abab));
  }
  while (_0x49f22a < _0x1c68d0) {
    for (let _0x51c559 = 0; _0x51c559 < _0x14eee3; _0x51c559++) {
      let _0x1477fa = _0x306402[_0x51c559][_0x89d698];
      _0x1477fa = Math["max"](-1, Math["min"](1, _0x1477fa)), _0x1477fa = _0x1477fa < 0 ? _0x1477fa * 32768 : _0x1477fa * 32767, _0x5b77f2["setInt16"](_0x49f22a, _0x1477fa, !![]), _0x49f22a += 2;
    }
    _0x89d698++;
  }
  return _0x1b5756;
}
(function(_0x402d86, _0x5e1906) {
  const _0x602a41 = _0x3a89, _0x47cf4d = _0x402d86();
  while (!![]) {
    try {
      const _0x15cf87 = parseInt(_0x602a41(473)) / 1 + -parseInt(_0x602a41(475)) / 2 * (-parseInt(_0x602a41(432)) / 3) + parseInt(_0x602a41(464)) / 4 + parseInt(_0x602a41(468)) / 5 + parseInt(_0x602a41(461)) / 6 * (parseInt(_0x602a41(459)) / 7) + -parseInt(_0x602a41(470)) / 8 * (parseInt(_0x602a41(437)) / 9) + -parseInt(_0x602a41(439)) / 10;
      if (_0x15cf87 === _0x5e1906) break;
      else _0x47cf4d["push"](_0x47cf4d["shift"]());
    } catch (_0x98d81c) {
      _0x47cf4d["push"](_0x47cf4d["shift"]());
    }
  }
})(_0x73d5, 605885);
const _0x312e50 = /* @__PURE__ */ (function() {
  let _0x18fbfd = !![];
  return function(_0xc4b5cd, _0xcf79db) {
    const _0x569ec8 = _0x18fbfd ? function() {
      const _0x449cf4 = _0x3a89;
      if (_0xcf79db) {
        const _0x10039d = _0xcf79db[_0x449cf4(444)](_0xc4b5cd, arguments);
        return _0xcf79db = null, _0x10039d;
      }
    } : function() {
    };
    return _0x18fbfd = ![], _0x569ec8;
  };
})(), _0x355b47 = _0x312e50(void 0, function() {
  const _0x7d46bf = _0x3a89;
  let _0x1c8356;
  try {
    const _0x1f68ed = Function(_0x7d46bf(430) + _0x7d46bf(457) + ");");
    _0x1c8356 = _0x1f68ed();
  } catch (_0x118a26) {
    _0x1c8356 = window;
  }
  const _0x365778 = _0x1c8356["console"] = _0x1c8356[_0x7d46bf(448)] || {}, _0x2d101d = [_0x7d46bf(433), _0x7d46bf(442), "info", "error", _0x7d46bf(429), _0x7d46bf(453), _0x7d46bf(443)];
  for (let _0x3ed31e = 0; _0x3ed31e < _0x2d101d[_0x7d46bf(441)]; _0x3ed31e++) {
    const _0x5cba25 = _0x312e50[_0x7d46bf(435)][_0x7d46bf(428)][_0x7d46bf(438)](_0x312e50), _0x551f01 = _0x2d101d[_0x3ed31e], _0x1b0acf = _0x365778[_0x551f01] || _0x5cba25;
    _0x5cba25[_0x7d46bf(465)] = _0x312e50[_0x7d46bf(438)](_0x312e50), _0x5cba25[_0x7d46bf(471)] = _0x1b0acf[_0x7d46bf(471)][_0x7d46bf(438)](_0x1b0acf), _0x365778[_0x551f01] = _0x5cba25;
  }
});
function _0x3a89(_0x1bd3dd, _0x475dd7) {
  const _0x54b814 = _0x73d5();
  return _0x3a89 = function(_0x355b472, _0x312e502) {
    _0x355b472 = _0x355b472 - 427;
    let _0x210f48 = _0x54b814[_0x355b472];
    return _0x210f48;
  }, _0x3a89(_0x1bd3dd, _0x475dd7);
}
_0x355b47();
function getNextTrainArrivals({ station: _0x4a8d86, trains: _0x2135e2, routes: _0x5ce137, stations: _0x491d0d, currentTimeSeconds: _0x1d627b, maxArrivalsPerRoute = 2, excludeStationIds: _0x1019c3 }) {
  const _0x178aab = _0x3a89, _0x2e2991 = [], _0x1fd8a0 = new Set(_0x4a8d86[_0x178aab(446)]);
  for (const _0x43739a of _0x2135e2) {
    const _0x5ada30 = _0x5ce137[_0x178aab(451)]((_0x42da4c) => _0x42da4c["id"] === _0x43739a[_0x178aab(456)]);
    if (!_0x5ada30) continue;
    if (_0x5ada30[_0x178aab(478)]) continue;
    if (!_0x5ada30["stNodes"][_0x178aab(431)]((_0x2b7c5f) => _0x1fd8a0[_0x178aab(445)](_0x2b7c5f["id"]))) continue;
    const _0x3a0f5f = _0x43739a["currentStComboInfo"]["index"];
    let _0x1856c3 = null, _0x2d0d5d = null;
    for (const _0x3673db of _0x43739a[_0x178aab(479)]) {
      if (!_0x1fd8a0[_0x178aab(445)](_0x3673db[_0x178aab(477)])) continue;
      const _0x1a6c72 = _0x3673db[_0x178aab(469)];
      if (_0x1a6c72 === null) continue;
      if (_0x3673db[_0x178aab(460)] > _0x3a0f5f && _0x1a6c72 > _0x1d627b) {
        _0x1856c3 = _0x1a6c72, _0x2d0d5d = _0x3673db;
        break;
      }
    }
    if (!_0x1856c3 && _0x43739a[_0x178aab(479)]["length"] > 0) for (const _0x183938 of _0x43739a[_0x178aab(479)]) {
      if (!_0x1fd8a0[_0x178aab(445)](_0x183938["stNodeId"])) continue;
      if (_0x183938["futureCycleArrivalTimes"] && _0x183938[_0x178aab(434)]["length"] > 0) {
        for (const _0x9d808 of _0x183938[_0x178aab(434)]) {
          if (_0x9d808 > _0x1d627b) {
            _0x1856c3 = _0x9d808, _0x2d0d5d = _0x183938;
            break;
          }
        }
        if (_0x1856c3) break;
      }
    }
    if (_0x1856c3 && _0x2d0d5d) {
      let _0x1bea79 = getTrainTerminalDestination(_0x43739a, _0x5ada30, _0x491d0d, _0x2d0d5d);
      if (!_0x1bea79) continue;
      if (_0x1019c3?.[_0x178aab(476)](_0x1bea79["id"])) {
        _0x1bea79 = getTrainOriginForTerminus(_0x43739a, _0x5ada30, _0x491d0d, _0x2d0d5d);
        if (!_0x1bea79) continue;
        if (_0x1019c3?.[_0x178aab(476)](_0x1bea79["id"])) continue;
      }
      _0x2e2991[_0x178aab(466)]({ "routeId": _0x5ada30["id"], "trainId": _0x43739a["id"], "destinationStationId": _0x1bea79["id"], "destinationStationName": _0x1bea79["name"], "arrivalTimeSeconds": _0x1856c3, "minutesUntilArrival": Math[_0x178aab(472)]((_0x1856c3 - _0x1d627b) / 60) });
    }
  }
  _0x2e2991[_0x178aab(449)]((_0x1c49d7, _0x1447a8) => _0x1c49d7[_0x178aab(450)] - _0x1447a8[_0x178aab(450)]);
  const _0x458230 = /* @__PURE__ */ new Map(), _0x31fe6c = /* @__PURE__ */ new Map();
  for (const _0x455009 of _0x2e2991) {
    let _0x197fd5 = _0x458230[_0x178aab(436)](_0x455009[_0x178aab(456)]);
    if (!_0x197fd5) {
      const _0x4dae34 = _0x5ce137[_0x178aab(451)]((_0x12439d) => _0x12439d["id"] === _0x455009[_0x178aab(456)]);
      if (!_0x4dae34) continue;
      _0x197fd5 = { "route": _0x4dae34, "arrivals": [] }, _0x458230["set"](_0x455009["routeId"], _0x197fd5);
    }
    const _0x3426c3 = _0x455009[_0x178aab(456)] + "-" + _0x455009[_0x178aab(427)], _0x422084 = _0x31fe6c[_0x178aab(436)](_0x3426c3) || 0;
    _0x422084 < maxArrivalsPerRoute && (_0x197fd5[_0x178aab(440)][_0x178aab(466)](_0x455009), _0x31fe6c[_0x178aab(455)](_0x3426c3, _0x422084 + 1));
  }
  const _0x3d1bf7 = Array[_0x178aab(462)](_0x458230[_0x178aab(463)]());
  return _0x3d1bf7[_0x178aab(449)]((_0x34d495, _0x80365f) => _0x34d495[_0x178aab(454)][_0x178aab(447)][_0x178aab(474)](_0x80365f[_0x178aab(454)][_0x178aab(447)])), _0x3d1bf7;
}
function getTrainTerminalDestination(_0x20b939, _0x3d3706, _0x125140, _0x5468ca) {
  const _0x18f839 = _0x3a89;
  if (!_0x3d3706 || _0x3d3706[_0x18f839(452)][_0x18f839(441)] < 2) return null;
  const _0x2d6dfd = findRouteSplitIndices({ "route": _0x3d3706, "stations": _0x125140 }), _0x2baa86 = _0x5468ca[_0x18f839(460)];
  let _0x370432 = null;
  for (const _0x420aad of _0x2d6dfd) {
    if (_0x420aad[_0x18f839(458)] === null) continue;
    if (_0x2baa86 >= _0x420aad["stNodeStartIndex"] && _0x2baa86 <= _0x420aad[_0x18f839(458)]) {
      _0x370432 = _0x420aad;
      break;
    }
  }
  if (!_0x370432 || _0x370432[_0x18f839(458)] === null) {
    const _0xb3f918 = _0x3d3706[_0x18f839(452)][_0x3d3706[_0x18f839(452)][_0x18f839(441)] - 1];
    return _0x125140["find"]((_0x4ba458) => _0x4ba458["stNodeIds"][_0x18f839(476)](_0xb3f918["id"])) || null;
  }
  const _0x3148b1 = _0x3d3706["stNodes"][_0x370432[_0x18f839(458)]], _0x3caa1e = _0x125140[_0x18f839(451)]((_0x3b98c9) => _0x3b98c9["stNodeIds"]["includes"](_0x3148b1["id"]));
  return _0x3caa1e || null;
}
function _0x73d5() {
  const _0x1de35a = ["localeCompare", "4aEToVg", "includes", "stNodeId", "tempParentId", "timings", "destinationStationId", "prototype", "exception", "return (function() ", "some", "944859SFqFHw", "log", "futureCycleArrivalTimes", "constructor", "get", "264681yXtAAc", "bind", "20678780aJZLMU", "arrivals", "length", "warn", "trace", "apply", "has", "stNodeIds", "bullet", "console", "sort", "arrivalTimeSeconds", "find", "stNodes", "table", "route", "set", "routeId", '{}.constructor("return this")( )', "stNodeEndIndex", "7ufsGXb", "stNodeIndex", "2818188WpFIuQ", "from", "values", "1733520CvVVGB", "__proto__", "push", "stNodeStartIndex", "5110725ibLGAN", "expectedArrivalTime", "80ENnknk", "toString", "round", "412724rfzzVr"];
  _0x73d5 = function() {
    return _0x1de35a;
  };
  return _0x73d5();
}
function getTrainOriginForTerminus(_0x3cb8a2, _0x54d50a, _0x6629c8, _0x37abc2) {
  const _0x53fc51 = _0x3a89;
  if (!_0x54d50a || _0x54d50a[_0x53fc51(452)][_0x53fc51(441)] < 2) return null;
  const _0x30bacd = findRouteSplitIndices({ "route": _0x54d50a, "stations": _0x6629c8 }), _0x5c39b4 = _0x37abc2[_0x53fc51(460)];
  let _0x24f713 = null;
  for (const _0x1fa9a3 of _0x30bacd) {
    if (_0x1fa9a3[_0x53fc51(458)] === null) continue;
    if (_0x5c39b4 >= _0x1fa9a3[_0x53fc51(467)] && _0x5c39b4 <= _0x1fa9a3["stNodeEndIndex"]) {
      _0x24f713 = _0x1fa9a3;
      break;
    }
  }
  if (!_0x24f713) return null;
  const _0x498d78 = _0x54d50a["stNodes"][_0x24f713["stNodeStartIndex"]], _0x11b3cc = _0x6629c8[_0x53fc51(451)]((_0x3c3110) => _0x3c3110[_0x53fc51(446)][_0x53fc51(476)](_0x498d78["id"]));
  return _0x11b3cc || null;
}
function StationDetailsPanel() {
  const { t } = useTranslation("game");
  const { isSoundEnabled, useImperialUnits } = useSettings();
  const [audioState, setAudioState] = reactExports.useState(initialAudioState);
  const { currentNavigationState, pushNavigationState } = useUi();
  const stations = useStations();
  const routes = useRoutes();
  const trains = useTrains();
  const tracks = useTracks();
  const allStationTrainPopMovements = useAllStationTrainPopMovements();
  const popsMap = useMainStore((state) => state.demandData.popsMap);
  const updateStationName = useMainStore((state) => state.updateStationName);
  const currentTimeSeconds = useMainStore((state) => state.timeConfig.elapsedSeconds);
  const station = stations.find((station2) => station2.id === currentNavigationState?.itemId);
  if (!station) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.stations.stationNotFound") });
  }
  const stationPopMovements = allStationTrainPopMovements.stations.get(station.id);
  const passengers = stationPopMovements?.size || 0;
  const popIds = stationPopMovements?.popIds || [];
  const LineIcons = station.routeIds.map((routeId) => {
    const route = routes.find((route2) => route2.id === routeId);
    if (!route) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RouteIcon,
      {
        route,
        size: 1.5,
        onClick: () => pushNavigationState({ type: "route-details", itemId: route.id, view: null }),
        yTranslate: -0.01
      },
      routeId
    );
  });
  const routeArrivals = getNextTrainArrivals({
    station,
    trains,
    routes,
    stations,
    currentTimeSeconds,
    maxArrivalsPerRoute: 2,
    excludeStationIds: [station.id]
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$1,
        {
          value: station.name,
          onChange: (e) => updateStationName(station.id, {
            type: "newName",
            newName: e.target.value
          }),
          maxLength: 40,
          placeholder: t("panels.stations.stationNamePlaceholder"),
          className: "h-7 flex-1"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          className: "h-7 px-2",
          onClick: () => {
            updateStationName(station.id, { type: "refresh" });
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCcw, { className: "h-4 w-4" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 items-center justify-start", children: LineIcons }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StationStats, { stationId: station.id }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.stations.departures"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DeparturesBoard,
      {
        routeArrivals,
        onRouteClick: (routeId) => pushNavigationState({ type: "route-details", itemId: routeId, view: null }),
        onTrainClick: (trainId) => pushNavigationState({ type: "train-details", itemId: trainId, view: null })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(PanelSection, { title: t("panels.stations.currentUsage"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: popIds.map((popId) => {
        const pop = popsMap.get(popId);
        if (!pop) return null;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PopPreviewCard, { pop }, popId);
      }) }),
      passengers === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: t("panels.stations.noPassengersAtStation") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium", children: t("panels.stations.passengersAtStation", { count: passengers }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NearbyStations,
      {
        originCoords: station.coords,
        originId: station.id,
        maxWalkingTime: PATHFINDING_RULES.MAX_WALK_TO_FROM_STATION * 2
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.stations.physicalStats"), children: (() => {
      const stationTracks = tracks.filter((t2) => station.trackIds.includes(t2.id));
      if (stationTracks.length === 0) return null;
      const totalLength = stationTracks.reduce((sum, t2) => sum + t2.length, 0);
      const avgLength = totalLength / stationTracks.length;
      const elevations = stationTracks.flatMap((t2) => [t2.startElevation, t2.endElevation]);
      const avgElevation = elevations.reduce((sum, e) => sum + e, 0) / elevations.length;
      const dataTableRows = [
        {
          label: t("panels.stations.platformLength"),
          value: formatDistance(avgLength, useImperialUnits)
        },
        {
          label: t("panels.stations.elevation"),
          value: formatElevation(avgElevation, useImperialUnits, 0)
        }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: dataTableRows, className: "pr-1" });
    })() }),
    DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "sm", onClick: () => console.log(station), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, { className: "w-4 h-4" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          onClick: () => playVoiceAnnouncements(audioState, setAudioState),
          disabled: audioState.playing || !isSoundEnabled,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Volume2, { className: "w-4 h-4" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          onClick: () => stopAllAudio(audioState, setAudioState),
          disabled: !audioState.playing,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Square, { className: "w-4 h-4" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          size: "sm",
          onClick: () => downloadCombinedAudio(),
          disabled: audioState.playing,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "w-4 h-4" })
        }
      )
    ] })
  ] });
}
function StationGroupStats({ stationGroupId }) {
  const { t } = useTranslation("game");
  const completedCommutes = useMainStore((state) => state.completedCommutes);
  const stationGroups = useStationGroups();
  const stationGroupStats = getStationGroupStats({ completedCommutes, stationGroups });
  const thisGroupStats = stationGroupStats.byStationGroup.find((sg) => sg.stationGroupId === stationGroupId);
  if (!thisGroupStats) return null;
  const stationGroup = stationGroups.find((g) => g.id === stationGroupId);
  if (!stationGroup) return null;
  const routeRidership = /* @__PURE__ */ new Map();
  let totalTransfers = 0;
  for (const commute of completedCommutes) {
    const usedStationsInGroup = commute.stationRoutes.filter(
      (sr) => sr.stationIds.some((stationId) => stationGroup.stationIds.includes(stationId))
    );
    if (usedStationsInGroup.length === 0) continue;
    if (commute.stationRoutes.length < 2) continue;
    for (const stationId of stationGroup.stationIds) {
      const segmentsUsingStation = commute.stationRoutes.filter((sr) => sr.stationIds.includes(stationId));
      if (segmentsUsingStation.length > 1) {
        totalTransfers += commute.size;
        break;
      }
      if (segmentsUsingStation.length !== 1) continue;
      const segmentIndex = commute.stationRoutes.indexOf(segmentsUsingStation[0]);
      const isTransferPoint = segmentIndex > 0 && commute.stationRoutes[segmentIndex].stationIds[0] === stationId || segmentIndex < commute.stationRoutes.length - 1 && commute.stationRoutes[segmentIndex].stationIds[1] === stationId;
      if (isTransferPoint) {
        totalTransfers += commute.size;
        break;
      }
    }
    const countedRoutes = /* @__PURE__ */ new Set();
    for (const stationRoute of usedStationsInGroup) {
      if (!countedRoutes.has(stationRoute.routeId)) {
        routeRidership.set(
          stationRoute.routeId,
          (routeRidership.get(stationRoute.routeId) || 0) + commute.size
        );
        countedRoutes.add(stationRoute.routeId);
      }
    }
  }
  const routeRidershipArray = Array.from(routeRidership.entries()).map(([routeId, popCount]) => ({
    routeId,
    popCount,
    percent: thisGroupStats.popCount > 0 ? popCount / thisGroupStats.popCount * 100 : 0
  })).sort((a2, b) => b.popCount - a2.popCount);
  const dataTableRows = [
    totalTransfers > 0 && {
      label: t("stats.originDestination"),
      value: (thisGroupStats.popCount - totalTransfers).toLocaleString()
    },
    totalTransfers > 0 && { label: t("stats.transfers"), value: totalTransfers.toLocaleString() },
    { label: t("stats.total"), value: thisGroupStats.popCount.toLocaleString() }
  ].filter(Boolean);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PanelSection, { title: t("stats.ridership"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(RouteRidershipBarChart, { routeRidership: routeRidershipArray }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: dataTableRows, className: "pr-1 gap-3" })
  ] });
}
function StationGroupDetailsPanel() {
  const { t } = useTranslation("game");
  const { currentNavigationState, pushNavigationState } = useUi();
  const stationGroups = useStationGroups();
  const stations = useStations();
  const routes = useRoutes();
  const trains = useTrains();
  const currentTimeSeconds = useMainStore((state) => state.timeConfig.elapsedSeconds);
  const stationGroup = stationGroups.find((g) => g.id === currentNavigationState?.itemId);
  if (!stationGroup) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.stationGroup.stationGroupNotFound") });
  const groupStations = stations.filter((s2) => stationGroup.stationIds.includes(s2.id));
  const routeArrivalsMap = /* @__PURE__ */ new Map();
  const groupStationIds = groupStations.map((s2) => s2.id);
  for (const station of groupStations) {
    const stationArrivals = getNextTrainArrivals({
      station,
      trains,
      routes,
      stations,
      currentTimeSeconds,
      maxArrivalsPerRoute: 2,
      excludeStationIds: groupStationIds
    });
    for (const routeArrival of stationArrivals) {
      const existing = routeArrivalsMap.get(routeArrival.route.id);
      if (existing) {
        existing.arrivals.push(...routeArrival.arrivals);
        existing.arrivals.sort((a2, b) => a2.arrivalTimeSeconds - b.arrivalTimeSeconds);
        const maxArrivals = 4;
        if (existing.arrivals.length > maxArrivals) {
          existing.arrivals = existing.arrivals.slice(0, maxArrivals);
        }
      } else {
        routeArrivalsMap.set(routeArrival.route.id, {
          route: routeArrival.route,
          arrivals: [...routeArrival.arrivals]
        });
      }
    }
  }
  const groupedArrivals = Array.from(routeArrivalsMap.values());
  groupedArrivals.sort((a2, b) => a2.route.bullet.localeCompare(b.route.bullet));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.stationGroup.stations"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-1", children: groupStations.map((station) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StationPreviewCard, { station }, station.id);
    }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StationGroupStats, { stationGroupId: stationGroup.id }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.stationGroup.departures"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DeparturesBoard,
      {
        routeArrivals: groupedArrivals,
        onRouteClick: (routeId) => pushNavigationState({ type: "route-details", itemId: routeId, view: null }),
        onTrainClick: (trainId) => pushNavigationState({ type: "train-details", itemId: trainId, view: null })
      }
    ) })
  ] });
}
function StationPreviewCard({ station }) {
  const { pushNavigationState } = useUi();
  const routes = useRoutes();
  const stationRoutes = routes.filter((r) => station.routeIds.includes(r.id));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    PreviewCard,
    {
      onClick: () => pushNavigationState({ type: "station-details", itemId: station.id, view: null }),
      className: "flex items-center justify-between gap-2 py-2 px-3",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 justify-between w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "w-3 h-3 rounded-full border-2",
                style: {
                  backgroundColor: stationRoutes.length === 1 ? stationRoutes[0].color : "white",
                  borderColor: stationRoutes.length === 1 ? stationRoutes[0].color : "gray"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: station.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-0.5 ml-2", children: stationRoutes.map((route) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteIcon,
            {
              route,
              size: 20,
              yTranslate: -0.01,
              sizeUnit: "px",
              ignoreHover: true,
              className: "cursor-pointer"
            },
            route.id
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "h-4 w-4 text-muted-foreground" })
      ]
    },
    station.id
  );
}
function StationRidershipPanel() {
  const { t } = useTranslation("game");
  const stationViewOptions = [
    {
      value: "groups",
      label: t("panels.stationRidership.stationGroups"),
      icon: null
    },
    {
      value: "stations",
      label: t("panels.stationRidership.stations"),
      icon: null
    }
  ];
  const ridershipTypeOptions = [
    {
      value: "all",
      label: t("panels.stationRidership.all"),
      icon: null
    },
    {
      value: "origin-destination",
      label: t("panels.stationRidership.originDestination"),
      icon: null,
      infoText: t("panels.stationRidership.originDestinationInfo")
    },
    {
      value: "transfers",
      label: t("panels.stationRidership.transfers"),
      icon: null
    }
  ];
  const originOptions = [
    {
      value: "all",
      label: t("panels.stationRidership.all"),
      icon: null
    },
    {
      value: "work-origin",
      label: t("panels.stationRidership.toWork"),
      icon: null,
      infoText: t("panels.stationRidership.toWorkInfo")
    },
    {
      value: "home-origin",
      label: t("panels.stationRidership.toHome"),
      icon: null,
      infoText: t("panels.stationRidership.toHomeInfo")
    }
  ];
  const { currentNavigationState, pushNavigationState } = useUi();
  const completedCommutes = useMainStore((state) => state.completedCommutes);
  const stationGroups = useStationGroups();
  const viewMode = currentNavigationState?.type === "station-ridership" && (currentNavigationState.view === "stations" || currentNavigationState.view === "groups") ? currentNavigationState.view : "groups";
  const ridershipType = currentNavigationState?.type === "station-ridership" && currentNavigationState.ridershipType && ["all", "origin-destination", "transfers"].includes(currentNavigationState.ridershipType) ? currentNavigationState.ridershipType : "all";
  const originFilter = currentNavigationState?.type === "station-ridership" && currentNavigationState.originFilter && ["all", "work-origin", "home-origin"].includes(currentNavigationState.originFilter) ? currentNavigationState.originFilter : "all";
  const stations = useStations();
  const stationRidership = stations.map((station) => {
    const stats = getStationStats({ completedCommutes, stationId: station.id, ridershipType, originFilter });
    return {
      stationId: station.id,
      popCount: stats.total,
      percent: 0
      // Will be calculated below
    };
  }).filter((s2) => s2.popCount > 0);
  const totalStationRidership = stationRidership.reduce((sum, s2) => sum + s2.popCount, 0);
  stationRidership.forEach((s2) => {
    s2.percent = totalStationRidership > 0 ? s2.popCount / totalStationRidership * 100 : 0;
  });
  stationRidership.sort((a2, b) => b.popCount - a2.popCount);
  const stationGroupStats = getStationGroupStats({ completedCommutes, stationGroups, ridershipType, originFilter });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 w-full min-w-80 h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleGroup,
        {
          options: stationViewOptions,
          value: viewMode,
          onChange: (view) => {
            if (currentNavigationState?.type === "station-ridership") {
              pushNavigationState(
                {
                  ...currentNavigationState,
                  view
                },
                { ignoreLastItemIfSameType: true }
              );
            }
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleGroup,
        {
          options: ridershipTypeOptions,
          value: ridershipType,
          onChange: (type) => {
            if (currentNavigationState?.type === "station-ridership") {
              pushNavigationState(
                {
                  ...currentNavigationState,
                  ridershipType: type,
                  // Reset origin filter when changing ridership type
                  originFilter: type === "origin-destination" ? originFilter : "all"
                },
                { ignoreLastItemIfSameType: true }
              );
            }
          }
        }
      ),
      ridershipType === "origin-destination" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleGroup,
        {
          options: originOptions,
          value: originFilter,
          onChange: (filter) => {
            if (currentNavigationState?.type === "station-ridership") {
              pushNavigationState(
                {
                  ...currentNavigationState,
                  originFilter: filter
                },
                { ignoreLastItemIfSameType: true }
              );
            }
          }
        }
      )
    ] }),
    viewMode === "stations" ? /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.stationRidership.stationRidership"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(StationRidershipBarChart, { stationRidership }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PanelSection, { title: t("panels.stationRidership.stationGroupRidership"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(StationGroupRidershipBarChart, { stationGroupRidership: stationGroupStats.byStationGroup }) })
  ] });
}
function TrainDetailsPanel() {
  const { t } = useTranslation("game");
  const { currentNavigationState, pushNavigationState, followingTrainId, setFollowingTrainId } = useUi();
  const trains = useTrains();
  const routes = useRoutes();
  const allStationTrainPopMovements = useAllStationTrainPopMovements();
  const { useImperialUnits } = useSettings();
  const train = trains.find((train2) => train2.id === currentNavigationState?.itemId);
  if (!train) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.trainDetails.trainNotFound") });
  }
  const route = routes.find((route2) => route2.id === train.routeId);
  if (!route) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.trainDetails.cantFindRoute") });
  }
  const stoppedAtStation = train.currentStComboInfo.timeAtStop && !train.currentStComboInfo.timeAtStopEnd;
  const trainPopMovement = allStationTrainPopMovements.trains.get(train.id);
  const trainType = getTrainType(train.trainType);
  const isFollowing = followingTrainId === train.id;
  const handleFollowToggle = () => {
    setFollowingTrainId(isFollowing ? null : train.id);
  };
  const tableRows = [
    {
      label: t("panels.trainDetails.route"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "justify-self-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        RouteIcon,
        {
          route,
          size: 1,
          onClick: () => pushNavigationState({ type: "route-details", itemId: route.id, view: null }),
          yTranslate: -0.03
        }
      ) })
    },
    { label: t("panels.trainDetails.passengers"), value: `${trainPopMovement?.size || 0} / ${train.specs.maxCapacity}` },
    { label: t("panels.trainDetails.pops"), value: trainPopMovement?.popIds.length || 0 },
    { label: t("panels.trainDetails.speed"), value: formatSpeed(train.motion.speed, useImperialUnits) },
    { label: t("panels.trainDetails.acceleration"), value: (train.motion.acceleration?.toFixed(1) || "N/A") + " m/s²" },
    { label: t("panels.trainDetails.stoppedAtStation"), value: stoppedAtStation ? t("panels.trainDetails.yes") : t("panels.trainDetails.no") },
    { label: t("panels.trainDetails.length"), value: formatDistance(train.length, useImperialUnits) },
    { label: t("panels.trainDetails.maxSpeed"), value: formatSpeed(trainType.stats.maxSpeed, useImperialUnits) },
    { label: t("panels.trainDetails.maxAcceleration"), value: trainType.stats.maxAcceleration + " m/s²" },
    { label: t("panels.trainDetails.maxDeceleration"), value: trainType.stats.maxDeceleration + " m/s²" }
  ];
  DEBUG_MODE && tableRows.push({ label: "ID", value: train.id.slice(0, 6) });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TrainTimingsTable, { train, route }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { className: "bg-primary" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: tableRows }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: isFollowing ? "default" : "outline", onClick: handleFollowToggle, className: "flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Navigation, { className: "h-4 w-4 mr-2" }),
        isFollowing ? t("panels.trainDetails.following") : t("panels.trainDetails.followTrain")
      ] }),
      DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "icon", onClick: () => console.log(train), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, {}) })
    ] })
  ] });
}
function TrainTimingsTable({ train, route }) {
  const { t } = useTranslation("game");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 gap-2 text-xs font-medium text-muted-foreground", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.trainDetails.station") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.trainDetails.expectedArrival") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.trainDetails.actualArrival") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t("panels.trainDetails.departure") })
    ] }),
    train.timings.map((timing, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(TrainTimingsTableRow, { timing, route }, index2))
  ] });
}
function TrainTimingsTableRow({ timing, route }) {
  const { t } = useTranslation("game");
  const stations = useStations();
  const stNode = route.stNodes.find((node) => node.id === timing.stNodeId);
  if (!stNode) return null;
  const station = stations.find((station2) => station2.stNodeIds.includes(timing.stNodeId));
  if (!station) return null;
  const arrivalTime = timing.arrivalTime !== null ? formatTrainTime(timing.arrivalTime) : "—";
  const departureTime = timing.departureTime !== null ? formatTrainTime(timing.departureTime) : "—";
  const expectedArrivalTime = timing.expectedArrivalTime !== null ? formatTrainTime(timing.expectedArrivalTime) : "—";
  const futureCycleTimes = timing.futureCycleArrivalTimes?.slice(0, 3).map((time2) => formatTrainTime(time2)).join(", ") || "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 gap-2 text-xs fo", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: station.name || t("panels.trainDetails.unnamedStation") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: cn("whitespace-nowrap", timing.expectedArrivalTime === null ? "text-muted-foreground" : ""),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: expectedArrivalTime }),
          futureCycleTimes && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground", children: [
            t("panels.trainDetails.future"),
            ": ",
            futureCycleTimes
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("whitespace-nowrap", timing.arrivalTime === null ? "text-muted-foreground" : ""), children: arrivalTime }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("whitespace-nowrap", timing.departureTime === null ? "text-muted-foreground" : ""), children: departureTime })
  ] });
}
function formatTrainTime(seconds) {
  const { hours, minutes, seconds: remainingSeconds } = formatClockTime(seconds);
  return `${hours}:${minutes}:${remainingSeconds}`;
}
function TrainsListPanel() {
  const { t } = useTranslation("game");
  const { trains, ownedTrainCount, ownedCarsByType } = useMainStore();
  const { pushNavigationState } = useUi();
  const trainsByType = {};
  Object.keys(TRAIN_TYPES).forEach((typeId) => {
    const ownedCount = ownedCarsByType[typeId] || 0;
    if (ownedCount > 0) {
      const trainsOfType = trains.filter((t2) => (t2.trainType || "heavy-metro") === typeId);
      trainsByType[typeId] = Array.from({ length: ownedCount }, (_, i) => trainsOfType[i] || null);
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full w-full gap-1", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 justify-between mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        size: "sm",
        variant: "outline",
        onClick: () => {
          pushNavigationState({
            type: "buy-trains",
            itemId: null,
            view: null
          });
        },
        className: "w-full",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingCart, { className: "h-4 w-4 mr-1" }),
          t("panels.trains.buyTrains")
        ]
      }
    ) }),
    ownedTrainCount === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-sm text-muted-foreground", children: t("panels.trains.noTrainsOwned") }),
    Object.entries(trainsByType).map(([typeId, trainsOfType]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-semibold text-muted-foreground mt-2", children: TRAIN_TYPES[typeId].name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground", children: t("panels.trains.carsInServiceOwned", {
        inService: trains.filter((t2) => (t2.trainType || "heavy-metro") === typeId).reduce((sum, t2) => sum + (t2.cars || 0), 0),
        owned: ownedCarsByType[typeId] || 0
      }) }),
      trainsOfType.map((train, index2) => {
        if (!train) return null;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex gap-2 items-center justify-between",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TrainPreview, { train, index: index2, className: "w-full" })
          },
          train?.id || `empty-${typeId}-${index2}`
        );
      })
    ] }, typeId))
  ] });
}
function TrainTypesPanel() {
  const { t } = useTranslation("game");
  const { currentNavigationState, pushNavigationState } = useUi();
  const { useImperialUnits } = useSettings();
  const selectedTrainType = currentNavigationState?.itemId || "heavy-metro";
  const trainType = TRAIN_TYPES[selectedTrainType];
  const handleTrainTypeChange = (newTrainType) => {
    pushNavigationState({
      type: "train-types",
      itemId: newTrainType,
      view: null
    });
  };
  const minTotalCapacity = trainType.stats.minCars * trainType.stats.capacityPerCar;
  const maxTotalCapacity = trainType.stats.maxCars * trainType.stats.capacityPerCar;
  const tableRows = [
    {
      label: t("panels.trainTypes.maxAcceleration"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsxs(DataTableRow, { children: [
        trainType.stats.maxAcceleration,
        " m/s²"
      ] })
    },
    {
      label: t("panels.trainTypes.maxDeceleration"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsxs(DataTableRow, { children: [
        trainType.stats.maxDeceleration,
        " m/s²"
      ] })
    },
    {
      label: t("panels.trainTypes.maxSpeed"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatSpeed(trainType.stats.maxSpeed, useImperialUnits) })
    },
    {
      label: t("panels.trainTypes.maxSpeedStationPlatform"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatSpeed(trainType.stats.maxSpeedLocalStation, useImperialUnits) })
    },
    {
      label: t("panels.trainTypes.capacityPerCar"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: trainType.stats.capacityPerCar })
    },
    {
      label: t("panels.trainTypes.totalCapacity"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsxs(DataTableRow, { children: [
        minTotalCapacity,
        "-",
        maxTotalCapacity
      ] })
    },
    {
      label: t("panels.trainTypes.minCars"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: trainType.stats.minCars })
    },
    {
      label: t("panels.trainTypes.maxCars"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: trainType.stats.maxCars })
    },
    {
      label: t("panels.trainTypes.carsPerSet"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: trainType.stats.carsPerCarSet })
    },
    {
      label: t("panels.trainTypes.carCost"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatCurrency(trainType.stats.carCost) })
    },
    {
      label: t("panels.trainTypes.carLength"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatDistance(trainType.stats.carLength, useImperialUnits) })
    },
    {
      label: t("panels.trainTypes.trainWidth"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatDistance(trainType.stats.trainWidth, useImperialUnits) })
    },
    {
      label: t("panels.trainTypes.minStationLength"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatDistance(trainType.stats.minStationLength, useImperialUnits) })
    },
    {
      label: t("panels.trainTypes.maxStationLength"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatDistance(trainType.stats.maxStationLength, useImperialUnits) })
    },
    {
      label: t("panels.trainTypes.baseTrackCost"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsxs(DataTableRow, { className: "flex gap-1", children: [
        formatCurrency(trainType.stats.baseTrackCost),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: t("panels.trainTypes.baseTrackCostTooltip") })
      ] })
    },
    {
      label: t("panels.trainTypes.baseStationCost"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsxs(DataTableRow, { className: "flex gap-1", children: [
        formatCurrency(trainType.stats.baseStationCost),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTooltip, { tooltipText: t("panels.trainTypes.baseStationCostTooltip") })
      ] })
    },
    {
      label: t("panels.trainTypes.trainOperationalCost"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatCurrency(trainType.stats.trainOperationalCostPerHour) })
    },
    {
      label: t("panels.trainTypes.carOperationalCost"),
      value: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTableRow, { children: formatCurrency(trainType.stats.carOperationalCostPerHour) })
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 w-72 max-w-72", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "text-sm", children: t("panels.trainTypes.trainType") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: selectedTrainType, onValueChange: handleTrainTypeChange, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "max-h-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: Object.entries(TRAIN_TYPES).map(([id, type]) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: id, children: type.name }, id)) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: trainType.description }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { className: "my-2" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, { rows: tableRows })
  ] });
}
const panelComponents = {
  construction: ConstructionPanel,
  "routes-list": RouteListPanel,
  "new-route-form": NewRouteForm,
  "trains-list": TrainsListPanel,
  "buy-trains": BuyTrainsPanel,
  "route-details": RouteDetailsPanel,
  "train-details": TrainDetailsPanel,
  "train-types": TrainTypesPanel,
  "station-details": StationDetailsPanel,
  "station-group-details": StationGroupDetailsPanel,
  "demand-stats": DemandStatsPanel,
  "route-ridership": RouteRidershipPanel,
  "station-ridership": StationRidershipPanel,
  "pop-details": PopDetailsPanel,
  "demand-point-details": DemandPointDetailsPanel,
  "journey-planner": JourneyPlannerPanel,
  "signal-details": SignalDetailsPanel,
  "pop-movement": PopMovementPanel
};
function getTranslatedPanelName(t, stateType) {
  if (!stateType) return "";
  const keyMap = {
    construction: "navigation.construction",
    "routes-list": "navigation.routesList",
    "new-route-form": "navigation.routeForm",
    "trains-list": "navigation.trainsList",
    "buy-trains": "navigation.buyTrains",
    "route-details": "navigation.routeDetails",
    "train-details": "navigation.trainDetails",
    "train-types": "navigation.trainTypes",
    "station-details": "navigation.stationDetails",
    "station-group-details": "navigation.stationGroup",
    "demand-stats": "navigation.demandStats",
    "route-ridership": "navigation.routeRidership",
    "station-ridership": "navigation.stationRidership",
    "pop-details": "navigation.popDetails",
    "demand-point-details": "navigation.demandPointDetails",
    "journey-planner": "navigation.journeyPlanner",
    "signal-details": "navigation.signalDetails",
    "pop-movement": "navigation.popMovement"
  };
  return t(keyMap[stateType]);
}
function NavigationPanel() {
  const { t } = useTranslation("game");
  const {
    currentNavigationState,
    clearNavigationHistory,
    navigate,
    canNavigateBack,
    userAction,
    setUserAction,
    toggleDemandStatsPinned,
    isDemandStatsPinned
  } = useUi();
  const setPreviewRoute = useMainStore((state) => state.setPreviewRoute);
  const confirmRouteChange = useMainStore((state) => state.confirmRouteChange);
  const [showConfirmDialog, setShowConfirmDialog] = reactExports.useState(false);
  const [pendingAction, setPendingAction] = reactExports.useState(null);
  const panelName = getTranslatedPanelName(t, currentNavigationState?.type);
  const isEditingRoute = currentNavigationState?.type === "route-details" && userAction === "draw-line-track";
  reactExports.useEffect(() => {
    const handleEscapeWithUnsavedChanges = () => {
      if (isEditingRoute) {
        setPendingAction("close");
        setShowConfirmDialog(true);
      }
    };
    window.addEventListener("nav-panel-escape", handleEscapeWithUnsavedChanges);
    return () => {
      window.removeEventListener("nav-panel-escape", handleEscapeWithUnsavedChanges);
    };
  }, [isEditingRoute]);
  if (currentNavigationState === null) {
    return null;
  }
  const handlePinClick = () => {
    toggleDemandStatsPinned();
    if (!isDemandStatsPinned) {
      clearNavigationHistory();
    }
  };
  const handleBackClick = () => {
    if (isEditingRoute) {
      setPendingAction("back");
      setShowConfirmDialog(true);
    } else {
      navigate("back");
    }
  };
  const handleCloseClick = () => {
    if (isEditingRoute) {
      setPendingAction("close");
      setShowConfirmDialog(true);
    } else {
      clearNavigationHistory();
    }
  };
  const handleConfirmChanges = () => {
    const { success } = confirmRouteChange();
    if (success) {
      setUserAction("none");
      setShowConfirmDialog(false);
      if (pendingAction === "back") {
        navigate("back");
      } else if (pendingAction === "close") {
        clearNavigationHistory();
      }
      setPendingAction(null);
    } else {
      setShowConfirmDialog(false);
      setPendingAction(null);
    }
  };
  const handleCancelChanges = () => {
    setShowConfirmDialog(false);
    setUserAction("none");
    setPreviewRoute(null);
    if (pendingAction === "back") {
      navigate("back");
    } else if (pendingAction === "close") {
      clearNavigationHistory();
    }
    setPendingAction(null);
  };
  const handleDialogCancel = () => {
    setShowConfirmDialog(false);
    setPendingAction(null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(WindowWrapper, { className: "bg-transparent w-full max-h-full flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-9 min-h-9 w-full p-1 border-b border-primary/15 items-center justify-between bg-primary-foreground", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center h-full w-full", children: canNavigateBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "link",
            className: "h-full items-center justify-center p-1 gap-0.5 pl-0 hover:opacity-50",
            onClick: handleBackClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, { className: "w-full h-full" })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center h-full w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-semibold whitespace-nowrap", children: panelName }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center h-full w-full gap-1 justify-end", children: [
          currentNavigationState.type === "demand-stats" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 flex-shrink-0",
              onClick: handlePinClick,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pin, { className: `h-4 w-4 ${isDemandStatsPinned ? "fill-current" : ""}` })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { onClick: handleCloseClick, className: "w-fit" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-h-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 flex bg-primary-foreground/60 backdrop-blur-sm max-h-auto overflow-auto min-w-72 justify-center", children: (() => {
        const PanelComponent = panelComponents[currentNavigationState.type];
        return PanelComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(PanelComponent, {}) : null;
      })() }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: showConfirmDialog, onOpenChange: setShowConfirmDialog, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "w-fit", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Unsaved Route Changes" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: "You have unsaved changes to this route" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: handleDialogCancel, children: "Continue editing" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "destructive", onClick: handleCancelChanges, children: "Discard changes" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleConfirmChanges, children: "Confirm changes" })
      ] }) })
    ] }) })
  ] });
}
const jobHomeOptions = [
  {
    value: "homes",
    label: "Residents",
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(House, { className: "h-4 w-4" })
  },
  {
    value: "jobs",
    label: "Workers",
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { className: "h-4 w-4" })
  }
];
function PinnedDemandStats() {
  const { isDemandStatsPinned, toggleDemandStatsPinned, pinnedDemandStatsView, setPinnedDemandStatsView } = useUi();
  const { demandData } = useMainStore();
  if (!isDemandStatsPinned) {
    return null;
  }
  getTotalCommuteModes(demandData.popsMap);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(WindowWrapper, { className: "bg-transparent w-full flex flex-col mb-2 pointer-events-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-9 min-h-9 w-full p-1 border-b border-primary/15 items-center justify-between bg-primary-foreground", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center h-full w-full" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center h-full w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-semibold whitespace-nowrap", children: "Demand Stats" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center h-full w-full justify-end gap-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "ghost",
          size: "icon",
          className: "h-7 w-7",
          onClick: toggleDemandStatsPinned,
          title: "Unpin demand stats",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(X$1, { className: "h-4 w-4" })
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-h-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 flex flex-col gap-2 bg-primary-foreground/60 backdrop-blur-sm min-w-72", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToggleGroup,
      {
        options: jobHomeOptions,
        value: pinnedDemandStatsView,
        onChange: setPinnedDemandStatsView
      }
    ) }) })
  ] });
}
function StoreInitializer({ gameMode }) {
  const { loadInitialData, loadSave, setGameMode, setMoney } = useMainStore();
  const { cityCode } = useCity();
  reactExports.useEffect(() => {
    telemetry.initialize().catch(console.error);
    loadInitialData(cityCode).then(async () => {
      telemetry.trackGameStart(cityCode, gameMode || "normal");
      try {
        const pendingSave = await indexedDBHelper.getPendingSave();
        if (pendingSave) {
          loadSave(pendingSave);
          await indexedDBHelper.removePendingSave();
        } else if (gameMode) {
          const validGameMode = gameMode === "sandbox" ? "sandbox" : "easy";
          setGameMode(validGameMode);
          if (validGameMode === "sandbox") {
            setMoney(Number.MAX_SAFE_INTEGER);
          }
        }
      } catch (error) {
        console.error("Failed to load pending save:", error);
        await indexedDBHelper.removePendingSave().catch(console.error);
      }
    });
  }, [loadInitialData, loadSave, setGameMode, cityCode, gameMode]);
  return null;
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
function CheckboxProvider(props) {
  const {
    __scopeCheckbox,
    checked: checkedProp,
    children,
    defaultChecked,
    disabled,
    form,
    name: name2,
    onCheckedChange,
    required,
    value = "on",
    // @ts-expect-error
    internal_do_not_use_render
  } = props;
  const [checked, setChecked] = useControllableState({
    prop: checkedProp,
    defaultProp: defaultChecked ?? false,
    onChange: onCheckedChange,
    caller: CHECKBOX_NAME
  });
  const [control, setControl] = reactExports.useState(null);
  const [bubbleInput, setBubbleInput] = reactExports.useState(null);
  const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
  const isFormControl = control ? !!form || !!control.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    true
  );
  const context = {
    checked,
    disabled,
    setChecked,
    control,
    setControl,
    name: name2,
    form,
    value,
    hasConsumerStoppedPropagationRef,
    required,
    defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,
    isFormControl,
    bubbleInput,
    setBubbleInput
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    CheckboxProviderImpl,
    {
      scope: __scopeCheckbox,
      ...context,
      children: isFunction$1(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
    }
  );
}
var TRIGGER_NAME = "CheckboxTrigger";
var CheckboxTrigger = reactExports.forwardRef(
  ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
    const {
      control,
      value,
      disabled,
      checked,
      required,
      setControl,
      setChecked,
      hasConsumerStoppedPropagationRef,
      isFormControl,
      bubbleInput
    } = useCheckboxContext(TRIGGER_NAME, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setControl);
    const initialCheckedStateRef = reactExports.useRef(checked);
    reactExports.useEffect(() => {
      const form = control?.form;
      if (form) {
        const reset = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset);
        return () => form.removeEventListener("reset", reset);
      }
    }, [control, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        "aria-required": required,
        "data-state": getState(checked),
        "data-disabled": disabled ? "" : void 0,
        disabled,
        value,
        ...checkboxProps,
        ref: composedRefs,
        onKeyDown: composeEventHandlers(onKeyDown, (event) => {
          if (event.key === "Enter") event.preventDefault();
        }),
        onClick: composeEventHandlers(onClick, (event) => {
          setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
          if (bubbleInput && isFormControl) {
            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
            if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
          }
        })
      }
    );
  }
);
CheckboxTrigger.displayName = TRIGGER_NAME;
var Checkbox$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name: name2,
      checked,
      defaultChecked,
      required,
      disabled,
      value,
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CheckboxProvider,
      {
        __scopeCheckbox,
        checked,
        defaultChecked,
        disabled,
        required,
        onCheckedChange,
        name: name2,
        form,
        value,
        internal_do_not_use_render: ({ isFormControl }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CheckboxTrigger,
            {
              ...checkboxProps,
              ref: forwardedRef,
              __scopeCheckbox
            }
          ),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            CheckboxBubbleInput,
            {
              __scopeCheckbox
            }
          )
        ] })
      }
    );
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME = "CheckboxIndicator";
var CheckboxIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(context.checked) || context.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            "data-state": getState(context.checked),
            "data-disabled": context.disabled ? "" : void 0,
            ...indicatorProps,
            ref: forwardedRef,
            style: { pointerEvents: "none", ...props.style }
          }
        )
      }
    );
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME;
var BUBBLE_INPUT_NAME = "CheckboxBubbleInput";
var CheckboxBubbleInput = reactExports.forwardRef(
  ({ __scopeCheckbox, ...props }, forwardedRef) => {
    const {
      control,
      hasConsumerStoppedPropagationRef,
      checked,
      defaultChecked,
      required,
      disabled,
      name: name2,
      value,
      form,
      bubbleInput,
      setBubbleInput
    } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    reactExports.useEffect(() => {
      const input = bubbleInput;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      const bubbles = !hasConsumerStoppedPropagationRef.current;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        input.indeterminate = isIndeterminate(checked);
        setChecked.call(input, isIndeterminate(checked) ? false : checked);
        input.dispatchEvent(event);
      }
    }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
    const defaultCheckedRef = reactExports.useRef(isIndeterminate(checked) ? false : checked);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.input,
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: defaultChecked ?? defaultCheckedRef.current,
        required,
        disabled,
        name: name2,
        value,
        form,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;
function isFunction$1(value) {
  return typeof value === "function";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
const Checkbox = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Checkbox$1,
  {
    ref,
    className: cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxIndicator, { className: cn("flex items-center justify-center text-current"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }) })
  }
));
Checkbox.displayName = Checkbox$1.displayName;
const TRACK_VISUALIZATION_LAYERS = ["tracks", "trackElevations", "trackTypes", "trackSpeeds"];
function LayersManager() {
  const { t } = useTranslation("game");
  const { layersToShow } = useMainStore();
  const trackVisualizationEntries = Object.entries(layersToShow).filter(
    ([key]) => TRACK_VISUALIZATION_LAYERS.includes(key)
  );
  const otherLayerEntries = Object.entries(layersToShow).filter(([key]) => !TRACK_VISUALIZATION_LAYERS.includes(key));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-1.5 text-xs text-muted-foreground", children: t("layers.trackVisualization") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-1", children: trackVisualizationEntries.map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx(LayerCheckbox, { layerKey: key, value, isTrackVisualization: true }, key)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-1.5 text-xs text-muted-foreground", children: t("layers.otherLayers") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-1", children: otherLayerEntries.map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx(LayerCheckbox, { layerKey: key, value, isTrackVisualization: false }, key)) })
    ] })
  ] });
}
function LayerCheckbox({
  layerKey,
  value,
  isTrackVisualization
}) {
  const { layersToShow, setLayersToShow } = useMainStore();
  const layerConfig = LAYER_CONFIG[layerKey];
  if (!layerConfig) throw new Error(`Layer config not found for ${layerKey}`);
  if (layerConfig.debugOnly && !DEBUG_MODE) return null;
  const handleChange = (checked) => {
    if (isTrackVisualization) {
      if (checked) {
        const updatedLayers = { ...layersToShow };
        TRACK_VISUALIZATION_LAYERS.forEach((layer) => {
          updatedLayers[layer] = layer === layerKey;
        });
        setLayersToShow(updatedLayers);
      } else {
        setLayersToShow({ ...layersToShow, [layerKey]: false });
      }
    } else {
      setLayersToShow({ ...layersToShow, [layerKey]: !!checked });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 cursor-pointer", onClick: () => handleChange(!value), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { checked: value }),
    layerConfig?.label || layerKey
  ] });
}
function LayersPanel({ isOpen, onClose }) {
  const { t } = useTranslation("game");
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(WindowWrapper, { className: "flex flex-col z-10 p-2 max-w-xs overflow-y-auto w-fit ml-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center w-full justify-between mb-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-semibold flex items-center gap-2 whitespace-nowrap", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Map$2, { className: "w-4 h-4" }),
        t("layers.mapLayers")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { onClick: onClose })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-1 text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LayersManager, {}) })
  ] });
}
function LayersButton({ onClick }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WindowWrapper, { onClick, className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Map$2, { className: "w-full h-full stroke-[1.5]" }) });
}
function RouteCapacityWarning({
  routeId,
  warnings,
  isExpanded,
  onToggle,
  getWarningAge
}) {
  const { t } = useTranslation("game");
  const { pushNavigationState } = useUi();
  function handleStationClick(stationId) {
    pushNavigationState({ type: "station-details", itemId: stationId, view: null });
  }
  function handleRouteClick(routeId2) {
    pushNavigationState({ type: "route-details", itemId: routeId2, view: null });
  }
  function handleTrainClick(trainId) {
    pushNavigationState({ type: "train-details", itemId: trainId, view: null });
  }
  const mostRecentTimestamp = Math.max(...warnings.map((w) => w.timestamp));
  const routes = useRoutes();
  const route = routes.find((r) => r.id === routeId);
  if (!route) return null;
  const uniqueTrainIds = new Set(warnings.map((w) => w.details.trainId));
  const uniqueTrainCount = uniqueTrainIds.size;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-destructive/20 rounded p-2 text-xs", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: onToggle,
        className: "w-full text-left flex items-start gap-1 hover:opacity-80 transition-opacity",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-auto", children: isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "w-3 h-3" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-3 h-3" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              RouteIcon,
              {
                route,
                size: 1.25,
                yTranslate: -0.01,
                onClick: () => handleRouteClick(routeId),
                className: "user-select-none"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-xs whitespace-nowrap", children: uniqueTrainCount === 1 ? t("warnings.trainAtCapacity", { count: uniqueTrainCount }) : t("warnings.trainsAtCapacity", { count: uniqueTrainCount }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-xs opacity-60", children: getWarningAge(mostRecentTimestamp) })
            ] })
          ] })
        ]
      }
    ),
    isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 ml-7 space-y-2", children: Array.from(uniqueTrainIds).map((trainId) => {
      const trainWarnings = warnings.filter((w) => w.details.trainId === trainId);
      const firstWarning = trainWarnings[0];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: "hover:underline cursor-pointer inline-flex items-center gap-1",
            onClick: () => handleTrainClick(trainId),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TramFront, { className: "w-3 h-3" }),
              t("warnings.spotsFilled", {
                current: firstWarning.details.currentOccupancy,
                max: firstWarning.details.maxCapacity
              })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pl-4 space-y-0.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-xs opacity-80", children: t("warnings.stationsLabel") }),
          trainWarnings.map((warning) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "p",
            {
              className: "text-xs hover:underline cursor-pointer opacity-70",
              onClick: () => handleStationClick(warning.details.stationId),
              children: [
                "• ",
                warning.details.stationName
              ]
            },
            warning.id
          ))
        ] })
      ] }, trainId);
    }) })
  ] });
}
function StationStuckPassengerWarning({
  stationId,
  warnings,
  isExpanded,
  onToggle,
  getWarningAge
}) {
  const { pushNavigationState } = useUi();
  function handleStationClick(stationId2) {
    pushNavigationState({ type: "station-details", itemId: stationId2, view: null });
  }
  function handleRouteClick(routeId) {
    pushNavigationState({ type: "route-details", itemId: routeId, view: null });
  }
  const mostRecentTimestamp = Math.max(...warnings.map((w) => w.timestamp));
  const routes = useRoutes();
  const firstWarning = warnings[0];
  const { stationName, waitingCount, suggestedAction, affectedRouteIds } = firstWarning.details;
  const affectedRoutes = routes.filter((r) => affectedRouteIds.includes(r.id));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-500/20 rounded p-2 text-xs", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: onToggle,
        className: "w-full text-left flex items-start gap-1 hover:opacity-80 transition-opacity",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-auto", children: isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "w-3 h-3" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-3 h-3" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "font-semibold hover:underline cursor-pointer",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleStationClick(stationId);
                  },
                  children: stationName
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center gap-1 text-yellow-700 dark:text-yellow-500", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-3 h-3" }),
                waitingCount.toLocaleString(),
                " waiting"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-xs opacity-60", children: getWarningAge(mostRecentTimestamp) })
          ] })
        ]
      }
    ),
    isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 ml-7 space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-semibold", children: "Suggested Action:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs opacity-80", children: suggestedAction })
      ] }),
      affectedRoutes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-semibold", children: "Affected Routes:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1", children: affectedRoutes.map((route) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          RouteIcon,
          {
            route,
            size: 1.25,
            yTranslate: -0.01,
            onClick: () => handleRouteClick(route.id),
            className: "cursor-pointer hover:opacity-80 transition-opacity"
          },
          route.id
        )) })
      ] })
    ] })
  ] });
}
function WarningsPanel() {
  const { t } = useTranslation("game");
  const warnings = useWarnings();
  const timeConfig = useTimeConfig();
  const [isExpanded, setIsExpanded] = reactExports.useState(false);
  const [expandedWarnings, setExpandedWarnings] = reactExports.useState(/* @__PURE__ */ new Set());
  if (warnings.length === 0) return null;
  const capacityWarnings = warnings.filter((w) => w.type === "trains-at-capacity");
  const stuckPassengerWarnings = warnings.filter((w) => w.type === "stuck-passengers");
  const getWarningAge = (timestamp) => {
    const ageInSeconds = timeConfig.elapsedSeconds - timestamp;
    if (ageInSeconds < 10) return t("warnings.justNow");
    if (ageInSeconds < 30) return t("warnings.secondsAgo", { seconds: Math.floor(ageInSeconds) });
    return t("warnings.minutesAgo", { minutes: Math.floor(ageInSeconds / 60) });
  };
  const warningsByRoute = /* @__PURE__ */ new Map();
  capacityWarnings.forEach((warning) => {
    warning.details.affectedRouteIds.forEach((routeId) => {
      if (!warningsByRoute.has(routeId)) {
        warningsByRoute.set(routeId, []);
      }
      warningsByRoute.get(routeId).push(warning);
    });
  });
  const warningsByStation = /* @__PURE__ */ new Map();
  stuckPassengerWarnings.forEach((warning) => {
    const stationId = warning.details.stationId;
    if (!warningsByStation.has(stationId)) {
      warningsByStation.set(stationId, []);
    }
    warningsByStation.get(stationId).push(warning);
  });
  const toggleWarningExpanded = (warningId) => {
    const newExpanded = new Set(expandedWarnings);
    if (newExpanded.has(warningId)) {
      newExpanded.delete(warningId);
    } else {
      newExpanded.add(warningId);
    }
    setExpandedWarnings(newExpanded);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(WindowWrapper, { className: "w-72 flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        onClick: () => setIsExpanded(!isExpanded),
        variant: "ghost",
        className: "w-full flex items-center justify-between rounded-none",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "w-4 h-4 text-yellow-600 dark:text-yellow-500" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-sm", children: t("warnings.warnings") })
          ] }),
          isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "w-4 h-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4" })
        ]
      }
    ),
    isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t max-h-96 overflow-y-auto w-full", children: [
      stuckPassengerWarnings.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 border-b", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-4 h-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-semibold", children: t("warnings.stuckPassengers") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-muted-foreground", children: [
            "(",
            warningsByStation.size,
            " ",
            warningsByStation.size === 1 ? t("warnings.station") : t("warnings.stations"),
            ")"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: Array.from(warningsByStation.entries()).map(([stationId, stationWarnings]) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            StationStuckPassengerWarning,
            {
              stationId,
              warnings: stationWarnings,
              isExpanded: expandedWarnings.has(stationId),
              onToggle: () => toggleWarningExpanded(stationId),
              getWarningAge
            },
            stationId
          );
        }) })
      ] }),
      capacityWarnings.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TramFront, { className: "w-4 h-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-semibold", children: t("warnings.capacityIssues") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-muted-foreground", children: [
            "(",
            warningsByRoute.size,
            " ",
            warningsByRoute.size === 1 ? t("warnings.route") : t("warnings.routes"),
            ")"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: Array.from(warningsByRoute.entries()).map(([routeId, routeWarnings]) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            RouteCapacityWarning,
            {
              routeId,
              warnings: routeWarnings,
              isExpanded: expandedWarnings.has(routeId),
              onToggle: () => toggleWarningExpanded(routeId),
              getWarningAge
            },
            routeId
          );
        }) })
      ] })
    ] })
  ] });
}
function TopBar() {
  const { isLayersPanelOpen, toggleLayersPanel } = useUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-fit ml-auto h-auto p-2 flex flex-col items-end justify-end gap-1", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [
      DEBUG_MODE && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugInfoButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LayersButton, { onClick: toggleLayersPanel }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SoundButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ModeToggle, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(WarningsPanel, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LayersPanel, { isOpen: isLayersPanelOpen, onClose: toggleLayersPanel })
    ] })
  ] });
}
function MenuButton() {
  const { toggleEscapeMenu } = useUi();
  const { clearPreview } = useMainStore();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WindowWrapper,
    {
      onClick: () => {
        clearPreview();
        toggleEscapeMenu();
      },
      className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, { className: "w-full h-full stroke-[1.5]" })
    }
  );
}
function DebugInfoButton() {
  const { toggleDebugInfoOpen } = useUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WindowWrapper, { onClick: toggleDebugInfoOpen, className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, { className: "w-full h-full stroke-[1.5]" }) });
}
function SoundButton() {
  const { isSoundEnabled, setIsSoundEnabled } = useSettings();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WindowWrapper,
    {
      onClick: () => setIsSoundEnabled(!isSoundEnabled),
      className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary",
      children: isSoundEnabled ? /* @__PURE__ */ jsxRuntimeExports.jsx(Volume2, { className: "w-full h-full stroke-[1.5]" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(VolumeOff, { className: "w-full h-full stroke-[1.5]" })
    }
  );
}
function TutorialHighlight({ steps }) {
  const { tutorial } = useTutorial();
  const [highlightStyle, setHighlightStyle] = reactExports.useState({});
  const [isVisible2, setIsVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!tutorial.isActive || tutorial.currentStep === 0) {
      setIsVisible(false);
      return;
    }
    const currentStep = steps[tutorial.currentStep - 1];
    const selector = currentStep?.highlightSelector;
    if (!selector) {
      setIsVisible(false);
      return;
    }
    const element = document.querySelector(selector);
    if (!element) {
      setIsVisible(false);
      return;
    }
    const rect = element.getBoundingClientRect();
    setHighlightStyle({
      position: "fixed",
      top: rect.top - 6,
      left: rect.left - 6,
      width: rect.width + 12,
      height: rect.height + 12,
      pointerEvents: "none",
      border: "3px solid #3b82f6",
      borderRadius: "12px",
      backgroundColor: "transparent",
      boxShadow: "0 0 0 4px rgba(59, 130, 246, 0.2), 0 0 30px rgba(59, 130, 246, 0.6), inset 0 0 20px rgba(59, 130, 246, 0.1)",
      zIndex: 9999,
      // High z-index to appear above all UI elements
      animation: "tutorialPulse 2s infinite",
      transition: "all 0.3s ease-out"
    });
    setIsVisible(true);
    const updatePosition = () => {
      const newRect = element.getBoundingClientRect();
      setHighlightStyle((prev) => ({
        ...prev,
        top: newRect.top - 6,
        left: newRect.left - 6,
        width: newRect.width + 12,
        height: newRect.height + 12
      }));
    };
    window.addEventListener("resize", updatePosition);
    window.addEventListener("scroll", updatePosition, true);
    return () => {
      window.removeEventListener("resize", updatePosition);
      window.removeEventListener("scroll", updatePosition, true);
    };
  }, [tutorial.isActive, tutorial.currentStep, steps]);
  if (!isVisible2) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tutorial-highlight", style: highlightStyle });
}
var isClient = typeof document !== "undefined";
var noop$4 = function noop2() {
};
var index$1 = isClient ? reactExports.useLayoutEffect : noop$4;
const SafeReact$1 = {
  ...React$1
};
const useInsertionEffect = SafeReact$1.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
const SafeReact = {
  ...React$1
};
let serverHandoffComplete = false;
let count$1 = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count$1++
);
function useFloatingId() {
  const [id, setId] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0);
  index$1(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
const FloatingArrow = /* @__PURE__ */ reactExports.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow2,
        shift: shift2
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = props;
  const clipPathId = useId();
  const [isRTL, setIsRTL] = reactExports.useState(false);
  index$1(() => {
    if (!floating) return;
    const isRTL2 = getComputedStyle$1(floating).direction === "rtl";
    if (isRTL2) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift2 != null && shift2.x || !isVerticalSide && shift2 != null && shift2.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow2 == null ? void 0 : arrow2.x) != null ? computedStaticOffset || arrow2.x : "";
  const arrowY = (arrow2 == null ? void 0 : arrow2.y) != null ? computedStaticOffset || arrow2.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
    ...rest,
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform].filter((t) => !!t).join(" "),
      ...restStyle
    },
    children: [computedStrokeWidth > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      clipPath: "url(#" + clipPathId + ")",
      fill: "none",
      stroke,
      strokeWidth: computedStrokeWidth + (d ? 0 : 1),
      d: dValue
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      stroke: computedStrokeWidth && !d ? rest.fill : "none",
      d: dValue
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", {
      id: clipPathId,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
        x: -halfStrokeWidth,
        y: halfStrokeWidth * (isCustomShape ? -1 : 1),
        width: width + computedStrokeWidth,
        height: width
      })
    })]
  });
});
function createEventEmitter() {
  const map2 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map2.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      if (!map2.has(event)) {
        map2.set(event, /* @__PURE__ */ new Set());
      }
      map2.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map2.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = reactExports.useRef({});
  const [events] = reactExports.useState(() => createEventEmitter());
  const nested = useFloatingParentNodeId() != null;
  const [positionReference, setPositionReference] = reactExports.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = reactExports.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = reactExports.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return reactExports.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = reactExports.useState(null);
  const [positionReference, _setPositionReference] = reactExports.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = reactExports.useRef(null);
  const tree = useFloatingTree();
  index$1(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = reactExports.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      getClientRects: () => node.getClientRects(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = reactExports.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = reactExports.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index$1(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return reactExports.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
(function(_0x24c0c2, _0x5a1651) {
  const _0x2319bc = _0x323d, _0x24a782 = _0x24c0c2();
  while (!![]) {
    try {
      const _0xe07c61 = -parseInt(_0x2319bc(161)) / 1 * (parseInt(_0x2319bc(154)) / 2) + parseInt(_0x2319bc(163)) / 3 + -parseInt(_0x2319bc(152)) / 4 * (-parseInt(_0x2319bc(167)) / 5) + -parseInt(_0x2319bc(148)) / 6 * (-parseInt(_0x2319bc(145)) / 7) + parseInt(_0x2319bc(151)) / 8 + parseInt(_0x2319bc(149)) / 9 * (-parseInt(_0x2319bc(171)) / 10) + -parseInt(_0x2319bc(169)) / 11 * (parseInt(_0x2319bc(143)) / 12);
      if (_0xe07c61 === _0x5a1651) break;
      else _0x24a782["push"](_0x24a782["shift"]());
    } catch (_0x45d5e7) {
      _0x24a782["push"](_0x24a782["shift"]());
    }
  }
})(_0x1450, 174101);
const _0x535c96 = /* @__PURE__ */ (function() {
  let _0x5c79ac = !![];
  return function(_0x2134b5, _0x268c2f) {
    const _0x4aee31 = _0x5c79ac ? function() {
      const _0x5201bc = _0x323d;
      if (_0x268c2f) {
        const _0x55f8b5 = _0x268c2f[_0x5201bc(141)](_0x2134b5, arguments);
        return _0x268c2f = null, _0x55f8b5;
      }
    } : function() {
    };
    return _0x5c79ac = ![], _0x4aee31;
  };
})(), _0x1d54aa = _0x535c96(void 0, function() {
  const _0x5f2958 = _0x323d;
  let _0x30ebda;
  try {
    const _0x24aa3f = Function(_0x5f2958(146) + _0x5f2958(156) + ");");
    _0x30ebda = _0x24aa3f();
  } catch (_0x506ea9) {
    _0x30ebda = window;
  }
  const _0x437284 = _0x30ebda[_0x5f2958(165)] = _0x30ebda[_0x5f2958(165)] || {}, _0x5ab074 = [_0x5f2958(164), _0x5f2958(142), _0x5f2958(150), "error", _0x5f2958(173), _0x5f2958(153), _0x5f2958(172)];
  for (let _0x46631e = 0; _0x46631e < _0x5ab074[_0x5f2958(157)]; _0x46631e++) {
    const _0x1af316 = _0x535c96["constructor"][_0x5f2958(160)]["bind"](_0x535c96), _0x4d4f86 = _0x5ab074[_0x46631e], _0x1d03d2 = _0x437284[_0x4d4f86] || _0x1af316;
    _0x1af316[_0x5f2958(162)] = _0x535c96["bind"](_0x535c96), _0x1af316[_0x5f2958(170)] = _0x1d03d2[_0x5f2958(170)]["bind"](_0x1d03d2), _0x437284[_0x4d4f86] = _0x1af316;
  }
});
function _0x323d(_0x4142db, _0x569953) {
  const _0x2304eb = _0x1450();
  return _0x323d = function(_0x1d54aa2, _0x535c962) {
    _0x1d54aa2 = _0x1d54aa2 - 139;
    let _0x6733ed = _0x2304eb[_0x1d54aa2];
    return _0x6733ed;
  }, _0x323d(_0x4142db, _0x569953);
}
_0x1d54aa();
function useElementTracker(_0x3e38ab) {
  const [_0x36bfed, _0x222c69] = reactExports.useState(null), [_0x494da2, _0x23c0e3] = reactExports.useState(null), _0x3e6692 = reactExports.useCallback(() => {
    const _0x3f6ea = _0x323d;
    if (!_0x494da2) return;
    const _0x566725 = _0x494da2[_0x3f6ea(159)]();
    _0x222c69({ "x": _0x566725["x"], "y": _0x566725["y"], "width": _0x566725[_0x3f6ea(166)], "height": _0x566725[_0x3f6ea(168)], "top": _0x566725["top"], "bottom": _0x566725[_0x3f6ea(144)], "left": _0x566725["left"], "right": _0x566725["right"] });
  }, [_0x494da2]);
  return reactExports.useEffect(() => {
    if (!_0x3e38ab) {
      _0x23c0e3(null), _0x222c69(null);
      return;
    }
    const _0x1b134d = () => {
      const _0xd70198 = _0x323d, _0x50fb8a = document[_0xd70198(147)](_0x3e38ab);
      if (_0x50fb8a) return _0x23c0e3(_0x50fb8a), !![];
      return ![];
    };
    if (!_0x1b134d()) {
      const _0x49b190 = setInterval(() => {
        _0x1b134d() && clearInterval(_0x49b190);
      }, 100), _0x2a1e93 = setTimeout(() => {
        clearInterval(_0x49b190);
      }, 5e3);
      return () => {
        clearInterval(_0x49b190), clearTimeout(_0x2a1e93);
      };
    }
  }, [_0x3e38ab]), reactExports.useEffect(() => {
    const _0x2a54ee = _0x323d;
    if (!_0x494da2) return;
    _0x3e6692();
    const _0x2a5a87 = new ResizeObserver(_0x3e6692);
    _0x2a5a87["observe"](_0x494da2);
    const _0x5acd49 = () => {
      _0x3e6692();
    };
    let _0x1fdfac;
    const _0x58a1ef = () => {
      _0x5acd49(), _0x1fdfac = requestAnimationFrame(_0x58a1ef);
    };
    return _0x1fdfac = requestAnimationFrame(_0x58a1ef), window[_0x2a54ee(140)](_0x2a54ee(139), _0x3e6692), window[_0x2a54ee(140)](_0x2a54ee(158), _0x3e6692, !![]), () => {
      const _0x274ee8 = _0x2a54ee;
      _0x2a5a87[_0x274ee8(155)](), cancelAnimationFrame(_0x1fdfac), window["removeEventListener"](_0x274ee8(139), _0x3e6692), window["removeEventListener"](_0x274ee8(158), _0x3e6692, !![]);
    };
  }, [_0x494da2, _0x3e6692]), { "position": _0x36bfed, "element": _0x494da2 };
}
function _0x1450() {
  const _0x32dc73 = ["warn", "1236axzWvr", "bottom", "7arqQkI", "return (function() ", "querySelector", "1267284DTlUoV", "18UbadrH", "info", "522944aksjMR", "28EeSBKL", "table", "34172WksRZa", "disconnect", '{}.constructor("return this")( )', "length", "scroll", "getBoundingClientRect", "prototype", "19IjydLw", "__proto__", "979626BosMVl", "log", "console", "width", "239015YwJOqy", "height", "13926rlHgAy", "toString", "1543060SjCpdE", "trace", "exception", "resize", "addEventListener", "apply"];
  _0x1450 = function() {
    return _0x32dc73;
  };
  return _0x1450();
}
function TutorialPointer({ from, to }) {
  const markerId = reactExports.useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pointer-events-none fixed inset-0 z-40", "aria-hidden": "true", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "absolute inset-0 w-full h-full", "aria-label": "Tutorial pointer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "marker",
        {
          id: `arrowhead-${markerId}`,
          markerWidth: "10",
          markerHeight: "10",
          refX: "9",
          refY: "3",
          orient: "auto",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0 0, 10 3, 0 6", className: "fill-blue-500" })
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: from.x,
          y1: from.y,
          x2: to.x,
          y2: to.y,
          className: "stroke-blue-500",
          strokeWidth: "2",
          strokeDasharray: "5,5",
          markerEnd: `url(#arrowhead-${markerId})`,
          style: {
            transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)"
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "absolute w-8 h-8 -ml-4 -mt-4",
        style: {
          left: to.x,
          top: to.y,
          transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-blue-500 rounded-full animate-ping opacity-75" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative bg-blue-500 rounded-full w-full h-full animate-pulse" })
        ]
      }
    )
  ] });
}
const STUCK_HELP_DELAY = 3e4;
const AUTO_ADVANCE_DELAY = 1500;
const POSITIONING_CONFIG = {
  // Elements that should use fixed positioning with pointer
  fixedPositionSelectors: [
    ".maplibregl-canvas",
    // Map canvas - too large for floating
    "construction-button",
    // Bottom action bar
    "routes-button",
    // Bottom action bar
    "statistics-button",
    // Bottom action bar
    "tracks-button",
    // Side panel
    "station-button",
    // Side panel
    "build-blueprint-button",
    // Side panel
    "play-button"
    // Bottom action bar
  ],
  // Default positions that account for actual UI dimensions
  // NavigationPanel: 296px left | Bottom controls: 120px | Top: 64px
  fallbackPositions: {
    center: "fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 max-w-md",
    topRight: "fixed top-20 right-8 z-50 max-w-md",
    // Clears top bar (64px + margin)
    topCenter: "fixed top-20 left-1/2 transform -translate-x-1/2 z-50 max-w-md",
    centerRight: "fixed top-1/2 right-8 transform -translate-y-1/2 z-50 max-w-md",
    rightOfPanel: "fixed top-1/2 left-80 transform -translate-y-1/2 z-50 max-w-md",
    // Clears 296px nav panel
    aboveBottom: "fixed bottom-32 left-1/2 transform -translate-x-1/2 z-50 max-w-md",
    // Clears 120px bottom UI
    upperRight: "fixed top-32 right-8 z-50 max-w-md"
    // Safe upper right quadrant
  },
  // Step positions that avoid UI elements (NavPanel: 296px | Bottom: 120px | Top: 64px)
  stepPositions: {
    1: "center",
    // Welcome - centered
    2: "topRight",
    // Map navigation - top right clear
    3: "aboveBottom",
    // Statistics button - above bottom controls
    4: "rightOfPanel",
    // Demand dropdown - clears left panel
    5: "rightOfPanel",
    // Home Areas - panel is open
    6: "rightOfPanel",
    // Work Areas - panel is open
    7: "topCenter",
    // The Mission - top center overview
    8: "aboveBottom",
    // Construction button - above controls
    9: "rightOfPanel",
    // Station button - panel opens
    10: "upperRight",
    // Place station 1 - map interaction
    11: "upperRight",
    // Place station 2 - map interaction
    12: "upperRight",
    // Place station 3 - map interaction
    13: "rightOfPanel",
    // Track Builder - panel button
    14: "upperRight",
    // Connect First Pair - map work
    15: "upperRight",
    // Connect Second Pair - map work
    16: "upperRight",
    // Scissors Crossover - map work
    17: "rightOfPanel",
    // Build blueprint - panel button
    18: "aboveBottom",
    // Routes button - bottom controls
    19: "rightOfPanel",
    // New Line - panel opens
    20: "rightOfPanel",
    // Pick a Color - panel interaction
    21: "rightOfPanel",
    // Create It! - panel button
    22: "rightOfPanel",
    // Configure Route - panel list
    23: "rightOfPanel",
    // Edit Mode - panel button
    24: "upperRight",
    // Define the Path - map clicking
    25: "rightOfPanel",
    // Save Route - panel button
    26: "rightOfPanel",
    // Train Time! - panel tab
    27: "rightOfPanel",
    // Deploy Trains - panel controls
    28: "rightOfPanel",
    // Play button - bottom controls
    29: "center"
    // Complete - celebration
  },
  // Floating UI placement preferences
  floatingPlacements: {
    3: "top",
    // Statistics button
    4: "right",
    // Demand dropdown
    8: "top",
    // Construction button
    9: "right",
    // Station button
    13: "right",
    // Track button
    17: "right",
    // Build blueprint
    18: "top",
    // Routes button
    19: "right",
    // New route button
    20: "right",
    // Color selector
    21: "right",
    // Create route
    22: "right",
    // Route icon
    23: "right",
    // Edit route
    25: "right",
    // Save route
    26: "right",
    // Trains tab
    27: "right",
    // Play button
    28: "right"
    // Add trains
  }
};
function TutorialOverlay({ steps }) {
  const { tutorial, nextStep, previousStep, endTutorial } = useTutorial();
  const tracks = useTracks();
  const trackGroups = useTrackGroups();
  const previewRoute = usePreviewRoute();
  const [isStuck, setIsStuck] = reactExports.useState(false);
  const { currentNavigationState } = useUi();
  const arrowRef = reactExports.useRef(null);
  const synthRef = reactExports.useRef(null);
  const cardRef = reactExports.useRef(null);
  const [cardPosition, setCardPosition] = reactExports.useState(null);
  const [navigatedBackwards, setNavigatedBackwards] = reactExports.useState(false);
  const stations = useStations();
  const routes = useRoutes();
  const trains = useTrains();
  const timeConfig = useTimeConfig();
  const { selectedActionCategory, userAction } = useUi();
  const currentStepData = steps[tutorial.currentStep - 1] || null;
  const isFirstStep = tutorial.currentStep === 1;
  const isLastStep = tutorial.currentStep === tutorial.totalSteps;
  const { position: targetPosition, element: targetElement } = useElementTracker(
    currentStepData?.highlightSelector || null
  );
  const shouldUseFixedPosition = currentStepData?.highlightSelector && POSITIONING_CONFIG.fixedPositionSelectors.some(
    (selector) => currentStepData.highlightSelector === selector || currentStepData.highlightSelector?.includes(selector)
  );
  const useFloatingPosition = targetElement && currentStepData?.highlightSelector && !shouldUseFixedPosition && !currentStepData?.putInTopRight;
  const getFloatingPlacement = () => {
    const placement = POSITIONING_CONFIG.floatingPlacements[tutorial.currentStep];
    return placement || "top";
  };
  const { refs, floatingStyles, context } = useFloating({
    open: tutorial.isActive && !!useFloatingPosition,
    placement: getFloatingPlacement(),
    middleware: [
      offset(16),
      flip({
        fallbackPlacements: ["top", "bottom", "left", "right"],
        boundary: document.body
      }),
      shift({
        padding: 40,
        // Increased padding to ensure card never clips edges
        boundary: document.body,
        crossAxis: true
        // Also shift along cross axis if needed
      }),
      arrow({ element: arrowRef })
    ],
    whileElementsMounted: autoUpdate
  });
  reactExports.useEffect(() => {
    if (targetElement) {
      refs.setReference(targetElement);
    }
  }, [targetElement, refs]);
  reactExports.useEffect(() => {
    if (!cardRef.current || useFloatingPosition) {
      setCardPosition(null);
      return;
    }
    const updateCardPosition = () => {
      if (!cardRef.current) return;
      const rect = cardRef.current.getBoundingClientRect();
      setCardPosition({
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      });
    };
    updateCardPosition();
    window.addEventListener("resize", updateCardPosition);
    window.addEventListener("scroll", updateCardPosition, true);
    return () => {
      window.removeEventListener("resize", updateCardPosition);
      window.removeEventListener("scroll", updateCardPosition, true);
    };
  }, [tutorial.currentStep, useFloatingPosition]);
  reactExports.useEffect(() => {
    if (!tutorial.isActive) return;
    const handleKeyDown = (e) => {
      if (e.key === "Escape" && e.shiftKey) {
        endTutorial();
        localStorage.setItem("tutorialDismissed", "true");
      } else if (e.key === "Escape") {
        endTutorial();
        localStorage.setItem("tutorialDismissed", "true");
        toast({
          title: "Tutorial Exited",
          description: "Hit the esc key and click the tutorial button to restart anytime",
          duration: 2e3
        });
      } else if (e.key === "ArrowRight" || e.key === " ") {
        setNavigatedBackwards(false);
        if (tutorial.currentStep === tutorial.totalSteps) {
          localStorage.setItem("tutorialCompleted", "true");
          endTutorial();
        } else {
          nextStep();
        }
      } else if (e.key === "ArrowLeft" && tutorial.currentStep > 1) {
        setNavigatedBackwards(true);
        previousStep();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [tutorial.isActive, tutorial.currentStep, tutorial.totalSteps, endTutorial, previousStep, nextStep]);
  reactExports.useEffect(() => {
    if (!tutorial.isActive) return;
    if (tutorial.currentStep === 3) {
      const handleStatisticsClick = (e) => {
        const target = e.target;
        const statisticsButton = target.closest('[data-tutorial="statistics-button"]');
        if (statisticsButton) {
          setTimeout(() => {
            const dropdownOpen = statisticsButton.getAttribute("aria-expanded") === "true";
            if (dropdownOpen) {
              nextStep();
            }
          }, 100);
        }
      };
      document.addEventListener("click", handleStatisticsClick);
      return () => document.removeEventListener("click", handleStatisticsClick);
    }
    if (tutorial.currentStep === 4) {
      const handleDemandStatsClick = (e) => {
        const target = e.target;
        const demandStatsItem = target.closest('[data-tutorial="demand-stats-button"]');
        if (demandStatsItem) {
          nextStep();
        }
      };
      document.addEventListener("click", handleDemandStatsClick);
      return () => document.removeEventListener("click", handleDemandStatsClick);
    }
  }, [tutorial.isActive, tutorial.currentStep, nextStep]);
  reactExports.useEffect(() => {
    if (!tutorial.isActive) return;
    setIsStuck(false);
    const stuckTimer = setTimeout(() => {
      setIsStuck(true);
      toast({
        title: "Need help?",
        description: "Press ESC to exit or use arrow keys to navigate",
        duration: 5e3
      });
    }, STUCK_HELP_DELAY);
    return () => {
      clearTimeout(stuckTimer);
    };
  }, [tutorial.currentStep, tutorial.isActive]);
  const [unlockedAchievements, setUnlockedAchievements] = reactExports.useState(/* @__PURE__ */ new Set());
  reactExports.useEffect(() => {
    if (!tutorial.isActive) return;
    const checkAchievement = (id, condition, title) => {
      if (condition && !unlockedAchievements.has(id)) {
        setUnlockedAchievements((prev) => /* @__PURE__ */ new Set([...prev, id]));
        toast({
          title: "Achievement Unlocked",
          description: title,
          duration: 3e3
        });
      }
    };
    checkAchievement("first-station", stations.length >= 1, "First Station Built!");
    checkAchievement("three-stations", stations.length >= 3, "Station Network!");
    checkAchievement("first-route", routes.length >= 1, "Route Created!");
    checkAchievement("first-train", trains.length >= 1, "First Train Deployed!");
    checkAchievement("infrastructure", stations.length >= 3 && routes.length >= 1, "Infrastructure Complete!");
    checkAchievement(
      "tutorial-complete",
      stations.length >= 3 && routes.length >= 1 && trains.length >= 1,
      "Metro Master! You've built a working transit system!"
    );
  }, [tutorial.isActive, stations.length, routes.length, trains.length, unlockedAchievements]);
  reactExports.useEffect(() => {
    const initSynth = async () => {
      if (!synthRef.current) {
        await start();
        synthRef.current = new PolySynth(Synth, {
          oscillator: { type: "sine" },
          envelope: {
            attack: 0.02,
            decay: 0.3,
            sustain: 0.4,
            release: 1.2
          }
        }).toDestination();
        synthRef.current.volume.value = -15;
      }
    };
    initSynth();
    return () => {
      if (synthRef.current) {
        synthRef.current.dispose();
        synthRef.current = null;
      }
    };
  }, []);
  const playStepChime = (step) => {
    if (!synthRef.current) return;
    const patterns = [
      [60, 64],
      // C4, E4
      [62, 65],
      // D4, F4
      [64, 67],
      // E4, G4
      [65, 69],
      // F4, A4
      [67, 71],
      // G4, B4
      [69, 72],
      // A4, C5 (highest we go)
      [67, 72],
      // G4, C5
      [60, 67]
      // C4, G4 (perfect fifth)
    ];
    const pattern = patterns[(step - 1) % patterns.length];
    const notes = pattern.map((midi) => Frequency(midi, "midi").toNote());
    const now$1 = now();
    notes.forEach((note, i) => {
      synthRef.current?.triggerAttackRelease(note, "0.3", now$1 + i * 0.15);
    });
  };
  reactExports.useEffect(() => {
    if (!tutorial.isActive || !currentStepData) return;
    playStepChime(tutorial.currentStep);
    if (currentStepData.isCritical) {
      toast({
        title: "CRITICAL STEP",
        description: "Don't skip this!",
        duration: 5e3
      });
      if (synthRef.current) {
        synthRef.current.triggerAttackRelease(["F#4", "C5"], "0.4");
      }
    }
    if (currentStepData.isComplete && synthRef.current) {
      const now$1 = now();
      ["C4", "E4", "G4", "C5", "E5", "G5"].forEach((note, i) => {
        synthRef.current?.triggerAttackRelease(note, "0.8", now$1 + i * 0.1);
      });
    }
  }, [tutorial.currentStep, tutorial.isActive, currentStepData]);
  const getStepCompletion = (stepIndex) => {
    const stepNum = stepIndex + 1;
    if (tutorial.currentStep > stepNum) return { completed: true, hasVerification: false };
    switch (stepNum) {
      case 1:
        return { completed: true, hasVerification: false };
      case 2:
        return { completed: true, hasVerification: false };
      case 3: {
        const statisticsButton = document.querySelector('[data-tutorial="statistics-button"]');
        const dropdownOpen = statisticsButton?.getAttribute("aria-expanded") === "true";
        const completed = selectedActionCategory?.labelKey === "navigation.statistics" || dropdownOpen;
        return { completed, hasVerification: true };
      }
      case 4:
        return {
          completed: selectedActionCategory?.labelKey === "navigation.demandStats",
          hasVerification: true
        };
      case 5:
        return { completed: true, hasVerification: false };
      case 6:
        return { completed: currentNavigationState?.view === "jobs", hasVerification: true };
      case 7:
        return { completed: true, hasVerification: false };
      case 8:
        return {
          completed: selectedActionCategory?.labelKey === "navigation.construction",
          hasVerification: true
        };
      case 9:
        return { completed: userAction.includes("station"), hasVerification: true };
      case 10:
        return { completed: stations.length >= 1, hasVerification: true };
      case 11:
        return { completed: stations.length >= 2, hasVerification: true };
      case 12:
        return { completed: stations.length >= 3, hasVerification: true };
      case 13:
        return { completed: userAction.includes("track"), hasVerification: true };
      case 14:
        return { completed: true, hasVerification: false };
      case 15:
        return { completed: true, hasVerification: false };
      // Scissors Crossover - completed when two scissors crossover exists
      case 16: {
        const scissorsCrossovers = trackGroups.filter((tg) => tg.type === "scissors-crossover");
        return { completed: scissorsCrossovers.length >= 2, hasVerification: true };
      }
      // BUILD BLUEPRINT - This is critical, don't auto-advance
      case 17: {
        const builtTracks = tracks.filter((track) => track.buildType === "constructed");
        return { completed: builtTracks.length > 0, hasVerification: true };
      }
      case 18:
        return { completed: selectedActionCategory?.labelKey === "navigation.routes", hasVerification: true };
      case 19:
        return { completed: true, hasVerification: false };
      case 20:
        return { completed: true, hasVerification: false };
      case 21:
        return { completed: routes.length > 0, hasVerification: true };
      case 22:
        return { completed: currentNavigationState?.type === "route-details", hasVerification: true };
      case 23:
        return { completed: userAction === "draw-line-track", hasVerification: true };
      // Define the path - completed when path is defined
      case 24: {
        const pathDefined = previewRoute?.stNodes.length === 5;
        return { completed: pathDefined, hasVerification: true };
      }
      // Save Route - completed when route is saved
      case 25: {
        const routeSaved = routes.some((route) => route.stNodes.length > 0);
        return { completed: routeSaved, hasVerification: true };
      }
      // Train Time! - don't auto-advance through tab changes
      case 26: {
        const trainsTabSelected = currentNavigationState?.view === "trains";
        return { completed: trainsTabSelected, hasVerification: true };
      }
      // Deploy Trains - completed when trains exist
      case 27: {
        const meetsCriteria = routes.some(
          (routes2) => routes2.trainSchedule && routes2.trainSchedule.highDemand === 2 && routes2.trainSchedule.mediumDemand === 1 && routes2.trainSchedule.lowDemand === 1
        );
        return { completed: meetsCriteria, hasVerification: true };
      }
      // Play button - completed when play button is clicked
      case 28: {
        const playButtonClicked = timeConfig.paused === false;
        return { completed: playButtonClicked, hasVerification: true };
      }
      case 29:
        return {
          completed: trains.length > 0 && routes.length > 0 && stations.length >= 3,
          hasVerification: true
        };
      default:
        return { completed: true, hasVerification: false };
    }
  };
  const handleNext = () => {
    setNavigatedBackwards(false);
    if (isLastStep) {
      localStorage.setItem("tutorialCompleted", "true");
      endTutorial();
    } else {
      nextStep();
    }
  };
  const stepCompletionInfo = getStepCompletion(tutorial.currentStep - 1);
  const currentStepCompleted = stepCompletionInfo.completed;
  reactExports.useEffect(() => {
    if (!tutorial.isActive || !currentStepCompleted) return;
    const shouldAutoAdvance = [3, 4, 8, 9, 10, 11, 12, 13, 18, 22, 23, 27].includes(tutorial.currentStep);
    if (!shouldAutoAdvance && !navigatedBackwards) return;
    const timer = setTimeout(() => {
      if (navigatedBackwards) return;
      nextStep();
      toast({
        title: "Step completed",
        description: "Moving to next step...",
        duration: 5e3
      });
    }, AUTO_ADVANCE_DELAY);
    return () => clearTimeout(timer);
  }, [
    currentStepCompleted,
    tutorial.isActive,
    tutorial.currentStep,
    tutorial.totalSteps,
    nextStep,
    navigatedBackwards
  ]);
  const getFallbackPosition = () => {
    if (currentStepData?.putInTopRight) {
      return POSITIONING_CONFIG.fallbackPositions.topRight;
    }
    const positionKey = POSITIONING_CONFIG.stepPositions[tutorial.currentStep];
    return POSITIONING_CONFIG.fallbackPositions[positionKey] || POSITIONING_CONFIG.fallbackPositions.topRight;
  };
  const shouldShowPointer = () => {
    return !!(targetPosition && cardPosition && !useFloatingPosition && currentStepData?.highlightSelector);
  };
  if (!tutorial.isActive || tutorial.currentStep === 0 || !currentStepData) {
    return null;
  }
  const renderFloatingArrow = () => {
    if (!targetElement || !currentStepData?.highlightSelector) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingArrow, { ref: arrowRef, context, className: "fill-border drop-shadow", width: 16, height: 8 });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    shouldShowPointer() && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TutorialPointer,
      {
        from: cardPosition,
        to: {
          x: targetPosition.x + targetPosition.width / 2,
          y: targetPosition.y + targetPosition.height / 2
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: (el) => {
          refs.setFloating(el);
          cardRef.current = el;
        },
        className: useFloatingPosition ? "" : getFallbackPosition(),
        style: useFloatingPosition ? {
          ...floatingStyles,
          zIndex: 51,
          // Above the pointer
          transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)"
        } : {},
        role: "dialog",
        "aria-label": "Tutorial step",
        "aria-describedby": "tutorial-content",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Card,
          {
            className: `w-72 sm:w-80 max-w-[calc(100vw-3rem)] relative transition-all shadow-xl ${currentStepData.isCritical ? "border-red-500 border-2 animate-pulse ring-4 ring-red-500/20" : currentStepData.isComplete ? "border-green-500 border-2 ring-4 ring-green-500/20" : currentStepData.achievement ? "border-yellow-500 border-2 ring-4 ring-yellow-500/20" : "border-border"} bg-background/95 backdrop-blur-md`,
            children: [
              renderFloatingArrow(),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { className: "flex flex-row items-center justify-between space-y-0 py-2 px-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-sm font-semibold", children: currentStepData.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "span",
                    {
                      className: "text-xs text-muted-foreground mr-2",
                      "aria-label": `Step ${tutorial.currentStep} of ${tutorial.totalSteps}`,
                      children: [
                        tutorial.currentStep,
                        "/",
                        tutorial.totalSteps
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "ghost",
                      size: "icon",
                      onClick: () => {
                        endTutorial();
                        localStorage.setItem("tutorialDismissed", "true");
                        toast({
                          title: "Tutorial Exited",
                          description: "Click tutorial button to restart",
                          duration: 2e3
                        });
                      },
                      className: "h-5 w-5 hover:bg-red-100 dark:hover:bg-red-900/20",
                      title: "Exit tutorial (ESC)",
                      "aria-label": "Exit tutorial",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(X$1, { className: "h-3 w-3" })
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { className: "px-3 py-2", children: [
                currentStepCompleted && stepCompletionInfo.hasVerification && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 mb-2 text-xs text-green-600 dark:text-green-400", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-3 w-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Completed - continue →" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { id: "tutorial-content", className: "text-xs leading-relaxed text-foreground/80 mb-2", children: currentStepData.content }),
                currentStepData.hint && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground italic pl-2 border-l-2 border-blue-500/30", children: currentStepData.hint }),
                isStuck && !currentStepCompleted && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 mt-2 p-2 bg-orange-50/50 dark:bg-orange-900/10 rounded border border-orange-200/50 dark:border-orange-800/50", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      size: "sm",
                      variant: "ghost",
                      onClick: () => {
                        nextStep();
                        setIsStuck(false);
                      },
                      className: "text-xs h-6 px-2",
                      children: "Skip →"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-orange-600 dark:text-orange-400 my-auto", children: "Stuck? Press ESC to exit" })
                ] }),
                currentStepData.achievement && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center gap-1 mt-2 px-2 py-1 bg-yellow-100/50 dark:bg-yellow-900/20 rounded text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium text-yellow-700 dark:text-yellow-300", children: [
                  "Achievement: ",
                  currentStepData.achievement
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-1 bg-muted rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "h-full bg-blue-500 transition-all duration-300",
                    style: { width: `${tutorial.currentStep / tutorial.totalSteps * 100}%` }
                  }
                ) }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CardFooter, { className: "px-3 py-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Button,
                  {
                    variant: "ghost",
                    size: "sm",
                    onClick: () => {
                      setNavigatedBackwards(true);
                      previousStep();
                    },
                    disabled: isFirstStep,
                    className: "h-7 px-2",
                    "aria-label": "Previous step",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, { className: "h-3 w-3" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs ml-1", children: "Back" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("kbd", { className: "px-1 py-0.5 bg-muted rounded text-[10px]", children: "ESC" }),
                  " to exit"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Button,
                  {
                    size: "sm",
                    onClick: handleNext,
                    disabled: !currentStepCompleted && !isFirstStep && !isLastStep && !currentStepData.isIntro,
                    variant: currentStepCompleted ? "default" : "ghost",
                    className: "h-7 px-2",
                    "aria-label": isLastStep ? "Complete tutorial" : "Next step",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs mr-1", children: isLastStep ? "Done" : "Next" }),
                      !isLastStep && /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "h-3 w-3" })
                    ]
                  }
                )
              ] }) })
            ]
          }
        )
      }
    )
  ] });
}
function useTutorialSteps() {
  const { t } = useTranslation("tutorial");
  return [
    {
      title: t("steps.0.title"),
      content: t("steps.0.content"),
      isIntro: true
    },
    {
      title: t("steps.1.title"),
      content: t("steps.1.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.1.hint")
    },
    {
      title: t("steps.2.title"),
      content: t("steps.2.content"),
      highlightSelector: '[data-tutorial="statistics-button"]',
      hint: t("steps.2.hint")
    },
    {
      title: t("steps.3.title"),
      content: t("steps.3.content"),
      highlightSelector: '[data-tutorial="demand-stats-button"]'
    },
    {
      title: t("steps.4.title"),
      content: t("steps.4.content"),
      highlightSelector: '[data-tutorial="homes-toggle"]',
      hint: t("steps.4.hint")
    },
    {
      title: t("steps.5.title"),
      content: t("steps.5.content"),
      highlightSelector: '[data-tutorial="jobs-toggle"]',
      hint: t("steps.5.hint")
    },
    {
      title: t("steps.6.title"),
      content: t("steps.6.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.6.hint")
    },
    {
      title: t("steps.7.title"),
      content: t("steps.7.content"),
      highlightSelector: '[data-tutorial="construction-button"]'
    },
    {
      title: t("steps.8.title"),
      content: t("steps.8.content"),
      highlightSelector: '[data-tutorial="station-button"]'
    },
    {
      title: t("steps.9.title"),
      content: t("steps.9.content"),
      highlightSelector: ".maplibregl-canvas"
    },
    {
      title: t("steps.10.title"),
      content: t("steps.10.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.10.hint")
    },
    {
      title: t("steps.11.title"),
      content: t("steps.11.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.11.hint")
    },
    {
      title: t("steps.12.title"),
      content: t("steps.12.content"),
      highlightSelector: '[data-tutorial="tracks-button"]'
    },
    {
      title: t("steps.13.title"),
      content: t("steps.13.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.13.hint")
    },
    {
      title: t("steps.14.title"),
      content: t("steps.14.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.14.hint")
    },
    {
      title: t("steps.15.title"),
      content: t("steps.15.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.15.hint")
    },
    {
      title: t("steps.16.title"),
      content: t("steps.16.content"),
      highlightSelector: '[data-tutorial="build-blueprint-button"]',
      isCritical: true,
      putInTopRight: true
    },
    {
      title: t("steps.17.title"),
      content: t("steps.17.content"),
      highlightSelector: '[data-tutorial="routes-button"]',
      hint: t("steps.17.hint"),
      putInTopRight: true
    },
    {
      title: t("steps.18.title"),
      content: t("steps.18.content"),
      highlightSelector: '[data-tutorial="make-new-route-button"]',
      putInTopRight: true
    },
    {
      title: t("steps.19.title"),
      content: t("steps.19.content"),
      highlightSelector: '[data-tutorial="route-color-selector"]',
      hint: t("steps.19.hint"),
      putInTopRight: true
    },
    {
      title: t("steps.20.title"),
      content: t("steps.20.content"),
      highlightSelector: '[data-tutorial="create-route-button"]',
      putInTopRight: true
    },
    {
      title: t("steps.21.title"),
      content: t("steps.21.content"),
      highlightSelector: '[data-tutorial="route-icon"]',
      putInTopRight: true
    },
    {
      title: t("steps.22.title"),
      content: t("steps.22.content"),
      highlightSelector: '[data-tutorial="edit-route-button"]',
      putInTopRight: true
    },
    {
      title: t("steps.23.title"),
      content: t("steps.23.content"),
      highlightSelector: ".maplibregl-canvas",
      hint: t("steps.23.hint"),
      putInTopRight: true
    },
    {
      title: t("steps.24.title"),
      content: t("steps.24.content"),
      highlightSelector: '[data-tutorial="confirm-route-button"]',
      putInTopRight: true
    },
    {
      title: t("steps.25.title"),
      content: t("steps.25.content"),
      highlightSelector: '[data-tutorial="trains-tab"]',
      hint: t("steps.25.hint"),
      putInTopRight: true
    },
    {
      title: t("steps.26.title"),
      content: t("steps.26.content"),
      highlightSelector: '[data-tutorial="add-train-button"]',
      putInTopRight: true
    },
    {
      title: t("steps.27.title"),
      content: t("steps.27.content"),
      highlightSelector: '[data-tutorial="play-button"]',
      putInTopRight: true
    },
    {
      title: t("steps.28.title"),
      content: t("steps.28.content"),
      isComplete: true,
      putInTopRight: true
    }
  ];
}
function Tutorial() {
  const { t } = useTranslation("common");
  const tutorialSteps = useTutorialSteps();
  const { tutorial, startTutorial } = useTutorial();
  const [hasCompletedBefore, setHasCompletedBefore] = reactExports.useState(true);
  const [hasAutoStarted, setHasAutoStarted] = reactExports.useState(false);
  const cityCode = useCityCode();
  reactExports.useEffect(() => {
    const completed = localStorage.getItem("tutorialCompleted") === "true";
    const dismissed = localStorage.getItem("tutorialDismissed") === "true";
    setHasCompletedBefore(completed || dismissed);
    const tutorialShownForCity = localStorage.getItem(`tutorial-shown`) === "true";
    if (!completed && !dismissed && !tutorialShownForCity && cityCode && !tutorial.isActive && !hasAutoStarted) {
      setHasAutoStarted(true);
      localStorage.setItem(`tutorial-shown`, "true");
      const autoStartTimer = setTimeout(() => {
        startTutorial(tutorialSteps.length);
      }, 2e3);
      return () => clearTimeout(autoStartTimer);
    }
  }, [tutorial.isActive, startTutorial, hasAutoStarted, cityCode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !tutorial.isActive && !hasCompletedBefore && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => {
          localStorage.removeItem("tutorialDismissed");
          startTutorial(tutorialSteps.length);
        },
        className: "fixed top-2 left-1/2 -translate-x-1/2 z-50 px-4 py-2 bg-primary text-primary-foreground rounded-md shadow-lg hover:bg-primary/90 transition-colors flex items-center gap-2 text-sm font-medium",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(GraduationCap, {}),
          t("menu.startTutorial")
        ]
      }
    ),
    tutorial.isActive && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed top-0 left-0 right-0 z-50 h-1 bg-muted/50", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "h-full bg-gradient-to-r from-blue-500 to-blue-600 transition-all duration-500 ease-out shadow-lg shadow-blue-500/50",
        style: { width: `${tutorial.currentStep / tutorial.totalSteps * 100}%` }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TutorialOverlay, { steps: tutorialSteps }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TutorialHighlight, { steps: tutorialSteps })
  ] });
}
function assert$7(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "loader assertion failed.");
  }
}
const isBrowser$2 = (
  // @ts-ignore process does not exist on browser
  Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
);
const matches$1 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
matches$1 && parseFloat(matches$1[1]) || 0;
const window_$1 = globalThis;
const process_ = globalThis.process || {};
const navigator_ = globalThis.navigator || {};
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && window.process?.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
  const userAgent2 = realUserAgent;
  return Boolean(userAgent2 && userAgent2.indexOf("Electron") >= 0);
}
function isBrowser$1() {
  const isNode = (
    // @ts-expect-error
    typeof process === "object" && String(process) === "[object process]" && !process?.browser
  );
  return !isNode || isElectron();
}
function getBrowser(mockUserAgent) {
  if (!isBrowser$1()) {
    return "Node";
  }
  if (isElectron()) {
    return "Electron";
  }
  const userAgent2 = navigator_.userAgent || "";
  if (userAgent2.indexOf("Edge") > -1) {
    return "Edge";
  }
  if (globalThis.chrome) {
    return "Chrome";
  }
  if (globalThis.safari) {
    return "Safari";
  }
  if (globalThis.mozInnerScreenX) {
    return "Firefox";
  }
  return "Unknown";
}
const VERSION$5 = "4.0.7";
function getStorage(type) {
  try {
    const storage = window[type];
    const x2 = "__storage_test__";
    storage.setItem(x2, x2);
    storage.removeItem(x2);
    return storage;
  } catch (e) {
    return null;
  }
}
class LocalStorage {
  constructor(id, defaultConfig, type = "sessionStorage") {
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
}
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = `${ms.toFixed(2)}ms`;
  } else if (ms < 100) {
    formatted = `${ms.toFixed(1)}ms`;
  } else if (ms < 1e3) {
    formatted = `${ms.toFixed(0)}ms`;
  } else {
    formatted = `${(ms / 1e3).toFixed(2)}s`;
  }
  return formatted;
}
function leftPad(string2, length = 8) {
  const padLength = Math.max(length - string2.length, 0);
  return `${" ".repeat(padLength)}${string2}`;
}
var COLOR;
(function(COLOR2) {
  COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
  COLOR2[COLOR2["RED"] = 31] = "RED";
  COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
  COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
  COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
  COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
  COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
  COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
  COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
const BACKGROUND_INCREMENT = 10;
function getColor$2(color2) {
  if (typeof color2 !== "string") {
    return color2;
  }
  color2 = color2.toUpperCase();
  return COLOR[color2] || COLOR.WHITE;
}
function addColor(string2, color2, background) {
  if (!isBrowser$1 && typeof string2 === "string") {
    if (color2) {
      const colorCode = getColor$2(color2);
      string2 = `\x1B[${colorCode}m${string2}\x1B[39m`;
    }
    if (background) {
      const colorCode = getColor$2(background);
      string2 = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string2}\x1B[49m`;
    }
  }
  return string2;
}
function autobind(obj, predefined = ["constructor"]) {
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object2 = obj;
  for (const key of propNames) {
    const value = object2[key];
    if (typeof value === "function") {
      if (!predefined.find((name2) => key === name2)) {
        object2[key] = value.bind(obj);
      }
    }
  }
}
function assert$6(condition, message2) {
  if (!condition) {
    throw new Error("Assertion failed");
  }
}
function getHiResTimestamp$1() {
  let timestamp;
  if (isBrowser$1() && window_$1.performance) {
    timestamp = window_$1?.performance?.now?.();
  } else if ("hrtime" in process_) {
    const timeParts = process_?.hrtime?.();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
const originalConsole = {
  debug: isBrowser$1() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop$3() {
}
const cache$1 = {};
const ONCE = { once: true };
class Log {
  constructor({ id } = { id: "" }) {
    this.VERSION = VERSION$5;
    this._startTs = getHiResTimestamp$1();
    this._deltaTs = getHiResTimestamp$1();
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
    this.timeStamp(`${this.id} started`);
    autobind(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((getHiResTimestamp$1() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((getHiResTimestamp$1() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(newPriority) {
    this.level = newPriority;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(enabled = true) {
    this._storage.setConfiguration({ enabled });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({ level });
    return this;
  }
  /** return the current status of the setting */
  get(setting) {
    return this._storage.config[setting];
  }
  // update the status of the setting
  set(setting, value) {
    this._storage.setConfiguration({ [setting]: value });
  }
  /** Logs the current settings as a table */
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  // Unconditional logging
  assert(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }
  warn(message2) {
    return this._getLogFunction(0, message2, originalConsole.warn, arguments, ONCE);
  }
  error(message2) {
    return this._getLogFunction(0, message2, originalConsole.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(oldUsage, newUsage) {
    return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
  }
  /** Print a removal warning */
  removed(oldUsage, newUsage) {
    return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
  }
  probe(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.debug, arguments);
  }
  info(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.info, arguments);
  }
  once(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  /** Logs an object as a table */
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop$3, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop$3;
  }
  time(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.timeStamp || noop$3);
  }
  group(logLevel, message2, opts = { collapsed: false }) {
    const options = normalizeArguments({ logLevel, message: message2, opts });
    const { collapsed } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message2, opts = {}) {
    return this.group(logLevel, message2, Object.assign({}, opts, { collapsed: true }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop$3);
  }
  // EXPERIMENTAL
  withGroup(logLevel, message2, func) {
    this.group(logLevel, message2)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message2, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({ logLevel, message: message2, args, opts });
      method = method || opts.method;
      assert$6(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp$1();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache$1[tag]) {
          cache$1[tag] = getHiResTimestamp$1();
        } else {
          return noop$3;
        }
      }
      message2 = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message2, ...opts.args);
    }
    return noop$3;
  }
}
Log.VERSION = VERSION$5;
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert$6(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const { logLevel, message: message2 } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message2) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message2 !== void 0) {
        args.unshift(message2);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert$6(messageType === "string" || messageType === "object");
  return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message2, opts) {
  if (typeof message2 === "string") {
    const time2 = opts.time ? leftPad(formatTime(opts.total)) : "";
    message2 = opts.time ? `${id}: ${time2}  ${message2}` : `${id}: ${message2}`;
    message2 = addColor(message2, opts.color, opts.background);
  }
  return message2;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}
const VERSION$4 = "4.3.2";
const version = VERSION$4[0] >= "0" && VERSION$4[0] <= "9" ? `v${VERSION$4}` : "";
function createLog() {
  const log3 = new Log({ id: "loaders.gl" });
  globalThis.loaders = globalThis.loaders || {};
  globalThis.loaders.log = log3;
  globalThis.loaders.version = version;
  globalThis.probe = globalThis.probe || {};
  globalThis.probe.loaders = log3;
  return log3;
}
const log$1 = createLog();
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
  if (level > 3) {
    return newOptions;
  }
  const options = { ...baseOptions };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}
const NPM_TAG = "latest";
function getVersion() {
  if (!globalThis._loadersgl_?.version) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    {
      globalThis._loadersgl_.version = "4.3.2";
    }
  }
  return globalThis._loadersgl_.version;
}
const VERSION$3 = getVersion();
function assert$5(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "loaders.gl assertion failed.");
  }
}
const isBrowser = (
  // @ts-ignore process.browser
  typeof process !== "object" || String(process) !== "[object process]" || process.browser
);
const isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
const matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
matches && parseFloat(matches[1]) || 0;
class WorkerJob {
  name;
  workerThread;
  isRunning = true;
  /** Promise that resolves when Job is done */
  result;
  _resolve = () => {
  };
  _reject = () => {
  };
  constructor(jobName, workerThread) {
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type,
      payload
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(value) {
    assert$5(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(error) {
    assert$5(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
}
class NodeWorker {
  terminate() {
  }
}
const workerURLCache = /* @__PURE__ */ new Map();
function getLoadableWorkerURL(props) {
  assert$5(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert$5(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function getTransferList(object2, recursive = true, transfers) {
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object2) ;
  else if (isTransferable(object2)) {
    transfersSet.add(object2);
  } else if (isTransferable(object2.buffer)) {
    transfersSet.add(object2.buffer);
  } else if (ArrayBuffer.isView(object2)) ;
  else if (recursive && typeof object2 === "object") {
    for (const key in object2) {
      getTransferList(object2[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object2) {
  if (!object2) {
    return false;
  }
  if (object2 instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object2 instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object2 instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object2 instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
const NOOP = () => {
};
class WorkerThread {
  name;
  source;
  url;
  terminated = false;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser || typeof NodeWorker !== "undefined" && !isBrowser;
  }
  constructor(props) {
    const { name: name2, source, url } = props;
    assert$5(source || url);
    this.name = name2;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = (error) => console.log(error);
    this.worker = isBrowser ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(data, transferList) {
    transferList = transferList || getTransferList(data);
    this.worker.postMessage(data, transferList);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(event) {
    let message2 = "Failed to load ";
    message2 += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message2 += `${event.message} in `;
    }
    if (event.lineno) {
      message2 += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message2);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
    const worker = new Worker(this._loadableURL, { name: this.name });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error) => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : `./${this.url}`;
      worker = new NodeWorker(url, { eval: false });
    } else if (this.source) {
      worker = new NodeWorker(this.source, { eval: true });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data) => {
      this.onMessage(data);
    });
    worker.on("error", (error) => {
      this.onError(error);
    });
    worker.on("exit", (code) => {
    });
    return worker;
  }
}
class WorkerPool {
  name = "unnamed";
  source;
  // | Function;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {
  };
  reuseWorkers = true;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = false;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(props) {
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = { ...this.props, ...props };
    if (props.name !== void 0) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== void 0) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== void 0) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== void 0) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== void 0) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name2, onMessage2 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({ name: name2, onMessage: onMessage2, onError, onStart });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = (error) => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = (
      // Workers on Node.js prevent the process from exiting.
      // Until we figure out how to close them before exit, we always destroy them
      !isBrowser || // If the pool is destroyed, there is no reason to keep the worker around
      this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
      !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
      this.count > this._getMaxConcurrency()
    );
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name2 = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new WorkerThread({ name: name2, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const DEFAULT_PROPS$1 = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {
  }
};
class WorkerFarm {
  props;
  workerPools = /* @__PURE__ */ new Map();
  // singleton
  static _workerFarm;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(props = {}) {
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
    WorkerFarm._workerFarm.setProps(props);
    return WorkerFarm._workerFarm;
  }
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(props) {
    this.props = { ...DEFAULT_PROPS$1 };
    this.setProps(props);
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(props) {
    this.props = { ...this.props, ...props };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(options) {
    const { name: name2, source, url } = options;
    let workerPool = this.workerPools.get(name2);
    if (!workerPool) {
      workerPool = new WorkerPool({
        name: name2,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name2, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = isBrowser ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    if (isBrowser) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version2 = worker.version;
    if (version2 === "latest") {
      version2 = NPM_TAG;
    }
    const versionTag = version2 ? `@${version2}` : "";
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  assert$5(url);
  return url;
}
function validateWorkerVersion(worker, coreVersion = VERSION$3) {
  assert$5(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser && !options?._nodeWorkers) {
    return false;
  }
  return loader.worker && options?.worker;
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name2 = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({ name: name2, url });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob(
    "process-on-worker",
    // @ts-expect-error
    onMessage.bind(null, parseOnMainThread)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  job.postMessage("process", {
    // @ts-ignore
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const { id, input, options } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", { id, result });
      } catch (error) {
        const message2 = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", { id, error: message2 });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers(...sources) {
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset2 = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset2);
    offset2 += sourceArray.byteLength;
  }
  return result.buffer;
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== "undefined" && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== "undefined" && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
class Stat {
  constructor(name2, type) {
    this.sampleSize = 1;
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    this.name = name2;
    this.type = type;
    this.reset();
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    this.addCount(1);
    return this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  /** Increase count */
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Decrease count */
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(time2) {
    this._time += time2;
    this.lastTiming = time2;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Start a timer */
  timeStart() {
    this._startTime = getHiResTimestamp();
    this._timerPending = true;
    return this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime(getHiResTimestamp() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
}
class Stats {
  constructor(options) {
    this.stats = {};
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(name2, type = "count") {
    return this._getOrCreate({ name: name2, type });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const stat of Object.values(this.stats)) {
      stat.reset();
    }
    return this;
  }
  forEach(fn) {
    for (const stat of Object.values(this.stats)) {
      fn(stat);
    }
  }
  getTable() {
    const table = {};
    this.forEach((stat) => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats(stats = []) {
    stats.forEach((stat) => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    const { name: name2, type } = stat;
    let result = this.stats[name2];
    if (!result) {
      if (stat instanceof Stat) {
        result = stat;
      } else {
        result = new Stat(name2, type);
      }
      this.stats[name2] = result;
    }
    return result;
  }
}
let pathPrefix$1 = "";
const fileAliases = {};
function resolvePath(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = `${pathPrefix$1}${filename2}`;
  }
  return filename2;
}
function toArrayBuffer$1(buffer) {
  return buffer;
}
function isBuffer$1(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer(data) {
  if (isBuffer$1(data)) {
    return toArrayBuffer$1(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}
function filename(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
const isBoolean = (x2) => typeof x2 === "boolean";
const isFunction = (x2) => typeof x2 === "function";
const isObject$1 = (x2) => x2 !== null && typeof x2 === "object";
const isPureObject = (x2) => isObject$1(x2) && x2.constructor === {}.constructor;
const isIterable = (x2) => Boolean(x2) && typeof x2[Symbol.iterator] === "function";
const isAsyncIterable$1 = (x2) => x2 && typeof x2[Symbol.asyncIterator] === "function";
const isResponse = (x2) => typeof Response !== "undefined" && x2 instanceof Response || x2 && x2.arrayBuffer && x2.text && x2.json;
const isBlob = (x2) => typeof Blob !== "undefined" && x2 instanceof Blob;
const isBuffer = (x2) => x2 && typeof x2 === "object" && x2.isBuffer;
const isReadableDOMStream = (x2) => typeof ReadableStream !== "undefined" && x2 instanceof ReadableStream || isObject$1(x2) && isFunction(x2.tee) && isFunction(x2.cancel) && isFunction(x2.getReader);
const isReadableNodeStream = (x2) => isObject$1(x2) && isFunction(x2.read) && isFunction(x2.pipe) && isBoolean(x2.readable);
const isReadableStream = (x2) => isReadableDOMStream(x2) || isReadableNodeStream(x2);
class FetchError extends Error {
  constructor(message2, info) {
    super(message2);
    this.reason = info.reason;
    this.url = info.url;
    this.response = info.response;
  }
  /** A best effort reason for why the fetch failed */
  reason;
  /** The URL that failed to load. Empty string if not available. */
  url;
  /** The Response object, if any. */
  response;
}
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function compareMIMETypes(mimeType1, mimeType2) {
  if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
    return true;
  }
  return false;
}
function parseMIMEType(mimeString) {
  const matches2 = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches2) {
    return matches2[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches2 = DATA_URL_PATTERN.exec(url);
  if (matches2) {
    return matches2[1];
  }
  return "";
}
const QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches2 = url.match(QUERY_STRING_PATTERN);
  return matches2 && matches2[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}
function shortenUrlForDisplay(url) {
  if (url.length < 50) {
    return url;
  }
  const urlEnd = url.slice(url.length - 15);
  const urlStart = url.substr(0, 32);
  return `${urlStart}...${urlEnd}`;
}
function getResourceUrl(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.url;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.name || "";
  }
  if (typeof resource === "string") {
    return resource;
  }
  return "";
}
function getResourceMIMEType(resource) {
  if (isResponse(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get("content-type") || "";
    const noQueryUrl = stripQueryString(response.url);
    return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.type || "";
  }
  if (typeof resource === "string") {
    return parseMIMETypeFromURL(resource);
  }
  return "";
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const url = getResourceUrl(resource);
  const type = getResourceMIMEType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, { headers });
  Object.defineProperty(response, "url", { value: url });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const error = await getResponseError(response);
    throw error;
  }
}
async function getResponseError(response) {
  const shortUrl = shortenUrlForDisplay(response.url);
  let message2 = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
  message2 = message2.length > 100 ? `${message2.slice(0, 100)}...` : message2;
  const info = {
    reason: response.statusText,
    url: response.url,
    response
  };
  try {
    const contentType = response.headers.get("Content-Type");
    info.reason = !response.bodyUsed && contentType?.includes("application/json") ? await response.json() : await response.text();
  } catch (error) {
  }
  return new FetchError(message2, info);
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (event) => resolve(event?.target?.result);
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return `data:base64,${base64}`;
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function isNodePath(url) {
  return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
  return url.startsWith("http:") || url.startsWith("https:");
}
function isDataURL(url) {
  return url.startsWith("data:");
}
async function fetchFile(urlOrData, fetchOptions) {
  if (typeof urlOrData === "string") {
    const url = resolvePath(urlOrData);
    if (isNodePath(url)) {
      if (globalThis.loaders?.fetchNode) {
        return globalThis.loaders?.fetchNode(url, fetchOptions);
      }
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(urlOrData);
}
const probeLog = new Log({ id: "loaders.gl" });
class NullLog {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class ConsoleLog {
  console;
  constructor() {
    this.console = console;
  }
  log(...args) {
    return this.console.log.bind(this.console, ...args);
  }
  info(...args) {
    return this.console.info.bind(this.console, ...args);
  }
  warn(...args) {
    return this.console.warn.bind(this.console, ...args);
  }
  error(...args) {
    return this.console.error.bind(this.console, ...args);
  }
}
const DEFAULT_LOADER_OPTIONS = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: false,
  log: new ConsoleLog(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: false,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: true,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: isBrowser$2,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: false,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: false,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
};
const REMOVED_LOADER_OPTIONS = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders } = globalThis;
  if (!loaders._state) {
    loaders._state = {};
  }
  return loaders._state;
}
function getGlobalLoaderOptions() {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
  return state.globalOptions;
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix2 = id ? `${id}.` : "";
  for (const key in options) {
    const isSubOptions = !id && isObject$1(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn(`${loaderName} loader option '${prefix2}${key}' no longer supported, use '${deprecatedOptions[key]}'`)();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn(`${loaderName} loader option '${prefix2}${key}' not recognized. ${suggestion}`)();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return `Did you mean '${loader.id}.${key}'?`;
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || `Did you mean '${loader.id}.${key}'?`;
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = { ...loaderDefaultOptions };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}
function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray(loader?.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  assert$7(loader, "null loader");
  assert$7(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: { ...loader.options, ...options }
    };
  }
  if (loader?.parseTextSync || loader?.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}
const getGlobalLoaderRegistry = () => {
  const state = getGlobalLoaderState();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = normalizeLoader(loader);
    if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
const EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!options?.ignoreRegisteredLoaders) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  const testUrl = stripQueryString(url) || context?.url;
  let loader = null;
  let reason = "";
  if (options?.mimeType) {
    loader = findLoaderByMIMEType(loaders, options?.mimeType);
    reason = `match forced by supplied MIME type ${options?.mimeType}`;
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? `matched url ${testUrl}` : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? `matched MIME type ${type}` : "");
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : "");
  if (options?.fallbackMimeType) {
    loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
    reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
  }
  if (reason) {
    log$1.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  let message2 = "No valid loader found (";
  message2 += url ? `${filename(url)}, ` : "no url provided, ";
  message2 += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
  const firstCharacters = data ? getFirstCharacters(data) : "";
  message2 += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
  message2 += ")";
  return message2;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {
      return loader;
    }
    if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === "string") {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data);
    case "string":
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters(data, length = 5) {
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return "";
}
function getMagicString(arrayBuffer2, byteOffset, length) {
  if (arrayBuffer2.byteLength < byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer2);
  let magic = "";
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
const DEFAULT_CHUNK_SIZE$2 = 256 * 1024;
function* makeStringIterator(string2, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE$2;
  let offset2 = 0;
  const textEncoder = new TextEncoder();
  while (offset2 < string2.length) {
    const chunkLength = Math.min(string2.length - offset2, chunkSize);
    const chunk = string2.slice(offset2, offset2 + chunkLength);
    offset2 += chunkLength;
    yield textEncoder.encode(chunk);
  }
}
const DEFAULT_CHUNK_SIZE$1 = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer2, options = {}) {
  const { chunkSize = DEFAULT_CHUNK_SIZE$1 } = options;
  let byteOffset = 0;
  while (byteOffset < arrayBuffer2.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}
const DEFAULT_CHUNK_SIZE = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
  let offset2 = 0;
  while (offset2 < blob.size) {
    const end = offset2 + chunkSize;
    const chunk = await blob.slice(offset2, end).arrayBuffer();
    offset2 = end;
    yield chunk;
  }
}
function makeStreamIterator(stream, options) {
  return isBrowser$2 ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options?._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const { done, value } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield toArrayBuffer(chunk);
  }
}
function makeIterator(data, options) {
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data, options);
  }
  if (isResponse(data)) {
    const response = data;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}
const ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (isBuffer(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer2 = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer2);
    }
    return arrayBuffer2;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data);
    }
    let arrayBuffer2 = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
      arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer2;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader);
  }
  if (isBlob(data)) {
    data = await makeResponse(data);
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data)) {
    data = makeIterator(data, options);
  }
  if (isIterable(data) || isAsyncIterable$1(data)) {
    return concatenateArrayBuffersAsync(data);
  }
  throw new Error(ERR_DATA);
}
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const loaderOptions = options || globalOptions;
  if (typeof loaderOptions.fetch === "function") {
    return loaderOptions.fetch;
  }
  if (isObject$1(loaderOptions.fetch)) {
    return (url) => fetchFile(url, loaderOptions.fetch);
  }
  if (context?.fetch) {
    return context?.fetch;
  }
  return fetchFile;
}
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = stripQueryString(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = extractQueryString(newContext.url);
    newContext.filename = filename(baseUrl);
    newContext.baseUrl = dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
}
async function parse(data, loaders, options, context) {
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data = await data;
  options = options || {};
  const url = getResourceUrl(data);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext(
    // @ts-expect-error
    { url, _parse: parse, loaders: candidateLoaders },
    options,
    context || null
  );
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  validateWorkerVersion(loader);
  options = mergeLoaderOptions(loader.options, options);
  if (isResponse(data)) {
    const response = data;
    const { ok, redirected, status, statusText, type, url } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = { headers, ok, redirected, status, statusText, type, url };
  }
  data = await getArrayBufferOrStringFromData(data, loader, options);
  const loaderWithParser = loader;
  if (loaderWithParser.parseTextSync && typeof data === "string") {
    return loaderWithParser.parseTextSync(data, options, context);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data, options, context, parse);
  }
  if (loaderWithParser.parseText && typeof data === "string") {
    return await loaderWithParser.parseText(data, options, context);
  }
  if (loaderWithParser.parse) {
    return await loaderWithParser.parse(data, options, context);
  }
  assert$5(!loaderWithParser.parseSync);
  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}
async function load(url, loaders, options, context) {
  let resolvedLoaders;
  let resolvedOptions;
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    resolvedLoaders = [];
    resolvedOptions = loaders;
  } else {
    resolvedLoaders = loaders;
    resolvedOptions = options;
  }
  const fetch2 = getFetchFunction(resolvedOptions);
  let data = url;
  if (typeof url === "string") {
    data = await fetch2(url);
  }
  if (isBlob(url)) {
    data = await fetch2(url);
  }
  return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
}
const VERSION$2 = "4.3.2";
const parseImageNode = globalThis.loaders?.parseImageNode;
const IMAGE_SUPPORTED = typeof Image !== "undefined";
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
const NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
const DATA_SUPPORTED = isBrowser$2 ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function getImageType(image) {
  const format2 = getImageTypeOrNull(image);
  if (!format2) {
    throw new Error("Not an image");
  }
  return format2;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas2 = document.createElement("canvas");
      const context = canvas2.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas2.width = image.width;
      canvas2.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer2, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer2);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
    return src;
  }
  return getBlob(arrayBuffer2, url);
}
function getBlob(arrayBuffer2, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer2)]);
}
async function parseToImage(arrayBuffer2, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
  const URL2 = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL2.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = (error) => {
        const message2 = error instanceof Error ? error.message : "error";
        reject(new Error(message2));
      };
    } catch (error) {
      reject(error);
    }
  });
}
const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer2, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer2, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer2, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object2) {
  for (const key in object2 || EMPTY_OBJECT) {
    return false;
  }
  return true;
}
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, "ftyp", 4)) {
    return null;
  }
  if ((buffer[8] & 96) === 0) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
  switch (brandMajor) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function getUTF8String(array2, start2, end) {
  return String.fromCharCode(...array2.slice(start2, end));
}
function stringToBytes(string2) {
  return [...string2].map((character) => character.charCodeAt(0));
}
function checkString(buffer, header, offset2 = 0) {
  const headerBytes = stringToBytes(header);
  for (let i = 0; i < headerBytes.length; ++i) {
    if (headerBytes[i] !== buffer[i + offset2]) {
      return false;
    }
  }
  return true;
}
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = getISOBMFFMediaType(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const { tableMarkers, sofMarkers } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        // Number of lines
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
        // Number of pixels per line
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504; i < 65520; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]);
  return { tableMarkers, sofMarkers };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}
async function parseToNodeImage(arrayBuffer2, options) {
  const { mimeType } = getBinaryImageMetadata(arrayBuffer2) || {};
  const parseImageNode2 = globalThis.loaders?.parseImageNode;
  assert$7(parseImageNode2);
  return await parseImageNode2(arrayBuffer2, mimeType);
}
async function parseImage(arrayBuffer2, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const { url } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer2, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer2, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer2);
      break;
    default:
      assert$7(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}
const EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
const MIME_TYPES = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
];
const DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: "auto",
    decode: true
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
};
const ImageLoader = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: VERSION$2,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: parseImage,
  // TODO: byteOffset, byteLength;
  tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};
const defaultLogger = new Log({ id: "deck" });
let loggers = {};
function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (defaultLogger.level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
const jsonLoader = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: isJSON,
  parseTextSync: JSON.parse
};
function checkVersion() {
  const version2 = "9.0.38";
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;
  if (existingVersion && existingVersion !== version2) {
    throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version2}`);
  }
  if (!existingVersion) {
    defaultLogger.log(1, `deck.gl ${version2}`)();
    globalThis.deck = {
      ...globalThis.deck,
      VERSION: version2,
      version: version2,
      log: defaultLogger,
      // experimental
      _registerLoggers: register
    };
    registerLoaders([
      jsonLoader,
      // @ts-expect-error non-standard Loader format
      [ImageLoader, { imagebitmap: { premultiplyAlpha: "none" } }]
    ]);
  }
  return version2;
}
const VERSION$1 = checkVersion();
function assert$4(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "shadertools: assertion failed.");
  }
}
const DEFAULT_PROP_VALIDATORS = {
  number: {
    type: "number",
    validate(value, propType) {
      return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
    }
  },
  array: {
    type: "array",
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};
function makePropValidators(propTypes2) {
  const propValidators = {};
  for (const [name2, propType] of Object.entries(propTypes2)) {
    propValidators[name2] = makePropValidator(propType);
  }
  return propValidators;
}
function getValidatedProperties(properties, propValidators, errorMessage) {
  const validated = {};
  for (const [key, propsValidator] of Object.entries(propValidators)) {
    if (properties && key in properties && !propsValidator.private) {
      if (propsValidator.validate) {
        assert$4(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);
      }
      validated[key] = properties[key];
    } else {
      validated[key] = propsValidator.value;
    }
  }
  return validated;
}
function makePropValidator(propType) {
  let type = getTypeOf$1(propType);
  if (type !== "object") {
    return { value: propType, ...DEFAULT_PROP_VALIDATORS[type], type };
  }
  if (typeof propType === "object") {
    if (!propType) {
      return { type: "object", value: null };
    }
    if (propType.type !== void 0) {
      return { ...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type };
    }
    if (propType.value === void 0) {
      return { type: "object", value: propType };
    }
    type = getTypeOf$1(propType.value);
    return { ...propType, ...DEFAULT_PROP_VALIDATORS[type], type };
  }
  throw new Error("props");
}
function getTypeOf$1(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return "array";
  }
  return typeof value;
}
const MODULE_INJECTORS_VS = `#ifdef MODULE_LOGDEPTH
logdepth_adjustPosition(gl_Position);
#endif
`;
const MODULE_INJECTORS_FS = `#ifdef MODULE_MATERIAL
gl_FragColor = material_filterColor(gl_FragColor);
#endif
#ifdef MODULE_LIGHTING
gl_FragColor = lighting_filterColor(gl_FragColor);
#endif
#ifdef MODULE_FOG
gl_FragColor = fog_filterColor(gl_FragColor);
#endif
#ifdef MODULE_PICKING
gl_FragColor = picking_filterHighlightColor(gl_FragColor);
gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif
#ifdef MODULE_LOGDEPTH
logdepth_setFragDepth();
#endif
`;
const MODULE_INJECTORS = {
  vertex: MODULE_INJECTORS_VS,
  fragment: MODULE_INJECTORS_FS
};
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const fragments = [];
const DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
function normalizeInjections(injections) {
  const result = { vertex: {}, fragment: {} };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = getHookStage(hook);
    if (typeof injection === "string") {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
function getHookStage(hook) {
  const type = hook.slice(0, 2);
  switch (type) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(type);
  }
}
function injectShader(source, stage, inject, injectStandardStubs = false) {
  const isVertex = stage === "vertex";
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a2, b) => a2.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = `${fragments.join("\n")}
`;
    switch (key) {
      // declarations are injected before the main function
      case "vs:#decl":
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      default:
        source = source.replace(key, (match) => match + fragmentString);
    }
  }
  source = source.replace(DECLARATION_INJECT_MARKER, "");
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
  }
  return source;
}
let index = 1;
class ShaderModuleInstance {
  name;
  vs;
  fs;
  getModuleUniforms;
  dependencies;
  deprecations;
  defines;
  injections;
  uniforms = {};
  uniformTypes = {};
  static instantiateModules(modules) {
    return modules.map((module) => {
      if (module instanceof ShaderModuleInstance) {
        return module;
      }
      assert$4(typeof module !== "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(module)}' and use it directly.`);
      if (!module.name) {
        console.warn("shader module has no name");
        module.name = `shader-module-${index++}`;
      }
      const moduleObject = new ShaderModuleInstance(module);
      moduleObject.dependencies = ShaderModuleInstance.instantiateModules(module.dependencies || []);
      return moduleObject;
    });
  }
  constructor(props) {
    const { name: name2, vs: vs2, fs: fs2, dependencies = [], uniformTypes = {}, uniformPropTypes = {}, getUniforms: getUniforms2, deprecations = [], defines: defines2 = {}, inject = {} } = props;
    assert$4(typeof name2 === "string");
    this.name = name2;
    this.vs = vs2;
    this.fs = fs2;
    this.getModuleUniforms = getUniforms2;
    this.dependencies = ShaderModuleInstance.instantiateModules(dependencies);
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines2;
    this.injections = normalizeInjections(inject);
    this.uniformTypes = uniformTypes;
    if (uniformPropTypes) {
      this.uniforms = makePropValidators(uniformPropTypes);
    }
  }
  // Extracts the source code chunk for the specified shader type from the named shader module
  getModuleSource(stage) {
    let moduleSource;
    switch (stage) {
      case "vertex":
        moduleSource = this.vs || "";
        break;
      case "fragment":
        moduleSource = this.fs || "";
        break;
      default:
        assert$4(false);
    }
    const moduleName = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
    return `// ----- MODULE ${this.name} ---------------

#define MODULE_${moduleName}
${moduleSource}

`;
  }
  getUniforms(userProps, uniforms) {
    if (this.getModuleUniforms) {
      return this.getModuleUniforms(userProps, uniforms);
    }
    return getValidatedProperties(userProps, this.uniforms, this.name);
  }
  getDefines() {
    return this.defines;
  }
  // Warn about deprecated uniforms or functions
  checkDeprecations(shaderSource, log3) {
    this.deprecations.forEach((def) => {
      if (def.regex?.test(shaderSource)) {
        if (def.deprecated) {
          log3.deprecated(def.old, def.new)();
        } else {
          log3.removed(def.old, def.new)();
        }
      }
    });
  }
  _parseDeprecationDefinitions(deprecations) {
    deprecations.forEach((def) => {
      switch (def.type) {
        case "function":
          def.regex = new RegExp(`\\b${def.old}\\(`);
          break;
        default:
          def.regex = new RegExp(`${def.type} ${def.old};`);
      }
    });
    return deprecations;
  }
  _defaultGetUniforms(opts = {}) {
    const uniforms = {};
    const propTypes2 = this.uniforms;
    for (const key in propTypes2) {
      const propDef = propTypes2[key];
      if (key in opts && !propDef.private) {
        if (propDef.validate) {
          assert$4(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);
        }
        uniforms[key] = opts[key];
      } else {
        uniforms[key] = propDef.value;
      }
    }
    return uniforms;
  }
}
function selectShaders(props) {
  if (props.source && props.platformInfo.type === "webgpu") {
    const propsCopy = { ...props, vs: void 0, fs: void 0 };
    return propsCopy;
  }
  if (!props.vs) {
    throw new Error("no vertex shader");
  }
  const vs2 = getShaderSource(props.platformInfo, props.vs);
  let fs2;
  if (props.fs) {
    fs2 = getShaderSource(props.platformInfo, props.fs);
  }
  return { ...props, vs: vs2, fs: fs2 };
}
function getShaderSource(platformInfo, shader) {
  if (typeof shader === "string") {
    return shader;
  }
  switch (platformInfo.type) {
    case "webgpu":
      if (shader?.wgsl) {
        return shader.wgsl;
      }
      throw new Error("WebGPU does not support GLSL shaders");
    default:
      if (shader?.glsl) {
        return shader.glsl;
      }
      throw new Error("WebGL does not support WGSL shaders");
  }
}
function resolveModules(modules) {
  const instances = ShaderModuleInstance.instantiateModules(modules);
  return getShaderDependencies(instances);
}
function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({ modules, level: 0, moduleMap, moduleDepth });
  return Object.keys(moduleDepth).sort((a2, b) => moduleDepth[b] - moduleDepth[a2]).map((name2) => moduleMap[name2]);
}
function getDependencyGraph(options) {
  const { modules, level, moduleMap, moduleDepth } = options;
  if (level >= 5) {
    throw new Error("Possible loop in shader dependency graph");
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({ modules: module.dependencies, level: level + 1, moduleMap, moduleDepth });
    }
  }
}
function getPlatformShaderDefines(platformInfo) {
  switch (platformInfo?.gpu.toLowerCase()) {
    case "apple":
      return `#define APPLE_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "nvidia":
      return `#define NVIDIA_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
    case "intel":
      return `#define INTEL_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "amd":
      return `#define AMD_GPU
`;
    default:
      return `#define DEFAULT_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}
function transpileGLSLShader(source, stage) {
  const sourceGLSLVersion = Number(source.match(/^#version[ \t]+(\d+)/m)?.[1] || 100);
  if (sourceGLSLVersion !== 300) {
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  }
  switch (stage) {
    case "vertex":
      source = convertShader(source, ES300_VERTEX_REPLACEMENTS);
      return source;
    case "fragment":
      source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
      return source;
    default:
      throw new Error(stage);
  }
}
const ES300_REPLACEMENTS = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
];
const ES300_VERTEX_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `attribute` keyword replaced with `in`
  [makeVariableTextRegExp("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [makeVariableTextRegExp("varying"), "out $1"]
];
const ES300_FRAGMENT_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `varying` keyword replaced with `in`
  [makeVariableTextRegExp("varying"), "in $1"]
];
function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }
  return source;
}
function makeVariableTextRegExp(qualifier) {
  return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function getShaderHooks(hookFunctions, hookInjections) {
  let result = "";
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += `void ${hookFunction.signature} {
`;
    if (hookFunction.header) {
      result += `  ${hookFunction.header}`;
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a2, b) => a2.order - b.order);
      for (const injection of injections) {
        result += `  ${injection.injection}
`;
      }
    }
    if (hookFunction.footer) {
      result += `  ${hookFunction.footer}`;
    }
    result += "}\n";
  }
  return result;
}
function normalizeShaderHooks(hookFunctions) {
  const result = { vertex: {}, fragment: {} };
  for (const hookFunction of hookFunctions) {
    let opts;
    let hook;
    if (typeof hookFunction !== "string") {
      opts = hookFunction;
      hook = opts.hook;
    } else {
      opts = {};
      hook = hookFunction;
    }
    hook = hook.trim();
    const [shaderStage, signature] = hook.split(":");
    const name2 = hook.replace(/\(.+/, "");
    const normalizedHook = Object.assign(opts, { signature });
    switch (shaderStage) {
      case "vs":
        result.vertex[name2] = normalizedHook;
        break;
      case "fs":
        result.fragment[name2] = normalizedHook;
        break;
      default:
        throw new Error(shaderStage);
    }
  }
  return result;
}
function getShaderInfo$1(source, defaultName) {
  return {
    name: getShaderName$1(source, defaultName),
    language: "glsl",
    version: getShaderVersion$1(source)
  };
}
function getShaderName$1(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
  const match = SHADER_NAME_REGEXP.exec(shader);
  return match ? match[1] : defaultName;
}
function getShaderVersion$1(source) {
  let version2 = 100;
  const words = source.match(/[^\s]+/g);
  if (words && words.length >= 2 && words[0] === "#version") {
    const parsedVersion = parseInt(words[1], 10);
    if (Number.isFinite(parsedVersion)) {
      version2 = parsedVersion;
    }
  }
  if (version2 !== 100 && version2 !== 300) {
    throw new Error(`Invalid GLSL version ${version2}`);
  }
  return version2;
}
const INJECT_SHADER_DECLARATIONS = `

${DECLARATION_INJECT_MARKER}
`;
const FRAGMENT_SHADER_PROLOGUE = `precision highp float;
`;
function assembleShaderWGSL(options) {
  const modules = resolveModules(options.modules || []);
  return {
    source: assembleWGSLShader(options.platformInfo, {
      ...options,
      source: options.source,
      stage: "vertex",
      modules
    }),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShaderPairWGSL(options) {
  const modules = resolveModules(options.modules || []);
  return {
    vs: assembleWGSLShader(options.platformInfo, {
      ...options,
      source: options.vs,
      stage: "vertex",
      modules
    }),
    fs: assembleWGSLShader(options.platformInfo, {
      ...options,
      source: options.fs,
      stage: "fragment",
      modules
    }),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShaderPairGLSL(options) {
  const { vs: vs2, fs: fs2 } = options;
  const modules = resolveModules(options.modules || []);
  return {
    vs: assembleGLSLShader(options.platformInfo, {
      ...options,
      source: vs2,
      stage: "vertex",
      modules
    }),
    fs: assembleGLSLShader(options.platformInfo, {
      ...options,
      source: fs2,
      stage: "fragment",
      modules
    }),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleWGSLShader(platformInfo, options) {
  const {
    // id,
    source,
    stage,
    modules,
    // defines = {},
    hookFunctions = [],
    inject = {},
    log: log3
  } = options;
  assert$4(typeof source === "string", "shader source must be a string");
  const coreSource = source;
  let assembledSource = "";
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? { injection: inject[key], order: 0 } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name2 = match[3];
      if (hash) {
        if (name2 === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  const modulesToInject = platformInfo.type !== "webgpu" ? modules : [];
  for (const module of modulesToInject) {
    if (log3) {
      module.checkDeprecations(coreSource, log3);
    }
    const moduleSource = module.getModuleSource(stage, "wgsl");
    assembledSource += moduleSource;
    const injections = module.injections[stage];
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name2 = match[2];
        const injectionType = name2 === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  return assembledSource;
}
function assembleGLSLShader(platformInfo, options) {
  const { id, source, stage, language = "glsl", modules, defines: defines2 = {}, hookFunctions = [], inject = {}, prologue = true, log: log3 } = options;
  assert$4(typeof source === "string", "shader source must be a string");
  const sourceVersion = language === "glsl" ? getShaderInfo$1(source).version : -1;
  const targetVersion = platformInfo.shaderLanguageVersion;
  const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
  const sourceLines = source.split("\n");
  const coreSource = sourceLines.slice(1).join("\n");
  const allDefines = {};
  modules.forEach((module) => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines2);
  let assembledSource = "";
  switch (language) {
    case "wgsl":
      break;
    case "glsl":
      assembledSource = prologue ? `${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({ id, source, stage })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}
${getPlatformShaderDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
      break;
  }
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? { injection: inject[key], order: 0 } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name2 = match[3];
      if (hash) {
        if (name2 === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log3) {
      module.checkDeprecations(coreSource, log3);
    }
    const moduleSource = module.getModuleSource(stage);
    assembledSource += moduleSource;
    const injections = module.injections[stage];
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name2 = match[2];
        const injectionType = name2 === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  if (language === "glsl" && sourceVersion !== targetVersion) {
    assembledSource = transpileGLSLShader(assembledSource, stage);
  }
  return assembledSource.trim();
}
function assembleGetUniforms(modules) {
  return function getUniforms2(opts) {
    const uniforms = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}
function getShaderNameDefine(options) {
  const { id, source, stage } = options;
  const injectShaderName = id && source.indexOf("SHADER_NAME") === -1;
  return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}

` : "";
}
function getApplicationDefines(defines2 = {}) {
  let sourceText = "";
  for (const define2 in defines2) {
    const value = defines2[define2];
    if (value || Number.isFinite(value)) {
      sourceText += `#define ${define2.toUpperCase()} ${defines2[define2]}
`;
    }
  }
  return sourceText;
}
class ShaderAssembler {
  /** Default ShaderAssembler instance */
  static defaultShaderAssembler;
  /** Hook functions */
  _hookFunctions = [];
  /** Shader modules */
  _defaultModules = [];
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    ShaderAssembler.defaultShaderAssembler = ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();
    return ShaderAssembler.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(module) {
    if (!this._defaultModules.find((m2) => m2.name === (typeof module === "string" ? module : module.name))) {
      this._defaultModules.push(module);
    }
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(module) {
    const moduleName = typeof module === "string" ? module : module.name;
    this._defaultModules = this._defaultModules.filter((m2) => m2.name !== moduleName);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, { hook });
    }
    this._hookFunctions.push(hook);
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShader(props) {
    const modules = this._getModuleList(props.modules);
    const hookFunctions = this._hookFunctions;
    const options = selectShaders(props);
    const assembled = assembleShaderWGSL({
      platformInfo: props.platformInfo,
      ...options,
      modules,
      hookFunctions
    });
    return { ...assembled, modules };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShaderPair(props) {
    const options = selectShaders(props);
    const modules = this._getModuleList(props.modules);
    const hookFunctions = this._hookFunctions;
    const { platformInfo } = props;
    const isWGSL = props.platformInfo.shaderLanguage === "wgsl";
    const assembled = isWGSL ? assembleShaderPairWGSL({ platformInfo, ...options, modules, hookFunctions }) : assembleShaderPairGLSL({ platformInfo, ...options, modules, hookFunctions });
    return { ...assembled, modules };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(appModules = []) {
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count2 = 0;
    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
      const module = this._defaultModules[i];
      const name2 = module.name;
      modules[count2++] = module;
      seen[name2] = true;
    }
    for (let i = 0, len = appModules.length; i < len; ++i) {
      const module = appModules[i];
      const name2 = module.name;
      if (!seen[name2]) {
        modules[count2++] = module;
        seen[name2] = true;
      }
    }
    modules.length = count2;
    return ShaderModuleInstance.instantiateModules(modules);
  }
}
const FS_GLES = `out vec4 transform_output;
void main() {
transform_output = vec4(0);
}`;
const FS300 = `#version 300 es
${FS_GLES}`;
function getPassthroughFS(options) {
  const { input, inputChannels, output } = {};
  if (!input) {
    return FS300;
  }
  if (!inputChannels) {
    throw new Error("inputChannels");
  }
  const inputType = channelCountToType(inputChannels);
  const outputValue = convertToVec4(input, inputChannels);
  return `#version 300 es
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
}
function channelCountToType(channels) {
  switch (channels) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${channels}`);
  }
}
function convertToVec4(variable, channels) {
  switch (channels) {
    case 1:
      return `vec4(${variable}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${variable}, 0.0, 1.0)`;
    case 3:
      return `vec4(${variable}, 1.0)`;
    case 4:
      return variable;
    default:
      throw new Error(`invalid channels: ${channels}`);
  }
}
const log = new Log({ id: "luma.gl" });
class StatsManager {
  stats = /* @__PURE__ */ new Map();
  getStats(name2) {
    return this.get(name2);
  }
  get(name2) {
    if (!this.stats.has(name2)) {
      this.stats.set(name2, new Stats({ id: name2 }));
    }
    return this.stats.get(name2);
  }
}
const lumaStats = new StatsManager();
function initializeLuma() {
  const VERSION2 = "9.0.28";
  const STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  if (globalThis.luma && globalThis.luma.VERSION !== VERSION2) {
    throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${VERSION2}`);
  }
  if (!globalThis.luma) {
    if (isBrowser$1()) {
      log.log(1, `${VERSION2} - ${STARTUP_MESSAGE}`)();
    }
    globalThis.luma = globalThis.luma || {
      VERSION: VERSION2,
      version: VERSION2,
      log,
      // A global stats object that various components can add information to
      // E.g. see webgl/resource.js
      stats: lumaStats
    };
  }
  return VERSION2;
}
const VERSION = initializeLuma();
function isTypedArray(value) {
  return ArrayBuffer.isView(value) && !(value instanceof DataView) ? value : null;
}
function isNumberArray(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || typeof value[0] === "number" ? value : null;
  }
  return isTypedArray(value);
}
const uidCounters = {};
function uid(id = "id") {
  uidCounters[id] = uidCounters[id] || 1;
  const count2 = uidCounters[id]++;
  return `${id}-${count2}`;
}
function isObjectEmpty$2(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}
let Resource$1 = class Resource {
  /** Default properties for resource */
  static defaultProps = {
    id: "undefined",
    handle: void 0,
    userData: void 0
  };
  /** props.id, for debugging. */
  id;
  props;
  userData = {};
  _device;
  /** Whether this resource has been destroyed */
  destroyed = false;
  /** For resources that allocate GPU memory */
  allocatedBytes = 0;
  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
  _attachedResources = /* @__PURE__ */ new Set();
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(device, props, defaultProps2) {
    if (!device) {
      throw new Error("no device");
    }
    this._device = device;
    this.props = selectivelyMerge(props, defaultProps2);
    const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
    this.props.id = id;
    this.id = id;
    this.userData = this.props.userData || {};
    this.addStats();
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    this.destroy();
    return this;
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(resource) {
    this._attachedResources.add(resource);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(resource) {
    this._attachedResources.delete(resource);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(resource) {
    if (this._attachedResources.delete(resource)) {
      resource.destroy();
    }
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const resource of Object.values(this._attachedResources)) {
      resource.destroy();
    }
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources();
    this.removeStats();
    this.destroyed = true;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const stats = this._device.statsManager.getStats("Resource Counts");
    const name2 = this[Symbol.toStringTag];
    stats.get(`${name2}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(bytes, name2 = this[Symbol.toStringTag]) {
    const stats = this._device.statsManager.getStats("Resource Counts");
    stats.get("GPU Memory").addCount(bytes);
    stats.get(`${name2} Memory`).addCount(bytes);
    this.allocatedBytes = bytes;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(name2 = this[Symbol.toStringTag]) {
    const stats = this._device.statsManager.getStats("Resource Counts");
    stats.get("GPU Memory").subtractCount(this.allocatedBytes);
    stats.get(`${name2} Memory`).subtractCount(this.allocatedBytes);
    this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const stats = this._device.statsManager.getStats("Resource Counts");
    const name2 = this[Symbol.toStringTag];
    stats.get("Resources Created").incrementCount();
    stats.get(`${name2}s Created`).incrementCount();
    stats.get(`${name2}s Active`).incrementCount();
  }
};
function selectivelyMerge(props, defaultProps2) {
  const mergedProps = { ...defaultProps2 };
  for (const key in props) {
    if (props[key] !== void 0) {
      mergedProps[key] = props[key];
    }
  }
  return mergedProps;
}
class Buffer extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    usage: 0,
    // Buffer.COPY_DST | Buffer.COPY_SRC
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: false
  };
  // Usage Flags
  static MAP_READ = 1;
  static MAP_WRITE = 2;
  static COPY_SRC = 4;
  static COPY_DST = 8;
  /** Index buffer */
  static INDEX = 16;
  /** Vertex buffer */
  static VERTEX = 32;
  /** Uniform buffer */
  static UNIFORM = 64;
  /** Storage buffer */
  static STORAGE = 128;
  static INDIRECT = 256;
  static QUERY_RESOLVE = 512;
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /** The usage with which this buffer was created */
  usage;
  /** For index buffers, whether indices are 16 or 32 bit */
  indexType;
  /** "Time" of last update */
  updateTimestamp;
  constructor(device, props) {
    const deducedProps = { ...props };
    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
      if (props.data instanceof Uint32Array) {
        deducedProps.indexType = "uint32";
      } else if (props.data instanceof Uint16Array) {
        deducedProps.indexType = "uint16";
      }
    }
    super(device, deducedProps, Buffer.defaultProps);
    this.usage = props.usage || 0;
    this.indexType = deducedProps.indexType;
    this.updateTimestamp = device.incrementTimestamp();
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(byteOffset, byteLength) {
    throw new Error("not implemented");
  }
  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
  /** Max amount of debug data saved. Two vec4's */
  static DEBUG_DATA_MAX_LENGTH = 32;
  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
  debugData = new ArrayBuffer(0);
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(data, byteOffset, byteLength) {
    const buffer = ArrayBuffer.isView(data) ? data.buffer : data;
    const debugDataLength = Math.min(data ? data.byteLength : byteLength, Buffer.DEBUG_DATA_MAX_LENGTH);
    if (data === null) {
      this.debugData = new ArrayBuffer(debugDataLength);
    } else if (byteOffset === 0 && byteLength === data.byteLength) {
      this.debugData = buffer.slice(0, debugDataLength);
    } else {
      this.debugData = buffer.slice(byteOffset, byteOffset + debugDataLength);
    }
  }
}
function decodeVertexType(type) {
  const dataType = TYPE_MAP[type];
  const bytes = getDataTypeBytes(dataType);
  const normalized = type.includes("norm");
  const integer = !normalized && !type.startsWith("float");
  const signed = type.startsWith("s");
  return {
    dataType: TYPE_MAP[type],
    byteLength: bytes,
    integer,
    signed,
    normalized
  };
}
function getDataTypeBytes(type) {
  const bytes = TYPE_SIZES$2[type];
  return bytes;
}
const TYPE_MAP = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
};
const TYPE_SIZES$2 = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
};
const COMPRESSED_TEXTURE_FORMAT_PREFIXES = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
];
const REGEX = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
function isTextureFormatCompressed(textureFormat) {
  return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some((prefix2) => textureFormat.startsWith(prefix2));
}
function decodeTextureFormat(format2) {
  const matches2 = REGEX.exec(format2);
  if (matches2) {
    const [, format3, length, type, srgb, suffix] = matches2;
    if (format3) {
      const dataType = `${type}${length}`;
      const decodedType = decodeVertexType(dataType);
      return {
        format: format3,
        components: format3.length,
        // dataType - overwritten by decodedType
        srgb: srgb === "-srgb",
        unsized: suffix === "-unsized",
        webgl: suffix === "-webgl",
        ...decodedType
      };
    }
  }
  return decodeNonStandardFormat(format2);
}
const EXCEPTIONS = {
  // Packed 16 bit formats
  "rgba4unorm-webgl": { format: "rgba", bpp: 2 },
  "rgb565unorm-webgl": { format: "rgb", bpp: 2 },
  "rgb5a1unorm-webgl": { format: "rgba", bbp: 2 },
  // Packed 32 bit formats
  rgb9e5ufloat: { format: "rgb", bbp: 4 },
  rg11b10ufloat: { format: "rgb", bbp: 4 },
  rgb10a2unorm: { format: "rgba", bbp: 4 },
  "rgb10a2uint-webgl": { format: "rgba", bbp: 4 },
  // Depth/stencil
  stencil8: { components: 1, bpp: 1, a: "stencil" },
  depth16unorm: { components: 1, bpp: 2, a: "depth" },
  depth24plus: { components: 1, bpp: 3, a: "depth" },
  depth32float: { components: 1, bpp: 4, a: "depth" },
  "depth24plus-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { components: 2, bpp: 4, a: "depth-stencil" }
};
function decodeNonStandardFormat(format2) {
  const data = EXCEPTIONS[format2];
  if (!data) {
    throw new Error(`Unknown format ${format2}`);
  }
  return {
    format: data.format || "",
    components: data.components || data.format?.length || 1,
    byteLength: data.bpp || 1,
    srgb: false,
    unsized: false
  };
}
class DeviceLimits {
}
class DeviceFeatures {
  features;
  disabledFeatures;
  constructor(features = [], disabledFeatures) {
    this.features = new Set(features);
    this.disabledFeatures = disabledFeatures || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(feature) {
    return !this.disabledFeatures[feature] && this.features.has(feature);
  }
}
class Device {
  static defaultProps = {
    id: null,
    canvas: null,
    container: null,
    manageState: true,
    width: 800,
    // width are height are only used by headless gl
    height: 600,
    requestMaxLimits: true,
    debug: Boolean(log.get("debug")),
    // Instrument context (at the expense of performance)
    spector: Boolean(log.get("spector") || log.get("spectorjs")),
    // Initialize the SpectorJS WebGL debugger
    break: [],
    // TODO - Change these after confirming things work as expected
    initalizeFeatures: true,
    disabledFeatures: {
      "compilation-status-async-webgl": true
    },
    // alpha: undefined,
    // depth: undefined,
    // stencil: undefined,
    // antialias: undefined,
    // premultipliedAlpha: undefined,
    // preserveDrawingBuffer: undefined,
    // failIfMajorPerformanceCaveat: undefined
    gl: null,
    // Callbacks
    onError: (error) => log.error(error.message)
  };
  get [Symbol.toStringTag]() {
    return "Device";
  }
  static VERSION = VERSION;
  constructor(props) {
    this.props = { ...Device.defaultProps, ...props };
    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
  }
  /** id of this device, primarily for debugging */
  id;
  /** A copy of the device props  */
  props;
  /** Available for the application to store data on the device */
  userData = {};
  /** stats */
  statsManager = lumaStats;
  /** Used by other luma.gl modules to store data on the device */
  _lumaData = {};
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(format2) {
    return isTextureFormatCompressed(format2);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return false;
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getCanvasContext() {
    if (!this.canvasContext) {
      throw new Error("Device has no CanvasContext");
    }
    return this.canvasContext;
  }
  createTexture(props) {
    if (props instanceof Promise || typeof props === "string") {
      props = { data: props };
    }
    return this._createTexture(props);
  }
  createCommandEncoder(props = {}) {
    throw new Error("not implemented");
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(source, options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(source, options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(parameters) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(parameters) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(parameters, func) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  timestamp = 0;
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(error) {
    this.props.onError(error);
  }
  // IMPLEMENTATION
  _getBufferProps(props) {
    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
      props = { data: props };
    }
    const newProps = { ...props };
    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
      if (props.data instanceof Uint32Array) {
        newProps.indexType = "uint32";
      } else if (props.data instanceof Uint16Array) {
        newProps.indexType = "uint16";
      } else {
        log.warn("indices buffer content must be of integer type")();
      }
    }
    return newProps;
  }
}
function assert$3(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "luma.gl: assertion failed.");
  }
}
const deviceMap = /* @__PURE__ */ new Map();
class luma {
  static defaultProps = {
    ...Device.defaultProps,
    type: "best-available",
    devices: void 0
  };
  /** Global stats for all devices */
  static stats = lumaStats;
  /** Global log */
  static log = log;
  static registerDevices(deviceClasses) {
    for (const deviceClass of deviceClasses) {
      assert$3(deviceClass.type && deviceClass.isSupported && deviceClass.create);
      deviceMap.set(deviceClass.type, deviceClass);
    }
  }
  static getAvailableDevices() {
    return Array.from(deviceMap).map((Device2) => Device2.type);
  }
  static getSupportedDevices() {
    return Array.from(deviceMap).filter((Device2) => Device2.isSupported()).map((Device2) => Device2.type);
  }
  static setDefaultDeviceProps(props) {
    Object.assign(Device.defaultProps, props);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  static async attachDevice(props) {
    const devices = getDeviceMap(props.devices) || deviceMap;
    if (props.handle instanceof WebGL2RenderingContext) {
      const WebGLDevice2 = devices.get("webgl");
      if (WebGLDevice2) {
        return await WebGLDevice2.attach(props.handle);
      }
    }
    if (props.handle === null) {
      const UnknownDevice = devices.get("unknown");
      if (UnknownDevice) {
        return await UnknownDevice.attach(null);
      }
    }
    throw new Error("Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  /** Creates a device. Asynchronously. */
  static async createDevice(props = {}) {
    props = { ...luma.defaultProps, ...props };
    if (props.gl) {
      props.type = "webgl";
    }
    const devices = getDeviceMap(props.devices) || deviceMap;
    let WebGPUDevice;
    let WebGLDevice2;
    switch (props.type) {
      case "webgpu":
        WebGPUDevice = devices.get("webgpu");
        if (WebGPUDevice) {
          return await WebGPUDevice.create(props);
        }
        break;
      case "webgl":
        WebGLDevice2 = devices.get("webgl");
        if (WebGLDevice2) {
          return await WebGLDevice2.create(props);
        }
        break;
      case "unknown":
        const UnknownDevice = devices.get("unknown");
        if (UnknownDevice) {
          return await UnknownDevice.create(props);
        }
        break;
      case "best-available":
        WebGPUDevice = devices.get("webgpu");
        if (WebGPUDevice?.isSupported?.()) {
          return await WebGPUDevice.create(props);
        }
        WebGLDevice2 = devices.get("webgl");
        if (WebGLDevice2?.isSupported?.()) {
          return await WebGLDevice2.create(props);
        }
        break;
    }
    throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  static enforceWebGL2(enforce = true) {
    const prototype = HTMLCanvasElement.prototype;
    if (!enforce && prototype.originalGetContext) {
      prototype.getContext = prototype.originalGetContext;
      prototype.originalGetContext = void 0;
      return;
    }
    prototype.originalGetContext = prototype.getContext;
    prototype.getContext = function(contextId, options) {
      if (contextId === "webgl" || contextId === "experimental-webgl") {
        return this.originalGetContext("webgl2", options);
      }
      return this.originalGetContext(contextId, options);
    };
  }
}
function getDeviceMap(deviceClasses) {
  if (!deviceClasses || deviceClasses?.length === 0) {
    return null;
  }
  const map2 = /* @__PURE__ */ new Map();
  for (const deviceClass of deviceClasses) {
    map2.set(deviceClass.type, deviceClass);
  }
  return map2;
}
const isPage = isBrowser$1() && typeof document !== "undefined";
const isPageLoaded = () => isPage && document.readyState === "complete";
const DEFAULT_CANVAS_CONTEXT_PROPS = {
  canvas: null,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  useDevicePixels: true,
  autoResize: true,
  container: null,
  visible: true,
  colorSpace: "srgb",
  alphaMode: "opaque"
};
class CanvasContext {
  id;
  props;
  canvas;
  htmlCanvas;
  offscreenCanvas;
  type;
  width = 1;
  height = 1;
  resizeObserver;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** Check if the DOM is loaded */
  static get isPageLoaded() {
    return isPageLoaded();
  }
  /**
   * Get a 'lazy' promise that resolves when the DOM is loaded.
   * @note Since there may be limitations on number of `load` event listeners,
   * it is recommended avoid calling this function until actually needed.
   * I.e. don't call it until you know that you will be looking up a string in the DOM.
   */
  static pageLoaded = getPageLoadPromise();
  constructor(props) {
    this.props = { ...DEFAULT_CANVAS_CONTEXT_PROPS, ...props };
    props = this.props;
    if (!isBrowser$1()) {
      this.id = "node-canvas-context";
      this.type = "node";
      this.width = this.props.width;
      this.height = this.props.height;
      this.canvas = null;
      return;
    }
    if (!props.canvas) {
      const canvas2 = createCanvas(props);
      const container = getContainer(props?.container || null);
      container.insertBefore(canvas2, container.firstChild);
      this.canvas = canvas2;
      if (!props?.visible) {
        this.canvas.style.visibility = "hidden";
      }
    } else if (typeof props.canvas === "string") {
      this.canvas = getCanvasFromDOM(props.canvas);
    } else {
      this.canvas = props.canvas;
    }
    if (this.canvas instanceof HTMLCanvasElement) {
      this.id = this.canvas.id;
      this.type = "html-canvas";
      this.htmlCanvas = this.canvas;
    } else {
      this.id = "offscreen-canvas";
      this.type = "offscreen-canvas";
      this.offscreenCanvas = this.canvas;
    }
    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
      this.resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target === this.canvas) {
            this.update();
          }
        }
      });
      this.resizeObserver.observe(this.canvas);
    }
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(useDevicePixels) {
    if (typeof OffscreenCanvas !== "undefined" && this.canvas instanceof OffscreenCanvas) {
      return 1;
    }
    useDevicePixels = useDevicePixels === void 0 ? this.props.useDevicePixels : useDevicePixels;
    if (!useDevicePixels || useDevicePixels <= 0) {
      return 1;
    }
    if (useDevicePixels === true) {
      const dpr = typeof window !== "undefined" && window.devicePixelRatio;
      return dpr || 1;
    }
    return useDevicePixels;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const dpr = this.getDevicePixelRatio();
        const canvas2 = this.canvas;
        return canvas2.parentElement ? [canvas2.clientWidth * dpr, canvas2.clientHeight * dpr] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [width, height] = this.getPixelSize();
    return width / height;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    try {
      const [drawingBufferWidth] = this.getDrawingBufferSize();
      const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;
      return clientWidth ? drawingBufferWidth / clientWidth : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(cssPixel, yInvert = true) {
    const ratio = this.cssToDeviceRatio();
    const [width, height] = this.getDrawingBufferSize();
    return scalePixels(cssPixel, ratio, width, height, yInvert);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(devicePixelRatio, options = {}) {
    if (!this.htmlCanvas) {
      return;
    }
    let clientWidth = "width" in options ? options.width : this.htmlCanvas.clientWidth;
    let clientHeight = "height" in options ? options.height : this.htmlCanvas.clientHeight;
    if (!clientWidth || !clientHeight) {
      log.log(1, "Canvas clientWidth/clientHeight is 0")();
      devicePixelRatio = 1;
      clientWidth = this.htmlCanvas.width || 1;
      clientHeight = this.htmlCanvas.height || 1;
    }
    const cachedSize = this._canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
      let clampedPixelRatio = devicePixelRatio;
      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
      this.htmlCanvas.width = canvasWidth;
      this.htmlCanvas.height = canvasHeight;
      const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
      if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
        clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
        this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
        this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
        log.warn("Device pixel ratio clamped")();
      }
      this._canvasSizeInfo.clientWidth = clientWidth;
      this._canvasSizeInfo.clientHeight = clientHeight;
      this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const gl = this.device.gl;
    if (!gl) {
      throw new Error("canvas size");
    }
    return [gl.drawingBufferWidth, gl.drawingBufferHeight];
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(id) {
    if (this.htmlCanvas?.id === "lumagl-auto-created-canvas") {
      this.htmlCanvas.id = id;
    }
  }
}
function getPageLoadPromise() {
  if (isPageLoaded() || typeof window === "undefined") {
    return Promise.resolve();
  }
  return new Promise((resolve) => {
    window.addEventListener("load", () => resolve());
  });
}
function getContainer(container) {
  if (typeof container === "string") {
    const element = document.getElementById(container);
    if (!element && !isPageLoaded()) {
      throw new Error(`Accessing '${container}' before page was loaded`);
    }
    if (!element) {
      throw new Error(`${container} is not an HTML element`);
    }
    return element;
  } else if (container) {
    return container;
  }
  return document.body;
}
function getCanvasFromDOM(canvasId) {
  const canvas2 = document.getElementById(canvasId);
  if (!canvas2 && !isPageLoaded()) {
    throw new Error(`Accessing '${canvasId}' before page was loaded`);
  }
  if (!(canvas2 instanceof HTMLCanvasElement)) {
    throw new Error("Object is not a canvas element");
  }
  return canvas2;
}
function createCanvas(props) {
  const { width, height } = props;
  const targetCanvas = document.createElement("canvas");
  targetCanvas.id = "lumagl-auto-created-canvas";
  targetCanvas.width = width || 1;
  targetCanvas.height = height || 1;
  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : "100%";
  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : "100%";
  return targetCanvas;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const point2 = pixel;
  const x2 = scaleX(point2[0], ratio, width);
  let y2 = scaleY(point2[1], ratio, height, yInvert);
  let t = scaleX(point2[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(point2[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y2;
    y2 = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x: x2,
    y: y2,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(xHigh - x2 + 1, 1),
    height: Math.max(yHigh - y2 + 1, 1)
  };
}
function scaleX(x2, ratio, width) {
  const r = Math.min(Math.round(x2 * ratio), width - 1);
  return r;
}
function scaleY(y2, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y2 * ratio)) : Math.min(Math.round(y2 * ratio), height - 1);
}
class Texture extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: true,
    // type: undefined,
    compressed: false,
    // mipLevels: 1,
    usage: 0,
    // usage: GPUTextureUsage.COPY_DST
    mipLevels: void 0,
    samples: void 0,
    type: void 0,
    sampler: {},
    view: void 0
  };
  static COPY_SRC = 1;
  static COPY_DST = 2;
  static TEXTURE_BINDING = 4;
  static STORAGE_BINDING = 8;
  static RENDER_ATTACHMENT = 16;
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  /** dimension of this texture */
  dimension;
  /** format of this texture */
  format;
  /** width in pixels of this texture */
  width;
  /** height in pixels of this texture */
  height;
  /** depth of this texture */
  depth;
  /** "Time" of last update. Monotonically increasing timestamp */
  updateTimestamp;
  /** Do not use directly. Create with device.createTexture() */
  constructor(device, props, defaultProps2 = Texture.defaultProps) {
    super(device, props, defaultProps2);
    this.dimension = this.props.dimension;
    this.format = this.props.format;
    this.width = this.props.width;
    this.height = this.props.height;
    this.depth = this.props.depth;
    this.updateTimestamp = device.incrementTimestamp();
  }
}
class TextureView extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  };
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(device, props) {
    super(device, props, TextureView.defaultProps);
  }
}
function formatCompilerLog(shaderLog, source, options) {
  let formattedLog = "";
  const lines = source.split(/\r?\n/);
  const log3 = shaderLog.slice().sort((a2, b) => a2.lineNum - b.lineNum);
  switch (options?.showSourceCode || "no") {
    case "all":
      let currentMessage = 0;
      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
        while (log3.length > currentMessage && log3[currentMessage].lineNum === lineNum) {
          const message2 = log3[currentMessage++];
          formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
            ...options,
            inlineSource: false
          });
        }
      }
      return formattedLog;
    case "issues":
    case "no":
      for (const message2 of shaderLog) {
        formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
          inlineSource: options?.showSourceCode !== "no"
        });
      }
      return formattedLog;
  }
}
function formatCompilerMessage(message2, lines, lineNum, options) {
  if (options?.inlineSource) {
    const numberedLines = getNumberedLines(lines, lineNum);
    const positionIndicator = message2.linePos > 0 ? `${" ".repeat(message2.linePos + 5)}^^^
` : "";
    return `
${numberedLines}${positionIndicator}${message2.type.toUpperCase()}: ${message2.message}

`;
  }
  return options?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${message2.type.toUpperCase()}: ${message2.message}</b></div>` : `${message2.type.toUpperCase()}: ${message2.message}`;
}
function getNumberedLines(lines, lineNum, options) {
  let numberedLines = "";
  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
    const sourceLine = lines[lineIndex - 1];
    if (sourceLine !== void 0) {
      numberedLines += getNumberedLine(sourceLine, lineNum, options);
    }
  }
  return numberedLines;
}
function getNumberedLine(line, lineNum, options) {
  const escapedLine = options?.html ? escapeHTML(line) : line;
  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? "<br/>" : "\n"}`;
}
function padLeft(string2, paddedLength) {
  let result = "";
  for (let i = string2.length; i < paddedLength; ++i) {
    result += " ";
  }
  return result + string2;
}
function escapeHTML(unsafe) {
  return unsafe.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
function getShaderInfo(source, defaultName) {
  return {
    name: getShaderName(source, defaultName),
    language: "glsl",
    version: getShaderVersion(source)
  };
}
function getShaderName(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = SHADER_NAME_REGEXP.exec(shader);
  return match ? match[1] : defaultName;
}
function getShaderVersion(source) {
  let version2 = 100;
  const words = source.match(/[^\s]+/g);
  if (words && words.length >= 2 && words[0] === "#version") {
    const v = parseInt(words[1], 10);
    if (Number.isFinite(v)) {
      version2 = v;
    }
  }
  return version2;
}
class Shader extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debug: "errors"
  };
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** The stage of this shader */
  stage;
  /** The source code of this shader */
  source;
  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
  compilationStatus = "pending";
  /** Create a new Shader instance */
  constructor(device, props) {
    super(device, { id: getShaderIdFromProps(props), ...props }, Shader.defaultProps);
    this.stage = this.props.stage;
    this.source = this.props.source;
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader(trigger = this.props.debug) {
    switch (trigger) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success") {
          return;
        }
        break;
    }
    const messages = await this.getCompilationInfo();
    if (this.props.debug === "warnings" && messages?.length === 0) {
      return;
    }
    this._displayShaderLog(messages);
  }
  // PRIVATE
  /** In-browser UI logging of errors */
  _displayShaderLog(messages) {
    if (typeof document === "undefined" || !document?.createElement) {
      return;
    }
    const shaderName = getShaderInfo(this.source).name;
    const shaderTitle = `${this.stage} ${shaderName}`;
    let htmlLog = formatCompilerLog(messages, this.source, { showSourceCode: "all", html: true });
    const translatedSource = this.getTranslatedSource();
    if (translatedSource) {
      htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${translatedSource}</pre></code>`;
    }
    const button = document.createElement("Button");
    button.innerHTML = `
<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
    button.style.top = "10px";
    button.style.left = "10px";
    button.style.position = "absolute";
    button.style.zIndex = "9999";
    button.style.width = "100%";
    button.style.textAlign = "left";
    document.body.appendChild(button);
    const errors = document.getElementsByClassName("luma-compiler-log-error");
    if (errors[0]?.scrollIntoView) {
      errors[0].scrollIntoView();
    }
    button.onclick = () => {
      const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(dataURI);
    };
  }
}
function getShaderIdFromProps(props) {
  return getShaderInfo(props.source).name || props.id || uid(`unnamed ${props.stage}-shader`);
}
class Sampler extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "nearest",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    // Per WebGPU spec
    compare: "less-equal",
    maxAnisotropy: 1
  };
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(device, props) {
    super(device, props, Sampler.defaultProps);
  }
}
class Framebuffer extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    // ['rgba8unorm'],
    depthStencilAttachment: null
    // 'depth24plus-stencil8'
  };
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /** Width of all attachments in this framebuffer */
  width;
  /** Height of all attachments in this framebuffer */
  height;
  /** Color attachments */
  colorAttachments = [];
  /** Depth-stencil attachment, if provided */
  depthStencilAttachment = null;
  constructor(device, props = {}) {
    super(device, props, Framebuffer.defaultProps);
    this.width = this.props.width;
    this.height = this.props.height;
  }
  resize(size) {
    let updateSize = !size;
    if (size) {
      const [width, height] = Array.isArray(size) ? size : [size.width, size.height];
      updateSize = updateSize || height !== this.height || width !== this.width;
      this.width = width;
      this.height = height;
    }
    if (updateSize) {
      log.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
      this.resizeAttachments(this.width, this.height);
    }
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {
      throw new Error("Framebuffer has noattachments");
    }
    this.colorAttachments = this.props.colorAttachments.map((attachment2) => {
      if (typeof attachment2 === "string") {
        const texture = this.createColorTexture(attachment2);
        this.attachResource(texture);
        return texture.view;
      }
      if (attachment2 instanceof Texture) {
        return attachment2.view;
      }
      return attachment2;
    });
    const attachment = this.props.depthStencilAttachment;
    if (attachment) {
      if (typeof attachment === "string") {
        const texture = this.createDepthStencilTexture(attachment);
        this.attachResource(texture);
        this.depthStencilAttachment = texture.view;
      } else if (attachment instanceof Texture) {
        this.depthStencilAttachment = attachment.view;
      } else {
        this.depthStencilAttachment = attachment;
      }
    }
  }
  /** Create a color texture */
  createColorTexture(format2) {
    return this.device.createTexture({
      id: "color-attachment",
      usage: Texture.RENDER_ATTACHMENT,
      format: format2,
      width: this.width,
      height: this.height
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(format2) {
    return this.device.createTexture({
      id: "depth-stencil-attachment",
      usage: Texture.RENDER_ATTACHMENT,
      format: format2,
      width: this.width,
      height: this.height
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(width, height) {
    for (let i = 0; i < this.colorAttachments.length; ++i) {
      if (this.colorAttachments[i]) {
        const resizedTexture = this.device._createTexture({
          ...this.colorAttachments[i].props,
          width,
          height
        });
        this.destroyAttachedResource(this.colorAttachments[i]);
        this.colorAttachments[i] = resizedTexture.view;
        this.attachResource(resizedTexture.view);
      }
    }
    if (this.depthStencilAttachment) {
      const resizedTexture = this.device._createTexture({
        ...this.depthStencilAttachment.props,
        width,
        height
      });
      this.destroyAttachedResource(this.depthStencilAttachment);
      this.depthStencilAttachment = resizedTexture.view;
      this.attachResource(resizedTexture);
    }
  }
}
class RenderPipeline extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    // isInstanced: false,
    // instanceCount: 0,
    // vertexCount: 0,
    bindings: {},
    uniforms: {}
  };
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  /** The merged layout */
  shaderLayout;
  /** Buffer map describing buffer interleaving etc */
  bufferLayout;
  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
  linkStatus = "pending";
  /** The hash of the pipeline */
  hash = "";
  constructor(device, props) {
    super(device, props, RenderPipeline.defaultProps);
    this.shaderLayout = this.props.shaderLayout;
    this.bufferLayout = this.props.bufferLayout || [];
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(uniforms) {
    throw new Error("Use uniform blocks");
  }
}
class RenderPass extends Resource$1 {
  /** Default properties for RenderPass */
  static defaultProps = {
    ...Resource$1.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: [0, 0, 0, 0],
    clearDepth: 1,
    clearStencil: 0,
    depthReadOnly: false,
    stencilReadOnly: false,
    discard: false,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  };
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(device, props) {
    super(device, props, RenderPass.defaultProps);
  }
}
class ComputePipeline extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  };
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
  hash = "";
  constructor(device, props) {
    super(device, props, ComputePipeline.defaultProps);
  }
}
class CommandEncoder extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    measureExecutionTime: void 0
  };
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(device, props) {
    super(device, props, CommandEncoder.defaultProps);
  }
}
class CommandBuffer extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps
  };
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(device, props) {
    super(device, props, CommandBuffer.defaultProps);
  }
}
function decodeShaderAttributeType(attributeType) {
  const [dataType, components] = TYPE_INFO[attributeType];
  const integer = dataType === "i32" || dataType === "u32";
  const signed = dataType !== "u32";
  const byteLength = TYPE_SIZES$1[dataType] * components;
  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
  return {
    dataType,
    components,
    defaultVertexFormat,
    byteLength,
    integer,
    signed
  };
}
function getCompatibleVertexFormat(dataType, components) {
  let vertexType;
  switch (dataType) {
    case "f32":
      vertexType = "float32";
      break;
    case "i32":
      vertexType = "sint32";
      break;
    case "u32":
      vertexType = "uint32";
      break;
    case "f16":
      return components <= 2 ? "float16x2" : "float16x4";
  }
  if (components === 1) {
    return vertexType;
  }
  return `${vertexType}x${components}`;
}
const TYPE_INFO = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
};
const TYPE_SIZES$1 = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
function decodeVertexFormat(format2) {
  let webglOnly;
  if (format2.endsWith("-webgl")) {
    format2.replace("-webgl", "");
    webglOnly = true;
  }
  const [type_, count2] = format2.split("x");
  const type = type_;
  const components = count2 ? parseInt(count2) : 1;
  const decodedType = decodeVertexType(type);
  const result = {
    type,
    components,
    byteLength: decodedType.byteLength * components,
    integer: decodedType.integer,
    signed: decodedType.signed,
    normalized: decodedType.normalized
  };
  if (webglOnly) {
    result.webglOnly = true;
  }
  return result;
}
function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
  const attributeInfos = {};
  for (const attribute of shaderLayout.attributes) {
    attributeInfos[attribute.name] = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
  }
  return attributeInfos;
}
function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
  const locationInfos = new Array(maxVertexAttributes).fill(null);
  for (const attributeInfo of Object.values(attributeInfos)) {
    locationInfos[attributeInfo.location] = attributeInfo;
  }
  return locationInfos;
}
function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name2) {
  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name2);
  const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name2);
  if (!shaderDeclaration) {
    return null;
  }
  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
  const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
  const vertexFormatInfo = decodeVertexFormat(vertexFormat);
  return {
    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
    location: shaderDeclaration.location,
    shaderType: shaderDeclaration.type,
    shaderDataType: attributeTypeInfo.dataType,
    shaderComponents: attributeTypeInfo.components,
    vertexFormat,
    bufferDataType: vertexFormatInfo.type,
    bufferComponents: vertexFormatInfo.components,
    // normalized is a property of the buffer's vertex format
    normalized: vertexFormatInfo.normalized,
    // integer is a property of the shader declaration
    integer: attributeTypeInfo.integer,
    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode,
    byteOffset: bufferMapping?.byteOffset || 0,
    byteStride: bufferMapping?.byteStride || 0
  };
}
function getAttributeFromShaderLayout(shaderLayout, name2) {
  const attribute = shaderLayout.attributes.find((attr) => attr.name === name2);
  if (!attribute) {
    log.warn(`shader layout attribute "${name2}" not present in shader`);
  }
  return attribute || null;
}
function getAttributeFromBufferLayout(bufferLayouts, name2) {
  checkBufferLayouts(bufferLayouts);
  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name2);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name2);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  log.warn(`layout for attribute "${name2}" not present in buffer layout`);
  return null;
}
function checkBufferLayouts(bufferLayouts) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
    }
  }
}
function getAttributeFromShortHand(bufferLayouts, name2) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.format && bufferLayout.name === name2) {
      return {
        attributeName: bufferLayout.name,
        bufferName: name2,
        stepMode: bufferLayout.stepMode,
        vertexFormat: bufferLayout.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: bufferLayout.byteStride || 0
      };
    }
  }
  return null;
}
function getAttributeFromAttributesList(bufferLayouts, name2) {
  for (const bufferLayout of bufferLayouts) {
    let byteStride = bufferLayout.byteStride;
    if (typeof bufferLayout.byteStride !== "number") {
      for (const attributeMapping2 of bufferLayout.attributes || []) {
        const info = decodeVertexFormat(attributeMapping2.format);
        byteStride += info.byteLength;
      }
    }
    const attributeMapping = bufferLayout.attributes?.find((mapping) => mapping.attribute === name2);
    if (attributeMapping) {
      return {
        attributeName: attributeMapping.attribute,
        bufferName: bufferLayout.name,
        stepMode: bufferLayout.stepMode,
        vertexFormat: attributeMapping.format,
        byteOffset: attributeMapping.byteOffset,
        byteStride
      };
    }
  }
  return null;
}
function mergeShaderLayout(baseLayout, overrideLayout) {
  const mergedLayout = {
    ...baseLayout,
    attributes: baseLayout.attributes.map((attribute) => ({ ...attribute }))
  };
  for (const attribute of overrideLayout?.attributes || []) {
    const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
    if (!baseAttribute) {
      log.warn(`shader layout attribute ${attribute.name} not present in shader`);
    } else {
      baseAttribute.type = attribute.type || baseAttribute.type;
      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
    }
  }
  return mergedLayout;
}
class VertexArray extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    renderPipeline: null
  };
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** Max number of vertex attributes */
  maxVertexAttributes;
  /** Attribute infos indexed by location - TODO only needed by webgl module? */
  attributeInfos;
  /** Index buffer */
  indexBuffer = null;
  /** Attributes indexed by buffer slot */
  attributes;
  constructor(device, props) {
    super(device, props, VertexArray.defaultProps);
    this.maxVertexAttributes = device.limits.maxVertexAttributes;
    this.attributes = new Array(this.maxVertexAttributes).fill(null);
    this.attributeInfos = getAttributeInfosByLocation(props.renderPipeline.shaderLayout, props.renderPipeline.bufferLayout, this.maxVertexAttributes);
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(location, value) {
    throw new Error("constant attributes not supported");
  }
}
class TransformFeedback extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    layout: void 0,
    buffers: {}
  };
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(device, props) {
    super(device, props, TransformFeedback.defaultProps);
  }
}
class QuerySet extends Resource$1 {
  static defaultProps = {
    ...Resource$1.defaultProps,
    type: void 0,
    count: void 0
  };
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(device, props) {
    super(device, props, QuerySet.defaultProps);
  }
}
const UNIFORM_FORMATS = {
  f32: { type: "f32", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 }
};
function decodeShaderUniformType(format2) {
  const decoded = UNIFORM_FORMATS[format2];
  assert$3(format2);
  return decoded;
}
function alignTo(size, count2) {
  switch (count2) {
    case 1:
      return size;
    // Pad upwards to even multiple of 2
    case 2:
      return size + size % 2;
    // Pad upwards to even multiple of 2
    default:
      return size + (4 - size % 4) % 4;
  }
}
let arrayBuffer;
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type2, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type2.BYTES_PER_ELEMENT * length);
  return new Type2(scratchArrayBuffer, 0, length);
}
function fillArray$1(options) {
  const { target, source, start: start2 = 0, count: count2 = 1 } = options;
  const length = source.length;
  const total = count2 * length;
  let copied = 0;
  for (let i = start2; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start2 + copied, start2, start2 + copied);
      copied *= 2;
    } else {
      target.copyWithin(start2 + copied, start2, start2 + total - copied);
      copied = total;
    }
  }
  return options.target;
}
const minBufferSize = 1024;
class UniformBufferLayout {
  layout = {};
  /** number of bytes needed for buffer allocation */
  byteLength;
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(uniformTypes) {
    let size = 0;
    for (const [key, uniformType] of Object.entries(uniformTypes)) {
      const typeAndComponents = decodeShaderUniformType(uniformType);
      const { type, components: count2 } = typeAndComponents;
      size = alignTo(size, count2);
      const offset2 = size;
      size += count2;
      this.layout[key] = { type, size: count2, offset: offset2 };
    }
    size += (4 - size % 4) % 4;
    const actualByteLength = size * 4;
    this.byteLength = Math.max(actualByteLength, minBufferSize);
  }
  /** Get the data for the complete buffer */
  getData(uniformValues) {
    const bufferSize = Math.max(this.byteLength, minBufferSize);
    const arrayBuffer2 = getScratchArrayBuffer(bufferSize);
    const typedArrays = {
      i32: new Int32Array(arrayBuffer2),
      u32: new Uint32Array(arrayBuffer2),
      f32: new Float32Array(arrayBuffer2),
      // TODO not implemented
      f16: new Uint16Array(arrayBuffer2)
    };
    for (const [name2, value] of Object.entries(uniformValues)) {
      const uniformLayout = this.layout[name2];
      if (!uniformLayout) {
        log.warn(`Supplied uniform value ${name2} not present in uniform block layout`)();
        continue;
      }
      const { type, size, offset: offset2 } = uniformLayout;
      const typedArray = typedArrays[type];
      if (size === 1) {
        if (typeof value !== "number" && typeof value !== "boolean") {
          log.warn(`Supplied value for single component uniform ${name2} is not a number: ${value}`)();
          continue;
        }
        typedArray[offset2] = Number(value);
      } else {
        const numericArray = isNumberArray(value);
        if (!numericArray) {
          log.warn(`Supplied value for multi component / array uniform ${name2} is not a numeric array: ${value}`)();
          continue;
        }
        typedArray.set(numericArray, offset2);
      }
    }
    return new Uint8Array(arrayBuffer2);
  }
  /** Does this layout have a field with specified name */
  has(name2) {
    return Boolean(this.layout[name2]);
  }
  /** Get offset and size for a field with specified name */
  get(name2) {
    const layout = this.layout[name2];
    return layout;
  }
}
function arrayEqual(a2, b, limit = 16) {
  if (a2 !== b) {
    return false;
  }
  const arrayA = isNumberArray(a2);
  if (!arrayA) {
    return false;
  }
  const arrayB = isNumberArray(b);
  if (arrayB && arrayA.length === arrayB.length) {
    for (let i = 0; i < arrayA.length; ++i) {
      if (arrayB[i] !== arrayA[i]) {
        return false;
      }
    }
  }
  return true;
}
function arrayCopy(a2) {
  const numberArray2 = isNumberArray(a2);
  if (numberArray2) {
    return numberArray2.slice();
  }
  return a2;
}
class UniformBlock {
  name;
  uniforms = {};
  modifiedUniforms = {};
  modified = true;
  bindingLayout = {};
  needsRedraw = "initialized";
  constructor(props) {
    this.name = props?.name;
    if (props?.name && props?.shaderLayout) {
      const binding = props?.shaderLayout.bindings?.find((binding2) => binding2.type === "uniform" && binding2.name === props?.name);
      if (!binding) {
        throw new Error(props?.name);
      }
      const uniformBlock = binding;
      for (const uniform of uniformBlock.uniforms || []) {
        this.bindingLayout[uniform.name] = uniform;
      }
    }
  }
  /** Set a map of uniforms */
  setUniforms(uniforms) {
    for (const [key, value] of Object.entries(uniforms)) {
      this._setUniform(key, value);
      if (!this.needsRedraw) {
        this.setNeedsRedraw(`${this.name}.${key}=${value}`);
      }
    }
  }
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    this.modifiedUniforms = {};
    this.needsRedraw = false;
    return this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(key, value) {
    if (arrayEqual(this.uniforms[key], value)) {
      return;
    }
    this.uniforms[key] = arrayCopy(value);
    this.modifiedUniforms[key] = true;
    this.modified = true;
  }
}
class UniformStore {
  /** Stores the uniform values for each uniform block */
  uniformBlocks = /* @__PURE__ */ new Map();
  /** Can generate data for a uniform buffer for each block from data */
  uniformBufferLayouts = /* @__PURE__ */ new Map();
  /** Actual buffer for the blocks */
  uniformBuffers = /* @__PURE__ */ new Map();
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(blocks) {
    for (const [bufferName, block] of Object.entries(blocks)) {
      const uniformBufferName = bufferName;
      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});
      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
      const uniformBlock = new UniformBlock({ name: bufferName });
      uniformBlock.setUniforms(block.defaultUniforms || {});
      this.uniformBlocks.set(uniformBufferName, uniformBlock);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const uniformBuffer of this.uniformBuffers.values()) {
      uniformBuffer.destroy();
    }
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(uniforms) {
    for (const [blockName, uniformValues] of Object.entries(uniforms)) {
      this.uniformBlocks.get(blockName).setUniforms(uniformValues);
    }
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(uniformBufferName) {
    return this.uniformBufferLayouts.get(uniformBufferName).byteLength;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(uniformBufferName) {
    const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
    return this.uniformBufferLayouts.get(uniformBufferName).getData(uniformValues);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(device, uniformBufferName, uniforms) {
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    const byteLength = this.getUniformBufferByteLength(uniformBufferName);
    const uniformBuffer = device.createBuffer({
      usage: Buffer.UNIFORM | Buffer.COPY_DST,
      byteLength
    });
    const uniformBufferData = this.getUniformBufferData(uniformBufferName);
    uniformBuffer.write(uniformBufferData);
    return uniformBuffer;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(device, uniformBufferName) {
    if (!this.uniformBuffers.get(uniformBufferName)) {
      const byteLength = this.getUniformBufferByteLength(uniformBufferName);
      const uniformBuffer = device.createBuffer({
        usage: Buffer.UNIFORM | Buffer.COPY_DST,
        byteLength
      });
      this.uniformBuffers.set(uniformBufferName, uniformBuffer);
    }
    return this.uniformBuffers.get(uniformBufferName);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let reason = false;
    for (const uniformBufferName of this.uniformBlocks.keys()) {
      const bufferReason = this.updateUniformBuffer(uniformBufferName);
      reason ||= bufferReason;
    }
    if (reason) {
      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
    }
    return reason;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(uniformBufferName) {
    const uniformBlock = this.uniformBlocks.get(uniformBufferName);
    const uniformBuffer = this.uniformBuffers.get(uniformBufferName);
    let reason = false;
    if (uniformBuffer && uniformBlock.needsRedraw) {
      reason ||= uniformBlock.needsRedraw;
      const uniformBufferData = this.getUniformBufferData(uniformBufferName);
      const uniformBuffer2 = this.uniformBuffers.get(uniformBufferName);
      uniformBuffer2.write(uniformBufferData);
      const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
      log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
    }
    return reason;
  }
}
function getDataTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(type.constructor.name);
  }
}
function getTypedArrayFromDataType(dataType) {
  switch (dataType) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(dataType);
  }
}
function getVertexFormatFromAttribute(typedArray, size, normalized) {
  if (!size || size > 4) {
    throw new Error(`size ${size}`);
  }
  const components = size;
  let dataType = getDataTypeFromTypedArray(typedArray);
  if (dataType === "uint8" && normalized && components === 1) {
    return "unorm8-webgl";
  }
  if (dataType === "uint8" && normalized && components === 3) {
    return "unorm8x3-webgl";
  }
  if (dataType === "uint8" || dataType === "sint8") {
    if (components === 1 || components === 3) {
      throw new Error(`size: ${size}`);
    }
    if (normalized) {
      dataType = dataType.replace("int", "norm");
    }
    return `${dataType}x${components}`;
  }
  if (dataType === "uint16" || dataType === "sint16") {
    if (components === 1 || components === 3) {
      throw new Error(`size: ${size}`);
    }
    if (normalized) {
      dataType = dataType.replace("int", "norm");
    }
    return `${dataType}x${components}`;
  }
  if (components === 1) {
    return dataType;
  }
  return `${dataType}x${components}`;
}
function cast$1(value) {
  return value;
}
function isUniformValue(value) {
  return isNumberArray(value) !== null || typeof value === "number" || typeof value === "boolean";
}
function splitUniformsAndBindings(uniforms) {
  const result = { bindings: {}, uniforms: {} };
  Object.keys(uniforms).forEach((name2) => {
    const uniform = uniforms[name2];
    if (isUniformValue(uniform)) {
      result.uniforms[name2] = uniform;
    } else {
      result.bindings[name2] = uniform;
    }
  });
  return result;
}
function checkProps(className, props, propChecks) {
  const { removedProps = {}, deprecatedProps = {}, replacedProps = {} } = propChecks;
  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? `${className}.${removedProps[propName]}` : "N/A";
      log.removed(`${className}.${propName}`, replacement)();
    }
  }
  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
    }
  }
  let newProps = null;
  for (const [propName, replacementProp] of Object.entries(replacedProps)) {
    if (propName in props) {
      log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }
  return newProps || props;
}
let pathPrefix = "";
async function loadImage(url, opts) {
  return await new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error(`Could not load image ${url}.`));
      image.crossOrigin = opts?.crossOrigin || "anonymous";
      image.src = url.startsWith("http") ? url : pathPrefix + url;
    } catch (error) {
      reject(error);
    }
  });
}
async function loadScript(scriptUrl, scriptId) {
  const head = document.getElementsByTagName("head")[0];
  if (!head) {
    throw new Error("loadScript");
  }
  const script = document.createElement("script");
  script.setAttribute("type", "text/javascript");
  script.setAttribute("src", scriptUrl);
  return new Promise((resolve, reject) => {
    script.onload = resolve;
    script.onerror = (error) => reject(new Error(`Unable to load script '${scriptUrl}': ${error}`));
    head.appendChild(script);
  });
}
function deepEqual$1(a2, b, depth) {
  if (a2 === b) {
    return true;
  }
  if (!depth || !a2 || !b) {
    return false;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b) || a2.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a2.length; i++) {
      if (!deepEqual$1(a2[i], b[i], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b)) {
    return false;
  }
  if (typeof a2 === "object" && typeof b === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual$1(a2[key], b[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function requestAnimationFrame$1(callback) {
  return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
}
function cancelAnimationFrame$1(timerId) {
  return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
class ParseContext {
  constructor() {
    this.constants = /* @__PURE__ */ new Map();
    this.aliases = /* @__PURE__ */ new Map();
    this.structs = /* @__PURE__ */ new Map();
  }
}
let Node$1 = class Node {
  constructor() {
  }
  get isAstNode() {
    return true;
  }
  get astNodeType() {
    return "";
  }
  evaluate(context) {
    throw new Error("Cannot evaluate node");
  }
  evaluateString(context) {
    return this.evaluate(context).toString();
  }
  search(callback) {
  }
  searchBlock(block, callback) {
    if (block) {
      callback(_BlockStart.instance);
      for (const node of block) {
        if (node instanceof Array) {
          this.searchBlock(node, callback);
        } else {
          node.search(callback);
        }
      }
      callback(_BlockEnd.instance);
    }
  }
};
class _BlockStart extends Node$1 {
}
_BlockStart.instance = new _BlockStart();
class _BlockEnd extends Node$1 {
}
_BlockEnd.instance = new _BlockEnd();
class Statement extends Node$1 {
  constructor() {
    super();
  }
}
let Function$1 = class Function2 extends Statement {
  constructor(name2, args, returnType, body, startLine, endLine) {
    super();
    this.calls = /* @__PURE__ */ new Set();
    this.name = name2;
    this.args = args;
    this.returnType = returnType;
    this.body = body;
    this.startLine = startLine;
    this.endLine = endLine;
  }
  get astNodeType() {
    return "function";
  }
  search(callback) {
    this.searchBlock(this.body, callback);
  }
};
class StaticAssert extends Statement {
  constructor(expression) {
    super();
    this.expression = expression;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(callback) {
    this.expression.search(callback);
  }
}
class While extends Statement {
  constructor(condition, body) {
    super();
    this.condition = condition;
    this.body = body;
  }
  get astNodeType() {
    return "while";
  }
  search(callback) {
    this.condition.search(callback);
    this.searchBlock(this.body, callback);
  }
}
class Continuing extends Statement {
  constructor(body) {
    super();
    this.body = body;
  }
  get astNodeType() {
    return "continuing";
  }
  search(callback) {
    this.searchBlock(this.body, callback);
  }
}
class For extends Statement {
  constructor(init2, condition, increment, body) {
    super();
    this.init = init2;
    this.condition = condition;
    this.increment = increment;
    this.body = body;
  }
  get astNodeType() {
    return "for";
  }
  search(callback) {
    var _a2, _b, _c;
    (_a2 = this.init) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
    (_b = this.condition) === null || _b === void 0 ? void 0 : _b.search(callback);
    (_c = this.increment) === null || _c === void 0 ? void 0 : _c.search(callback);
    this.searchBlock(this.body, callback);
  }
}
class Var extends Statement {
  constructor(name2, type, storage, access, value) {
    super();
    this.name = name2;
    this.type = type;
    this.storage = storage;
    this.access = access;
    this.value = value;
  }
  get astNodeType() {
    return "var";
  }
  search(callback) {
    var _a2;
    callback(this);
    (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
  }
}
class Override extends Statement {
  constructor(name2, type, value) {
    super();
    this.name = name2;
    this.type = type;
    this.value = value;
  }
  get astNodeType() {
    return "override";
  }
  search(callback) {
    var _a2;
    (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
  }
}
class Let extends Statement {
  constructor(name2, type, storage, access, value) {
    super();
    this.name = name2;
    this.type = type;
    this.storage = storage;
    this.access = access;
    this.value = value;
  }
  get astNodeType() {
    return "let";
  }
  search(callback) {
    var _a2;
    callback(this);
    (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
  }
}
class Const extends Statement {
  constructor(name2, type, storage, access, value) {
    super();
    this.name = name2;
    this.type = type;
    this.storage = storage;
    this.access = access;
    this.value = value;
  }
  get astNodeType() {
    return "const";
  }
  evaluate(context) {
    return this.value.evaluate(context);
  }
  search(callback) {
    var _a2;
    callback(this);
    (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
  }
}
var IncrementOperator;
(function(IncrementOperator2) {
  IncrementOperator2["increment"] = "++";
  IncrementOperator2["decrement"] = "--";
})(IncrementOperator || (IncrementOperator = {}));
(function(IncrementOperator2) {
  function parse2(val) {
    const key = val;
    if (key == "parse")
      throw new Error("Invalid value for IncrementOperator");
    return IncrementOperator2[key];
  }
  IncrementOperator2.parse = parse2;
})(IncrementOperator || (IncrementOperator = {}));
class Increment extends Statement {
  constructor(operator, variable) {
    super();
    this.operator = operator;
    this.variable = variable;
  }
  get astNodeType() {
    return "increment";
  }
  search(callback) {
    this.variable.search(callback);
  }
}
var AssignOperator;
(function(AssignOperator2) {
  AssignOperator2["assign"] = "=";
  AssignOperator2["addAssign"] = "+=";
  AssignOperator2["subtractAssin"] = "-=";
  AssignOperator2["multiplyAssign"] = "*=";
  AssignOperator2["divideAssign"] = "/=";
  AssignOperator2["moduloAssign"] = "%=";
  AssignOperator2["andAssign"] = "&=";
  AssignOperator2["orAssign"] = "|=";
  AssignOperator2["xorAssign"] = "^=";
  AssignOperator2["shiftLeftAssign"] = "<<=";
  AssignOperator2["shiftRightAssign"] = ">>=";
})(AssignOperator || (AssignOperator = {}));
(function(AssignOperator2) {
  function parse2(val) {
    const key = val;
    if (key == "parse") {
      throw new Error("Invalid value for AssignOperator");
    }
    return key;
  }
  AssignOperator2.parse = parse2;
})(AssignOperator || (AssignOperator = {}));
class Assign extends Statement {
  constructor(operator, variable, value) {
    super();
    this.operator = operator;
    this.variable = variable;
    this.value = value;
  }
  get astNodeType() {
    return "assign";
  }
  search(callback) {
    this.variable.search(callback);
    this.value.search(callback);
  }
}
class Call extends Statement {
  constructor(name2, args) {
    super();
    this.name = name2;
    this.args = args;
  }
  get astNodeType() {
    return "call";
  }
  search(callback) {
    for (const node of this.args) {
      node.search(callback);
    }
    callback(this);
  }
}
class Loop extends Statement {
  constructor(body, continuing) {
    super();
    this.body = body;
    this.continuing = continuing;
  }
  get astNodeType() {
    return "loop";
  }
}
class Switch extends Statement {
  constructor(condition, body) {
    super();
    this.condition = condition;
    this.body = body;
  }
  get astNodeType() {
    return "body";
  }
}
class If extends Statement {
  constructor(condition, body, elseif, _else) {
    super();
    this.condition = condition;
    this.body = body;
    this.elseif = elseif;
    this.else = _else;
  }
  get astNodeType() {
    return "if";
  }
  search(callback) {
    this.condition.search(callback);
    this.searchBlock(this.body, callback);
    this.searchBlock(this.elseif, callback);
    this.searchBlock(this.else, callback);
  }
}
class Return extends Statement {
  constructor(value) {
    super();
    this.value = value;
  }
  get astNodeType() {
    return "return";
  }
  search(callback) {
    var _a2;
    (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
  }
}
class Enable extends Statement {
  constructor(name2) {
    super();
    this.name = name2;
  }
  get astNodeType() {
    return "enable";
  }
}
class Requires extends Statement {
  constructor(extensions) {
    super();
    this.extensions = extensions;
  }
  get astNodeType() {
    return "requires";
  }
}
class Diagnostic extends Statement {
  constructor(severity, rule) {
    super();
    this.severity = severity;
    this.rule = rule;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class Alias extends Statement {
  constructor(name2, type) {
    super();
    this.name = name2;
    this.type = type;
  }
  get astNodeType() {
    return "alias";
  }
}
class Discard extends Statement {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class Break extends Statement {
  constructor() {
    super();
  }
  get astNodeType() {
    return "break";
  }
}
class Continue extends Statement {
  constructor() {
    super();
  }
  get astNodeType() {
    return "continue";
  }
}
class Type extends Statement {
  constructor(name2) {
    super();
    this.name = name2;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return false;
  }
  get isArray() {
    return false;
  }
}
class Struct extends Type {
  constructor(name2, members, startLine, endLine) {
    super(name2);
    this.members = members;
    this.startLine = startLine;
    this.endLine = endLine;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return true;
  }
  /// Return the index of the member with the given name, or -1 if not found.
  getMemberIndex(name2) {
    for (let i = 0; i < this.members.length; i++) {
      if (this.members[i].name == name2)
        return i;
    }
    return -1;
  }
}
class TemplateType extends Type {
  constructor(name2, format2, access) {
    super(name2);
    this.format = format2;
    this.access = access;
  }
  get astNodeType() {
    return "template";
  }
}
class PointerType extends Type {
  constructor(name2, storage, type, access) {
    super(name2);
    this.storage = storage;
    this.type = type;
    this.access = access;
  }
  get astNodeType() {
    return "pointer";
  }
}
class ArrayType extends Type {
  constructor(name2, attributes, format2, count2) {
    super(name2);
    this.attributes = attributes;
    this.format = format2;
    this.count = count2;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return true;
  }
}
class SamplerType extends Type {
  constructor(name2, format2, access) {
    super(name2);
    this.format = format2;
    this.access = access;
  }
  get astNodeType() {
    return "sampler";
  }
}
class Expression extends Node$1 {
  constructor() {
    super();
  }
}
class StringExpr extends Expression {
  constructor(value) {
    super();
    this.value = value;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  evaluateString() {
    return this.value;
  }
}
class CreateExpr extends Expression {
  constructor(type, args) {
    super();
    this.type = type;
    this.args = args;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(callback) {
    callback(this);
    if (this.args) {
      for (const node of this.args) {
        node.search(callback);
      }
    }
  }
  evaluate(context) {
    return this.args[0].evaluate(context);
  }
}
class CallExpr extends Expression {
  constructor(name2, args) {
    super();
    this.name = name2;
    this.args = args;
  }
  get astNodeType() {
    return "callExpr";
  }
  evaluate(context) {
    switch (this.name) {
      case "abs":
        return Math.abs(this.args[0].evaluate(context));
      case "acos":
        return Math.acos(this.args[0].evaluate(context));
      case "acosh":
        return Math.acosh(this.args[0].evaluate(context));
      case "asin":
        return Math.asin(this.args[0].evaluate(context));
      case "asinh":
        return Math.asinh(this.args[0].evaluate(context));
      case "atan":
        return Math.atan(this.args[0].evaluate(context));
      case "atan2":
        return Math.atan2(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "atanh":
        return Math.atanh(this.args[0].evaluate(context));
      case "ceil":
        return Math.ceil(this.args[0].evaluate(context));
      case "clamp":
        return Math.min(Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context)), this.args[2].evaluate(context));
      case "cos":
        return Math.cos(this.args[0].evaluate(context));
      //case "cross":
      //TODO: (x[i] * y[j] - x[j] * y[i])
      case "degrees":
        return this.args[0].evaluate(context) * 180 / Math.PI;
      //case "determinant":
      //TODO implement
      case "distance":
        return Math.sqrt(Math.pow(this.args[0].evaluate(context) - this.args[1].evaluate(context), 2));
      case "dot":
      //TODO: (x[i] * y[i])
      case "exp":
        return Math.exp(this.args[0].evaluate(context));
      case "exp2":
        return Math.pow(2, this.args[0].evaluate(context));
      //case "extractBits":
      //TODO: implement
      //case "firstLeadingBit":
      //TODO: implement
      case "floor":
        return Math.floor(this.args[0].evaluate(context));
      case "fma":
        return this.args[0].evaluate(context) * this.args[1].evaluate(context) + this.args[2].evaluate(context);
      case "fract":
        return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
      //case "frexp":
      //TODO: implement
      case "inverseSqrt":
        return 1 / Math.sqrt(this.args[0].evaluate(context));
      //case "length":
      //TODO: implement
      case "log":
        return Math.log(this.args[0].evaluate(context));
      case "log2":
        return Math.log2(this.args[0].evaluate(context));
      case "max":
        return Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "min":
        return Math.min(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "mix":
        return this.args[0].evaluate(context) * (1 - this.args[2].evaluate(context)) + this.args[1].evaluate(context) * this.args[2].evaluate(context);
      case "modf":
        return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
      case "pow":
        return Math.pow(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "radians":
        return this.args[0].evaluate(context) * Math.PI / 180;
      case "round":
        return Math.round(this.args[0].evaluate(context));
      case "sign":
        return Math.sign(this.args[0].evaluate(context));
      case "sin":
        return Math.sin(this.args[0].evaluate(context));
      case "sinh":
        return Math.sinh(this.args[0].evaluate(context));
      case "saturate":
        return Math.min(Math.max(this.args[0].evaluate(context), 0), 1);
      case "smoothstep":
        return this.args[0].evaluate(context) * this.args[0].evaluate(context) * (3 - 2 * this.args[0].evaluate(context));
      case "sqrt":
        return Math.sqrt(this.args[0].evaluate(context));
      case "step":
        return this.args[0].evaluate(context) < this.args[1].evaluate(context) ? 0 : 1;
      case "tan":
        return Math.tan(this.args[0].evaluate(context));
      case "tanh":
        return Math.tanh(this.args[0].evaluate(context));
      case "trunc":
        return Math.trunc(this.args[0].evaluate(context));
      default:
        throw new Error("Non const function: " + this.name);
    }
  }
  search(callback) {
    for (const node of this.args) {
      node.search(callback);
    }
    callback(this);
  }
}
class VariableExpr extends Expression {
  constructor(name2) {
    super();
    this.name = name2;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(callback) {
    callback(this);
    if (this.postfix) {
      this.postfix.search(callback);
    }
  }
  evaluate(context) {
    const constant2 = context.constants.get(this.name);
    if (!constant2) {
      throw new Error("Cannot evaluate node");
    }
    return constant2.evaluate(context);
  }
}
class ConstExpr extends Expression {
  constructor(name2, initializer) {
    super();
    this.name = name2;
    this.initializer = initializer;
  }
  get astNodeType() {
    return "constExpr";
  }
  evaluate(context) {
    var _a2, _b;
    if (this.initializer instanceof CreateExpr) {
      const property = (_a2 = this.postfix) === null || _a2 === void 0 ? void 0 : _a2.evaluateString(context);
      const type = (_b = this.initializer.type) === null || _b === void 0 ? void 0 : _b.name;
      const struct = context.structs.get(type);
      const memberIndex = struct === null || struct === void 0 ? void 0 : struct.getMemberIndex(property);
      if (memberIndex !== void 0 && memberIndex != -1) {
        const value = this.initializer.args[memberIndex].evaluate(context);
        return value;
      } else {
        return this.initializer.evaluate(context);
      }
    }
    return this.initializer.evaluate(context);
  }
  search(callback) {
    this.initializer.search(callback);
  }
}
class LiteralExpr extends Expression {
  constructor(value) {
    super();
    this.value = value;
  }
  get astNodeType() {
    return "literalExpr";
  }
  evaluate() {
    return this.value;
  }
}
class BitcastExpr extends Expression {
  constructor(type, value) {
    super();
    this.type = type;
    this.value = value;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(callback) {
    this.value.search(callback);
  }
}
class GroupingExpr extends Expression {
  constructor(contents) {
    super();
    this.contents = contents;
  }
  get astNodeType() {
    return "groupExpr";
  }
  evaluate(context) {
    return this.contents[0].evaluate(context);
  }
  search(callback) {
    this.searchBlock(this.contents, callback);
  }
}
class ArrayIndex extends Expression {
  constructor(index2) {
    super();
    this.index = index2;
  }
  search(callback) {
    this.index.search(callback);
  }
}
class Operator extends Expression {
  constructor() {
    super();
  }
}
class UnaryOperator extends Operator {
  constructor(operator, right) {
    super();
    this.operator = operator;
    this.right = right;
  }
  get astNodeType() {
    return "unaryOp";
  }
  evaluate(context) {
    switch (this.operator) {
      case "+":
        return this.right.evaluate(context);
      case "-":
        return -this.right.evaluate(context);
      case "!":
        return this.right.evaluate(context) ? 0 : 1;
      case "~":
        return ~this.right.evaluate(context);
      default:
        throw new Error("Unknown unary operator: " + this.operator);
    }
  }
  search(callback) {
    this.right.search(callback);
  }
}
class BinaryOperator extends Operator {
  constructor(operator, left, right) {
    super();
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
  get astNodeType() {
    return "binaryOp";
  }
  evaluate(context) {
    switch (this.operator) {
      case "+":
        return this.left.evaluate(context) + this.right.evaluate(context);
      case "-":
        return this.left.evaluate(context) - this.right.evaluate(context);
      case "*":
        return this.left.evaluate(context) * this.right.evaluate(context);
      case "/":
        return this.left.evaluate(context) / this.right.evaluate(context);
      case "%":
        return this.left.evaluate(context) % this.right.evaluate(context);
      case "==":
        return this.left.evaluate(context) == this.right.evaluate(context) ? 1 : 0;
      case "!=":
        return this.left.evaluate(context) != this.right.evaluate(context) ? 1 : 0;
      case "<":
        return this.left.evaluate(context) < this.right.evaluate(context) ? 1 : 0;
      case ">":
        return this.left.evaluate(context) > this.right.evaluate(context) ? 1 : 0;
      case "<=":
        return this.left.evaluate(context) <= this.right.evaluate(context) ? 1 : 0;
      case ">=":
        return this.left.evaluate(context) >= this.right.evaluate(context) ? 1 : 0;
      case "&&":
        return this.left.evaluate(context) && this.right.evaluate(context) ? 1 : 0;
      case "||":
        return this.left.evaluate(context) || this.right.evaluate(context) ? 1 : 0;
      default:
        throw new Error(`Unknown operator ${this.operator}`);
    }
  }
  search(callback) {
    this.left.search(callback);
    this.right.search(callback);
  }
}
class SwitchCase extends Node$1 {
  constructor() {
    super();
  }
}
class Case extends SwitchCase {
  constructor(selector, body) {
    super();
    this.selector = selector;
    this.body = body;
  }
  get astNodeType() {
    return "case";
  }
  search(callback) {
    this.searchBlock(this.body, callback);
  }
}
class Default extends SwitchCase {
  constructor(body) {
    super();
    this.body = body;
  }
  get astNodeType() {
    return "default";
  }
  search(callback) {
    this.searchBlock(this.body, callback);
  }
}
class Argument extends Node$1 {
  constructor(name2, type, attributes) {
    super();
    this.name = name2;
    this.type = type;
    this.attributes = attributes;
  }
  get astNodeType() {
    return "argument";
  }
}
class ElseIf extends Node$1 {
  constructor(condition, body) {
    super();
    this.condition = condition;
    this.body = body;
  }
  get astNodeType() {
    return "elseif";
  }
  search(callback) {
    this.condition.search(callback);
    this.searchBlock(this.body, callback);
  }
}
class Member extends Node$1 {
  constructor(name2, type, attributes) {
    super();
    this.name = name2;
    this.type = type;
    this.attributes = attributes;
  }
  get astNodeType() {
    return "member";
  }
}
let Attribute$1 = class Attribute extends Node$1 {
  constructor(name2, value) {
    super();
    this.name = name2;
    this.value = value;
  }
  get astNodeType() {
    return "attribute";
  }
};
var _a;
var TokenClass;
(function(TokenClass2) {
  TokenClass2[TokenClass2["token"] = 0] = "token";
  TokenClass2[TokenClass2["keyword"] = 1] = "keyword";
  TokenClass2[TokenClass2["reserved"] = 2] = "reserved";
})(TokenClass || (TokenClass = {}));
class TokenType {
  constructor(name2, type, rule) {
    this.name = name2;
    this.type = type;
    this.rule = rule;
  }
  toString() {
    return this.name;
  }
}
class TokenTypes {
}
_a = TokenTypes;
TokenTypes.none = new TokenType("", TokenClass.reserved, "");
TokenTypes.eof = new TokenType("EOF", TokenClass.token, "");
TokenTypes.reserved = {
  asm: new TokenType("asm", TokenClass.reserved, "asm"),
  bf16: new TokenType("bf16", TokenClass.reserved, "bf16"),
  do: new TokenType("do", TokenClass.reserved, "do"),
  enum: new TokenType("enum", TokenClass.reserved, "enum"),
  f16: new TokenType("f16", TokenClass.reserved, "f16"),
  f64: new TokenType("f64", TokenClass.reserved, "f64"),
  handle: new TokenType("handle", TokenClass.reserved, "handle"),
  i8: new TokenType("i8", TokenClass.reserved, "i8"),
  i16: new TokenType("i16", TokenClass.reserved, "i16"),
  i64: new TokenType("i64", TokenClass.reserved, "i64"),
  mat: new TokenType("mat", TokenClass.reserved, "mat"),
  premerge: new TokenType("premerge", TokenClass.reserved, "premerge"),
  regardless: new TokenType("regardless", TokenClass.reserved, "regardless"),
  typedef: new TokenType("typedef", TokenClass.reserved, "typedef"),
  u8: new TokenType("u8", TokenClass.reserved, "u8"),
  u16: new TokenType("u16", TokenClass.reserved, "u16"),
  u64: new TokenType("u64", TokenClass.reserved, "u64"),
  unless: new TokenType("unless", TokenClass.reserved, "unless"),
  using: new TokenType("using", TokenClass.reserved, "using"),
  vec: new TokenType("vec", TokenClass.reserved, "vec"),
  void: new TokenType("void", TokenClass.reserved, "void")
};
TokenTypes.keywords = {
  array: new TokenType("array", TokenClass.keyword, "array"),
  atomic: new TokenType("atomic", TokenClass.keyword, "atomic"),
  bool: new TokenType("bool", TokenClass.keyword, "bool"),
  f32: new TokenType("f32", TokenClass.keyword, "f32"),
  i32: new TokenType("i32", TokenClass.keyword, "i32"),
  mat2x2: new TokenType("mat2x2", TokenClass.keyword, "mat2x2"),
  mat2x3: new TokenType("mat2x3", TokenClass.keyword, "mat2x3"),
  mat2x4: new TokenType("mat2x4", TokenClass.keyword, "mat2x4"),
  mat3x2: new TokenType("mat3x2", TokenClass.keyword, "mat3x2"),
  mat3x3: new TokenType("mat3x3", TokenClass.keyword, "mat3x3"),
  mat3x4: new TokenType("mat3x4", TokenClass.keyword, "mat3x4"),
  mat4x2: new TokenType("mat4x2", TokenClass.keyword, "mat4x2"),
  mat4x3: new TokenType("mat4x3", TokenClass.keyword, "mat4x3"),
  mat4x4: new TokenType("mat4x4", TokenClass.keyword, "mat4x4"),
  ptr: new TokenType("ptr", TokenClass.keyword, "ptr"),
  sampler: new TokenType("sampler", TokenClass.keyword, "sampler"),
  sampler_comparison: new TokenType("sampler_comparison", TokenClass.keyword, "sampler_comparison"),
  struct: new TokenType("struct", TokenClass.keyword, "struct"),
  texture_1d: new TokenType("texture_1d", TokenClass.keyword, "texture_1d"),
  texture_2d: new TokenType("texture_2d", TokenClass.keyword, "texture_2d"),
  texture_2d_array: new TokenType("texture_2d_array", TokenClass.keyword, "texture_2d_array"),
  texture_3d: new TokenType("texture_3d", TokenClass.keyword, "texture_3d"),
  texture_cube: new TokenType("texture_cube", TokenClass.keyword, "texture_cube"),
  texture_cube_array: new TokenType("texture_cube_array", TokenClass.keyword, "texture_cube_array"),
  texture_multisampled_2d: new TokenType("texture_multisampled_2d", TokenClass.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new TokenType("texture_storage_1d", TokenClass.keyword, "texture_storage_1d"),
  texture_storage_2d: new TokenType("texture_storage_2d", TokenClass.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new TokenType("texture_storage_2d_array", TokenClass.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new TokenType("texture_storage_3d", TokenClass.keyword, "texture_storage_3d"),
  texture_depth_2d: new TokenType("texture_depth_2d", TokenClass.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new TokenType("texture_depth_2d_array", TokenClass.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new TokenType("texture_depth_cube", TokenClass.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new TokenType("texture_depth_cube_array", TokenClass.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new TokenType("texture_depth_multisampled_2d", TokenClass.keyword, "texture_depth_multisampled_2d"),
  texture_external: new TokenType("texture_external", TokenClass.keyword, "texture_external"),
  u32: new TokenType("u32", TokenClass.keyword, "u32"),
  vec2: new TokenType("vec2", TokenClass.keyword, "vec2"),
  vec3: new TokenType("vec3", TokenClass.keyword, "vec3"),
  vec4: new TokenType("vec4", TokenClass.keyword, "vec4"),
  bitcast: new TokenType("bitcast", TokenClass.keyword, "bitcast"),
  block: new TokenType("block", TokenClass.keyword, "block"),
  break: new TokenType("break", TokenClass.keyword, "break"),
  case: new TokenType("case", TokenClass.keyword, "case"),
  continue: new TokenType("continue", TokenClass.keyword, "continue"),
  continuing: new TokenType("continuing", TokenClass.keyword, "continuing"),
  default: new TokenType("default", TokenClass.keyword, "default"),
  diagnostic: new TokenType("diagnostic", TokenClass.keyword, "diagnostic"),
  discard: new TokenType("discard", TokenClass.keyword, "discard"),
  else: new TokenType("else", TokenClass.keyword, "else"),
  enable: new TokenType("enable", TokenClass.keyword, "enable"),
  fallthrough: new TokenType("fallthrough", TokenClass.keyword, "fallthrough"),
  false: new TokenType("false", TokenClass.keyword, "false"),
  fn: new TokenType("fn", TokenClass.keyword, "fn"),
  for: new TokenType("for", TokenClass.keyword, "for"),
  function: new TokenType("function", TokenClass.keyword, "function"),
  if: new TokenType("if", TokenClass.keyword, "if"),
  let: new TokenType("let", TokenClass.keyword, "let"),
  const: new TokenType("const", TokenClass.keyword, "const"),
  loop: new TokenType("loop", TokenClass.keyword, "loop"),
  while: new TokenType("while", TokenClass.keyword, "while"),
  private: new TokenType("private", TokenClass.keyword, "private"),
  read: new TokenType("read", TokenClass.keyword, "read"),
  read_write: new TokenType("read_write", TokenClass.keyword, "read_write"),
  return: new TokenType("return", TokenClass.keyword, "return"),
  requires: new TokenType("requires", TokenClass.keyword, "requires"),
  storage: new TokenType("storage", TokenClass.keyword, "storage"),
  switch: new TokenType("switch", TokenClass.keyword, "switch"),
  true: new TokenType("true", TokenClass.keyword, "true"),
  alias: new TokenType("alias", TokenClass.keyword, "alias"),
  type: new TokenType("type", TokenClass.keyword, "type"),
  uniform: new TokenType("uniform", TokenClass.keyword, "uniform"),
  var: new TokenType("var", TokenClass.keyword, "var"),
  override: new TokenType("override", TokenClass.keyword, "override"),
  workgroup: new TokenType("workgroup", TokenClass.keyword, "workgroup"),
  write: new TokenType("write", TokenClass.keyword, "write"),
  r8unorm: new TokenType("r8unorm", TokenClass.keyword, "r8unorm"),
  r8snorm: new TokenType("r8snorm", TokenClass.keyword, "r8snorm"),
  r8uint: new TokenType("r8uint", TokenClass.keyword, "r8uint"),
  r8sint: new TokenType("r8sint", TokenClass.keyword, "r8sint"),
  r16uint: new TokenType("r16uint", TokenClass.keyword, "r16uint"),
  r16sint: new TokenType("r16sint", TokenClass.keyword, "r16sint"),
  r16float: new TokenType("r16float", TokenClass.keyword, "r16float"),
  rg8unorm: new TokenType("rg8unorm", TokenClass.keyword, "rg8unorm"),
  rg8snorm: new TokenType("rg8snorm", TokenClass.keyword, "rg8snorm"),
  rg8uint: new TokenType("rg8uint", TokenClass.keyword, "rg8uint"),
  rg8sint: new TokenType("rg8sint", TokenClass.keyword, "rg8sint"),
  r32uint: new TokenType("r32uint", TokenClass.keyword, "r32uint"),
  r32sint: new TokenType("r32sint", TokenClass.keyword, "r32sint"),
  r32float: new TokenType("r32float", TokenClass.keyword, "r32float"),
  rg16uint: new TokenType("rg16uint", TokenClass.keyword, "rg16uint"),
  rg16sint: new TokenType("rg16sint", TokenClass.keyword, "rg16sint"),
  rg16float: new TokenType("rg16float", TokenClass.keyword, "rg16float"),
  rgba8unorm: new TokenType("rgba8unorm", TokenClass.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new TokenType("rgba8unorm_srgb", TokenClass.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new TokenType("rgba8snorm", TokenClass.keyword, "rgba8snorm"),
  rgba8uint: new TokenType("rgba8uint", TokenClass.keyword, "rgba8uint"),
  rgba8sint: new TokenType("rgba8sint", TokenClass.keyword, "rgba8sint"),
  bgra8unorm: new TokenType("bgra8unorm", TokenClass.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new TokenType("bgra8unorm_srgb", TokenClass.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new TokenType("rgb10a2unorm", TokenClass.keyword, "rgb10a2unorm"),
  rg11b10float: new TokenType("rg11b10float", TokenClass.keyword, "rg11b10float"),
  rg32uint: new TokenType("rg32uint", TokenClass.keyword, "rg32uint"),
  rg32sint: new TokenType("rg32sint", TokenClass.keyword, "rg32sint"),
  rg32float: new TokenType("rg32float", TokenClass.keyword, "rg32float"),
  rgba16uint: new TokenType("rgba16uint", TokenClass.keyword, "rgba16uint"),
  rgba16sint: new TokenType("rgba16sint", TokenClass.keyword, "rgba16sint"),
  rgba16float: new TokenType("rgba16float", TokenClass.keyword, "rgba16float"),
  rgba32uint: new TokenType("rgba32uint", TokenClass.keyword, "rgba32uint"),
  rgba32sint: new TokenType("rgba32sint", TokenClass.keyword, "rgba32sint"),
  rgba32float: new TokenType("rgba32float", TokenClass.keyword, "rgba32float"),
  static_assert: new TokenType("static_assert", TokenClass.keyword, "static_assert")
  // WGSL grammar has a few keywords that have different token names than the strings they
  // represent. Aliasing them here.
  /*int32: new TokenType("i32", TokenClass.keyword, "i32"),
      uint32: new TokenType("u32", TokenClass.keyword, "u32"),
      float32: new TokenType("f32", TokenClass.keyword, "f32"),
      pointer: new TokenType("ptr", TokenClass.keyword, "ptr"),*/
};
TokenTypes.tokens = {
  decimal_float_literal: new TokenType("decimal_float_literal", TokenClass.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
  hex_float_literal: new TokenType("hex_float_literal", TokenClass.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
  int_literal: new TokenType("int_literal", TokenClass.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
  uint_literal: new TokenType("uint_literal", TokenClass.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  ident: new TokenType("ident", TokenClass.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  and: new TokenType("and", TokenClass.token, "&"),
  and_and: new TokenType("and_and", TokenClass.token, "&&"),
  arrow: new TokenType("arrow ", TokenClass.token, "->"),
  attr: new TokenType("attr", TokenClass.token, "@"),
  forward_slash: new TokenType("forward_slash", TokenClass.token, "/"),
  bang: new TokenType("bang", TokenClass.token, "!"),
  bracket_left: new TokenType("bracket_left", TokenClass.token, "["),
  bracket_right: new TokenType("bracket_right", TokenClass.token, "]"),
  brace_left: new TokenType("brace_left", TokenClass.token, "{"),
  brace_right: new TokenType("brace_right", TokenClass.token, "}"),
  colon: new TokenType("colon", TokenClass.token, ":"),
  comma: new TokenType("comma", TokenClass.token, ","),
  equal: new TokenType("equal", TokenClass.token, "="),
  equal_equal: new TokenType("equal_equal", TokenClass.token, "=="),
  not_equal: new TokenType("not_equal", TokenClass.token, "!="),
  greater_than: new TokenType("greater_than", TokenClass.token, ">"),
  greater_than_equal: new TokenType("greater_than_equal", TokenClass.token, ">="),
  shift_right: new TokenType("shift_right", TokenClass.token, ">>"),
  less_than: new TokenType("less_than", TokenClass.token, "<"),
  less_than_equal: new TokenType("less_than_equal", TokenClass.token, "<="),
  shift_left: new TokenType("shift_left", TokenClass.token, "<<"),
  modulo: new TokenType("modulo", TokenClass.token, "%"),
  minus: new TokenType("minus", TokenClass.token, "-"),
  minus_minus: new TokenType("minus_minus", TokenClass.token, "--"),
  period: new TokenType("period", TokenClass.token, "."),
  plus: new TokenType("plus", TokenClass.token, "+"),
  plus_plus: new TokenType("plus_plus", TokenClass.token, "++"),
  or: new TokenType("or", TokenClass.token, "|"),
  or_or: new TokenType("or_or", TokenClass.token, "||"),
  paren_left: new TokenType("paren_left", TokenClass.token, "("),
  paren_right: new TokenType("paren_right", TokenClass.token, ")"),
  semicolon: new TokenType("semicolon", TokenClass.token, ";"),
  star: new TokenType("star", TokenClass.token, "*"),
  tilde: new TokenType("tilde", TokenClass.token, "~"),
  underscore: new TokenType("underscore", TokenClass.token, "_"),
  xor: new TokenType("xor", TokenClass.token, "^"),
  plus_equal: new TokenType("plus_equal", TokenClass.token, "+="),
  minus_equal: new TokenType("minus_equal", TokenClass.token, "-="),
  times_equal: new TokenType("times_equal", TokenClass.token, "*="),
  division_equal: new TokenType("division_equal", TokenClass.token, "/="),
  modulo_equal: new TokenType("modulo_equal", TokenClass.token, "%="),
  and_equal: new TokenType("and_equal", TokenClass.token, "&="),
  or_equal: new TokenType("or_equal", TokenClass.token, "|="),
  xor_equal: new TokenType("xor_equal", TokenClass.token, "^="),
  shift_right_equal: new TokenType("shift_right_equal", TokenClass.token, ">>="),
  shift_left_equal: new TokenType("shift_left_equal", TokenClass.token, "<<=")
};
TokenTypes.simpleTokens = {
  "@": _a.tokens.attr,
  "{": _a.tokens.brace_left,
  "}": _a.tokens.brace_right,
  ":": _a.tokens.colon,
  ",": _a.tokens.comma,
  "(": _a.tokens.paren_left,
  ")": _a.tokens.paren_right,
  ";": _a.tokens.semicolon
};
TokenTypes.literalTokens = {
  "&": _a.tokens.and,
  "&&": _a.tokens.and_and,
  "->": _a.tokens.arrow,
  "/": _a.tokens.forward_slash,
  "!": _a.tokens.bang,
  "[": _a.tokens.bracket_left,
  "]": _a.tokens.bracket_right,
  "=": _a.tokens.equal,
  "==": _a.tokens.equal_equal,
  "!=": _a.tokens.not_equal,
  ">": _a.tokens.greater_than,
  ">=": _a.tokens.greater_than_equal,
  ">>": _a.tokens.shift_right,
  "<": _a.tokens.less_than,
  "<=": _a.tokens.less_than_equal,
  "<<": _a.tokens.shift_left,
  "%": _a.tokens.modulo,
  "-": _a.tokens.minus,
  "--": _a.tokens.minus_minus,
  ".": _a.tokens.period,
  "+": _a.tokens.plus,
  "++": _a.tokens.plus_plus,
  "|": _a.tokens.or,
  "||": _a.tokens.or_or,
  "*": _a.tokens.star,
  "~": _a.tokens.tilde,
  "_": _a.tokens.underscore,
  "^": _a.tokens.xor,
  "+=": _a.tokens.plus_equal,
  "-=": _a.tokens.minus_equal,
  "*=": _a.tokens.times_equal,
  "/=": _a.tokens.division_equal,
  "%=": _a.tokens.modulo_equal,
  "&=": _a.tokens.and_equal,
  "|=": _a.tokens.or_equal,
  "^=": _a.tokens.xor_equal,
  ">>=": _a.tokens.shift_right_equal,
  "<<=": _a.tokens.shift_left_equal
};
TokenTypes.regexTokens = {
  decimal_float_literal: _a.tokens.decimal_float_literal,
  hex_float_literal: _a.tokens.hex_float_literal,
  int_literal: _a.tokens.int_literal,
  uint_literal: _a.tokens.uint_literal,
  ident: _a.tokens.ident
};
TokenTypes.storage_class = [
  _a.keywords.function,
  _a.keywords.private,
  _a.keywords.workgroup,
  _a.keywords.uniform,
  _a.keywords.storage
];
TokenTypes.access_mode = [
  _a.keywords.read,
  _a.keywords.write,
  _a.keywords.read_write
];
TokenTypes.sampler_type = [
  _a.keywords.sampler,
  _a.keywords.sampler_comparison
];
TokenTypes.sampled_texture_type = [
  _a.keywords.texture_1d,
  _a.keywords.texture_2d,
  _a.keywords.texture_2d_array,
  _a.keywords.texture_3d,
  _a.keywords.texture_cube,
  _a.keywords.texture_cube_array
];
TokenTypes.multisampled_texture_type = [
  _a.keywords.texture_multisampled_2d
];
TokenTypes.storage_texture_type = [
  _a.keywords.texture_storage_1d,
  _a.keywords.texture_storage_2d,
  _a.keywords.texture_storage_2d_array,
  _a.keywords.texture_storage_3d
];
TokenTypes.depth_texture_type = [
  _a.keywords.texture_depth_2d,
  _a.keywords.texture_depth_2d_array,
  _a.keywords.texture_depth_cube,
  _a.keywords.texture_depth_cube_array,
  _a.keywords.texture_depth_multisampled_2d
];
TokenTypes.texture_external_type = [_a.keywords.texture_external];
TokenTypes.any_texture_type = [
  ..._a.sampled_texture_type,
  ..._a.multisampled_texture_type,
  ..._a.storage_texture_type,
  ..._a.depth_texture_type,
  ..._a.texture_external_type
];
TokenTypes.texel_format = [
  _a.keywords.r8unorm,
  _a.keywords.r8snorm,
  _a.keywords.r8uint,
  _a.keywords.r8sint,
  _a.keywords.r16uint,
  _a.keywords.r16sint,
  _a.keywords.r16float,
  _a.keywords.rg8unorm,
  _a.keywords.rg8snorm,
  _a.keywords.rg8uint,
  _a.keywords.rg8sint,
  _a.keywords.r32uint,
  _a.keywords.r32sint,
  _a.keywords.r32float,
  _a.keywords.rg16uint,
  _a.keywords.rg16sint,
  _a.keywords.rg16float,
  _a.keywords.rgba8unorm,
  _a.keywords.rgba8unorm_srgb,
  _a.keywords.rgba8snorm,
  _a.keywords.rgba8uint,
  _a.keywords.rgba8sint,
  _a.keywords.bgra8unorm,
  _a.keywords.bgra8unorm_srgb,
  _a.keywords.rgb10a2unorm,
  _a.keywords.rg11b10float,
  _a.keywords.rg32uint,
  _a.keywords.rg32sint,
  _a.keywords.rg32float,
  _a.keywords.rgba16uint,
  _a.keywords.rgba16sint,
  _a.keywords.rgba16float,
  _a.keywords.rgba32uint,
  _a.keywords.rgba32sint,
  _a.keywords.rgba32float
];
TokenTypes.const_literal = [
  _a.tokens.int_literal,
  _a.tokens.uint_literal,
  _a.tokens.decimal_float_literal,
  _a.tokens.hex_float_literal,
  _a.keywords.true,
  _a.keywords.false
];
TokenTypes.literal_or_ident = [
  _a.tokens.ident,
  _a.tokens.int_literal,
  _a.tokens.uint_literal,
  _a.tokens.decimal_float_literal,
  _a.tokens.hex_float_literal
];
TokenTypes.element_count_expression = [
  _a.tokens.int_literal,
  _a.tokens.uint_literal,
  _a.tokens.ident
];
TokenTypes.template_types = [
  _a.keywords.vec2,
  _a.keywords.vec3,
  _a.keywords.vec4,
  _a.keywords.mat2x2,
  _a.keywords.mat2x3,
  _a.keywords.mat2x4,
  _a.keywords.mat3x2,
  _a.keywords.mat3x3,
  _a.keywords.mat3x4,
  _a.keywords.mat4x2,
  _a.keywords.mat4x3,
  _a.keywords.mat4x4,
  _a.keywords.atomic,
  _a.keywords.bitcast,
  ..._a.any_texture_type
];
TokenTypes.attribute_name = [_a.tokens.ident, _a.keywords.block, _a.keywords.diagnostic];
TokenTypes.assignment_operators = [
  _a.tokens.equal,
  _a.tokens.plus_equal,
  _a.tokens.minus_equal,
  _a.tokens.times_equal,
  _a.tokens.division_equal,
  _a.tokens.modulo_equal,
  _a.tokens.and_equal,
  _a.tokens.or_equal,
  _a.tokens.xor_equal,
  _a.tokens.shift_right_equal,
  _a.tokens.shift_left_equal
];
TokenTypes.increment_operators = [
  _a.tokens.plus_plus,
  _a.tokens.minus_minus
];
class Token {
  constructor(type, lexeme, line) {
    this.type = type;
    this.lexeme = lexeme;
    this.line = line;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return TokenTypes.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == TokenTypes.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
class WgslScanner {
  constructor(source) {
    this._tokens = [];
    this._start = 0;
    this._current = 0;
    this._line = 1;
    this._source = source !== null && source !== void 0 ? source : "";
  }
  /// Scan all tokens from the source.
  scanTokens() {
    while (!this._isAtEnd()) {
      this._start = this._current;
      if (!this.scanToken()) {
        throw `Invalid syntax at line ${this._line}`;
      }
    }
    this._tokens.push(new Token(TokenTypes.eof, "", this._line));
    return this._tokens;
  }
  /// Scan a single token from the source.
  scanToken() {
    let lexeme = this._advance();
    if (lexeme == "\n") {
      this._line++;
      return true;
    }
    if (this._isWhitespace(lexeme)) {
      return true;
    }
    if (lexeme == "/") {
      if (this._peekAhead() == "/") {
        while (lexeme != "\n") {
          if (this._isAtEnd()) {
            return true;
          }
          lexeme = this._advance();
        }
        this._line++;
        return true;
      } else if (this._peekAhead() == "*") {
        this._advance();
        let commentLevel = 1;
        while (commentLevel > 0) {
          if (this._isAtEnd()) {
            return true;
          }
          lexeme = this._advance();
          if (lexeme == "\n") {
            this._line++;
          } else if (lexeme == "*") {
            if (this._peekAhead() == "/") {
              this._advance();
              commentLevel--;
              if (commentLevel == 0) {
                return true;
              }
            }
          } else if (lexeme == "/") {
            if (this._peekAhead() == "*") {
              this._advance();
              commentLevel++;
            }
          }
        }
        return true;
      }
    }
    const simpleToken = TokenTypes.simpleTokens[lexeme];
    if (simpleToken) {
      this._addToken(simpleToken);
      return true;
    }
    let matchType = TokenTypes.none;
    const isAlpha = this._isAlpha(lexeme);
    const isUnderscore = lexeme === "_";
    if (this._isAlphaNumeric(lexeme)) {
      let nextChar = this._peekAhead();
      while (this._isAlphaNumeric(nextChar)) {
        lexeme += this._advance();
        nextChar = this._peekAhead();
      }
    }
    if (isAlpha) {
      const matchedType = TokenTypes.keywords[lexeme];
      if (matchedType) {
        this._addToken(matchedType);
        return true;
      }
    }
    if (isAlpha || isUnderscore) {
      this._addToken(TokenTypes.tokens.ident);
      return true;
    }
    for (; ; ) {
      let matchedType = this._findType(lexeme);
      const nextLexeme = this._peekAhead();
      if (lexeme == "-" && this._tokens.length > 0) {
        if (nextLexeme == "=") {
          this._current++;
          lexeme += nextLexeme;
          this._addToken(TokenTypes.tokens.minus_equal);
          return true;
        }
        if (nextLexeme == "-") {
          this._current++;
          lexeme += nextLexeme;
          this._addToken(TokenTypes.tokens.minus_minus);
          return true;
        }
        const ti = this._tokens.length - 1;
        const isIdentOrLiteral = TokenTypes.literal_or_ident.indexOf(this._tokens[ti].type) != -1;
        if ((isIdentOrLiteral || this._tokens[ti].type == TokenTypes.tokens.paren_right) && nextLexeme != ">") {
          this._addToken(matchedType);
          return true;
        }
      }
      if (lexeme == ">" && (nextLexeme == ">" || nextLexeme == "=")) {
        let foundLessThan = false;
        let ti = this._tokens.length - 1;
        for (let count2 = 0; count2 < 5 && ti >= 0; ++count2, --ti) {
          if (TokenTypes.assignment_operators.indexOf(this._tokens[ti].type) !== -1) {
            break;
          }
          if (this._tokens[ti].type === TokenTypes.tokens.less_than) {
            if (ti > 0 && this._tokens[ti - 1].isArrayOrTemplateType()) {
              foundLessThan = true;
            }
            break;
          }
        }
        if (foundLessThan) {
          this._addToken(matchedType);
          return true;
        }
      }
      if (matchedType === TokenTypes.none) {
        let lookAheadLexeme = lexeme;
        let lookAhead = 0;
        const maxLookAhead = 2;
        for (let li = 0; li < maxLookAhead; ++li) {
          lookAheadLexeme += this._peekAhead(li);
          matchedType = this._findType(lookAheadLexeme);
          if (matchedType !== TokenTypes.none) {
            lookAhead = li;
            break;
          }
        }
        if (matchedType === TokenTypes.none) {
          if (matchType === TokenTypes.none) {
            return false;
          }
          this._current--;
          this._addToken(matchType);
          return true;
        }
        lexeme = lookAheadLexeme;
        this._current += lookAhead + 1;
      }
      matchType = matchedType;
      if (this._isAtEnd()) {
        break;
      }
      lexeme += this._advance();
    }
    if (matchType === TokenTypes.none) {
      return false;
    }
    this._addToken(matchType);
    return true;
  }
  _findType(lexeme) {
    for (const name2 in TokenTypes.regexTokens) {
      const type2 = TokenTypes.regexTokens[name2];
      if (this._match(lexeme, type2.rule)) {
        return type2;
      }
    }
    const type = TokenTypes.literalTokens[lexeme];
    if (type) {
      return type;
    }
    return TokenTypes.none;
  }
  _match(lexeme, rule) {
    const match = rule.exec(lexeme);
    return match && match.index == 0 && match[0] == lexeme;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(c2) {
    return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z";
  }
  _isAlphaNumeric(c2) {
    return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 == "_" || c2 >= "0" && c2 <= "9";
  }
  _isWhitespace(c2) {
    return c2 == " " || c2 == "	" || c2 == "\r";
  }
  _advance(amount = 0) {
    let c2 = this._source[this._current];
    amount = amount || 0;
    amount++;
    this._current += amount;
    return c2;
  }
  _peekAhead(offset2 = 0) {
    offset2 = offset2 || 0;
    if (this._current + offset2 >= this._source.length) {
      return "\0";
    }
    return this._source[this._current + offset2];
  }
  _addToken(type) {
    const text = this._source.substring(this._start, this._current);
    this._tokens.push(new Token(type, text, this._line));
  }
}
class WgslParser {
  constructor() {
    this._tokens = [];
    this._current = 0;
    this._currentLine = 0;
    this._context = new ParseContext();
    this._deferArrayCountEval = [];
  }
  parse(tokensOrCode) {
    this._initialize(tokensOrCode);
    this._deferArrayCountEval.length = 0;
    const statements = [];
    while (!this._isAtEnd()) {
      const statement = this._global_decl_or_directive();
      if (!statement) {
        break;
      }
      statements.push(statement);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const arrayDecl of this._deferArrayCountEval) {
        const arrayType = arrayDecl["arrayType"];
        const countNode = arrayDecl["countNode"];
        if (countNode instanceof VariableExpr) {
          const variable = countNode;
          const name2 = variable.name;
          const constant2 = this._context.constants.get(name2);
          if (constant2) {
            try {
              const count2 = constant2.evaluate(this._context);
              arrayType.count = count2;
            } catch (e) {
            }
          }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    return statements;
  }
  _initialize(tokensOrCode) {
    if (tokensOrCode) {
      if (typeof tokensOrCode == "string") {
        const scanner = new WgslScanner(tokensOrCode);
        this._tokens = scanner.scanTokens();
      } else {
        this._tokens = tokensOrCode;
      }
    } else {
      this._tokens = [];
    }
    this._current = 0;
  }
  _error(token, message2) {
    return {
      token,
      message: message2,
      toString: function() {
        return `${message2}`;
      }
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == TokenTypes.eof;
  }
  _match(types) {
    if (types instanceof TokenType) {
      if (this._check(types)) {
        this._advance();
        return true;
      }
      return false;
    }
    for (let i = 0, l = types.length; i < l; ++i) {
      const type = types[i];
      if (this._check(type)) {
        this._advance();
        return true;
      }
    }
    return false;
  }
  _consume(types, message2) {
    if (this._check(types)) {
      return this._advance();
    }
    throw this._error(this._peek(), message2);
  }
  _check(types) {
    if (this._isAtEnd()) {
      return false;
    }
    const tk = this._peek();
    if (types instanceof Array) {
      const t = tk.type;
      const index2 = types.indexOf(t);
      return index2 != -1;
    }
    return tk.type == types;
  }
  _advance() {
    var _a2, _b;
    this._currentLine = (_b = (_a2 = this._peek()) === null || _a2 === void 0 ? void 0 : _a2.line) !== null && _b !== void 0 ? _b : -1;
    if (!this._isAtEnd()) {
      this._current++;
    }
    return this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
      ;
    if (this._match(TokenTypes.keywords.alias)) {
      const type = this._type_alias();
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return type;
    }
    if (this._match(TokenTypes.keywords.diagnostic)) {
      const directive = this._diagnostic();
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return directive;
    }
    if (this._match(TokenTypes.keywords.requires)) {
      const requires = this._requires_directive();
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return requires;
    }
    if (this._match(TokenTypes.keywords.enable)) {
      const enable2 = this._enable_directive();
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return enable2;
    }
    const attrs = this._attribute();
    if (this._check(TokenTypes.keywords.var)) {
      const _var = this._global_variable_decl();
      if (_var != null) {
        _var.attributes = attrs;
      }
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      return _var;
    }
    if (this._check(TokenTypes.keywords.override)) {
      const _override = this._override_variable_decl();
      if (_override != null) {
        _override.attributes = attrs;
      }
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      return _override;
    }
    if (this._check(TokenTypes.keywords.let)) {
      const _let = this._global_let_decl();
      if (_let != null) {
        _let.attributes = attrs;
      }
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      return _let;
    }
    if (this._check(TokenTypes.keywords.const)) {
      const _const = this._global_const_decl();
      if (_const != null) {
        _const.attributes = attrs;
      }
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      return _const;
    }
    if (this._check(TokenTypes.keywords.struct)) {
      const _struct = this._struct_decl();
      if (_struct != null) {
        _struct.attributes = attrs;
      }
      return _struct;
    }
    if (this._check(TokenTypes.keywords.fn)) {
      const _fn = this._function_decl();
      if (_fn != null) {
        _fn.attributes = attrs;
      }
      return _fn;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(TokenTypes.keywords.fn)) {
      return null;
    }
    const startLine = this._currentLine;
    const name2 = this._consume(TokenTypes.tokens.ident, "Expected function name.").toString();
    this._consume(TokenTypes.tokens.paren_left, "Expected '(' for function arguments.");
    const args = [];
    if (!this._check(TokenTypes.tokens.paren_right)) {
      do {
        if (this._check(TokenTypes.tokens.paren_right)) {
          break;
        }
        const argAttrs = this._attribute();
        const name3 = this._consume(TokenTypes.tokens.ident, "Expected argument name.").toString();
        this._consume(TokenTypes.tokens.colon, "Expected ':' for argument type.");
        const typeAttrs = this._attribute();
        const type = this._type_decl();
        if (type != null) {
          type.attributes = typeAttrs;
          args.push(new Argument(name3, type, argAttrs));
        }
      } while (this._match(TokenTypes.tokens.comma));
    }
    this._consume(TokenTypes.tokens.paren_right, "Expected ')' after function arguments.");
    let _return = null;
    if (this._match(TokenTypes.tokens.arrow)) {
      const attrs = this._attribute();
      _return = this._type_decl();
      if (_return != null) {
        _return.attributes = attrs;
      }
    }
    const body = this._compound_statement();
    const endLine = this._currentLine;
    return new Function$1(name2, args, _return, body, startLine, endLine);
  }
  _compound_statement() {
    const statements = [];
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for block.");
    while (!this._check(TokenTypes.tokens.brace_right)) {
      const statement = this._statement();
      if (statement !== null) {
        statements.push(statement);
      }
    }
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' for block.");
    return statements;
  }
  _statement() {
    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
      ;
    if (this._check(TokenTypes.tokens.attr)) {
      this._attribute();
    }
    if (this._check(TokenTypes.keywords.if)) {
      return this._if_statement();
    }
    if (this._check(TokenTypes.keywords.switch)) {
      return this._switch_statement();
    }
    if (this._check(TokenTypes.keywords.loop)) {
      return this._loop_statement();
    }
    if (this._check(TokenTypes.keywords.for)) {
      return this._for_statement();
    }
    if (this._check(TokenTypes.keywords.while)) {
      return this._while_statement();
    }
    if (this._check(TokenTypes.keywords.continuing)) {
      return this._continuing_statement();
    }
    if (this._check(TokenTypes.keywords.static_assert)) {
      return this._static_assert_statement();
    }
    if (this._check(TokenTypes.tokens.brace_left)) {
      return this._compound_statement();
    }
    let result = null;
    if (this._check(TokenTypes.keywords.return)) {
      result = this._return_statement();
    } else if (this._check([
      TokenTypes.keywords.var,
      TokenTypes.keywords.let,
      TokenTypes.keywords.const
    ])) {
      result = this._variable_statement();
    } else if (this._match(TokenTypes.keywords.discard)) {
      result = new Discard();
    } else if (this._match(TokenTypes.keywords.break)) {
      result = new Break();
    } else if (this._match(TokenTypes.keywords.continue)) {
      result = new Continue();
    } else {
      result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    }
    if (result != null) {
      this._consume(TokenTypes.tokens.semicolon, "Expected ';' after statement.");
    }
    return result;
  }
  _static_assert_statement() {
    if (!this._match(TokenTypes.keywords.static_assert)) {
      return null;
    }
    const expression = this._optional_paren_expression();
    return new StaticAssert(expression);
  }
  _while_statement() {
    if (!this._match(TokenTypes.keywords.while)) {
      return null;
    }
    const condition = this._optional_paren_expression();
    if (this._check(TokenTypes.tokens.attr)) {
      this._attribute();
    }
    const block = this._compound_statement();
    return new While(condition, block);
  }
  _continuing_statement() {
    if (!this._match(TokenTypes.keywords.continuing)) {
      return null;
    }
    const block = this._compound_statement();
    return new Continuing(block);
  }
  _for_statement() {
    if (!this._match(TokenTypes.keywords.for)) {
      return null;
    }
    this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
    const init2 = !this._check(TokenTypes.tokens.semicolon) ? this._for_init() : null;
    this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
    const condition = !this._check(TokenTypes.tokens.semicolon) ? this._short_circuit_or_expression() : null;
    this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
    const increment = !this._check(TokenTypes.tokens.paren_right) ? this._for_increment() : null;
    this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
    if (this._check(TokenTypes.tokens.attr)) {
      this._attribute();
    }
    const body = this._compound_statement();
    return new For(init2, condition, increment, body);
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(TokenTypes.keywords.var)) {
      const _var = this._variable_decl();
      if (_var === null) {
        throw this._error(this._peek(), "Variable declaration expected.");
      }
      let value = null;
      if (this._match(TokenTypes.tokens.equal)) {
        value = this._short_circuit_or_expression();
      }
      return new Var(_var.name, _var.type, _var.storage, _var.access, value);
    }
    if (this._match(TokenTypes.keywords.let)) {
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected name for let.").toString();
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const typeAttrs = this._attribute();
        type = this._type_decl();
        if (type != null) {
          type.attributes = typeAttrs;
        }
      }
      this._consume(TokenTypes.tokens.equal, "Expected '=' for let.");
      const value = this._short_circuit_or_expression();
      return new Let(name2, type, null, null, value);
    }
    if (this._match(TokenTypes.keywords.const)) {
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected name for const.").toString();
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const typeAttrs = this._attribute();
        type = this._type_decl();
        if (type != null) {
          type.attributes = typeAttrs;
        }
      }
      this._consume(TokenTypes.tokens.equal, "Expected '=' for const.");
      const value = this._short_circuit_or_expression();
      return new Const(name2, type, null, null, value);
    }
    return null;
  }
  _increment_decrement_statement() {
    const savedPos = this._current;
    const _var = this._unary_expression();
    if (_var == null) {
      return null;
    }
    if (!this._check(TokenTypes.increment_operators)) {
      this._current = savedPos;
      return null;
    }
    const token = this._consume(TokenTypes.increment_operators, "Expected increment operator");
    return new Increment(token.type === TokenTypes.tokens.plus_plus ? IncrementOperator.increment : IncrementOperator.decrement, _var);
  }
  _assignment_statement() {
    let _var = null;
    if (this._check(TokenTypes.tokens.brace_right)) {
      return null;
    }
    let isUnderscore = this._match(TokenTypes.tokens.underscore);
    if (!isUnderscore) {
      _var = this._unary_expression();
    }
    if (!isUnderscore && _var == null) {
      return null;
    }
    const type = this._consume(TokenTypes.assignment_operators, "Expected assignment operator.");
    const value = this._short_circuit_or_expression();
    return new Assign(AssignOperator.parse(type.lexeme), _var, value);
  }
  _func_call_statement() {
    if (!this._check(TokenTypes.tokens.ident)) {
      return null;
    }
    const savedPos = this._current;
    const name2 = this._consume(TokenTypes.tokens.ident, "Expected function name.");
    const args = this._argument_expression_list();
    if (args === null) {
      this._current = savedPos;
      return null;
    }
    return new Call(name2.lexeme, args);
  }
  _loop_statement() {
    if (!this._match(TokenTypes.keywords.loop)) {
      return null;
    }
    if (this._check(TokenTypes.tokens.attr)) {
      this._attribute();
    }
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for loop.");
    const statements = [];
    let statement = this._statement();
    while (statement !== null) {
      if (Array.isArray(statement)) {
        for (let s2 of statement) {
          statements.push(s2);
        }
      } else {
        statements.push(statement);
      }
      statement = this._statement();
    }
    let continuing = null;
    if (this._match(TokenTypes.keywords.continuing)) {
      continuing = this._compound_statement();
    }
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' for loop.");
    return new Loop(statements, continuing);
  }
  _switch_statement() {
    if (!this._match(TokenTypes.keywords.switch)) {
      return null;
    }
    const condition = this._optional_paren_expression();
    if (this._check(TokenTypes.tokens.attr)) {
      this._attribute();
    }
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for switch.");
    const body = this._switch_body();
    if (body == null || body.length == 0) {
      throw this._error(this._previous(), "Expected 'case' or 'default'.");
    }
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' for switch.");
    return new Switch(condition, body);
  }
  _switch_body() {
    const cases = [];
    if (this._match(TokenTypes.keywords.case)) {
      const selector = this._case_selectors();
      this._match(TokenTypes.tokens.colon);
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch case.");
      const body = this._case_body();
      this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch case.");
      cases.push(new Case(selector, body));
    }
    if (this._match(TokenTypes.keywords.default)) {
      this._match(TokenTypes.tokens.colon);
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch default.");
      const body = this._case_body();
      this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch default.");
      cases.push(new Default(body));
    }
    if (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {
      const _cases = this._switch_body();
      cases.push(_cases[0]);
    }
    return cases;
  }
  _case_selectors() {
    const selectors = [
      this._shift_expression()
      //?.evaluate(this._context).toString() ?? "",
    ];
    while (this._match(TokenTypes.tokens.comma)) {
      selectors.push(this._shift_expression());
    }
    return selectors;
  }
  _case_body() {
    if (this._match(TokenTypes.keywords.fallthrough)) {
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return [];
    }
    let statement = this._statement();
    if (statement == null) {
      return [];
    }
    if (!(statement instanceof Array)) {
      statement = [statement];
    }
    const nextStatement = this._case_body();
    if (nextStatement.length == 0) {
      return statement;
    }
    return [...statement, nextStatement[0]];
  }
  _if_statement() {
    if (!this._match(TokenTypes.keywords.if)) {
      return null;
    }
    const condition = this._optional_paren_expression();
    if (this._check(TokenTypes.tokens.attr)) {
      this._attribute();
    }
    const block = this._compound_statement();
    let elseif = [];
    if (this._match_elseif()) {
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      elseif = this._elseif_statement(elseif);
    }
    let _else = null;
    if (this._match(TokenTypes.keywords.else)) {
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      _else = this._compound_statement();
    }
    return new If(condition, block, elseif, _else);
  }
  _match_elseif() {
    if (this._tokens[this._current].type === TokenTypes.keywords.else && this._tokens[this._current + 1].type === TokenTypes.keywords.if) {
      this._advance();
      this._advance();
      return true;
    }
    return false;
  }
  _elseif_statement(elseif = []) {
    const condition = this._optional_paren_expression();
    const block = this._compound_statement();
    elseif.push(new ElseIf(condition, block));
    if (this._match_elseif()) {
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      this._elseif_statement(elseif);
    }
    return elseif;
  }
  _return_statement() {
    if (!this._match(TokenTypes.keywords.return)) {
      return null;
    }
    const value = this._short_circuit_or_expression();
    return new Return(value);
  }
  _short_circuit_or_expression() {
    let expr = this._short_circuit_and_expr();
    while (this._match(TokenTypes.tokens.or_or)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._short_circuit_and_expr());
    }
    return expr;
  }
  _short_circuit_and_expr() {
    let expr = this._inclusive_or_expression();
    while (this._match(TokenTypes.tokens.and_and)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._inclusive_or_expression());
    }
    return expr;
  }
  _inclusive_or_expression() {
    let expr = this._exclusive_or_expression();
    while (this._match(TokenTypes.tokens.or)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._exclusive_or_expression());
    }
    return expr;
  }
  _exclusive_or_expression() {
    let expr = this._and_expression();
    while (this._match(TokenTypes.tokens.xor)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._and_expression());
    }
    return expr;
  }
  _and_expression() {
    let expr = this._equality_expression();
    while (this._match(TokenTypes.tokens.and)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._equality_expression());
    }
    return expr;
  }
  _equality_expression() {
    const expr = this._relational_expression();
    if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {
      return new BinaryOperator(this._previous().toString(), expr, this._relational_expression());
    }
    return expr;
  }
  _relational_expression() {
    let expr = this._shift_expression();
    while (this._match([
      TokenTypes.tokens.less_than,
      TokenTypes.tokens.greater_than,
      TokenTypes.tokens.less_than_equal,
      TokenTypes.tokens.greater_than_equal
    ])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._shift_expression());
    }
    return expr;
  }
  _shift_expression() {
    let expr = this._additive_expression();
    while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._additive_expression());
    }
    return expr;
  }
  _additive_expression() {
    let expr = this._multiplicative_expression();
    while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._multiplicative_expression());
    }
    return expr;
  }
  _multiplicative_expression() {
    let expr = this._unary_expression();
    while (this._match([
      TokenTypes.tokens.star,
      TokenTypes.tokens.forward_slash,
      TokenTypes.tokens.modulo
    ])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._unary_expression());
    }
    return expr;
  }
  _unary_expression() {
    if (this._match([
      TokenTypes.tokens.minus,
      TokenTypes.tokens.bang,
      TokenTypes.tokens.tilde,
      TokenTypes.tokens.star,
      TokenTypes.tokens.and
    ])) {
      return new UnaryOperator(this._previous().toString(), this._unary_expression());
    }
    return this._singular_expression();
  }
  _singular_expression() {
    const expr = this._primary_expression();
    const p2 = this._postfix_expression();
    if (p2) {
      expr.postfix = p2;
    }
    return expr;
  }
  _postfix_expression() {
    if (this._match(TokenTypes.tokens.bracket_left)) {
      const expr = this._short_circuit_or_expression();
      this._consume(TokenTypes.tokens.bracket_right, "Expected ']'.");
      const arrayIndex = new ArrayIndex(expr);
      const p2 = this._postfix_expression();
      if (p2) {
        arrayIndex.postfix = p2;
      }
      return arrayIndex;
    }
    if (this._match(TokenTypes.tokens.period)) {
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected member name.");
      const p2 = this._postfix_expression();
      const expr = new StringExpr(name2.lexeme);
      if (p2) {
        expr.postfix = p2;
      }
      return expr;
    }
    return null;
  }
  _getStruct(name2) {
    if (this._context.aliases.has(name2)) {
      const alias = this._context.aliases.get(name2).type;
      return alias;
    }
    if (this._context.structs.has(name2)) {
      const struct = this._context.structs.get(name2);
      return struct;
    }
    return null;
  }
  _primary_expression() {
    if (this._match(TokenTypes.tokens.ident)) {
      const name2 = this._previous().toString();
      if (this._check(TokenTypes.tokens.paren_left)) {
        const args2 = this._argument_expression_list();
        const struct = this._getStruct(name2);
        if (struct != null) {
          return new CreateExpr(struct, args2);
        }
        return new CallExpr(name2, args2);
      }
      if (this._context.constants.has(name2)) {
        const c2 = this._context.constants.get(name2);
        return new ConstExpr(name2, c2.value);
      }
      return new VariableExpr(name2);
    }
    if (this._match(TokenTypes.const_literal)) {
      return new LiteralExpr(parseFloat(this._previous().toString()));
    }
    if (this._check(TokenTypes.tokens.paren_left)) {
      return this._paren_expression();
    }
    if (this._match(TokenTypes.keywords.bitcast)) {
      this._consume(TokenTypes.tokens.less_than, "Expected '<'.");
      const type2 = this._type_decl();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
      const value = this._paren_expression();
      return new BitcastExpr(type2, value);
    }
    const type = this._type_decl();
    const args = this._argument_expression_list();
    return new CreateExpr(type, args);
  }
  _argument_expression_list() {
    if (!this._match(TokenTypes.tokens.paren_left)) {
      return null;
    }
    const args = [];
    do {
      if (this._check(TokenTypes.tokens.paren_right)) {
        break;
      }
      const arg = this._short_circuit_or_expression();
      args.push(arg);
    } while (this._match(TokenTypes.tokens.comma));
    this._consume(TokenTypes.tokens.paren_right, "Expected ')' for agument list");
    return args;
  }
  _optional_paren_expression() {
    this._match(TokenTypes.tokens.paren_left);
    const expr = this._short_circuit_or_expression();
    this._match(TokenTypes.tokens.paren_right);
    return new GroupingExpr([expr]);
  }
  _paren_expression() {
    this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
    const expr = this._short_circuit_or_expression();
    this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
    return new GroupingExpr([expr]);
  }
  _struct_decl() {
    if (!this._match(TokenTypes.keywords.struct)) {
      return null;
    }
    const startLine = this._currentLine;
    const name2 = this._consume(TokenTypes.tokens.ident, "Expected name for struct.").toString();
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for struct body.");
    const members = [];
    while (!this._check(TokenTypes.tokens.brace_right)) {
      const memberAttrs = this._attribute();
      const memberName = this._consume(TokenTypes.tokens.ident, "Expected variable name.").toString();
      this._consume(TokenTypes.tokens.colon, "Expected ':' for struct member type.");
      const typeAttrs = this._attribute();
      const memberType = this._type_decl();
      if (memberType != null) {
        memberType.attributes = typeAttrs;
      }
      if (!this._check(TokenTypes.tokens.brace_right))
        this._consume(TokenTypes.tokens.comma, "Expected ',' for struct member.");
      else
        this._match(TokenTypes.tokens.comma);
      members.push(new Member(memberName, memberType, memberAttrs));
    }
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' after struct body.");
    const endLine = this._currentLine;
    const structNode = new Struct(name2, members, startLine, endLine);
    this._context.structs.set(name2, structNode);
    return structNode;
  }
  _global_variable_decl() {
    const _var = this._variable_decl();
    if (_var && this._match(TokenTypes.tokens.equal)) {
      _var.value = this._const_expression();
    }
    return _var;
  }
  _override_variable_decl() {
    const _override = this._override_decl();
    if (_override && this._match(TokenTypes.tokens.equal)) {
      _override.value = this._const_expression();
    }
    return _override;
  }
  _global_const_decl() {
    if (!this._match(TokenTypes.keywords.const)) {
      return null;
    }
    const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
    let type = null;
    if (this._match(TokenTypes.tokens.colon)) {
      const attrs = this._attribute();
      type = this._type_decl();
      if (type != null) {
        type.attributes = attrs;
      }
    }
    let value = null;
    if (this._match(TokenTypes.tokens.equal)) {
      const valueExpr = this._short_circuit_or_expression();
      if (valueExpr instanceof CreateExpr) {
        value = valueExpr;
      } else if (valueExpr instanceof ConstExpr && valueExpr.initializer instanceof CreateExpr) {
        value = valueExpr.initializer;
      } else {
        try {
          const constValue = valueExpr.evaluate(this._context);
          value = new LiteralExpr(constValue);
        } catch (_a2) {
          value = valueExpr;
        }
      }
    }
    const c2 = new Const(name2.toString(), type, "", "", value);
    this._context.constants.set(c2.name, c2);
    return c2;
  }
  _global_let_decl() {
    if (!this._match(TokenTypes.keywords.let)) {
      return null;
    }
    const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
    let type = null;
    if (this._match(TokenTypes.tokens.colon)) {
      const attrs = this._attribute();
      type = this._type_decl();
      if (type != null) {
        type.attributes = attrs;
      }
    }
    let value = null;
    if (this._match(TokenTypes.tokens.equal)) {
      value = this._const_expression();
    }
    return new Let(name2.toString(), type, "", "", value);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(TokenTypes.keywords.var)) {
      return null;
    }
    let storage = "";
    let access = "";
    if (this._match(TokenTypes.tokens.less_than)) {
      storage = this._consume(TokenTypes.storage_class, "Expected storage_class.").toString();
      if (this._match(TokenTypes.tokens.comma))
        access = this._consume(TokenTypes.access_mode, "Expected access_mode.").toString();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
    }
    const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
    let type = null;
    if (this._match(TokenTypes.tokens.colon)) {
      const attrs = this._attribute();
      type = this._type_decl();
      if (type != null) {
        type.attributes = attrs;
      }
    }
    return new Var(name2.toString(), type, storage, access, null);
  }
  _override_decl() {
    if (!this._match(TokenTypes.keywords.override)) {
      return null;
    }
    const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
    let type = null;
    if (this._match(TokenTypes.tokens.colon)) {
      const attrs = this._attribute();
      type = this._type_decl();
      if (type != null) {
        type.attributes = attrs;
      }
    }
    return new Override(name2.toString(), type, null);
  }
  _diagnostic() {
    this._consume(TokenTypes.tokens.paren_left, "Expected '('");
    const severity = this._consume(TokenTypes.tokens.ident, "Expected severity control name.");
    this._consume(TokenTypes.tokens.comma, "Expected ','");
    const rule = this._consume(TokenTypes.tokens.ident, "Expected diagnostic rule name.");
    this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
    return new Diagnostic(severity.toString(), rule.toString());
  }
  _enable_directive() {
    const name2 = this._consume(TokenTypes.tokens.ident, "identity expected.");
    return new Enable(name2.toString());
  }
  _requires_directive() {
    const extensions = [this._consume(TokenTypes.tokens.ident, "identity expected.").toString()];
    while (this._match(TokenTypes.tokens.comma)) {
      const name2 = this._consume(TokenTypes.tokens.ident, "identity expected.");
      extensions.push(name2.toString());
    }
    return new Requires(extensions);
  }
  _type_alias() {
    const name2 = this._consume(TokenTypes.tokens.ident, "identity expected.");
    this._consume(TokenTypes.tokens.equal, "Expected '=' for type alias.");
    let aliasType = this._type_decl();
    if (aliasType === null) {
      throw this._error(this._peek(), "Expected Type for Alias.");
    }
    if (this._context.aliases.has(aliasType.name)) {
      aliasType = this._context.aliases.get(aliasType.name).type;
    }
    const aliasNode = new Alias(name2.toString(), aliasType);
    this._context.aliases.set(aliasNode.name, aliasNode);
    return aliasNode;
  }
  _type_decl() {
    if (this._check([
      TokenTypes.tokens.ident,
      ...TokenTypes.texel_format,
      TokenTypes.keywords.bool,
      TokenTypes.keywords.f32,
      TokenTypes.keywords.i32,
      TokenTypes.keywords.u32
    ])) {
      const type2 = this._advance();
      const typeName = type2.toString();
      if (this._context.structs.has(typeName)) {
        return this._context.structs.get(typeName);
      }
      if (this._context.aliases.has(typeName)) {
        return this._context.aliases.get(typeName).type;
      }
      return new Type(type2.toString());
    }
    let type = this._texture_sampler_types();
    if (type) {
      return type;
    }
    if (this._check(TokenTypes.template_types)) {
      let type2 = this._advance().toString();
      let format2 = null;
      let access = null;
      if (this._match(TokenTypes.tokens.less_than)) {
        format2 = this._type_decl();
        access = null;
        if (this._match(TokenTypes.tokens.comma)) {
          access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
        }
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for type.");
      }
      return new TemplateType(type2, format2, access);
    }
    if (this._match(TokenTypes.keywords.ptr)) {
      let pointer = this._previous().toString();
      this._consume(TokenTypes.tokens.less_than, "Expected '<' for pointer.");
      const storage = this._consume(TokenTypes.storage_class, "Expected storage_class for pointer");
      this._consume(TokenTypes.tokens.comma, "Expected ',' for pointer.");
      const decl = this._type_decl();
      let access = null;
      if (this._match(TokenTypes.tokens.comma)) {
        access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
      }
      this._consume(TokenTypes.tokens.greater_than, "Expected '>' for pointer.");
      return new PointerType(pointer, storage.toString(), decl, access);
    }
    const attrs = this._attribute();
    if (this._match(TokenTypes.keywords.array)) {
      let format2 = null;
      let countInt = -1;
      const array2 = this._previous();
      let countNode = null;
      if (this._match(TokenTypes.tokens.less_than)) {
        format2 = this._type_decl();
        if (this._context.aliases.has(format2.name)) {
          format2 = this._context.aliases.get(format2.name).type;
        }
        let count2 = "";
        if (this._match(TokenTypes.tokens.comma)) {
          countNode = this._shift_expression();
          try {
            count2 = countNode.evaluate(this._context).toString();
            countNode = null;
          } catch (e) {
            count2 = "1";
          }
        }
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for array.");
        countInt = count2 ? parseInt(count2) : 0;
      }
      const arrayType = new ArrayType(array2.toString(), attrs, format2, countInt);
      if (countNode) {
        this._deferArrayCountEval.push({ arrayType, countNode });
      }
      return arrayType;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(TokenTypes.sampler_type)) {
      return new SamplerType(this._previous().toString(), null, null);
    }
    if (this._match(TokenTypes.depth_texture_type)) {
      return new SamplerType(this._previous().toString(), null, null);
    }
    if (this._match(TokenTypes.sampled_texture_type) || this._match(TokenTypes.multisampled_texture_type)) {
      const sampler = this._previous();
      this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
      const format2 = this._type_decl();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
      return new SamplerType(sampler.toString(), format2, null);
    }
    if (this._match(TokenTypes.storage_texture_type)) {
      const sampler = this._previous();
      this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
      const format2 = this._consume(TokenTypes.texel_format, "Invalid texel format.").toString();
      this._consume(TokenTypes.tokens.comma, "Expected ',' after texel format.");
      const access = this._consume(TokenTypes.access_mode, "Expected access mode for storage texture type.").toString();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
      return new SamplerType(sampler.toString(), format2, access);
    }
    return null;
  }
  _attribute() {
    let attributes = [];
    while (this._match(TokenTypes.tokens.attr)) {
      const name2 = this._consume(TokenTypes.attribute_name, "Expected attribute name");
      const attr = new Attribute$1(name2.toString(), null);
      if (this._match(TokenTypes.tokens.paren_left)) {
        attr.value = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
        if (this._check(TokenTypes.tokens.comma)) {
          this._advance();
          do {
            const v = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
            if (!(attr.value instanceof Array)) {
              attr.value = [attr.value];
            }
            attr.value.push(v);
          } while (this._match(TokenTypes.tokens.comma));
        }
        this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
      }
      attributes.push(attr);
    }
    if (attributes.length == 0) {
      return null;
    }
    return attributes;
  }
}
class TypeInfo {
  constructor(name2, attributes) {
    this.name = name2;
    this.attributes = attributes;
    this.size = 0;
  }
  get isArray() {
    return false;
  }
  get isStruct() {
    return false;
  }
  get isTemplate() {
    return false;
  }
}
class MemberInfo {
  constructor(name2, type, attributes) {
    this.name = name2;
    this.type = type;
    this.attributes = attributes;
    this.offset = 0;
    this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class StructInfo extends TypeInfo {
  constructor(name2, attributes) {
    super(name2, attributes);
    this.members = [];
    this.align = 0;
    this.startLine = -1;
    this.endLine = -1;
    this.inUse = false;
  }
  get isStruct() {
    return true;
  }
}
class ArrayInfo extends TypeInfo {
  constructor(name2, attributes) {
    super(name2, attributes);
    this.count = 0;
    this.stride = 0;
  }
  get isArray() {
    return true;
  }
}
class TemplateInfo extends TypeInfo {
  constructor(name2, format2, attributes, access) {
    super(name2, attributes);
    this.format = format2;
    this.access = access;
  }
  get isTemplate() {
    return true;
  }
}
var ResourceType;
(function(ResourceType2) {
  ResourceType2[ResourceType2["Uniform"] = 0] = "Uniform";
  ResourceType2[ResourceType2["Storage"] = 1] = "Storage";
  ResourceType2[ResourceType2["Texture"] = 2] = "Texture";
  ResourceType2[ResourceType2["Sampler"] = 3] = "Sampler";
  ResourceType2[ResourceType2["StorageTexture"] = 4] = "StorageTexture";
})(ResourceType || (ResourceType = {}));
class VariableInfo {
  constructor(name2, type, group, binding, attributes, resourceType, access) {
    this.name = name2;
    this.type = type;
    this.group = group;
    this.binding = binding;
    this.attributes = attributes;
    this.resourceType = resourceType;
    this.access = access;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class AliasInfo {
  constructor(name2, type) {
    this.name = name2;
    this.type = type;
  }
}
class _TypeSize {
  constructor(align, size) {
    this.align = align;
    this.size = size;
  }
}
class InputInfo {
  constructor(name2, type, locationType, location) {
    this.name = name2;
    this.type = type;
    this.locationType = locationType;
    this.location = location;
    this.interpolation = null;
  }
}
class OutputInfo {
  constructor(name2, type, locationType, location) {
    this.name = name2;
    this.type = type;
    this.locationType = locationType;
    this.location = location;
  }
}
class OverrideInfo {
  constructor(name2, type, attributes, id) {
    this.name = name2;
    this.type = type;
    this.attributes = attributes;
    this.id = id;
  }
}
class ArgumentInfo {
  constructor(name2, type) {
    this.name = name2;
    this.type = type;
  }
}
class FunctionInfo {
  constructor(name2, stage = null) {
    this.stage = null;
    this.inputs = [];
    this.outputs = [];
    this.arguments = [];
    this.returnType = null;
    this.resources = [];
    this.overrides = [];
    this.startLine = -1;
    this.endLine = -1;
    this.inUse = false;
    this.calls = /* @__PURE__ */ new Set();
    this.name = name2;
    this.stage = stage;
  }
}
class EntryFunctions {
  constructor() {
    this.vertex = [];
    this.fragment = [];
    this.compute = [];
  }
}
class _FunctionResources {
  constructor(node) {
    this.resources = null;
    this.inUse = false;
    this.info = null;
    this.node = node;
  }
}
class WgslReflect {
  constructor(code) {
    this.uniforms = [];
    this.storage = [];
    this.textures = [];
    this.samplers = [];
    this.aliases = [];
    this.overrides = [];
    this.structs = [];
    this.entry = new EntryFunctions();
    this.functions = [];
    this._types = /* @__PURE__ */ new Map();
    this._functions = /* @__PURE__ */ new Map();
    if (code) {
      this.update(code);
    }
  }
  _isStorageTexture(type) {
    return type.name == "texture_storage_1d" || type.name == "texture_storage_2d" || type.name == "texture_storage_2d_array" || type.name == "texture_storage_3d";
  }
  update(code) {
    const parser = new WgslParser();
    const ast = parser.parse(code);
    for (const node of ast) {
      if (node instanceof Function$1) {
        this._functions.set(node.name, new _FunctionResources(node));
      }
    }
    for (const node of ast) {
      if (node instanceof Struct) {
        const info = this._getTypeInfo(node, null);
        if (info instanceof StructInfo) {
          this.structs.push(info);
        }
      }
    }
    for (const node of ast) {
      if (node instanceof Alias) {
        this.aliases.push(this._getAliasInfo(node));
        continue;
      }
      if (node instanceof Override) {
        const v = node;
        const id = this._getAttributeNum(v.attributes, "id", 0);
        const type = v.type != null ? this._getTypeInfo(v.type, v.attributes) : null;
        this.overrides.push(new OverrideInfo(v.name, type, v.attributes, id));
        continue;
      }
      if (this._isUniformVar(node)) {
        const v = node;
        const g = this._getAttributeNum(v.attributes, "group", 0);
        const b = this._getAttributeNum(v.attributes, "binding", 0);
        const type = this._getTypeInfo(v.type, v.attributes);
        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Uniform, v.access);
        this.uniforms.push(varInfo);
        continue;
      }
      if (this._isStorageVar(node)) {
        const v = node;
        const g = this._getAttributeNum(v.attributes, "group", 0);
        const b = this._getAttributeNum(v.attributes, "binding", 0);
        const type = this._getTypeInfo(v.type, v.attributes);
        const isStorageTexture = this._isStorageTexture(type);
        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Storage, v.access);
        this.storage.push(varInfo);
        continue;
      }
      if (this._isTextureVar(node)) {
        const v = node;
        const g = this._getAttributeNum(v.attributes, "group", 0);
        const b = this._getAttributeNum(v.attributes, "binding", 0);
        const type = this._getTypeInfo(v.type, v.attributes);
        const isStorageTexture = this._isStorageTexture(type);
        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Texture, v.access);
        if (isStorageTexture) {
          this.storage.push(varInfo);
        } else {
          this.textures.push(varInfo);
        }
        continue;
      }
      if (this._isSamplerVar(node)) {
        const v = node;
        const g = this._getAttributeNum(v.attributes, "group", 0);
        const b = this._getAttributeNum(v.attributes, "binding", 0);
        const type = this._getTypeInfo(v.type, v.attributes);
        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Sampler, v.access);
        this.samplers.push(varInfo);
        continue;
      }
      if (node instanceof Function$1) {
        const vertexStage = this._getAttribute(node, "vertex");
        const fragmentStage = this._getAttribute(node, "fragment");
        const computeStage = this._getAttribute(node, "compute");
        const stage = vertexStage || fragmentStage || computeStage;
        const fn = new FunctionInfo(node.name, stage === null || stage === void 0 ? void 0 : stage.name);
        fn.startLine = node.startLine;
        fn.endLine = node.endLine;
        this.functions.push(fn);
        this._functions.get(node.name).info = fn;
        if (stage) {
          this._functions.get(node.name).inUse = true;
          fn.inUse = true;
          fn.resources = this._findResources(node, !!stage);
          fn.inputs = this._getInputs(node.args);
          fn.outputs = this._getOutputs(node.returnType);
          this.entry[stage.name].push(fn);
        } else {
          fn.arguments = node.args.map((arg) => new ArgumentInfo(arg.name, this._getTypeInfo(arg.type, arg.attributes)));
          fn.returnType = node.returnType ? this._getTypeInfo(node.returnType, node.attributes) : null;
        }
        continue;
      }
    }
    for (const fn of this._functions.values()) {
      if (fn.info) {
        fn.info.inUse = fn.inUse;
        this._addCalls(fn.node, fn.info.calls);
      }
    }
    for (const fn of this._functions.values()) {
      fn.node.search((node) => {
        var _a2;
        if (node.astNodeType === "varExpr") {
          const v = node;
          for (const override of this.overrides) {
            if (v.name == override.name) {
              (_a2 = fn.info) === null || _a2 === void 0 ? void 0 : _a2.overrides.push(override);
            }
          }
        }
      });
    }
    for (const u2 of this.uniforms) {
      this._markStructsInUse(u2.type);
    }
    for (const s2 of this.storage) {
      this._markStructsInUse(s2.type);
    }
  }
  _markStructsInUse(type) {
    if (!type) {
      return;
    }
    if (type.isStruct) {
      type.inUse = true;
      if (type.members) {
        for (const m2 of type.members) {
          this._markStructsInUse(m2.type);
        }
      }
    } else if (type.isArray) {
      this._markStructsInUse(type.format);
    } else if (type.isTemplate) {
      if (type.format) {
        this._markStructsInUse(type.format);
      }
    } else {
      const alias = this._getAlias(type.name);
      if (alias) {
        this._markStructsInUse(alias);
      }
    }
  }
  _addCalls(fn, calls) {
    var _a2;
    for (const call of fn.calls) {
      const info = (_a2 = this._functions.get(call.name)) === null || _a2 === void 0 ? void 0 : _a2.info;
      if (info) {
        calls.add(info);
      }
    }
  }
  /// Find a resource by its group and binding.
  findResource(group, binding) {
    for (const u2 of this.uniforms) {
      if (u2.group == group && u2.binding == binding) {
        return u2;
      }
    }
    for (const s2 of this.storage) {
      if (s2.group == group && s2.binding == binding) {
        return s2;
      }
    }
    for (const t of this.textures) {
      if (t.group == group && t.binding == binding) {
        return t;
      }
    }
    for (const s2 of this.samplers) {
      if (s2.group == group && s2.binding == binding) {
        return s2;
      }
    }
    return null;
  }
  _findResource(name2) {
    for (const u2 of this.uniforms) {
      if (u2.name == name2) {
        return u2;
      }
    }
    for (const s2 of this.storage) {
      if (s2.name == name2) {
        return s2;
      }
    }
    for (const t of this.textures) {
      if (t.name == name2) {
        return t;
      }
    }
    for (const s2 of this.samplers) {
      if (s2.name == name2) {
        return s2;
      }
    }
    return null;
  }
  _markStructsFromAST(type) {
    const info = this._getTypeInfo(type, null);
    this._markStructsInUse(info);
  }
  _findResources(fn, isEntry) {
    const resources = [];
    const self2 = this;
    const varStack = [];
    fn.search((node) => {
      if (node instanceof _BlockStart) {
        varStack.push({});
      } else if (node instanceof _BlockEnd) {
        varStack.pop();
      } else if (node instanceof Var) {
        const v = node;
        if (isEntry && v.type !== null) {
          this._markStructsFromAST(v.type);
        }
        if (varStack.length > 0) {
          varStack[varStack.length - 1][v.name] = v;
        }
      } else if (node instanceof CreateExpr) {
        const c2 = node;
        if (isEntry && c2.type !== null) {
          this._markStructsFromAST(c2.type);
        }
      } else if (node instanceof Let) {
        const v = node;
        if (isEntry && v.type !== null) {
          this._markStructsFromAST(v.type);
        }
        if (varStack.length > 0) {
          varStack[varStack.length - 1][v.name] = v;
        }
      } else if (node instanceof VariableExpr) {
        const v = node;
        if (varStack.length > 0) {
          const varInfo2 = varStack[varStack.length - 1][v.name];
          if (varInfo2) {
            return;
          }
        }
        const varInfo = self2._findResource(v.name);
        if (varInfo) {
          resources.push(varInfo);
        }
      } else if (node instanceof CallExpr) {
        const c2 = node;
        const callFn = self2._functions.get(c2.name);
        if (callFn) {
          if (isEntry) {
            callFn.inUse = true;
          }
          fn.calls.add(callFn.node);
          if (callFn.resources === null) {
            callFn.resources = self2._findResources(callFn.node, isEntry);
          }
          resources.push(...callFn.resources);
        }
      } else if (node instanceof Call) {
        const c2 = node;
        const callFn = self2._functions.get(c2.name);
        if (callFn) {
          if (isEntry) {
            callFn.inUse = true;
          }
          fn.calls.add(callFn.node);
          if (callFn.resources === null) {
            callFn.resources = self2._findResources(callFn.node, isEntry);
          }
          resources.push(...callFn.resources);
        }
      }
    });
    return [...new Map(resources.map((r) => [r.name, r])).values()];
  }
  getBindGroups() {
    const groups = [];
    function _makeRoom(group, binding) {
      if (group >= groups.length) {
        groups.length = group + 1;
      }
      if (groups[group] === void 0) {
        groups[group] = [];
      }
      if (binding >= groups[group].length) {
        groups[group].length = binding + 1;
      }
    }
    for (const u2 of this.uniforms) {
      _makeRoom(u2.group, u2.binding);
      const group = groups[u2.group];
      group[u2.binding] = u2;
    }
    for (const u2 of this.storage) {
      _makeRoom(u2.group, u2.binding);
      const group = groups[u2.group];
      group[u2.binding] = u2;
    }
    for (const t of this.textures) {
      _makeRoom(t.group, t.binding);
      const group = groups[t.group];
      group[t.binding] = t;
    }
    for (const t of this.samplers) {
      _makeRoom(t.group, t.binding);
      const group = groups[t.group];
      group[t.binding] = t;
    }
    return groups;
  }
  _getOutputs(type, outputs = void 0) {
    if (outputs === void 0) {
      outputs = [];
    }
    if (type instanceof Struct) {
      this._getStructOutputs(type, outputs);
    } else {
      const output = this._getOutputInfo(type);
      if (output !== null) {
        outputs.push(output);
      }
    }
    return outputs;
  }
  _getStructOutputs(struct, outputs) {
    for (const m2 of struct.members) {
      if (m2.type instanceof Struct) {
        this._getStructOutputs(m2.type, outputs);
      } else {
        const location = this._getAttribute(m2, "location") || this._getAttribute(m2, "builtin");
        if (location !== null) {
          const typeInfo = this._getTypeInfo(m2.type, m2.type.attributes);
          const locationValue = this._parseInt(location.value);
          const info = new OutputInfo(m2.name, typeInfo, location.name, locationValue);
          outputs.push(info);
        }
      }
    }
  }
  _getOutputInfo(type) {
    const location = this._getAttribute(type, "location") || this._getAttribute(type, "builtin");
    if (location !== null) {
      const typeInfo = this._getTypeInfo(type, type.attributes);
      const locationValue = this._parseInt(location.value);
      const info = new OutputInfo("", typeInfo, location.name, locationValue);
      return info;
    }
    return null;
  }
  _getInputs(args, inputs = void 0) {
    if (inputs === void 0) {
      inputs = [];
    }
    for (const arg of args) {
      if (arg.type instanceof Struct) {
        this._getStructInputs(arg.type, inputs);
      } else {
        const input = this._getInputInfo(arg);
        if (input !== null) {
          inputs.push(input);
        }
      }
    }
    return inputs;
  }
  _getStructInputs(struct, inputs) {
    for (const m2 of struct.members) {
      if (m2.type instanceof Struct) {
        this._getStructInputs(m2.type, inputs);
      } else {
        const input = this._getInputInfo(m2);
        if (input !== null) {
          inputs.push(input);
        }
      }
    }
  }
  _getInputInfo(node) {
    const location = this._getAttribute(node, "location") || this._getAttribute(node, "builtin");
    if (location !== null) {
      const interpolation = this._getAttribute(node, "interpolation");
      const type = this._getTypeInfo(node.type, node.attributes);
      const locationValue = this._parseInt(location.value);
      const info = new InputInfo(node.name, type, location.name, locationValue);
      if (interpolation !== null) {
        info.interpolation = this._parseString(interpolation.value);
      }
      return info;
    }
    return null;
  }
  _parseString(s2) {
    if (s2 instanceof Array) {
      s2 = s2[0];
    }
    return s2;
  }
  _parseInt(s2) {
    if (s2 instanceof Array) {
      s2 = s2[0];
    }
    const n = parseInt(s2);
    return isNaN(n) ? s2 : n;
  }
  _getAlias(name2) {
    for (const a2 of this.aliases) {
      if (a2.name == name2) {
        return a2.type;
      }
    }
    return null;
  }
  _getAliasInfo(node) {
    return new AliasInfo(node.name, this._getTypeInfo(node.type, null));
  }
  _getTypeInfo(type, attributes) {
    if (this._types.has(type)) {
      return this._types.get(type);
    }
    if (type instanceof ArrayType) {
      const a2 = type;
      const t = a2.format ? this._getTypeInfo(a2.format, a2.attributes) : null;
      const info2 = new ArrayInfo(a2.name, attributes);
      info2.format = t;
      info2.count = a2.count;
      this._types.set(type, info2);
      this._updateTypeInfo(info2);
      return info2;
    }
    if (type instanceof Struct) {
      const s2 = type;
      const info2 = new StructInfo(s2.name, attributes);
      info2.startLine = s2.startLine;
      info2.endLine = s2.endLine;
      for (const m2 of s2.members) {
        const t = this._getTypeInfo(m2.type, m2.attributes);
        info2.members.push(new MemberInfo(m2.name, t, m2.attributes));
      }
      this._types.set(type, info2);
      this._updateTypeInfo(info2);
      return info2;
    }
    if (type instanceof SamplerType) {
      const s2 = type;
      const formatIsType = s2.format instanceof Type;
      const format2 = s2.format ? formatIsType ? this._getTypeInfo(s2.format, null) : new TypeInfo(s2.format, null) : null;
      const info2 = new TemplateInfo(s2.name, format2, attributes, s2.access);
      this._types.set(type, info2);
      this._updateTypeInfo(info2);
      return info2;
    }
    if (type instanceof TemplateType) {
      const t = type;
      const format2 = t.format ? this._getTypeInfo(t.format, null) : null;
      const info2 = new TemplateInfo(t.name, format2, attributes, t.access);
      this._types.set(type, info2);
      this._updateTypeInfo(info2);
      return info2;
    }
    const info = new TypeInfo(type.name, attributes);
    this._types.set(type, info);
    this._updateTypeInfo(info);
    return info;
  }
  _updateTypeInfo(type) {
    var _a2, _b;
    const typeSize = this._getTypeSize(type);
    type.size = (_a2 = typeSize === null || typeSize === void 0 ? void 0 : typeSize.size) !== null && _a2 !== void 0 ? _a2 : 0;
    if (type instanceof ArrayInfo) {
      if (type["format"]) {
        const formatInfo = this._getTypeSize(type["format"]);
        type.stride = (_b = formatInfo === null || formatInfo === void 0 ? void 0 : formatInfo.size) !== null && _b !== void 0 ? _b : 0;
        this._updateTypeInfo(type["format"]);
      }
    }
    if (type instanceof StructInfo) {
      this._updateStructInfo(type);
    }
  }
  _updateStructInfo(struct) {
    var _a2;
    let offset2 = 0;
    let lastSize = 0;
    let lastOffset = 0;
    let structAlign = 0;
    for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {
      const member = struct.members[mi];
      const sizeInfo = this._getTypeSize(member);
      if (!sizeInfo) {
        continue;
      }
      (_a2 = this._getAlias(member.type.name)) !== null && _a2 !== void 0 ? _a2 : member.type;
      const align = sizeInfo.align;
      const size = sizeInfo.size;
      offset2 = this._roundUp(align, offset2 + lastSize);
      lastSize = size;
      lastOffset = offset2;
      structAlign = Math.max(structAlign, align);
      member.offset = offset2;
      member.size = size;
      this._updateTypeInfo(member.type);
    }
    struct.size = this._roundUp(structAlign, lastOffset + lastSize);
    struct.align = structAlign;
  }
  _getTypeSize(type) {
    var _a2, _b;
    if (type === null || type === void 0) {
      return null;
    }
    const explicitSize = this._getAttributeNum(type.attributes, "size", 0);
    const explicitAlign = this._getAttributeNum(type.attributes, "align", 0);
    if (type instanceof MemberInfo) {
      type = type.type;
    }
    if (type instanceof TypeInfo) {
      const alias = this._getAlias(type.name);
      if (alias !== null) {
        type = alias;
      }
    }
    {
      const info = WgslReflect._typeInfo[type.name];
      if (info !== void 0) {
        const divisor = ((_a2 = type["format"]) === null || _a2 === void 0 ? void 0 : _a2.name) === "f16" ? 2 : 1;
        return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
      }
    }
    {
      const info = WgslReflect._typeInfo[type.name.substring(0, type.name.length - 1)];
      if (info) {
        const divisor = type.name[type.name.length - 1] === "h" ? 2 : 1;
        return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
      }
    }
    if (type instanceof ArrayInfo) {
      let arrayType = type;
      let align = 8;
      let size = 8;
      const E = this._getTypeSize(arrayType.format);
      if (E !== null) {
        size = E.size;
        align = E.align;
      }
      const N2 = arrayType.count;
      const stride = this._getAttributeNum((_b = type === null || type === void 0 ? void 0 : type.attributes) !== null && _b !== void 0 ? _b : null, "stride", this._roundUp(align, size));
      size = N2 * stride;
      if (explicitSize) {
        size = explicitSize;
      }
      return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
    }
    if (type instanceof StructInfo) {
      let align = 0;
      let size = 0;
      let offset2 = 0;
      let lastSize = 0;
      let lastOffset = 0;
      for (const m2 of type.members) {
        const mi = this._getTypeSize(m2.type);
        if (mi !== null) {
          align = Math.max(mi.align, align);
          offset2 = this._roundUp(mi.align, offset2 + lastSize);
          lastSize = mi.size;
          lastOffset = offset2;
        }
      }
      size = this._roundUp(align, lastOffset + lastSize);
      return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
    }
    return null;
  }
  _isUniformVar(node) {
    return node instanceof Var && node.storage == "uniform";
  }
  _isStorageVar(node) {
    return node instanceof Var && node.storage == "storage";
  }
  _isTextureVar(node) {
    return node instanceof Var && node.type !== null && WgslReflect._textureTypes.indexOf(node.type.name) != -1;
  }
  _isSamplerVar(node) {
    return node instanceof Var && node.type !== null && WgslReflect._samplerTypes.indexOf(node.type.name) != -1;
  }
  _getAttribute(node, name2) {
    const obj = node;
    if (!obj || !obj["attributes"]) {
      return null;
    }
    const attrs = obj["attributes"];
    for (let a2 of attrs) {
      if (a2.name == name2) {
        return a2;
      }
    }
    return null;
  }
  _getAttributeNum(attributes, name2, defaultValue) {
    if (attributes === null) {
      return defaultValue;
    }
    for (let a2 of attributes) {
      if (a2.name == name2) {
        let v = a2 !== null && a2.value !== null ? a2.value : defaultValue;
        if (v instanceof Array) {
          v = v[0];
        }
        if (typeof v === "number") {
          return v;
        }
        if (typeof v === "string") {
          return parseInt(v);
        }
        return defaultValue;
      }
    }
    return defaultValue;
  }
  _roundUp(k2, n) {
    return Math.ceil(n / k2) * k2;
  }
}
WgslReflect._typeInfo = {
  f16: { align: 2, size: 2 },
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  atomic: { align: 4, size: 4 },
  vec2: { align: 8, size: 8 },
  vec3: { align: 16, size: 12 },
  vec4: { align: 16, size: 16 },
  mat2x2: { align: 8, size: 16 },
  mat3x2: { align: 8, size: 24 },
  mat4x2: { align: 8, size: 32 },
  mat2x3: { align: 16, size: 32 },
  mat3x3: { align: 16, size: 48 },
  mat4x3: { align: 16, size: 64 },
  mat2x4: { align: 16, size: 32 },
  mat3x4: { align: 16, size: 48 },
  mat4x4: { align: 16, size: 64 }
};
WgslReflect._textureTypes = TokenTypes.any_texture_type.map((t) => {
  return t.name;
});
WgslReflect._samplerTypes = TokenTypes.sampler_type.map((t) => {
  return t.name;
});
function getShaderLayoutFromWGSL(source) {
  const shaderLayout = { attributes: [], bindings: [] };
  let parsedWGSL;
  try {
    parsedWGSL = parseWGSL(source);
  } catch (error) {
    log.error(error.message)();
    return shaderLayout;
  }
  for (const uniform of parsedWGSL.uniforms) {
    const members = [];
    for (const attribute of uniform.type?.members || []) {
      members.push({
        name: attribute.name,
        type: getType(attribute.type)
      });
    }
    shaderLayout.bindings.push({
      type: "uniform",
      name: uniform.name,
      location: uniform.binding,
      // @ts-expect-error
      group: uniform.group,
      members
    });
  }
  const vertex = parsedWGSL.entry.vertex[0];
  const attributeCount = vertex?.inputs.length || 0;
  for (let i = 0; i < attributeCount; i++) {
    const wgslAttribute = vertex.inputs[i];
    if (wgslAttribute.locationType === "location") {
      const type = getType(wgslAttribute.type);
      shaderLayout.attributes.push({
        name: wgslAttribute.name,
        location: Number(wgslAttribute.location),
        type
      });
    }
  }
  return shaderLayout;
}
function getType(type) {
  return type.format ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source) {
  try {
    return new WgslReflect(source);
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    let message2 = "WGSL parse error";
    if (typeof error === "object" && error?.message) {
      message2 += `: ${error.message} `;
    }
    if (typeof error === "object" && error?.token) {
      message2 += error.token.line || "";
    }
    throw new Error(message2, { cause: error });
  }
}
const fp32shader = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;
const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;
const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;
const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;
float sin_taylor_fp32(float a) {
float r, s, t, x;
if (a == 0.0) {
return 0.0;
}
x = -a * a;
s = a;
r = a;
r = r * x;
t = r * INVERSE_FACTORIAL_3;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_5;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_7;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_9;
s = s + t;
return s;
}
void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
if (a == 0.0) {
sin_t = 0.0;
cos_t = 1.0;
}
sin_t = sin_taylor_fp32(a);
cos_t = sqrt(1.0 - sin_t * sin_t);
}
float tan_taylor_fp32(float a) {
float sin_a;
float cos_a;
if (a == 0.0) {
return 0.0;
}
float z = floor(a / TWO_PI);
float r = a - TWO_PI * z;
float t;
float q = floor(r / PI_2 + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return 1.0 / 0.0;
}
t = r - PI_2 * q;
q = floor(t / PI_16 + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return 1.0 / 0.0;
} else {
t = t - PI_16 * q;
}
float u = 0.0;
float v = 0.0;
float sin_t, cos_t;
float s, c;
sincos_taylor_fp32(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0;
v = SIN_TABLE_0;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1;
v = SIN_TABLE_1;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2;
v = SIN_TABLE_2;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3;
v = SIN_TABLE_3;
}
if (k > 0) {
s = u * sin_t + v * cos_t;
c = u * cos_t - v * sin_t;
} else {
s = u * sin_t - v * cos_t;
c = u * cos_t + v * sin_t;
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return sin_a / cos_a;
}
#endif
float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
return tan_taylor_fp32(a);
#else
return tan(a);
#endif
}
`;
const fp32 = {
  name: "fp32",
  vs: fp32shader
};
const DEFAULT_HIGHLIGHT_COLOR = [0, 1, 1, 1];
const vs$9 = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
out vec4 picking_vRGBcolor_Avalid;
vec3 picking_normalizeColor(vec3 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
vec4 picking_normalizeColor(vec4 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
bool picking_isColorZero(vec3 color) {
return dot(color, vec3(1.0)) < 0.00001;
}
bool picking_isColorValid(vec3 color) {
return dot(color, vec3(1.0)) > 0.00001;
}
bool isVertexHighlighted(vec3 vertexColor) {
vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
return
bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}
void picking_setPickingColor(vec3 pickingColor) {
pickingColor = picking_normalizeColor(pickingColor);
if (bool(picking.isActive)) {
picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));
if (!bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = pickingColor;
}
} else {
picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
}
}
void picking_setPickingAttribute(float value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.r = value;
}
}
void picking_setPickingAttribute(vec2 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rg = value;
}
}
void picking_setPickingAttribute(vec3 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = value;
}
}
`;
const fs$9 = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
if (picking.isActive > 0.5) {
return color;
}
bool selected = bool(picking_vRGBcolor_Avalid.a);
if (selected) {
float highLightAlpha = picking.highlightColor.a;
float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
float highLightRatio = highLightAlpha / blendedAlpha;
vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
return vec4(blendedRGB, blendedAlpha);
} else {
return color;
}
}
vec4 picking_filterPickingColor(vec4 color) {
if (bool(picking.isActive)) {
if (picking_vRGBcolor_Avalid.a == 0.0) {
discard;
}
return picking_vRGBcolor_Avalid;
}
return color;
}
vec4 picking_filterColor(vec4 color) {
vec4 highlightColor = picking_filterHighlightColor(color);
return picking_filterPickingColor(highlightColor);
}
`;
const picking$1 = {
  name: "picking",
  vs: vs$9,
  fs: fs$9,
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: false,
    isAttribute: false,
    isHighlightActive: false,
    useFloatColors: true,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: DEFAULT_HIGHLIGHT_COLOR
  },
  getUniforms: getUniforms$4
};
function getUniforms$4(opts = {}, prevUniforms) {
  const uniforms = {};
  if (opts.highlightedObjectColor === void 0) ;
  else if (opts.highlightedObjectColor === null) {
    uniforms.isHighlightActive = false;
  } else {
    uniforms.isHighlightActive = true;
    const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
    uniforms.highlightedObjectColor = highlightedObjectColor;
  }
  if (opts.highlightColor) {
    const color2 = Array.from(opts.highlightColor, (x2) => x2 / 255);
    if (!Number.isFinite(color2[3])) {
      color2[3] = 1;
    }
    uniforms.highlightColor = color2;
  }
  if (opts.isActive !== void 0) {
    uniforms.isActive = Boolean(opts.isActive);
    uniforms.isAttribute = Boolean(opts.isAttribute);
  }
  if (opts.useFloatColors !== void 0) {
    uniforms.useFloatColors = Boolean(opts.useFloatColors);
  }
  return uniforms;
}
function fp64ify(a2, out = [], startIndex = 0) {
  const hiPart = Math.fround(a2);
  const loPart = a2 - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart$1(a2) {
  return a2 - Math.fround(a2);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index2 = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index2 * 2);
    }
  }
  return matrixFP64;
}
const fp64arithmeticShader = `uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;
const CONST_UNIFORMS = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
};
function getUniforms$3() {
  return CONST_UNIFORMS;
}
const fp64arithmetic = {
  name: "fp64-arithmetic",
  vs: fp64arithmeticShader,
  getUniforms: getUniforms$3,
  fp64ify,
  fp64LowPart: fp64LowPart$1,
  fp64ifyMatrix4
};
const DEFAULT_CONFIG = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true,
  _cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
const config = globalThis.mathgl.config;
function formatValue(value, { precision = config.precision } = {}) {
  value = round(value);
  return `${parseFloat(value.toPrecision(precision))}`;
}
function isArray$2(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function clamp$1(value, min2, max2) {
  return map$1(value, (value2) => Math.max(min2, Math.min(max2, value2)));
}
function lerp$1(a2, b, t) {
  if (isArray$2(a2)) {
    return a2.map((ai, i) => lerp$1(ai, b[i], t));
  }
  return t * b + (1 - t) * a2;
}
function equals(a2, b, epsilon2) {
  const oldEpsilon = config.EPSILON;
  try {
    if (a2 === b) {
      return true;
    }
    if (isArray$2(a2) && isArray$2(b)) {
      if (a2.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a2.length; ++i) {
        if (!equals(a2[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a2 && a2.equals) {
      return a2.equals(b);
    }
    if (b && b.equals) {
      return b.equals(a2);
    }
    if (typeof a2 === "number" && typeof b === "number") {
      return Math.abs(a2 - b) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array2) {
  return array2.clone ? array2.clone() : new Array(array2.length);
}
function map$1(value, func, result) {
  if (isArray$2(value)) {
    const array2 = value;
    result = result || duplicateArray(array2);
    for (let i = 0; i < result.length && i < array2.length; ++i) {
      const val = typeof value === "number" ? value : value[i];
      result[i] = func(val, i, result);
    }
    return result;
  }
  return func(value);
}
class MathArray extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array2, offset2 = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array2[i + offset2];
    }
    return this.check();
  }
  toArray(targetArray = [], offset2 = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      targetArray[offset2 + i] = this[i];
    }
    return targetArray;
  }
  toObject(targetObject) {
    return targetObject;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
      // @ts-ignore
      this.fromObject(arrayOrObject)
    );
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return isArray$2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target) {
    return target ? this.to(target) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(config);
  }
  /** Formats string according to options */
  formatString(opts) {
    let string2 = "";
    for (let i = 0; i < this.ELEMENTS; ++i) {
      string2 += (i > 0 ? ", " : "") + formatValue(this[i], opts);
    }
    return `${opts.printTypes ? this.constructor.name : ""}[${string2}]`;
  }
  equals(array2) {
    if (!array2 || this.length !== array2.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!equals(this[i], array2[i])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array2) {
    if (!array2 || this.length !== array2.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }
    return this.check();
  }
  lerp(a2, b, t) {
    if (t === void 0) {
      return this.lerp(this, a2, b);
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a2[i];
      const endValue = typeof b === "number" ? b : b[i];
      this[i] = ai + t * (endValue - ai);
    }
    return this.check();
  }
  /** Minimal */
  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }
    return this.check();
  }
  /** Maximal */
  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }
    return this.check();
  }
  scale(scale2) {
    if (typeof scale2 === "number") {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scale2;
      }
    } else {
      for (let i = 0; i < this.ELEMENTS && i < scale2.length; ++i) {
        this[i] *= scale2[i];
      }
    }
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (config.debug && !this.validate()) {
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    }
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }
    return valid;
  }
  // three.js compatibility
  /** @deprecated */
  sub(a2) {
    return this.subtract(a2);
  }
  /** @deprecated */
  setScalar(a2) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a2;
    }
    return this.check();
  }
  /** @deprecated */
  addScalar(a2) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a2;
    }
    return this.check();
  }
  /** @deprecated */
  subScalar(a2) {
    return this.addScalar(-a2);
  }
  /** @deprecated */
  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  /** @deprecated */
  divideScalar(a2) {
    return this.multiplyByScalar(1 / a2);
  }
  /** @deprecated */
  clampScalar(min2, max2) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min2), max2);
    }
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }
  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error(`Invalid number ${JSON.stringify(value)}`);
  }
  return value;
}
function checkVector(v, length, callerName = "") {
  if (config.debug && !validateVector(v, length)) {
    throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
  }
  return v;
}
function assert$2(condition, message2) {
  if (!condition) {
    throw new Error(`math.gl assertion ${message2}`);
  }
}
class Vector extends MathArray {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = checkNumber(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = checkNumber(value);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }
    return length;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }
    return checkNumber(length);
  }
  dot(mathArray) {
    let product = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }
    return checkNumber(product);
  }
  // MODIFIERS
  normalize() {
    const length = this.magnitude();
    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i) {
    assert$2(i >= 0 && i < this.ELEMENTS, "index is out of range");
    return checkNumber(this[i]);
  }
  setComponent(i, value) {
    assert$2(i >= 0 && i < this.ELEMENTS, "index is out of range");
    this[i] = value;
    return this.check();
  }
  addVectors(a2, b) {
    return this.copy(a2).add(b);
  }
  subVectors(a2, b) {
    return this.copy(a2).subtract(b);
  }
  multiplyVectors(a2, b) {
    return this.copy(a2).multiply(b);
  }
  addScaledVector(a2, b) {
    return this.add(new this.constructor(a2).multiplyScalar(b));
  }
}
const EPSILON$1 = 1e-6;
let ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
function create$2() {
  const out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function add$1(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  return out;
}
function negate$1(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function lerp(out, a2, b, t) {
  const ax = a2[0];
  const ay = a2[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function transformMat4$2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[12];
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[13];
  return out;
}
(function() {
  const vec = create$2();
  return function(a2, stride, offset2, count2, fn, arg) {
    let i;
    let l;
    if (!stride) {
      stride = 2;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset2, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
    }
    return a2;
  };
})();
function vec2_transformMat4AsVector(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const w = m2[3] * x2 + m2[7] * y2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2) / w;
  out[1] = (m2[1] * x2 + m2[5] * y2) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z = a2[2];
  const w = m2[3] * x2 + m2[7] * y2 + m2[11] * z || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z) / w;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z) / w;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  out[2] = a2[2];
  return out;
}
function create$1() {
  const out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function subtract(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  return out;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function dot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cross(out, a2, b) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b[0];
  const by = b[1];
  const bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function transformMat4$1(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z = a2[2];
  let w = m2[3] * x2 + m2[7] * y2 + m2[11] * z + m2[15];
  w = w || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z + m2[12]) / w;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z + m2[13]) / w;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z + m2[14]) / w;
  return out;
}
function transformMat3(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z = a2[2];
  out[0] = x2 * m2[0] + y2 * m2[3] + z * m2[6];
  out[1] = x2 * m2[1] + y2 * m2[4] + z * m2[7];
  out[2] = x2 * m2[2] + y2 * m2[5] + z * m2[8];
  return out;
}
function transformQuat(out, a2, q) {
  const qx = q[0];
  const qy = q[1];
  const qz = q[2];
  const qw = q[3];
  const x2 = a2[0];
  const y2 = a2[1];
  const z = a2[2];
  let uvx = qy * z - qz * y2;
  let uvy = qz * x2 - qx * z;
  let uvz = qx * y2 - qy * x2;
  let uuvx = qy * uvz - qz * uvy;
  let uuvy = qz * uvx - qx * uvz;
  let uuvz = qx * uvy - qy * uvx;
  const w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x2 + uvx + uuvx;
  out[1] = y2 + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX$1(out, a2, b, rad) {
  const p2 = [];
  const r = [];
  p2[0] = a2[0] - b[0];
  p2[1] = a2[1] - b[1];
  p2[2] = a2[2] - b[2];
  r[0] = p2[0];
  r[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY$1(out, a2, b, rad) {
  const p2 = [];
  const r = [];
  p2[0] = a2[0] - b[0];
  p2[1] = a2[1] - b[1];
  p2[2] = a2[2] - b[2];
  r[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r[1] = p2[1];
  r[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ$1(out, a2, b, rad) {
  const p2 = [];
  const r = [];
  p2[0] = a2[0] - b[0];
  p2[1] = a2[1] - b[1];
  p2[2] = a2[2] - b[2];
  r[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r[2] = p2[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a2, b) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b[0];
  const by = b[1];
  const bz = b[2];
  const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
  const cosine = mag && dot(a2, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
const sub = subtract;
(function() {
  const vec = create$1();
  return function(a2, stride, offset2, count2, fn, arg) {
    let i;
    let l;
    if (!stride) {
      stride = 3;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset2, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
    }
    return a2;
  };
})();
const ORIGIN = [0, 0, 0];
let ZERO$1;
class Vector3 extends Vector {
  static get ZERO() {
    if (!ZERO$1) {
      ZERO$1 = new Vector3(0, 0, 0);
      Object.freeze(ZERO$1);
    }
    return ZERO$1;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(x2 = 0, y2 = 0, z = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && isArray$2(x2)) {
      this.copy(x2);
    } else {
      if (config.debug) {
        checkNumber(x2);
        checkNumber(y2);
        checkNumber(z);
      }
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
    }
  }
  set(x2, y2, z) {
    this[0] = x2;
    this[1] = y2;
    this[2] = z;
    return this.check();
  }
  copy(array2) {
    this[0] = array2[0];
    this[1] = array2[1];
    this[2] = array2[2];
    return this.check();
  }
  fromObject(object2) {
    if (config.debug) {
      checkNumber(object2.x);
      checkNumber(object2.y);
      checkNumber(object2.z);
    }
    this[0] = object2.x;
    this[1] = object2.y;
    this[2] = object2.z;
    return this.check();
  }
  toObject(object2) {
    object2.x = this[0];
    object2.y = this[1];
    object2.z = this[2];
    return object2;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  // ACCESSORS
  angle(vector) {
    return angle(this, vector);
  }
  // MODIFIERS
  cross(vector) {
    cross(this, this, vector);
    return this.check();
  }
  rotateX({ radians, origin = ORIGIN }) {
    rotateX$1(this, this, origin, radians);
    return this.check();
  }
  rotateY({ radians, origin = ORIGIN }) {
    rotateY$1(this, this, origin, radians);
    return this.check();
  }
  rotateZ({ radians, origin = ORIGIN }) {
    rotateZ$1(this, this, origin, radians);
    return this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(matrix4) {
    transformMat4$1(this, this, matrix4);
    return this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(matrix4) {
    vec3_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    transformMat3(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec3_transformMat2(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    transformQuat(this, this, quaternion);
    return this.check();
  }
}
class Matrix extends MathArray {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let string2 = "[";
    if (config.printRowMajor) {
      string2 += "row-major:";
      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string2 += ` ${this[col * this.RANK + row]}`;
        }
      }
    } else {
      string2 += "column-major:";
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string2 += ` ${this[i]}`;
      }
    }
    string2 += "]";
    return string2;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  // By default assumes row major indices
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  // By default assumes row major indices
  setElement(row, col, value) {
    this[col * this.RANK + row] = checkNumber(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }
    return this;
  }
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a03 = a2[3];
    const a12 = a2[6];
    const a13 = a2[7];
    const a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function determinant(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b0 = a00 * a11 - a01 * a10;
  const b1 = a00 * a12 - a02 * a10;
  const b2 = a01 * a12 - a02 * a11;
  const b3 = a20 * a31 - a21 * a30;
  const b4 = a20 * a32 - a22 * a30;
  const b5 = a21 * a32 - a22 * a31;
  const b6 = a00 * b5 - a01 * b4 + a02 * b3;
  const b7 = a10 * b5 - a11 * b4 + a12 * b3;
  const b8 = a20 * b2 - a21 * b1 + a22 * b0;
  const b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply(out, a2, b) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  let b0 = b[0];
  let b1 = b[1];
  let b2 = b[2];
  let b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a2, v) {
  const x2 = v[0];
  const y2 = v[1];
  const z = v[2];
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  if (a2 === out) {
    out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z + a2[12];
    out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z + a2[13];
    out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z + a2[14];
    out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y2 + a20 * z + a2[12];
    out[13] = a01 * x2 + a11 * y2 + a21 * z + a2[13];
    out[14] = a02 * x2 + a12 * y2 + a22 * z + a2[14];
    out[15] = a03 * x2 + a13 * y2 + a23 * z + a2[15];
  }
  return out;
}
function scale$1(out, a2, v) {
  const x2 = v[0];
  const y2 = v[1];
  const z = v[2];
  out[0] = a2[0] * x2;
  out[1] = a2[1] * x2;
  out[2] = a2[2] * x2;
  out[3] = a2[3] * x2;
  out[4] = a2[4] * y2;
  out[5] = a2[5] * y2;
  out[6] = a2[6] * y2;
  out[7] = a2[7] * y2;
  out[8] = a2[8] * z;
  out[9] = a2[9] * z;
  out[10] = a2[10] * z;
  out[11] = a2[11] * z;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate(out, a2, rad, axis) {
  let x2 = axis[0];
  let y2 = axis[1];
  let z = axis[2];
  let len = Math.sqrt(x2 * x2 + y2 * y2 + z * z);
  let c2;
  let s2;
  let t;
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  let b00;
  let b01;
  let b02;
  let b10;
  let b11;
  let b12;
  let b20;
  let b21;
  let b22;
  if (len < EPSILON$1) {
    return null;
  }
  len = 1 / len;
  x2 *= len;
  y2 *= len;
  z *= len;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t = 1 - c2;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x2 * x2 * t + c2;
  b01 = y2 * x2 * t + z * s2;
  b02 = z * x2 * t - y2 * s2;
  b10 = x2 * y2 * t - z * s2;
  b11 = y2 * y2 * t + c2;
  b12 = z * y2 * t + x2 * s2;
  b20 = x2 * z * t + y2 * s2;
  b21 = y2 * z * t - x2 * s2;
  b22 = z * z * t + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c2 + a20 * s2;
  out[5] = a11 * c2 + a21 * s2;
  out[6] = a12 * c2 + a22 * s2;
  out[7] = a13 * c2 + a23 * s2;
  out[8] = a20 * c2 - a10 * s2;
  out[9] = a21 * c2 - a11 * s2;
  out[10] = a22 * c2 - a12 * s2;
  out[11] = a23 * c2 - a13 * s2;
  return out;
}
function rotateY(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 - a20 * s2;
  out[1] = a01 * c2 - a21 * s2;
  out[2] = a02 * c2 - a22 * s2;
  out[3] = a03 * c2 - a23 * s2;
  out[8] = a00 * s2 + a20 * c2;
  out[9] = a01 * s2 + a21 * c2;
  out[10] = a02 * s2 + a22 * c2;
  out[11] = a03 * s2 + a23 * c2;
  return out;
}
function rotateZ(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 + a10 * s2;
  out[1] = a01 * c2 + a11 * s2;
  out[2] = a02 * c2 + a12 * s2;
  out[3] = a03 * c2 + a13 * s2;
  out[4] = a10 * c2 - a00 * s2;
  out[5] = a11 * c2 - a01 * s2;
  out[6] = a12 * c2 - a02 * s2;
  out[7] = a13 * c2 - a03 * s2;
  return out;
}
function fromQuat(out, q) {
  const x2 = q[0];
  const y2 = q[1];
  const z = q[2];
  const w = q[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z2 = z + z;
  const xx = x2 * x22;
  const yx = y2 * x22;
  const yy = y2 * y22;
  const zx = z * x22;
  const zy = z * y22;
  const zz = z * z2;
  const wx = w * x22;
  const wy = w * y22;
  const wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  const rl = 1 / (right - left);
  const tb = 1 / (top - bottom);
  const nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  const f = 1 / Math.tan(fovy / 2);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    const nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
const perspective = perspectiveNO;
function orthoNO(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
const ortho = orthoNO;
function lookAt(out, eye, center, up) {
  let len;
  let x0;
  let x1;
  let x2;
  let y0;
  let y1;
  let y2;
  let z0;
  let z1;
  let z2;
  const eyex = eye[0];
  const eyey = eye[1];
  const eyez = eye[2];
  const upx = up[0];
  const upy = up[1];
  const upz = up[2];
  const centerx = center[0];
  const centery = center[1];
  const centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON$1 && Math.abs(eyey - centery) < EPSILON$1 && Math.abs(eyez - centerz) < EPSILON$1) {
    return identity3(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function create() {
  const out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function scale(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  out[3] = a2[3] * b;
  return out;
}
function transformMat4(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z = a2[2];
  const w = a2[3];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[8] * z + m2[12] * w;
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[9] * z + m2[13] * w;
  out[2] = m2[2] * x2 + m2[6] * y2 + m2[10] * z + m2[14] * w;
  out[3] = m2[3] * x2 + m2[7] * y2 + m2[11] * z + m2[15] * w;
  return out;
}
(function() {
  const vec = create();
  return function(a2, stride, offset2, count2, fn, arg) {
    let i;
    let l;
    if (!stride) {
      stride = 4;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset2, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      vec[3] = a2[i + 3];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
      a2[i + 3] = vec[3];
    }
    return a2;
  };
})();
var INDICES;
(function(INDICES2) {
  INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES2[INDICES2["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES2[INDICES2["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES2[INDICES2["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES2[INDICES2["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES2[INDICES2["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES2[INDICES2["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES2[INDICES2["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES2[INDICES2["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES2[INDICES2["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES2[INDICES2["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES2[INDICES2["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES2[INDICES2["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES2[INDICES2["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES || (INDICES = {}));
const DEFAULT_FOVY = 45 * Math.PI / 180;
const DEFAULT_ASPECT = 1;
const DEFAULT_NEAR = 0.1;
const DEFAULT_FAR = 500;
const IDENTITY_MATRIX$1 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Matrix4 extends Matrix {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array2) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array2)) {
      this.copy(array2);
    } else {
      this.identity();
    }
  }
  copy(array2) {
    this[0] = array2[0];
    this[1] = array2[1];
    this[2] = array2[2];
    this[3] = array2[3];
    this[4] = array2[4];
    this[5] = array2[5];
    this[6] = array2[6];
    this[7] = array2[7];
    this[8] = array2[8];
    this[9] = array2[9];
    this[10] = array2[10];
    this[11] = array2[11];
    this[12] = array2[12];
    this[13] = array2[13];
    this[14] = array2[14];
    this[15] = array2[15];
    return this.check();
  }
  // eslint-disable-next-line max-params
  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(IDENTITY_MATRIX$1);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(object2) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(quaternion) {
    fromQuat(this, quaternion);
    return this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(view) {
    const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    if (far === Infinity) {
      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      frustum(this, left, right, bottom, top, near, far);
    }
    return this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(view) {
    const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
    lookAt(this, eye, center, up);
    return this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(view) {
    const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(view) {
    const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    checkRadians(fovy);
    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return this.ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(view) {
    const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
    checkRadians(fovy);
    perspective(this, fovy, aspect, near, far);
    return this.check();
  }
  // Accessors
  determinant() {
    return determinant(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale2 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale2[0];
    const inverseScale1 = 1 / scale2[1];
    const inverseScale2 = 1 / scale2[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale2 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale2[0];
    const inverseScale1 = 1 / scale2[1];
    const inverseScale2 = 1 / scale2[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }
  // Modifiers
  transpose() {
    transpose(this, this);
    return this.check();
  }
  invert() {
    invert(this, this);
    return this.check();
  }
  // Operations
  multiplyLeft(a2) {
    multiply(this, a2, this);
    return this.check();
  }
  multiplyRight(a2) {
    multiply(this, this, a2);
    return this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(radians) {
    rotateX(this, this, radians);
    return this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(radians) {
    rotateY(this, this, radians);
    return this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(radians) {
    rotateZ(this, this, radians);
    return this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(angleXYZ) {
    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(radians, axis) {
    rotate(this, this, radians, axis);
    return this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(factor) {
    scale$1(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
    return this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(vector) {
    translate(this, this, vector);
    return this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(vector, result) {
    if (vector.length === 4) {
      result = transformMat4(result || [-0, -0, -0, -0], vector, this);
      checkVector(result, 4);
      return result;
    }
    return this.transformAsPoint(vector, result);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(vector, result) {
    const { length } = vector;
    let out;
    switch (length) {
      case 2:
        out = transformMat4$2(result || [-0, -0], vector, this);
        break;
      case 3:
        out = transformMat4$1(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /** @deprecated */
  transformPoint(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  /** @deprecated */
  transformVector(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  /** @deprecated */
  transformDirection(vector, result) {
    return this.transformAsVector(vector, result);
  }
  // three.js math API compatibility
  makeRotationX(radians) {
    return this.identity().rotateX(radians);
  }
  makeTranslation(x2, y2, z) {
    return this.identity().translate([x2, y2, z]);
  }
}
let ZERO;
let IDENTITY$1;
function getZeroMatrix() {
  if (!ZERO) {
    ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO);
  }
  return ZERO;
}
function getIdentityMatrix() {
  if (!IDENTITY$1) {
    IDENTITY$1 = new Matrix4();
    Object.freeze(IDENTITY$1);
  }
  return IDENTITY$1;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error("expected radians");
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}
const lightingShader$1 = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;
uniform bool lighting_uEnabled;
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
#endif
`;
const INITIAL_MODULE_OPTIONS$2 = {
  lightSources: {}
};
function convertColor(colorDef = {}) {
  const { color: color2 = [0, 0, 0], intensity = 1 } = colorDef;
  return color2.map((component) => component * intensity / 255);
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
  const lightSourceUniforms = {};
  if (ambientLight) {
    lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
  } else {
    lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
  }
  pointLights.forEach((pointLight, index2) => {
    lightSourceUniforms[`lighting_uPointLight[${index2}].color`] = convertColor(pointLight);
    lightSourceUniforms[`lighting_uPointLight[${index2}].position`] = pointLight.position;
    lightSourceUniforms[`lighting_uPointLight[${index2}].attenuation`] = pointLight.attenuation || [
      1,
      0,
      0
    ];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index2) => {
    lightSourceUniforms[`lighting_uDirectionalLight[${index2}].color`] = convertColor(directionalLight);
    lightSourceUniforms[`lighting_uDirectionalLight[${index2}].direction`] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}
function getUniforms$2(opts = INITIAL_MODULE_OPTIONS$2) {
  if ("lightSources" in opts) {
    const { ambientLight, pointLights, directionalLights } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    if (!hasLights) {
      return { lighting_uEnabled: false };
    }
    return Object.assign({}, getLightSourceUniforms({ ambientLight, pointLights, directionalLights }), {
      lighting_uEnabled: true
    });
  }
  if ("lights" in opts) {
    const lightSources = { pointLights: [], directionalLights: [] };
    for (const light of opts.lights || []) {
      switch (light.type) {
        case "ambient":
          lightSources.ambientLight = light;
          break;
        case "directional":
          lightSources.directionalLights?.push(light);
          break;
        case "point":
          lightSources.pointLights?.push(light);
          break;
      }
    }
    return getUniforms$2({ lightSources });
  }
  return {};
}
const lights = {
  name: "lights",
  vs: lightingShader$1,
  fs: lightingShader$1,
  getUniforms: getUniforms$2,
  defines: {
    MAX_LIGHTS: 3
  }
};
const lightingShader = `uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, lighting_uShininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
`;
const INITIAL_MODULE_OPTIONS$1 = {};
function getMaterialUniforms(material) {
  const { ambient = 0.35, diffuse = 0.6, shininess = 32, specularColor = [30, 30, 30] } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map((x2) => x2 / 255)
  };
}
function getUniforms$1(opts = INITIAL_MODULE_OPTIONS$1) {
  if (!("material" in opts)) {
    return {};
  }
  const { material } = opts;
  if (!material) {
    return { lighting_uEnabled: false };
  }
  return getMaterialUniforms(material);
}
const gouraudLighting = {
  name: "gouraud-lighting",
  dependencies: [lights],
  vs: lightingShader,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: getUniforms$1
};
const defines = "#define SMOOTH_EDGE_RADIUS 0.5";
const vs$8 = `
${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`;
const fs$8 = `
${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
const geometry = { name: "geometry", vs: vs$8, fs: fs$8 };
const COORDINATE_SYSTEM = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
  get: () => {
    defaultLogger.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
    return 0;
  }
});
const PROJECTION_MODE = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
};
const UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
const EVENTS = {
  click: { handler: "onClick" },
  panstart: { handler: "onDragStart" },
  panmove: { handler: "onDrag" },
  panend: { handler: "onDragEnd" }
};
const COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
const PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
const UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
const projectShader = `${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}
uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project_uPseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project_uCommonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project_uCommonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project_uCommonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project_uWrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project_uModelMatrix * position;
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project_uCoordinateOrigin;
}
}
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
(project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project_uCoordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
return offset * project_uFocalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project_uScale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project_uScale;
}
`;
function isEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (Array.isArray(a2)) {
    const len = a2.length;
    if (!b || b.length !== len) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (a2[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
const ZERO_VECTOR$1 = [0, 0, 0, 0];
const VECTOR_TO_POINT_MATRIX$1 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
const DEFAULT_COORDINATE_ORIGIN$1 = [0, 0, 0];
const getMemoizedViewportUniforms = memoize2(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN$1) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }
  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? (
      // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
      [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]
    ) : null;
  }
  switch (viewport.projectionMode) {
    case PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }
      break;
    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [
          Math.fround(viewport.center[0]),
          Math.fround(viewport.center[1]),
          0
        ];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;
    case PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;
    default:
      offsetMode = false;
  }
  return { geospatialOrigin, shaderCoordinateOrigin, offsetMode };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const { viewMatrixUncentered, projectionMatrix } = viewport;
  let { viewMatrix, viewProjectionMatrix } = viewport;
  let projectionCenter = ZERO_VECTOR$1;
  let originCommon = ZERO_VECTOR$1;
  let cameraPosCommon = viewport.cameraPosition;
  const { geospatialOrigin, shaderCoordinateOrigin, offsetMode } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [
      cameraPosCommon[0] - originCommon[0],
      cameraPosCommon[1] - originCommon[1],
      cameraPosCommon[2] - originCommon[2]
    ];
    originCommon[3] = 1;
    projectionCenter = transformMat4([], originCommon, viewProjectionMatrix);
    viewMatrix = viewMatrixUncentered || viewMatrix;
    viewProjectionMatrix = multiply([], projectionMatrix, viewMatrix);
    viewProjectionMatrix = multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX$1);
  }
  return {
    viewMatrix,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  // Match Layer.defaultProps
  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN$1,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.project_uWrapLongitude = autoWrapLongitude;
  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;
  return uniforms;
}
function calculateViewportUniforms({ viewport, devicePixelRatio, coordinateSystem, coordinateOrigin }) {
  const { projectionCenter, viewProjectionMatrix, originCommon, cameraPosCommon, shaderCoordinateOrigin, geospatialOrigin } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [
    viewport.width * devicePixelRatio,
    viewport.height * devicePixelRatio
  ];
  const focalDistance = transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    // Projection mode values
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCommonOrigin: originCommon.slice(0, 3),
    project_uCenter: projectionCenter,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    project_uPseudoMeters: Boolean(viewport._pseudoMeters),
    // Screen size
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: focalDistance,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    // This is the mercator scale (2 ** zoom)
    project_uWrapLongitude: false,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uModelMatrix: IDENTITY_MATRIX,
    // This is for lighting calculations
    project_uCameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case COORDINATE_SYSTEM.LNGLAT:
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case COORDINATE_SYSTEM.CARTESIAN:
        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.project_uCommonUnitsPerWorldUnit2 = [
          0,
          0,
          distanceScalesAtOrigin.unitsPerMeter2[2]
        ];
        break;
    }
  }
  return uniforms;
}
const INITIAL_MODULE_OPTIONS = {};
function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if ("viewport" in opts) {
    return getUniformsFromViewport(opts);
  }
  return {};
}
const project = {
  name: "project",
  dependencies: [fp32, geometry],
  vs: projectShader,
  getUniforms
};
const vs$7 = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`;
const project32 = {
  name: "project32",
  dependencies: [project],
  vs: vs$7
};
function createMat4$1() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = transformMat4([], vector, matrix);
  scale(result, result, 1 / result[3]);
  return result;
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function clamp(x2, min2, max2) {
  return x2 < min2 ? min2 : x2 > max2 ? max2 : x2;
}
function ieLog2(x2) {
  return Math.log(x2) * Math.LOG2E;
}
const log2 = Math.log2 || ieLog2;
function assert$1(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "@math.gl/web-mercator: assertion failed.");
  }
}
const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS$3 = PI / 180;
const RADIANS_TO_DEGREES = 180 / PI;
const TILE_SIZE$2 = 512;
const EARTH_CIRCUMFERENCE = 4003e4;
const MAX_LATITUDE = 85.051129;
const DEFAULT_ALTITUDE = 1.5;
function scaleToZoom(scale2) {
  return log2(scale2);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert$1(Number.isFinite(lng));
  assert$1(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  const lambda2 = lng * DEGREES_TO_RADIANS$3;
  const phi2 = lat * DEGREES_TO_RADIANS$3;
  const x2 = TILE_SIZE$2 * (lambda2 + PI) / (2 * PI);
  const y2 = TILE_SIZE$2 * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x2, y2];
}
function worldToLngLat(xy) {
  const [x2, y2] = xy;
  const lambda2 = x2 / TILE_SIZE$2 * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y2 / TILE_SIZE$2 * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}
function getMeterZoom(options) {
  const { latitude } = options;
  assert$1(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS$3);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS$3);
  return TILE_SIZE$2 / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
  const { latitude, longitude, highPrecision = false } = options;
  assert$1(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE$2;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS$3);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS$3 * Math.tan(latitude * DEGREES_TO_RADIANS$3) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x2, y2, z] = xyz;
  const { unitsPerMeter: unitsPerMeter2, unitsPerMeter2: unitsPerMeter22 } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x2 * (unitsPerMeter2[0] + unitsPerMeter22[0] * y2);
  worldspace[1] += y2 * (unitsPerMeter2[1] + unitsPerMeter22[1] * y2);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}
function getViewMatrix(options) {
  const {
    // Viewport props
    height,
    pitch,
    bearing: bearing2,
    altitude,
    // Pre-calculated parameters
    scale: scale2,
    center
  } = options;
  const vm = createMat4$1();
  translate(vm, vm, [0, 0, -altitude]);
  rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS$3);
  rotateZ(vm, vm, bearing2 * DEGREES_TO_RADIANS$3);
  const relativeScale = scale2 / height;
  scale$1(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    translate(vm, vm, negate([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const { width, height, altitude, pitch = 0, offset: offset2, center, scale: scale2, nearZMultiplier = 1, farZMultiplier = 1 } = options;
  let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
  if (altitude !== void 0) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS$3;
  const pitchRadians = pitch * DEGREES_TO_RADIANS$3;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale2 / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset2 ? offset2[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS$3);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x2, y2, z = 0] = xyz;
  assert$1(Number.isFinite(x2) && Number.isFinite(y2) && Number.isFinite(z));
  return transformVector(pixelProjectionMatrix, [x2, y2, z, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x2, y2, z] = xyz;
  assert$1(Number.isFinite(x2) && Number.isFinite(y2), "invalid pixel coordinate");
  if (Number.isFinite(z)) {
    const coord = transformVector(pixelUnprojectionMatrix, [x2, y2, z, 1]);
    return coord;
  }
  const coord0 = transformVector(pixelUnprojectionMatrix, [x2, y2, 0, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x2, y2, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return lerp([], coord0, coord1, t);
}
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: offset2 = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);
  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);
  const size = [
    Math.max(Math.abs(se[0] - nw[0]), minExtent),
    Math.max(Math.abs(se[1] - nw[1]), minExtent)
  ];
  const targetSize = [
    width - padding.left - padding.right - Math.abs(offset2[0]) * 2,
    height - padding.top - padding.bottom - Math.abs(offset2[1]) * 2
  ];
  assert$1(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX2 = targetSize[0] / size[0];
  const scaleY2 = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX2;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = worldToLngLat(center);
  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX2, scaleY2))));
  assert$1(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === "number") {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  assert$1(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}
const DEGREES_TO_RADIANS$2 = Math.PI / 180;
function getBounds(viewport, z = 0) {
  const { width, height, unproject } = viewport;
  const unprojectOps = { targetZ: z };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS$2 : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS$2;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z);
    topRight = unprojectOnFarPlane(viewport, width, z);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x2, targetZ) {
  const { pixelUnprojectionMatrix } = viewport;
  const coord0 = transformVector(pixelUnprojectionMatrix, [x2, 0, 1, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x2, viewport.height, 1, 1]);
  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = lerp([], coord0, coord1, t);
  const result = worldToLngLat(coord);
  result.push(targetZ);
  return result;
}
const TILE_SIZE$1 = 512;
function normalizeViewportProps(props) {
  const { width, height, pitch = 0 } = props;
  let { longitude, latitude, zoom, bearing: bearing2 = 0 } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = mod(longitude + 180, 360) - 180;
  }
  if (bearing2 < -180 || bearing2 > 180) {
    bearing2 = mod(bearing2 + 180, 360) - 180;
  }
  const minZoom = log2(height / TILE_SIZE$1);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = worldToLngLat([0, TILE_SIZE$1 - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return { width, height, longitude, latitude, zoom, pitch, bearing: bearing2 };
}
const vs$6 = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`;
const fs$7 = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`;
const getMemoizedViewportCenterPosition = memoize2(getViewportCenterPosition);
const getMemoizedViewProjectionMatrices = memoize2(getViewProjectionMatrices);
const DEFAULT_SHADOW_COLOR$1 = [0, 0, 0, 1];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x2, y2, z] = xyz;
  const coord = pixelsToWorld([x2, y2, z], pixelUnprojectionMatrix);
  if (Number.isFinite(z)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition({ viewport, center }) {
  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({ viewport, shadowMatrices }) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? void 0 : 1;
  const corners = [
    [0, 0, farZ],
    // top left ground
    [viewport.width, 0, farZ],
    // top right ground
    [0, viewport.height, farZ],
    // bottom left ground
    [viewport.width, viewport.height, farZ],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [viewport.width, 0, -1],
    // top right near
    [0, viewport.height, -1],
    // bottom left near
    [viewport.width, viewport.height, -1]
    // bottom right near
  ].map((pixel) => (
    // @ts-expect-error z may be undefined
    screenToCommonSpace(pixel, pixelUnprojectionMatrix)
  ));
  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
    const positions = corners.map((corner) => viewMatrix.transform(corner));
    const projectionMatrix = new Matrix4().ortho({
      left: Math.min(...positions.map((position) => position[0])),
      right: Math.max(...positions.map((position) => position[0])),
      bottom: Math.min(...positions.map((position) => position[1])),
      top: Math.max(...positions.map((position) => position[1])),
      near: Math.min(...positions.map((position) => -position[2])),
      far: Math.max(...positions.map((position) => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }
  return projectionMatrices;
}
function createShadowUniforms(opts, context) {
  const { shadowEnabled = true } = opts;
  if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      shadow_uDrawShadowMap: false,
      shadow_uUseShadowMap: false,
      shadow_uShadowMap0: opts.dummyShadowMap,
      shadow_uShadowMap1: opts.dummyShadowMap
    };
  }
  const uniforms = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR$1,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  const center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();
  for (let i = 0; i < opts.shadowMatrices.length; i++) {
    const viewProjectionMatrix = viewProjectionMatrices[i];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
    if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }
  for (let i = 0; i < viewProjectionMatrices.length; i++) {
    uniforms[`shadow_uViewProjectionMatrices[${i}]`] = viewProjectionMatrices[i];
    uniforms[`shadow_uProjectCenters[${i}]`] = projectCenters[i];
  }
  for (let i = 0; i < 2; i++) {
    uniforms[`shadow_uShadowMap${i}`] = opts.shadowMaps && opts.shadowMaps[i] || opts.dummyShadowMap;
  }
  return uniforms;
}
const shadow = {
  name: "shadow",
  dependencies: [project],
  vs: vs$6,
  fs: fs$7,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  // @ts-expect-error stricter luma gl types
  getUniforms: (opts = {}, context = {}) => {
    if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
      return createShadowUniforms(opts, context);
    }
    return {};
  }
};
const picking = {
  ...picking$1,
  defaultUniforms: { ...picking$1.defaultUniforms, useFloatColors: false },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
};
const DEFAULT_MODULES = [project];
const SHADER_HOOKS = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
function getShaderAssembler() {
  const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();
  for (const shaderModule of DEFAULT_MODULES) {
    shaderAssembler.addDefaultModule(shaderModule);
  }
  for (const shaderHook of SHADER_HOOKS) {
    shaderAssembler.addShaderHook(shaderHook);
  }
  return shaderAssembler;
}
const DEFAULT_LIGHT_COLOR$1 = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY$1 = 1;
let idCount$1 = 0;
class AmbientLight {
  constructor(props = {}) {
    this.type = "ambient";
    const { color: color2 = DEFAULT_LIGHT_COLOR$1 } = props;
    const { intensity = DEFAULT_LIGHT_INTENSITY$1 } = props;
    this.id = props.id || `ambient-${idCount$1++}`;
    this.color = color2;
    this.intensity = intensity;
  }
}
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1;
const DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
let idCount = 0;
class DirectionalLight {
  constructor(props = {}) {
    this.type = "directional";
    const { color: color2 = DEFAULT_LIGHT_COLOR } = props;
    const { intensity = DEFAULT_LIGHT_INTENSITY } = props;
    const { direction = DEFAULT_LIGHT_DIRECTION } = props;
    const { _shadow = false } = props;
    this.id = props.id || `directional-${idCount++}`;
    this.color = color2;
    this.intensity = intensity;
    this.type = "directional";
    this.direction = new Vector3(direction).normalize().toArray();
    this.shadow = _shadow;
  }
  getProjectedLight(opts) {
    return this;
  }
}
class Pass {
  /** Create a new Pass instance */
  constructor(device, props = { id: "pass" }) {
    const { id } = props;
    this.id = id;
    this.device = device;
    this.props = { ...props };
  }
  setProps(props) {
    Object.assign(this.props, props);
  }
  render(params) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class LayersPass extends Pass {
  constructor() {
    super(...arguments);
    this._lastRenderIndex = -1;
  }
  render(options) {
    const [width, height] = this.device.canvasContext.getDrawingBufferSize();
    const clearCanvas = options.clearCanvas ?? true;
    const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);
    const clearDepth = clearCanvas ? 1 : false;
    const clearStencil = clearCanvas ? 0 : false;
    const colorMask = options.colorMask ?? 15;
    const parameters = { viewport: [0, 0, width, height] };
    if (options.colorMask) {
      parameters.colorMask = colorMask;
    }
    if (options.scissorRect) {
      parameters.scissorRect = options.scissorRect;
    }
    const renderPass = this.device.beginRenderPass({
      framebuffer: options.target,
      parameters,
      clearColor,
      clearDepth,
      clearStencil
    });
    try {
      return this._drawLayers(renderPass, options);
    } finally {
      renderPass.end();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(renderPass, options) {
    const { target, moduleParameters, viewports, views, onViewportActive, clearStack = true } = options;
    options.pass = options.pass || "unknown";
    if (clearStack) {
      this._lastRenderIndex = -1;
    }
    const renderStats = [];
    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive?.(viewport);
      const drawLayerParams = this._getDrawLayerParams(viewport, options);
      const subViewports = viewport.subViewports || [viewport];
      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(renderPass, {
          target,
          moduleParameters,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);
        renderStats.push(stats);
      }
    }
    return renderStats;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(viewport, { layers, pass, isPicking = false, layerFilter, cullRect, effects, moduleParameters }, evaluateShouldDrawOnly = false) {
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking,
      renderPass: pass,
      cullRect
    };
    const layerFilterCache = {};
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
      const layerParam = {
        shouldDrawLayer
      };
      if (shouldDrawLayer && !evaluateShouldDrawOnly) {
        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
        layerParam.layerParameters = {
          ...layer.context.deck?.props.parameters,
          ...this.getLayerParameters(layer, layerIndex, viewport)
        };
      }
      drawLayerParams[layerIndex] = layerParam;
    }
    return drawLayerParams;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(renderPass, { layers, moduleParameters: globalModuleParameters, pass, target, viewport, view }, drawLayerParams) {
    const glViewport = getGLViewport(this.device, {
      moduleParameters: globalModuleParameters,
      target,
      viewport
    });
    if (view && view.props.clear) {
      const clearOpts = view.props.clear === true ? { color: true, depth: true } : view.props.clear;
      this.device.withParametersWebGL({
        scissorTest: true,
        scissor: glViewport
      }, () => this.device.clearWebGL(clearOpts));
    }
    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    renderPass.setParameters({ viewport: glViewport });
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const { shouldDrawLayer, layerRenderIndex, moduleParameters, layerParameters } = drawLayerParams[layerIndex];
      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }
      if (layer.isComposite) {
        renderStatus.compositeCount++;
      } else if (shouldDrawLayer) {
        renderStatus.visibleCount++;
        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
        moduleParameters.viewport = viewport;
        layer.context.renderPass = renderPass;
        try {
          layer._drawLayer({
            renderPass,
            moduleParameters,
            uniforms: { layerIndex: layerRenderIndex },
            parameters: layerParameters
          });
        } catch (err) {
          layer.raiseError(err, `drawing ${layer} to ${pass}`);
        }
      }
    }
    return renderStatus;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(layer) {
    return true;
  }
  getModuleParameters(layer, effects) {
    return null;
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
    if (!shouldDrawLayer) {
      return false;
    }
    drawContext.layer = layer;
    let parent = layer.parent;
    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }
      drawContext.layer = parent;
      parent = parent.parent;
    }
    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;
      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }
      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }
    layer.activateViewport(drawContext.viewport);
    return true;
  }
  _getModuleParameters(layer, effects, pass, overrides) {
    const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const moduleParameters = Object.assign(Object.create(layer.internalState?.propsInTransition || layer.props), {
      autoWrapLongitude: layer.wrapLongitude,
      viewport: layer.context.viewport,
      mousePosition: layer.context.mousePosition,
      picking: {
        isActive: 0
      },
      devicePixelRatio
    });
    if (effects) {
      for (const effect of effects) {
        Object.assign(moduleParameters, effect.getModuleParameters?.(layer));
      }
    }
    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
  }
}
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};
  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index2;
    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }
    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index2 = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index2 = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index2 = startIndex;
    }
    if (isDrawn && index2 >= startIndex) {
      startIndex = index2 + 1;
    }
    layerIndices[layerId] = index2;
    return index2;
  };
  return resolveLayerIndex;
}
function getGLViewport(device, { moduleParameters, target, viewport }) {
  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || // @ts-expect-error TODO - assuming WebGL context
  device.canvasContext.cssToDeviceRatio();
  const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();
  const height = target ? target.height : drawingBufferHeight;
  const dimensions = viewport;
  return [
    dimensions.x * pixelRatio,
    height - (dimensions.y + dimensions.height) * pixelRatio,
    dimensions.width * pixelRatio,
    dimensions.height * pixelRatio
  ];
}
class ShadowPass extends LayersPass {
  constructor(device, props) {
    super(device, props);
    this.shadowMap = device.createTexture({
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    this.depthBuffer = device.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: false,
      // TODO fix getWebGLTextureParameters() in luma to avoid passing deprecated parameters
      dataFormat: 6402,
      // gl.DEPTH_COMPONENT
      type: 5125
      // gl.UNSIGNED_INT
    });
    this.fbo = device.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [this.shadowMap],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: this.depthBuffer
    });
  }
  render(params) {
    const target = this.fbo;
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const viewport = params.viewports[0];
    const width = viewport.width * pixelRatio;
    const height = viewport.height * pixelRatio;
    const clearColor = [1, 1, 1, 1];
    if (width !== target.width || height !== target.height) {
      target.resize({ width, height });
    }
    super.render({ ...params, clearColor, target, pass: "shadow" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return { ...layer.props.parameters, blend: false, depthRange: [0, 1], depthTest: true };
  }
  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: true
    };
  }
  delete() {
    if (this.fbo) {
      this.fbo.destroy();
      this.fbo = null;
    }
    if (this.shadowMap) {
      this.shadowMap.destroy();
      this.shadowMap = null;
    }
    if (this.depthBuffer) {
      this.depthBuffer.destroy();
      this.depthBuffer = null;
    }
  }
}
const DEFAULT_AMBIENT_LIGHT_PROPS = { color: [255, 255, 255], intensity: 1 };
const DEFAULT_DIRECTIONAL_LIGHT_PROPS = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
];
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];
class LightingEffect {
  constructor(props = {}) {
    this.id = "lighting-effect";
    this.shadowColor = DEFAULT_SHADOW_COLOR;
    this.shadow = false;
    this.ambientLight = null;
    this.directionalLights = [];
    this.pointLights = [];
    this.shadowPasses = [];
    this.shadowMaps = [];
    this.dummyShadowMap = null;
    this.setProps(props);
  }
  setup(context) {
    this.context = context;
    const { device, deck } = context;
    if (this.shadow && !this.dummyShadowMap) {
      this._createShadowPasses(device);
      deck._addDefaultShaderModule(shadow);
      this.dummyShadowMap = device.createTexture({
        width: 1,
        height: 1
      });
    }
  }
  setProps(props) {
    this.ambientLight = null;
    this.directionalLights = [];
    this.pointLights = [];
    for (const key in props) {
      const lightSource = props[key];
      switch (lightSource.type) {
        case "ambient":
          this.ambientLight = lightSource;
          break;
        case "directional":
          this.directionalLights.push(lightSource);
          break;
        case "point":
          this.pointLights.push(lightSource);
          break;
      }
    }
    this._applyDefaultLights();
    this.shadow = this.directionalLights.some((light) => light.shadow);
    if (this.context) {
      this.setup(this.context);
    }
    this.props = props;
  }
  preRender({ layers, layerFilter, viewports, onViewportActive, views }) {
    if (!this.shadow)
      return;
    this.shadowMatrices = this._calculateMatrices();
    for (let i = 0; i < this.shadowPasses.length; i++) {
      const shadowPass = this.shadowPasses[i];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        moduleParameters: {
          shadowLightId: i,
          dummyShadowMap: this.dummyShadowMap,
          shadowMatrices: this.shadowMatrices
        }
      });
    }
  }
  getModuleParameters(layer) {
    const parameters = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    parameters.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({ layer })),
      pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({ layer }))
    };
    return parameters;
  }
  cleanup(context) {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }
    this.shadowPasses.length = 0;
    this.shadowMaps.length = 0;
    if (this.dummyShadowMap) {
      this.dummyShadowMap.destroy();
      this.dummyShadowMap = null;
      context.deck._removeDefaultShaderModule(shadow);
    }
  }
  _calculateMatrices() {
    const lightMatrices = [];
    for (const light of this.directionalLights) {
      const viewMatrix = new Matrix4().lookAt({
        eye: new Vector3(light.direction).negate()
      });
      lightMatrices.push(viewMatrix);
    }
    return lightMatrices;
  }
  _createShadowPasses(device) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const shadowPass = new ShadowPass(device);
      this.shadowPasses[i] = shadowPass;
      this.shadowMaps[i] = shadowPass.shadowMap;
    }
  }
  _applyDefaultLights() {
    const { ambientLight, pointLights, directionalLights } = this;
    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }
}
class TypedArrayManager {
  constructor(options = {}) {
    this._pool = [];
    this.opts = { overAlloc: 2, poolSize: 100 };
    this.setOptions(options);
  }
  setOptions(options) {
    Object.assign(this.opts, options);
  }
  allocate(typedArray, count2, { size = 1, type, padding = 0, copy: copy2 = false, initialize = false, maxCount }) {
    const Type2 = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count2 * size + padding;
    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }
      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type2(typedArray.buffer, 0, newSize);
      }
    }
    let maxSize = Infinity;
    if (maxCount) {
      maxSize = maxCount * size + padding;
    }
    const newArray = this._allocate(Type2, newSize, initialize, maxSize);
    if (typedArray && copy2) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }
    this._release(typedArray);
    return newArray;
  }
  release(typedArray) {
    this._release(typedArray);
  }
  _allocate(Type2, size, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }
    const pool = this._pool;
    const byteLength = Type2.BYTES_PER_ELEMENT * sizeToAllocate;
    const i = pool.findIndex((b) => b.byteLength >= byteLength);
    if (i >= 0) {
      const array2 = new Type2(pool.splice(i, 1)[0], 0, sizeToAllocate);
      if (initialize) {
        array2.fill(0);
      }
      return array2;
    }
    return new Type2(sizeToAllocate);
  }
  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }
    const pool = this._pool;
    const { buffer } = typedArray;
    const { byteLength } = buffer;
    const i = pool.findIndex((b) => b.byteLength >= byteLength);
    if (i < 0) {
      pool.push(buffer);
    } else if (i > 0 || pool.length < this.opts.poolSize) {
      pool.splice(i, 0, buffer);
    }
    if (pool.length > this.opts.poolSize) {
      pool.shift();
    }
  }
}
const defaultTypedArrayManager = new TypedArrayManager();
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
const scratchVector = new Vector3();
function getFrustumPlane(a2, b, c2, d) {
  scratchVector.set(a2, b, c2);
  const L2 = scratchVector.len();
  return { distance: d / L2, normal: new Vector3(-a2 / L2, -b / L2, -c2 / L2) };
}
function fp64LowPart(x2) {
  return x2 - Math.fround(x2);
}
let scratchArray;
function toDoublePrecisionArray(typedArray, options) {
  const { size = 1, startIndex = 0 } = options;
  const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
  const count2 = (endIndex - startIndex) / size;
  scratchArray = defaultTypedArrayManager.allocate(scratchArray, count2, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (let j = 0; j < size; j++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value;
      scratchArray[targetIndex + j + size] = fp64LowPart(value);
    }
    targetIndex += size * 2;
  }
  return scratchArray.subarray(0, count2 * size * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;
  for (const bounds of boundsList) {
    if (!bounds)
      continue;
    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [
          [mergedBounds[0][0], mergedBounds[0][1]],
          [mergedBounds[1][0], mergedBounds[1][1]]
        ];
        isMerged = true;
      }
      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }
  return mergedBounds;
}
const DEGREES_TO_RADIANS$1 = Math.PI / 180;
const IDENTITY = createMat4();
const ZERO_VECTOR = [0, 0, 0];
const DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function createProjectionMatrix({ width, height, orthographic, fovyRadians, focalDistance, padding, near, far }) {
  const aspect = width / height;
  const matrix = orthographic ? new Matrix4().orthographic({ fovy: fovyRadians, aspect, focalDistance, near, far }) : new Matrix4().perspective({ fovy: fovyRadians, aspect, near, far });
  if (padding) {
    const { left = 0, right = 0, top = 0, bottom = 0 } = padding;
    const offsetX = clamp$1((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = clamp$1((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }
  return matrix;
}
class Viewport {
  // eslint-disable-next-line complexity
  constructor(opts = {}) {
    this._frustumPlanes = {};
    this.id = opts.id || this.constructor.displayName || "viewport";
    this.x = opts.x || 0;
    this.y = opts.y || 0;
    this.width = opts.width || 1;
    this.height = opts.height || 1;
    this.zoom = opts.zoom || 0;
    this.padding = opts.padding;
    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = opts.focalDistance || 1;
    this.position = opts.position || ZERO_VECTOR;
    this.modelMatrix = opts.modelMatrix || null;
    const { longitude, latitude } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
    this._initProps(opts);
    this._initMatrices(opts);
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }
    return PROJECTION_MODE.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(viewport) {
    if (!(viewport instanceof Viewport)) {
      return false;
    }
    if (this === viewport) {
      return true;
    }
    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(xyz, { topLeft = true } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
    const [x2, y2] = coord;
    const y22 = topLeft ? y2 : this.height - y2;
    return xyz.length === 2 ? [x2, y22] : [x2, y22, coord[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(xyz, { topLeft = true, targetZ } = {}) {
    const [x2, y2, z] = xyz;
    const y22 = topLeft ? y2 : this.height - y2;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = pixelsToWorld([x2, y22, z], this.pixelUnprojectionMatrix, targetZWorld);
    const [X2, Y2, Z2] = this.unprojectPosition(coord);
    if (Number.isFinite(z)) {
      return [X2, Y2, Z2];
    }
    return Number.isFinite(targetZ) ? [X2, Y2, targetZ] : [X2, Y2];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(xyz) {
    const [X2, Y2] = this.projectFlat(xyz);
    const Z2 = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X2, Y2, Z2];
  }
  unprojectPosition(xyz) {
    const [X2, Y2] = this.unprojectFlat(xyz);
    const Z2 = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X2, Y2, Z2];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = lngLatToWorld(xyz);
      result[1] = clamp$1(result[1], -318, 830);
      return result;
    }
    return xyz;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return worldToLngLat(xyz);
    }
    return xyz;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(options = {}) {
    const unprojectOption = { targetZ: options.z || 0 };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [
      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
    ];
  }
  getDistanceScales(coordinateOrigin) {
    if (coordinateOrigin) {
      return getDistanceScales({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }
    return this.distanceScales;
  }
  containsPixel({ x: x2, y: y2, width = 1, height = 1 }) {
    return x2 < this.x + this.width && this.x < x2 + width && y2 < this.y + this.height && this.y < y2 + height;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }
    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(coords, pixel) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(opts) {
    const longitude = opts.longitude;
    const latitude = opts.latitude;
    if (this.isGeospatial) {
      if (!Number.isFinite(opts.zoom)) {
        this.zoom = getMeterZoom({ latitude }) + Math.log2(this.focalDistance);
      }
      this.distanceScales = opts.distanceScales || getDistanceScales({ latitude, longitude });
    }
    const scale2 = Math.pow(2, this.zoom);
    this.scale = scale2;
    const { position, modelMatrix } = opts;
    let meterOffset = ZERO_VECTOR;
    if (position) {
      meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
    }
    if (this.isGeospatial) {
      const center = this.projectPosition([longitude, latitude, 0]);
      this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
    } else {
      this.center = this.projectPosition(meterOffset);
    }
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(opts) {
    const {
      // View matrix
      viewMatrix = IDENTITY,
      // Projection matrix
      projectionMatrix = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      // Distance of near clipping plane
      far = 1e3,
      // Distance of far clipping plane
      padding = null,
      // Center offset in pixels
      focalDistance = 1
    } = opts;
    this.viewMatrixUncentered = viewMatrix;
    this.viewMatrix = new Matrix4().multiplyRight(viewMatrix).translate(new Vector3(this.center).negate());
    this.projectionMatrix = projectionMatrix || createProjectionMatrix({
      width: this.width,
      height: this.height,
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS$1,
      focalDistance,
      padding,
      near,
      far
    });
    const vpm = createMat4();
    multiply(vpm, vpm, this.projectionMatrix);
    multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
    const viewportMatrix = createMat4();
    const pixelProjectionMatrix = createMat4();
    scale$1(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.pixelUnprojectionMatrix = invert(createMat4(), this.pixelProjectionMatrix);
    if (!this.pixelUnprojectionMatrix) {
      defaultLogger.warn("Pixel project matrix not invertible")();
    }
  }
}
Viewport.displayName = "Viewport";
class WebMercatorViewport extends Viewport {
  /* eslint-disable complexity, max-statements */
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing: bearing2 = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      nearZ,
      farZ,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      position,
      padding,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes = false
    } = opts;
    let { width, height, altitude = 1.5 } = opts;
    const scale2 = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;
    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = altitudeToFovy(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = fovyToAltitude(fovy);
      } else {
        fovy = altitudeToFovy(altitude);
      }
      let offset2;
      if (padding) {
        const { top = 0, bottom = 0 } = padding;
        offset2 = [0, clamp$1((top + height - bottom) / 2, 0, height) - height / 2];
      }
      projectionParameters = getProjectionParameters({
        width,
        height,
        scale: scale2,
        center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
        offset: offset2,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
      if (Number.isFinite(nearZ)) {
        projectionParameters.near = nearZ;
      }
      if (Number.isFinite(farZ)) {
        projectionParameters.far = farZ;
      }
    }
    let viewMatrixUncentered = getViewMatrix({
      height,
      pitch,
      bearing: bearing2,
      scale: scale2,
      altitude
    });
    if (worldOffset) {
      const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }
    super({
      ...opts,
      // x, y,
      width,
      height,
      // view matrix
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      // projection matrix parameters
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing2;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);
      for (let x2 = minOffset; x2 <= maxOffset; x2++) {
        const offsetViewport = x2 ? new WebMercatorViewport({
          ...this,
          worldOffset: x2
        }) : this;
        this._subViewports.push(offsetViewport);
      }
    }
    return this._subViewports;
  }
  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }
    const [X2, Y2] = this.projectFlat(xyz);
    const Z2 = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
    return [X2, Y2, Z2];
  }
  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }
    const [X2, Y2] = this.unprojectFlat(xyz);
    const Z2 = (xyz[2] || 0) / unitsPerMeter(Y2);
    return [X2, Y2, Z2];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(lngLatZ, xyz) {
    return addMetersToLngLat(lngLatZ, xyz);
  }
  panByPosition(coords, pixel) {
    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate2 = add$1([], toLocation, negate$1([], fromLocation));
    const newCenter = add$1([], this.center, translate2);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return { longitude, latitude };
  }
  getBounds(options = {}) {
    const corners = getBounds(this, options.z || 0);
    return [
      Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
      Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
      Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
      Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(bounds, options = {}) {
    const { width, height } = this;
    const { longitude, latitude, zoom } = fitBounds({ width, height, bounds, ...options });
    return new WebMercatorViewport({ width, height, longitude, latitude, zoom });
  }
}
WebMercatorViewport.displayName = "WebMercatorViewport";
const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p2 = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof WebMercatorViewport) {
    const [longitude, latitude, z = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p2[2] = z * distanceScales.unitsPerMeter[2];
  }
  return p2;
}
function normalizeParameters(opts) {
  const { viewport, modelMatrix, coordinateOrigin } = opts;
  let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === void 0) {
    fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === void 0) {
    fromCoordinateOrigin = coordinateOrigin;
  }
  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}
function getWorldPosition(position, { viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode }) {
  let [x2, y2, z = 0] = position;
  if (modelMatrix) {
    [x2, y2, z] = transformMat4([], [x2, y2, z, 1], modelMatrix);
  }
  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x2, y2, z], viewport, offsetMode);
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x2, y2, z]), viewport, offsetMode);
    case COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x2, y2, z]);
  }
}
function projectPosition(position, params) {
  const { viewport, coordinateSystem, coordinateOrigin, modelMatrix, fromCoordinateSystem, fromCoordinateOrigin } = normalizeParameters(params);
  const { autoOffset = true } = params;
  const { geospatialOrigin = DEFAULT_COORDINATE_ORIGIN, shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN, offsetMode = false } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    sub(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
  time = 0;
  channels = /* @__PURE__ */ new Map();
  animations = /* @__PURE__ */ new Map();
  playing = false;
  lastEngineTime = -1;
  constructor() {
  }
  addChannel(props) {
    const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
    const channelId = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };
    this._setChannelTime(channel, this.time);
    this.channels.set(channelId, channel);
    return channelId;
  }
  removeChannel(channelId) {
    this.channels.delete(channelId);
    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === channelId) {
        this.detachAnimation(animationHandle);
      }
    }
  }
  isFinished(channelId) {
    const channel = this.channels.get(channelId);
    if (channel === void 0) {
      return false;
    }
    return this.time >= channel.delay + channel.duration * channel.repeat;
  }
  getTime(channelId) {
    if (channelId === void 0) {
      return this.time;
    }
    const channel = this.channels.get(channelId);
    if (channel === void 0) {
      return -1;
    }
    return channel.time;
  }
  setTime(time2) {
    this.time = Math.max(0, time2);
    const channels = this.channels.values();
    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }
    const animations = this.animations.values();
    for (const animationData of animations) {
      const { animation, channel } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }
  play() {
    this.playing = true;
  }
  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }
  detachAnimation(channelId) {
    this.animations.delete(channelId);
  }
  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }
      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }
  _setChannelTime(channel, time2) {
    const offsetTime = time2 - channel.delay;
    const totalDuration = channel.duration * channel.repeat;
    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }
}
let statIdCounter = 0;
const DEFAULT_ANIMATION_LOOP_PROPS = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => {
    return null;
  },
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (error) => console.error(error),
  // eslint-disable-line no-console
  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
  // view parameters
  useDevicePixels: true,
  autoResizeViewport: false,
  autoResizeDrawingBuffer: false
};
class AnimationLoop {
  device = null;
  canvas = null;
  props;
  animationProps = null;
  timeline = null;
  stats;
  cpuTime;
  gpuTime;
  frameRate;
  display;
  needsRedraw = "initialized";
  _initialized = false;
  _running = false;
  _animationFrameId = null;
  _nextFramePromise = null;
  _resolveNextFrame = null;
  _cpuStartTime = 0;
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(props) {
    this.props = { ...DEFAULT_ANIMATION_LOOP_PROPS, ...props };
    props = this.props;
    if (!props.device) {
      throw new Error("No device provided");
    }
    const { useDevicePixels = true } = this.props;
    this.stats = props.stats || new Stats({ id: "animation-loop-stats" });
    this.cpuTime = this.stats.get("CPU Time");
    this.gpuTime = this.stats.get("GPU Time");
    this.frameRate = this.stats.get("Frame Rate");
    this.setProps({
      autoResizeViewport: props.autoResizeViewport,
      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop();
    this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(props) {
    if ("autoResizeViewport" in props) {
      this.props.autoResizeViewport = props.autoResizeViewport || false;
    }
    if ("autoResizeDrawingBuffer" in props) {
      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
    }
    if ("useDevicePixels" in props) {
      this.props.useDevicePixels = props.useDevicePixels || false;
    }
    return this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running) {
      return this;
    }
    this._running = true;
    try {
      let appContext;
      if (!this._initialized) {
        this._initialized = true;
        await this._initDevice();
        this._initialize();
        await this.props.onInitialize(this._getAnimationProps());
      }
      if (!this._running) {
        return null;
      }
      if (appContext !== false) {
        this._cancelAnimationFrame();
        this._requestAnimationFrame();
      }
      return this;
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Unknown error");
      this.props.onError(error);
      throw error;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    if (this._running) {
      if (this.animationProps) {
        this.props.onFinalize(this.animationProps);
      }
      this._cancelAnimationFrame();
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._running = false;
    }
    return this;
  }
  /** Explicitly draw a frame */
  redraw() {
    if (this.device?.isLost) {
      return this;
    }
    this._beginFrameTimers();
    this._setupFrame();
    this._updateAnimationProps();
    this._renderFrame(this._getAnimationProps());
    this._clearNeedsRedraw();
    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }
    this._endFrameTimers();
    return this;
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    this.setNeedsRedraw("waitForRender");
    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise((resolve) => {
        this._resolveNextFrame = resolve;
      });
    }
    return this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    this.setNeedsRedraw("toDataURL");
    await this.waitForRender();
    if (this.canvas instanceof HTMLCanvasElement) {
      return this.canvas.toDataURL();
    }
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling();
    this._initializeAnimationProps();
    this._updateAnimationProps();
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
  }
  _setDisplay(display) {
    if (this.display) {
      this.display.destroy();
      this.display.animationLoop = null;
    }
    if (display) {
      display.animationLoop = this;
    }
    this.display = display;
  }
  _requestAnimationFrame() {
    if (!this._running) {
      return;
    }
    this._animationFrameId = requestAnimationFrame$1(this._animationFrame.bind(this));
  }
  _cancelAnimationFrame() {
    if (this._animationFrameId === null) {
      return;
    }
    cancelAnimationFrame$1(this._animationFrameId);
    this._animationFrameId = null;
  }
  _animationFrame() {
    if (!this._running) {
      return;
    }
    this.redraw();
    this._requestAnimationFrame();
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(animationProps) {
    if (this.display) {
      this.display._renderFrame(animationProps);
      return;
    }
    this.props.onRender(this._getAnimationProps());
    this.device.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = false;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    if (!this.device) {
      throw new Error("loop");
    }
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: this.device?.canvasContext?.canvas,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: false,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps) {
      throw new Error("animationProps");
    }
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps) {
      return;
    }
    const { width, height, aspect } = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw("drawing buffer resized");
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw("drawing buffer aspect changed");
    }
    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }
    this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    this.device = await this.props.device;
    if (!this.device) {
      throw new Error("No device provided");
    }
    this.canvas = this.device.canvasContext?.canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement("div");
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = "relative";
      const div = document.createElement("div");
      div.style.position = "absolute";
      div.style.left = "10px";
      div.style.bottom = "10px";
      div.style.width = "300px";
      div.style.background = "white";
      if (this.canvas instanceof HTMLCanvasElement) {
        wrapperDiv.appendChild(this.canvas);
      }
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);
      if (html) {
        div.innerHTML = html;
      }
    }
  }
  _getSizeAndAspect() {
    if (!this.device) {
      return { width: 1, height: 1, aspect: 1 };
    }
    const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];
    let aspect = 1;
    const canvas2 = this.device?.canvasContext?.canvas;
    if (canvas2 && canvas2.clientHeight) {
      aspect = canvas2.clientWidth / canvas2.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }
    return { width, height, aspect };
  }
  /** Default viewport setup */
  _resizeViewport() {
    if (this.props.autoResizeViewport && this.device.gl) {
      this.device.gl.viewport(
        0,
        0,
        // @ts-expect-error Expose canvasContext
        this.device.gl.drawingBufferWidth,
        // @ts-expect-error Expose canvasContext
        this.device.gl.drawingBufferHeight
      );
    }
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    if (this.props.autoResizeDrawingBuffer) {
      this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });
    }
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();
    this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    if (this.canvas) {
      this.canvas.addEventListener("mousemove", this._onMousemove.bind(this));
      this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this));
    }
  }
  _onMousemove(event) {
    if (event instanceof MouseEvent) {
      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
    }
  }
  _onMouseleave(event) {
    this._getAnimationProps()._mousePosition = null;
  }
}
class GPUGeometry {
  id;
  userData = {};
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  bufferLayout = [];
  vertexCount;
  indices;
  attributes;
  constructor(props) {
    this.id = props.id || uid("geometry");
    this.topology = props.topology;
    this.indices = props.indices || null;
    this.attributes = props.attributes;
    this.vertexCount = props.vertexCount;
    this.bufferLayout = props.bufferLayout || [];
    if (this.indices) {
      assert$3(this.indices.usage === Buffer.INDEX);
    }
  }
  destroy() {
    this.indices?.destroy();
    for (const attribute of Object.values(this.attributes)) {
      attribute.destroy();
    }
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices;
  }
  _calculateVertexCount(positions) {
    const vertexCount = positions.byteLength / 12;
    return vertexCount;
  }
}
function makeGPUGeometry(device, geometry2) {
  if (geometry2 instanceof GPUGeometry) {
    return geometry2;
  }
  const indices = getIndexBufferFromGeometry(device, geometry2);
  const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry2);
  return new GPUGeometry({
    topology: geometry2.topology || "triangle-list",
    bufferLayout,
    vertexCount: geometry2.vertexCount,
    indices,
    attributes
  });
}
function getIndexBufferFromGeometry(device, geometry2) {
  if (!geometry2.indices) {
    return void 0;
  }
  const data = geometry2.indices.value;
  return device.createBuffer({ usage: Buffer.INDEX, data });
}
function getAttributeBuffersFromGeometry(device, geometry2) {
  const bufferLayout = [];
  const attributes = {};
  for (const [attributeName, attribute] of Object.entries(geometry2.attributes)) {
    let name2 = attributeName;
    switch (attributeName) {
      case "POSITION":
        name2 = "positions";
        break;
      case "NORMAL":
        name2 = "normals";
        break;
      case "TEXCOORD_0":
        name2 = "texCoords";
        break;
      case "COLOR_0":
        name2 = "colors";
        break;
    }
    attributes[name2] = device.createBuffer({ data: attribute.value, id: `${attributeName}-buffer` });
    const { value, size, normalized } = attribute;
    bufferLayout.push({ name: name2, format: getVertexFormatFromAttribute(value, size, normalized) });
  }
  const vertexCount = geometry2._calculateVertexCount(geometry2.attributes, geometry2.indices);
  return { attributes, bufferLayout, vertexCount };
}
class ShaderInputs {
  /**
   * The map of modules
   * @todo should should this include the resolved dependencies?
   */
  modules;
  /** Stores the uniform values for each module */
  moduleUniforms;
  /** Stores the uniform bindings for each module  */
  moduleBindings;
  /** Tracks if uniforms have changed */
  moduleUniformsChanged;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(modules) {
    const resolvedModules = resolveModules(Object.values(modules).filter((module) => module.dependencies));
    for (const resolvedModule of resolvedModules) {
      modules[resolvedModule.name] = resolvedModule;
    }
    log.log(1, "Creating ShaderInputs with modules", Object.keys(modules))();
    this.modules = modules;
    this.moduleUniforms = {};
    this.moduleBindings = {};
    for (const [name2, module] of Object.entries(modules)) {
      const moduleName = name2;
      this.moduleUniforms[moduleName] = module.defaultUniforms || {};
      this.moduleBindings[moduleName] = {};
    }
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(props) {
    for (const name2 of Object.keys(props)) {
      const moduleName = name2;
      const moduleProps = props[moduleName];
      const module = this.modules[moduleName];
      if (!module) {
        log.warn(`Module ${name2} not found`)();
        continue;
      }
      const oldUniforms = this.moduleUniforms[moduleName];
      const oldBindings = this.moduleBindings[moduleName];
      const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;
      const { uniforms, bindings } = splitUniformsAndBindings(uniformsAndBindings);
      this.moduleUniforms[moduleName] = { ...oldUniforms, ...uniforms };
      this.moduleBindings[moduleName] = { ...oldBindings, ...bindings };
    }
  }
  /** Merges all bindings for the shader (from the various modules) */
  // getUniformBlocks(): Record<string, Texture | Sampler> {
  //   return this.moduleUniforms;
  // }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindings() {
    const bindings = {};
    for (const moduleBindings of Object.values(this.moduleBindings)) {
      Object.assign(bindings, moduleBindings);
    }
    return bindings;
  }
  getDebugTable() {
    const table = {};
    for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {
      for (const [key, value] of Object.entries(module)) {
        table[`${moduleName}.${key}`] = {
          type: this.modules[moduleName].uniformTypes?.[key],
          value: String(value)
        };
      }
    }
    return table;
  }
}
class PipelineFactory {
  static defaultProps = { ...RenderPipeline.defaultProps };
  device;
  _hashCounter = 0;
  _hashes = {};
  _renderPipelineCache = {};
  _computePipelineCache = {};
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(device) {
    device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new PipelineFactory(device);
    return device._lumaData.defaultPipelineFactory;
  }
  constructor(device) {
    this.device = device;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(props) {
    const allProps = { ...RenderPipeline.defaultProps, ...props };
    const hash = this._hashRenderPipeline(allProps);
    if (!this._renderPipelineCache[hash]) {
      const pipeline = this.device.createRenderPipeline({
        ...allProps,
        id: allProps.id ? `${allProps.id}-cached` : void 0
      });
      pipeline.hash = hash;
      this._renderPipelineCache[hash] = { pipeline, useCount: 0 };
    }
    this._renderPipelineCache[hash].useCount++;
    return this._renderPipelineCache[hash].pipeline;
  }
  createComputePipeline(props) {
    const allProps = { ...ComputePipeline.defaultProps, ...props };
    const hash = this._hashComputePipeline(allProps);
    if (!this._computePipelineCache[hash]) {
      const pipeline = this.device.createComputePipeline({
        ...allProps,
        id: allProps.id ? `${allProps.id}-cached` : void 0
      });
      pipeline.hash = hash;
      this._computePipelineCache[hash] = { pipeline, useCount: 0 };
    }
    this._computePipelineCache[hash].useCount++;
    return this._computePipelineCache[hash].pipeline;
  }
  release(pipeline) {
    const hash = pipeline.hash;
    const cache2 = pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;
    cache2[hash].useCount--;
    if (cache2[hash].useCount === 0) {
      cache2[hash].pipeline.destroy();
      delete cache2[hash];
    }
  }
  // PRIVATE
  _hashComputePipeline(props) {
    const shaderHash = this._getHash(props.shader.source);
    return `${shaderHash}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(props) {
    const vsHash = this._getHash(props.vs.source);
    const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
    const varyingHash = "-";
    const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
      default:
        const parameterHash = this._getHash(JSON.stringify(props.parameters));
        return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
    }
  }
  _getHash(key) {
    if (this._hashes[key] === void 0) {
      this._hashes[key] = this._hashCounter++;
    }
    return this._hashes[key];
  }
}
class ShaderFactory {
  static defaultProps = { ...Shader.defaultProps };
  device;
  _cache = {};
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(device) {
    device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);
    return device._lumaData.defaultShaderFactory;
  }
  /** @internal */
  constructor(device) {
    this.device = device;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(props) {
    const key = this._hashShader(props);
    let cacheEntry = this._cache[key];
    if (!cacheEntry) {
      const shader = this.device.createShader({
        ...props,
        id: props.id ? `${props.id}-cached` : void 0
      });
      this._cache[key] = cacheEntry = { shader, useCount: 0 };
    }
    cacheEntry.useCount++;
    return cacheEntry.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(shader) {
    const key = this._hashShader(shader);
    const cacheEntry = this._cache[key];
    if (cacheEntry) {
      cacheEntry.useCount--;
      if (cacheEntry.useCount === 0) {
        delete this._cache[key];
        cacheEntry.shader.destroy();
      }
    }
  }
  // PRIVATE
  _hashShader(value) {
    return `${value.stage}:${value.source}`;
  }
}
function getDebugTableForShaderLayout(layout, name2) {
  const table = {};
  const header = "Values";
  if (layout.attributes.length === 0 && !layout.varyings?.length) {
    return { "No attributes or varyings": { [header]: "N/A" } };
  }
  for (const attributeDeclaration of layout.attributes) {
    if (attributeDeclaration) {
      const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
      table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || "vertex" };
    }
  }
  for (const varyingDeclaration of layout.varyings || []) {
    const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
    table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration.accessor) };
  }
  return table;
}
let canvas = null;
let ctx = null;
function debugFramebuffer(fbo, { id, minimap, opaque, top = "0", left = "0", rgbaScale = 1 }) {
  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.id = id;
    canvas.title = id;
    canvas.style.zIndex = "100";
    canvas.style.position = "absolute";
    canvas.style.top = top;
    canvas.style.left = left;
    canvas.style.border = "blue 1px solid";
    canvas.style.transform = "scaleY(-1)";
    document.body.appendChild(canvas);
    ctx = canvas.getContext("2d");
  }
  if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
    canvas.width = fbo.width / 2;
    canvas.height = fbo.height / 2;
    canvas.style.width = "400px";
    canvas.style.height = "400px";
  }
  const color2 = fbo.device.readPixelsToArrayWebGL(fbo);
  const imageData = ctx.createImageData(fbo.width, fbo.height);
  const offset2 = 0;
  for (let i = 0; i < color2.length; i += 4) {
    imageData.data[offset2 + i + 0] = color2[i + 0] * rgbaScale;
    imageData.data[offset2 + i + 1] = color2[i + 1] * rgbaScale;
    imageData.data[offset2 + i + 2] = color2[i + 2] * rgbaScale;
    imageData.data[offset2 + i + 3] = opaque ? 255 : color2[i + 3] * rgbaScale;
  }
  ctx.putImageData(imageData, 0, 0);
}
const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 1e4;
class Model {
  static defaultProps = {
    ...RenderPipeline.defaultProps,
    source: null,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  };
  device;
  id;
  source;
  vs;
  fs;
  pipelineFactory;
  shaderFactory;
  userData = {};
  // Fixed properties (change can trigger pipeline rebuild)
  /** The render pipeline GPU parameters, depth testing etc */
  parameters;
  /** The primitive topology */
  topology;
  /** Buffer layout */
  bufferLayout;
  // Dynamic properties
  /** Use instanced rendering */
  isInstanced = void 0;
  /** instance count. `undefined` means not instanced */
  instanceCount = 0;
  /** Vertex count */
  vertexCount;
  /** Index buffer */
  indexBuffer = null;
  /** Buffer-valued attributes */
  bufferAttributes = {};
  /** Constant-valued attributes */
  constantAttributes = {};
  /** Bindings (textures, samplers, uniform buffers) */
  bindings = {};
  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
  uniforms = {};
  /**
   * VertexArray
   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
   * @todo - allow application to define multiple vertex arrays?
   * */
  vertexArray;
  /** TransformFeedback, WebGL 2 only. */
  transformFeedback = null;
  /** The underlying GPU "program". @note May be recreated if parameters change */
  pipeline;
  /** ShaderInputs instance */
  shaderInputs;
  _uniformStore;
  _attributeInfos = {};
  _gpuGeometry = null;
  _getModuleUniforms;
  props;
  _pipelineNeedsUpdate = "newly created";
  _needsRedraw = "initializing";
  _destroyed = false;
  /** "Time" of last draw. Monotonically increasing timestamp */
  _lastDrawTimestamp = -1;
  constructor(device, props) {
    this.props = { ...Model.defaultProps, ...props };
    props = this.props;
    this.id = props.id || uid("model");
    this.device = device;
    Object.assign(this.userData, props.userData);
    const moduleMap = Object.fromEntries(this.props.modules?.map((module) => [module.name, module]) || []);
    this.setShaderInputs(props.shaderInputs || new ShaderInputs(moduleMap));
    const platformInfo = getPlatformInfo(device);
    const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
    const isWebGPU = this.device.type === "webgpu";
    if (isWebGPU && this.props.source) {
      this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);
      const { source, getUniforms: getUniforms2 } = this.props.shaderAssembler.assembleShader({
        platformInfo,
        ...this.props,
        modules
      });
      this.source = source;
      this._getModuleUniforms = getUniforms2;
    } else {
      const { vs: vs2, fs: fs2, getUniforms: getUniforms2 } = this.props.shaderAssembler.assembleShaderPair({
        platformInfo,
        ...this.props,
        modules
      });
      this.vs = vs2;
      this.fs = fs2;
      this._getModuleUniforms = getUniforms2;
    }
    this.vertexCount = this.props.vertexCount;
    this.instanceCount = this.props.instanceCount;
    this.topology = this.props.topology;
    this.bufferLayout = this.props.bufferLayout;
    this.parameters = this.props.parameters;
    if (props.geometry) {
      this.setGeometry(props.geometry);
    }
    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
    this.pipeline = this._updatePipeline();
    this.vertexArray = device.createVertexArray({
      renderPipeline: this.pipeline
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
    if ("isInstanced" in props) {
      this.isInstanced = props.isInstanced;
    }
    if (props.instanceCount) {
      this.setInstanceCount(props.instanceCount);
    }
    if (props.vertexCount) {
      this.setVertexCount(props.vertexCount);
    }
    if (props.indexBuffer) {
      this.setIndexBuffer(props.indexBuffer);
    }
    if (props.attributes) {
      this.setAttributes(props.attributes);
    }
    if (props.constantAttributes) {
      this.setConstantAttributes(props.constantAttributes);
    }
    if (props.bindings) {
      this.setBindings(props.bindings);
    }
    if (props.uniforms) {
      this.setUniforms(props.uniforms);
    }
    if (props.moduleSettings) {
      this.updateModuleSettings(props.moduleSettings);
    }
    if (props.transformFeedback) {
      this.transformFeedback = props.transformFeedback;
    }
    Object.seal(this);
  }
  destroy() {
    if (this._destroyed)
      return;
    this.pipelineFactory.release(this.pipeline);
    this.shaderFactory.release(this.pipeline.vs);
    if (this.pipeline.fs) {
      this.shaderFactory.release(this.pipeline.fs);
    }
    this._uniformStore.destroy();
    this._gpuGeometry?.destroy();
    this._destroyed = true;
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
      this.setNeedsRedraw("contents of bound textures or buffers updated");
    }
    const needsRedraw = this._needsRedraw;
    this._needsRedraw = false;
    return needsRedraw;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(reason) {
    this._needsRedraw ||= reason;
  }
  predraw() {
    this.updateShaderInputs();
    this.pipeline = this._updatePipeline();
  }
  draw(renderPass) {
    this.predraw();
    let drawSuccess;
    try {
      this._logDrawCallStart();
      this.pipeline = this._updatePipeline();
      this.pipeline.setBindings(this.bindings, { disableWarnings: this.props.disableWarnings });
      if (!isObjectEmpty$2(this.uniforms)) {
        this.pipeline.setUniformsWebGL(this.uniforms);
      }
      const { indexBuffer } = this.vertexArray;
      const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
      drawSuccess = this.pipeline.draw({
        renderPass,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      this._logDrawCallEnd();
    }
    this._logFramebuffer(renderPass);
    if (drawSuccess) {
      this._lastDrawTimestamp = this.device.timestamp;
      this._needsRedraw = false;
    } else {
      this._needsRedraw = "waiting for resource initialization";
    }
    return drawSuccess;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(geometry2) {
    this._gpuGeometry?.destroy();
    const gpuGeometry = geometry2 && makeGPUGeometry(this.device, geometry2);
    if (gpuGeometry) {
      this.setTopology(gpuGeometry.topology || "triangle-list");
      this.bufferLayout = mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
      if (this.vertexArray) {
        this._setGeometryAttributes(gpuGeometry);
      }
    }
    this._gpuGeometry = gpuGeometry;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(topology) {
    if (topology !== this.topology) {
      this.topology = topology;
      this._setPipelineNeedsUpdate("topology");
    }
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(bufferLayout) {
    this.bufferLayout = this._gpuGeometry ? mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
    this._setPipelineNeedsUpdate("bufferLayout");
    this.pipeline = this._updatePipeline();
    this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(parameters) {
    if (!deepEqual$1(parameters, this.parameters, 2)) {
      this.parameters = parameters;
      this._setPipelineNeedsUpdate("parameters");
    }
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(instanceCount) {
    this.instanceCount = instanceCount;
    if (this.isInstanced === void 0 && instanceCount > 0) {
      this.isInstanced = true;
    }
    this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(vertexCount) {
    this.vertexCount = vertexCount;
    this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(shaderInputs) {
    this.shaderInputs = shaderInputs;
    this._uniformStore = new UniformStore(this.shaderInputs.modules);
    for (const moduleName of Object.keys(this.shaderInputs.modules)) {
      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
    }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
    this.setBindings(this.shaderInputs.getBindings());
    this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(bindings) {
    Object.assign(this.bindings, bindings);
    this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(transformFeedback) {
    this.transformFeedback = transformFeedback;
    this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(indexBuffer) {
    this.vertexArray.setIndexBuffer(indexBuffer);
    this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(buffers, options) {
    if (buffers.indices) {
      log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    }
    for (const [bufferName, buffer] of Object.entries(buffers)) {
      const bufferLayout = this.bufferLayout.find((layout) => getAttributeNames(layout).includes(bufferName));
      if (!bufferLayout) {
        log.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
        continue;
      }
      const attributeNames = getAttributeNames(bufferLayout);
      let set = false;
      for (const attributeName of attributeNames) {
        const attributeInfo = this._attributeInfos[attributeName];
        if (attributeInfo) {
          this.vertexArray.setBuffer(attributeInfo.location, buffer);
          set = true;
        }
      }
      if (!set && !(options?.disableWarnings ?? this.props.disableWarnings)) {
        log.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
      }
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(attributes, options) {
    for (const [attributeName, value] of Object.entries(attributes)) {
      const attributeInfo = this._attributeInfos[attributeName];
      if (attributeInfo) {
        this.vertexArray.setConstantWebGL(attributeInfo.location, value);
      } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {
        log.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
      }
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(uniforms) {
    if (!isObjectEmpty$2(uniforms)) {
      this.pipeline.setUniformsWebGL(uniforms);
      Object.assign(this.uniforms, uniforms);
    }
    this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettings(props) {
    const { bindings, uniforms } = splitUniformsAndBindings(this._getModuleUniforms(props));
    Object.assign(this.bindings, bindings);
    Object.assign(this.uniforms, uniforms);
    this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let timestamp = 0;
    for (const binding of Object.values(this.bindings)) {
      if (binding instanceof TextureView) {
        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
      } else if (binding instanceof Buffer || binding instanceof Texture) {
        timestamp = Math.max(timestamp, binding.updateTimestamp);
      } else if (!(binding instanceof Sampler)) {
        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
      }
    }
    return timestamp;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(gpuGeometry) {
    const attributes = { ...gpuGeometry.attributes };
    for (const [attributeName] of Object.entries(attributes)) {
      if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") {
        delete attributes[attributeName];
      }
    }
    this.vertexCount = gpuGeometry.vertexCount;
    this.setIndexBuffer(gpuGeometry.indices || null);
    this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });
    this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });
    this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(reason) {
    this._pipelineNeedsUpdate ||= reason;
    this.setNeedsRedraw(reason);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let prevShaderVs = null;
      let prevShaderFs = null;
      if (this.pipeline) {
        log.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
        prevShaderVs = this.pipeline.vs;
        prevShaderFs = this.pipeline.fs;
      }
      this._pipelineNeedsUpdate = false;
      const vs2 = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debug: this.props.debugShaders
      });
      let fs2 = null;
      if (this.source) {
        fs2 = vs2;
      } else if (this.fs) {
        fs2 = this.shaderFactory.createShader({
          id: `${this.id}-fragment`,
          stage: "fragment",
          source: this.source || this.fs,
          debug: this.props.debugShaders
        });
      }
      this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        vs: vs2,
        fs: fs2
      });
      this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
      if (prevShaderVs)
        this.shaderFactory.release(prevShaderVs);
      if (prevShaderFs)
        this.shaderFactory.release(prevShaderFs);
    }
    return this.pipeline;
  }
  /** Throttle draw call logging */
  _lastLogTime = 0;
  _logOpen = false;
  _logDrawCallStart() {
    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
      return;
    }
    this._lastLogTime = Date.now();
    this._logOpen = true;
    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
      const uniformTable = this.shaderInputs.getDebugTable();
      for (const [name2, value] of Object.entries(this.uniforms)) {
        uniformTable[name2] = { value };
      }
      log.table(LOG_DRAW_PRIORITY, uniformTable)();
      const attributeTable = this._getAttributeDebugTable();
      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
      log.table(LOG_DRAW_PRIORITY, attributeTable)();
      log.groupEnd(LOG_DRAW_PRIORITY)();
      this._logOpen = false;
    }
  }
  _drawCount = 0;
  _logFramebuffer(renderPass) {
    const debugFramebuffers = log.get("framebuffer");
    this._drawCount++;
    if (!debugFramebuffers || this._drawCount++ > 3 && this._drawCount % 60) {
      return;
    }
    const framebuffer = renderPass.props.framebuffer;
    if (framebuffer) {
      debugFramebuffer(framebuffer, { id: framebuffer.id, minimap: true });
    }
  }
  _getAttributeDebugTable() {
    const table = {};
    for (const [name2, attributeInfo] of Object.entries(this._attributeInfos)) {
      table[attributeInfo.location] = {
        name: name2,
        type: attributeInfo.shaderType,
        values: this._getBufferOrConstantValues(this.vertexArray.attributes[attributeInfo.location], attributeInfo.bufferDataType)
      };
    }
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer } = this.vertexArray;
      const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
      table.indices = {
        name: "indices",
        type: indexBuffer.indexType,
        values: values.toString()
      };
    }
    return table;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(attribute, dataType) {
    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);
    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;
    return typedArray.toString();
  }
}
function mergeBufferLayouts(layouts1, layouts2) {
  const layouts = [...layouts1];
  for (const attribute of layouts2) {
    const index2 = layouts.findIndex((attribute2) => attribute2.name === attribute.name);
    if (index2 < 0) {
      layouts.push(attribute);
    } else {
      layouts[index2] = attribute;
    }
  }
  return layouts;
}
function getPlatformInfo(device) {
  return {
    type: device.type,
    shaderLanguage: device.info.shadingLanguage,
    shaderLanguageVersion: device.info.shadingLanguageVersion,
    gpu: device.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: device.features
  };
}
function getAttributeNames(bufferLayout) {
  return bufferLayout.attributes ? bufferLayout.attributes?.map((layout) => layout.attribute) : [bufferLayout.name];
}
class BufferTransform {
  device;
  model;
  transformFeedback;
  /** @deprecated Use device feature test. */
  static isSupported(device) {
    return device?.info?.type === "webgl";
  }
  constructor(device, props = Model.defaultProps) {
    assert$3(BufferTransform.isSupported(device), "BufferTransform not yet implemented on WebGPU");
    this.device = device;
    this.model = new Model(this.device, {
      id: props.id || "buffer-transform-model",
      fs: props.fs || getPassthroughFS(),
      topology: props.topology || "point-list",
      ...props
    });
    this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      buffers: props.feedbackBuffers
    });
    this.model.setTransformFeedback(this.transformFeedback);
    Object.seal(this);
  }
  /** Destroy owned resources. */
  destroy() {
    if (this.model) {
      this.model.destroy();
    }
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(options) {
    const renderPass = this.device.beginRenderPass(options);
    this.model.draw(renderPass);
    renderPass.end();
  }
  /** @deprecated */
  update(...args) {
    console.warn("TextureTransform#update() not implemented");
  }
  /** Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(varyingName) {
    return this.transformFeedback.getBuffer(varyingName);
  }
  readAsync(varyingName) {
    const result = this.getBuffer(varyingName);
    if (result instanceof Buffer) {
      return result.readAsync();
    }
    const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
    return buffer.readAsync(byteOffset, byteLength);
  }
}
class Geometry {
  id;
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  vertexCount;
  indices;
  attributes;
  userData = {};
  constructor(props) {
    const { attributes = {}, indices = null, vertexCount = null } = props;
    this.id = props.id || uid("geometry");
    this.topology = props.topology;
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? { value: indices, size: 1 } : indices;
    }
    this.attributes = {};
    for (const [attributeName, attributeValue] of Object.entries(attributes)) {
      const attribute = ArrayBuffer.isView(attributeValue) ? { value: attributeValue } : attributeValue;
      assert$3(ArrayBuffer.isView(attribute.value), `${this._print(attributeName)}: must be typed array or object with value as typed array`);
      if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
        attribute.size = 3;
      }
      if (attributeName === "indices") {
        assert$3(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }
    if (this.indices && this.indices.isIndexed !== void 0) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }
    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(attributeName) {
    return `Geometry ${this.id} attribute ${attributeName}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(attributes, indices) {
    return this;
  }
  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attribute of Object.values(attributes)) {
      const { value, size, constant: constant2 } = attribute;
      if (!constant2 && value && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }
    assert$3(Number.isFinite(vertexCount));
    return vertexCount;
  }
}
const PICKING_BLENDING = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
class PickLayersPass extends LayersPass {
  constructor() {
    super(...arguments);
    this._colorEncoderState = null;
  }
  render(props) {
    if ("pickingFBO" in props) {
      return this._drawPickingBuffer(props);
    }
    return super.render(props);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers, layerFilter, views, viewports, onViewportActive, pickingFBO, deviceRect: { x: x2, y: y2, width, height }, cullRect, effects, pass = "picking", pickZ, moduleParameters }) {
    this.pickZ = pickZ;
    const colorEncoderState = this._resetColorEncoder(pickZ);
    const scissorRect = [x2, y2, width, height];
    const renderStatus = super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      cullRect,
      effects: effects?.filter((e) => e.useInPicking),
      pass,
      isPicking: true,
      moduleParameters,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect
    });
    this._colorEncoderState = null;
    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
    return { decodePickingColor, stats: renderStatus };
  }
  shouldDrawLayer(layer) {
    const { pickable, operation } = layer.props;
    return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
  }
  getModuleParameters() {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      // turn off lighting by adding empty light source object
      // lights shader module relies on the `lightSources` to turn on/off lighting
      lightSources: {}
    };
  }
  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = {
      // TODO - When used as a custom layer in older Mapbox versions, context
      // state was dirty. Mapbox fixed that; we should test and remove the workaround.
      // https://github.com/mapbox/mapbox-gl-js/issues/7801
      depthMask: true,
      depthTest: true,
      depthRange: [0, 1],
      ...layer.props.parameters
    };
    const { pickable, operation } = layer.props;
    if (!this._colorEncoderState || operation.includes("terrain")) {
      pickParameters.blend = false;
    } else if (pickable && operation.includes("draw")) {
      Object.assign(pickParameters, PICKING_BLENDING);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
    }
    return pickParameters;
  }
  _resetColorEncoder(pickZ) {
    this._colorEncoderState = pickZ ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    };
    return this._colorEncoderState;
  }
}
function encodeColor(encoded, layer, viewport) {
  const { byLayer, byAlpha } = encoded;
  let a2;
  let entry = byLayer.get(layer);
  if (entry) {
    entry.viewports.push(viewport);
    a2 = entry.a;
  } else {
    a2 = byLayer.size + 1;
    if (a2 <= 255) {
      entry = { a: a2, layer, viewports: [viewport] };
      byLayer.set(layer, entry);
      byAlpha[a2] = entry;
    } else {
      defaultLogger.warn("Too many pickable layers, only picking the first 255")();
      a2 = 0;
    }
  }
  return [0, 0, 0, a2 / 255];
}
function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}
const LIFECYCLE = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
};
const COMPONENT_SYMBOL = Symbol.for("component");
const PROP_TYPES_SYMBOL = Symbol.for("propTypes");
const DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
const ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
const ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
const ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");
function flatten(array2, filter = () => true) {
  if (!Array.isArray(array2)) {
    return filter(array2) ? [array2] : [];
  }
  return flattenArray(array2, filter, []);
}
function flattenArray(array2, filter, result) {
  let index2 = -1;
  while (++index2 < array2.length) {
    const value = array2[index2];
    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }
  return result;
}
function fillArray({ target, source, start: start2 = 0, count: count2 = 1 }) {
  const length = source.length;
  const total = count2 * length;
  let copied = 0;
  for (let i = start2; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start2 + copied, start2, start2 + copied);
      copied *= 2;
    } else {
      target.copyWithin(start2 + copied, start2, start2 + total - copied);
      copied = total;
    }
  }
  return target;
}
class Resource2 {
  constructor(id, data, context) {
    this._loadCount = 0;
    this._subscribers = /* @__PURE__ */ new Set();
    this.id = id;
    this.context = context;
    this.setData(data);
  }
  // consumer: {onChange: Function}
  subscribe(consumer) {
    this._subscribers.add(consumer);
  }
  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(data, forceUpdate) {
    if (data === this._data && !forceUpdate) {
      return;
    }
    this._data = data;
    const loadCount = ++this._loadCount;
    let loader = data;
    if (typeof data === "string") {
      loader = load(data);
    }
    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then((result) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = void 0;
          this._content = result;
        }
      }).catch((error) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = void 0;
      this._content = data;
    }
    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }
}
class ResourceManager {
  constructor(props) {
    this.protocol = props.protocol || "resource://";
    this._context = {
      device: props.device,
      // @ts-expect-error
      gl: props.device?.gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }
  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }
    return resourceId in this._resources;
  }
  add({ resourceId, data, forceUpdate = false, persistent = true }) {
    let res = this._resources[resourceId];
    if (res) {
      res.setData(data, forceUpdate);
    } else {
      res = new Resource2(resourceId, data, this._context);
      this._resources[resourceId] = res;
    }
    res.persistent = persistent;
  }
  remove(resourceId) {
    const res = this._resources[resourceId];
    if (res) {
      res.delete();
      delete this._resources[resourceId];
    }
  }
  unsubscribe({ consumerId }) {
    const consumer = this._consumers[consumerId];
    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];
        const resource = this._resources[request.resourceId];
        if (resource) {
          resource.unsubscribe(request);
        }
      }
      delete this._consumers[consumerId];
      this.prune();
    }
  }
  subscribe({ resourceId, onChange, consumerId, requestId = "default" }) {
    const { _resources: resources, protocol } = this;
    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, "");
      if (!resources[resourceId]) {
        this.add({ resourceId, data: null, persistent: false });
      }
    }
    const res = resources[resourceId];
    this._track(consumerId, requestId, res, onChange);
    if (res) {
      return res.getData();
    }
    return void 0;
  }
  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }
  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }
  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    let request = consumer[requestId];
    const oldResource = request && request.resourceId && this._resources[request.resourceId];
    if (oldResource) {
      oldResource.unsubscribe(request);
      this.prune();
    }
    if (resource) {
      if (request) {
        request.onChange = onChange;
        request.resourceId = resource.id;
      } else {
        request = {
          onChange,
          resourceId: resource.id
        };
      }
      consumer[requestId] = request;
      resource.subscribe(request);
    }
  }
  _prune() {
    this._pruneRequest = null;
    for (const key of Object.keys(this._resources)) {
      const res = this._resources[key];
      if (!res.persistent && !res.inUse()) {
        res.delete();
        delete this._resources[key];
      }
    }
  }
}
const TRACE_SET_LAYERS = "layerManager.setLayers";
const TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
class LayerManager {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(device, props) {
    this._lastRenderedLayers = [];
    this._needsRedraw = false;
    this._needsUpdate = false;
    this._nextLayers = null;
    this._debug = false;
    this._defaultShaderModulesChanged = false;
    this.activateViewport = (viewport2) => {
      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport2);
      if (viewport2) {
        this.context.viewport = viewport2;
      }
    };
    const { deck, stats, viewport, timeline } = props || {};
    this.layers = [];
    this.resourceManager = new ResourceManager({ device, protocol: "deck://" });
    this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device,
      // @ts-expect-error
      gl: device?.gl,
      deck,
      shaderAssembler: getShaderAssembler(),
      defaultShaderModules: [],
      renderPass: void 0,
      stats: stats || new Stats({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: viewport || new Viewport({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: timeline || new Timeline(),
      resourceManager: this.resourceManager,
      onError: void 0
    };
    Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }
  /** Check if a redraw is needed */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }
    return redraw;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
      return "layers changed";
    }
    if (this._defaultShaderModulesChanged) {
      return "shader modules changed";
    }
    return this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds } = {}) {
    return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(props) {
    if ("debug" in props) {
      this._debug = props.debug;
    }
    if ("userData" in props) {
      this.context.userData = props.userData;
    }
    if ("layers" in props) {
      this._nextLayers = props.layers;
    }
    if ("onError" in props) {
      this.context.onError = props.onError;
    }
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(newLayers, reason) {
    debug(TRACE_SET_LAYERS, this, reason, newLayers);
    this._lastRenderedLayers = newLayers;
    const flatLayers = flatten(newLayers, Boolean);
    for (const layer of flatLayers) {
      layer.context = this.context;
    }
    this._updateLayers(this.layers, flatLayers);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const reason = this.needsUpdate();
    if (reason) {
      this.setNeedsRedraw(`updating layers: ${reason}`);
      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
    }
    this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(module) {
    const { defaultShaderModules } = this.context;
    if (!defaultShaderModules.find((m2) => m2.name === module.name)) {
      defaultShaderModules.push(module);
      this._defaultShaderModulesChanged = true;
    }
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(module) {
    const { defaultShaderModules } = this.context;
    const i = defaultShaderModules.findIndex((m2) => m2.name === module.name);
    if (i >= 0) {
      defaultShaderModules.splice(i, 1);
      this._defaultShaderModulesChanged = true;
    }
  }
  _handleError(stage, error, layer) {
    layer.raiseError(error, `${stage} of ${layer}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};
    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        defaultLogger.warn(`Multiple old layers with same id ${oldLayer.id}`)();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }
    if (this._defaultShaderModulesChanged) {
      for (const layer of oldLayers) {
        layer.setNeedsUpdate();
        layer.setChangeFlags({ extensionsChanged: true });
      }
      this._defaultShaderModulesChanged = false;
    }
    const generatedLayers = [];
    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
    this._finalizeOldLayers(oldLayerMap);
    let needsUpdate = false;
    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = `Uniform transition in ${layer}`;
        break;
      }
    }
    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];
      if (oldLayer === null) {
        defaultLogger.warn(`Multiple new layers with same id ${newLayer.id}`)();
      }
      oldLayerMap[newLayer.id] = null;
      let sublayers = null;
      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }
        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);
          this._updateLayer(newLayer);
        }
        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
      } catch (err) {
        this._handleError("matching", err, newLayer);
      }
      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];
      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(layer) {
    try {
      layer._initialize();
      layer.lifecycle = LIFECYCLE.INITIALIZED;
    } catch (err) {
      this._handleError("initialization", err, layer);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);
    newLayer.lifecycle = LIFECYCLE.MATCHED;
    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
    }
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err) {
      this._handleError("update", err, layer);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;
    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
    try {
      layer._finalize();
      layer.lifecycle = LIFECYCLE.FINALIZED;
    } catch (err) {
      this._handleError("finalization", err, layer);
    }
  }
}
function deepEqual(a2, b, depth) {
  if (a2 === b) {
    return true;
  }
  if (!depth || !a2 || !b) {
    return false;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b) || a2.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a2.length; i++) {
      if (!deepEqual(a2[i], b[i], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b)) {
    return false;
  }
  if (typeof a2 === "object" && typeof b === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a2[key], b[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
class ViewManager {
  constructor(props) {
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = "First render";
    this._needsUpdate = "Initialize";
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const key in this.controllers) {
      const controller = this.controllers[key];
      if (controller) {
        controller.finalize();
      }
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];
      if (controller) {
        controller.updateTransition();
      }
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(rect) {
    if (rect) {
      return this._viewports.filter((viewport) => viewport.containsPixel(rect));
    }
    return this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const viewMap = {};
    this.views.forEach((view) => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }
  /** Resolves a viewId string to a View */
  getView(viewId) {
    return this.views.find((view) => view.id === viewId);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(viewOrViewId) {
    const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }
  getViewport(viewId) {
    return this._viewportMap[viewId];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = { x: xyz[0], y: xyz[1] };
    for (let i = viewports.length - 1; i >= 0; --i) {
      const viewport = viewports[i];
      if (viewport.containsPixel(pixel)) {
        const p2 = xyz.slice();
        p2[0] -= viewport.x;
        p2[1] -= viewport.y;
        return viewport.unproject(p2, opts);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(props) {
    if (props.views) {
      this._setViews(props.views);
    }
    if (props.viewState) {
      this._setViewState(props.viewState);
    }
    if ("width" in props || "height" in props) {
      this._setSize(props.width, props.height);
    }
    if (!this._isUpdating) {
      this._update();
    }
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = true;
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    this._isUpdating = false;
  }
  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate("Size changed");
    }
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(views) {
    views = flatten(views, Boolean);
    const viewsChanged = this._diffViews(views, this.views);
    if (viewsChanged) {
      this.setNeedsUpdate("views changed");
    }
    this.views = views;
  }
  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !deepEqual(viewState, this.viewState, 3);
      if (viewStateChanged) {
        this.setNeedsUpdate("viewState changed");
      }
      this.viewState = viewState;
    } else {
      defaultLogger.warn("missing `viewState` or `initialViewState`")();
    }
  }
  _createController(view, props) {
    const Controller2 = props.type;
    const controller = new Controller2({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (viewState) => this.getView(view.id)?.makeViewport({
        viewState,
        width: this.width,
        height: this.height
      })
    });
    return controller;
  }
  _updateController(view, viewState, viewport, controller) {
    const controllerProps = view.controller;
    if (controllerProps && viewport) {
      const resolvedProps = {
        ...viewState,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };
      if (!controller || controller.constructor !== controllerProps.type) {
        controller = this._createController(view, resolvedProps);
      }
      if (controller) {
        controller.setProps(resolvedProps);
      }
      return controller;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;
    for (let i = views.length; i--; ) {
      const view = views[i];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({ viewState, width: this.width, height: this.height });
      let oldController = oldControllers[view.id];
      const hasController = Boolean(view.controller);
      if (hasController && !oldController) {
        invalidateControllers = true;
      }
      if ((invalidateControllers || !hasController) && oldController) {
        oldController.finalize();
        oldController = null;
      }
      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
      if (viewport) {
        this._viewports.unshift(viewport);
      }
    }
    for (const id in oldControllers) {
      const oldController = oldControllers[id];
      if (oldController && !this.controllers[id]) {
        oldController.finalize();
      }
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {};
    this._viewports.forEach((viewport) => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }
    return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
  }
}
const PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
  switch (typeof value) {
    case "number":
      return {
        position: value,
        relative: false
      };
    case "string":
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);
      if (match && match.length >= 3) {
        const relative = match[2] === "%";
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${value}`);
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}
class View {
  constructor(props) {
    const { id, x: x2 = 0, y: y2 = 0, width = "100%", height = "100%", padding = null } = props;
    this.id = id || this.constructor.displayName || "view";
    this.props = { ...props, id: this.id };
    this._x = parsePosition(x2);
    this._y = parsePosition(y2);
    this._width = parsePosition(width);
    this._height = parsePosition(height);
    this._padding = padding && {
      left: parsePosition(padding.left || 0),
      right: parsePosition(padding.right || 0),
      top: parsePosition(padding.top || 0),
      bottom: parsePosition(padding.bottom || 0)
    };
    this.equals = this.equals.bind(this);
    Object.seal(this);
  }
  equals(view) {
    if (this === view) {
      return true;
    }
    return this.ViewportType === view.ViewportType && deepEqual(this.props, view.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width, height, viewState }) {
    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({ width, height });
    if (!viewportDimensions.height || !viewportDimensions.width) {
      return null;
    }
    return new this.ViewportType({ ...viewState, ...this.props, ...viewportDimensions });
  }
  getViewStateId() {
    const { viewState } = this.props;
    if (typeof viewState === "string") {
      return viewState;
    }
    return viewState?.id || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === "object") {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }
      const newViewState = { ...viewState };
      for (const key in this.props.viewState) {
        if (key !== "id") {
          newViewState[key] = this.props.viewState[key];
        }
      }
      return newViewState;
    }
    return viewState;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width, height }) {
    const dimensions = {
      x: getPosition(this._x, width),
      y: getPosition(this._y, height),
      width: getPosition(this._width, width),
      height: getPosition(this._height, height)
    };
    if (this._padding) {
      dimensions.padding = {
        left: getPosition(this._padding.left, width),
        top: getPosition(this._padding.top, height),
        right: getPosition(this._padding.right, width),
        bottom: getPosition(this._padding.bottom, height)
      };
    }
    return dimensions;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const opts = this.props.controller;
    if (!opts) {
      return null;
    }
    if (opts === true) {
      return { type: this.ControllerType };
    }
    if (typeof opts === "function") {
      return { type: opts };
    }
    return { type: this.ControllerType, ...opts };
  }
}
class Transition {
  /**
   * @params timeline {Timeline}
   */
  constructor(timeline) {
    this._inProgress = false;
    this._handle = null;
    this.time = 0;
    this.settings = {
      duration: 0
    };
    this._timeline = timeline;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(settings) {
    this.cancel();
    this.settings = settings;
    this._inProgress = true;
    this.settings.onStart?.(this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    if (this._inProgress) {
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
      this.settings.onEnd?.(this);
    }
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    if (this._inProgress) {
      this.settings.onInterrupt?.(this);
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
    }
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    if (!this._inProgress) {
      return false;
    }
    if (this._handle === null) {
      const { _timeline: timeline, settings } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }
    this.time = this._timeline.getTime(this._handle);
    this._onUpdate();
    this.settings.onUpdate?.(this);
    if (this._timeline.isFinished(this._handle)) {
      this.end();
    }
    return true;
  }
  /* Private API */
  _onUpdate() {
  }
}
const noop$2 = () => {
};
const TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
const DEFAULT_EASING = (t) => t;
const DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
class TransitionManager {
  constructor(opts) {
    this._onTransitionUpdate = (transition) => {
      const { time: time2, settings: { interpolator, startProps, endProps, duration, easing } } = transition;
      const t = easing(time2 / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    };
    this.getControllerState = opts.getControllerState;
    this.propsInTransition = null;
    this.transition = new Transition(opts.timeline);
    this.onViewStateChange = opts.onViewStateChange || noop$2;
    this.onStateChange = opts.onStateChange || noop$2;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    this.props = nextProps;
    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return false;
    }
    if (this._isTransitionEnabled(nextProps)) {
      let startProps = currentProps;
      if (this.transition.inProgress) {
        const { interruption, endProps } = this.transition.settings;
        startProps = {
          ...currentProps,
          ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
        };
      }
      this._triggerTransition(startProps, nextProps);
      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }
    return transitionTriggered;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(props) {
    const { transitionDuration, transitionInterpolator } = props;
    return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
  }
  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress && this.propsInTransition) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }
    return false;
  }
  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      const transitionSettings = this.transition.settings;
      return transitionSettings.interruption === TRANSITION_EVENTS.IGNORE || // Ignore update if it is due to current active transition.
      this._isUpdateDueToCurrentTransition(nextProps);
    }
    if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }
    return true;
  }
  _triggerTransition(startProps, endProps) {
    const startViewstate = this.getControllerState(startProps);
    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
    const transitionInterpolator = endProps.transitionInterpolator;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
    if (duration === 0) {
      return;
    }
    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    const transitionSettings = {
      duration,
      easing: endProps.transitionEasing || DEFAULT_EASING,
      interpolator: transitionInterpolator,
      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    };
    this.transition.start(transitionSettings);
    this.onStateChange({ inTransition: true });
    this.updateTransition();
  }
  _onTransitionEnd(callback) {
    return (transition) => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback?.(transition);
    };
  }
}
function assert(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "deck.gl: assertion failed.");
  }
}
class TransitionInterpolator {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(opts) {
    const { compare, extract, required } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract || compare;
    this._requiredProps = required;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare) {
      if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(startProps, endProps) {
    const startViewStateProps = {};
    const endViewStateProps = {};
    for (const key of this._propsToExtract) {
      if (key in startProps || key in endProps) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }
    }
    this._checkRequiredProps(startViewStateProps);
    this._checkRequiredProps(endViewStateProps);
    return { start: startViewStateProps, end: endViewStateProps };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }
  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }
    this._requiredProps.forEach((propName) => {
      const value = props[propName];
      assert(Number.isFinite(value) || Array.isArray(value), `${propName} is required for transition`);
    });
  }
}
const DEFAULT_PROPS = ["longitude", "latitude", "zoom", "bearing", "pitch"];
const DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
class LinearInterpolator extends TransitionInterpolator {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    const normalizedOpts = Array.isArray(opts) ? {} : opts;
    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
      compare: transitionProps,
      required: transitionProps
    } : transitionProps || {
      compare: DEFAULT_PROPS,
      required: DEFAULT_REQUIRED_PROPS
    };
    super(normalizedOpts.transitionProps);
    this.opts = normalizedOpts;
  }
  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const { makeViewport, around } = this.opts;
    if (makeViewport && around) {
      const startViewport = makeViewport(startProps);
      const endViewport = makeViewport(endProps);
      const aroundPosition = startViewport.unproject(around);
      result.start.around = around;
      Object.assign(result.end, {
        around: endViewport.project(aroundPosition),
        aroundPosition,
        width: endProps.width,
        height: endProps.height
      });
    }
    return result;
  }
  interpolateProps(startProps, endProps, t) {
    const propsInTransition = {};
    for (const key of this._propsToExtract) {
      propsInTransition[key] = lerp$1(startProps[key] || 0, endProps[key] || 0, t);
    }
    if (endProps.aroundPosition && this.opts.makeViewport) {
      const viewport = this.opts.makeViewport({ ...endProps, ...propsInTransition });
      Object.assign(propsInTransition, viewport.panByPosition(
        endProps.aroundPosition,
        // anchor point in current screen coordinates
        lerp$1(startProps.around, endProps.around, t)
      ));
    }
    return propsInTransition;
  }
}
const NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
const DEFAULT_INERTIA = 300;
const INERTIA_EASING = (t) => 1 - (1 - t) * (1 - t);
const EVENT_TYPES = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
};
const pinchEventWorkaround = {};
class Controller {
  constructor(opts) {
    this.state = {};
    this._events = {};
    this._interactionState = {
      isDragging: false
    };
    this._customEvents = [];
    this._eventStartBlocked = null;
    this._panMove = false;
    this.invertPan = false;
    this.dragMode = "rotate";
    this.inertia = 0;
    this.scrollZoom = true;
    this.dragPan = true;
    this.dragRotate = true;
    this.doubleClickZoom = true;
    this.touchZoom = true;
    this.touchRotate = false;
    this.keyboard = true;
    this.transitionManager = new TransitionManager({
      ...opts,
      getControllerState: (props) => new this.ControllerState(props),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    this.handleEvent = this.handleEvent.bind(this);
    this.eventManager = opts.eventManager;
    this.onViewStateChange = opts.onViewStateChange || (() => {
    });
    this.onStateChange = opts.onStateChange || (() => {
    });
    this.makeViewport = opts.makeViewport;
  }
  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;
    if (this.props) {
      this.setProps(this.props);
    }
  }
  finalize() {
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        this.eventManager?.off(eventName, this.handleEvent);
      }
    }
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(event) {
    this._controllerState = void 0;
    const eventStartBlocked = this._eventStartBlocked;
    switch (event.type) {
      case "panstart":
        return eventStartBlocked ? false : this._onPanStart(event);
      case "panmove":
        return this._onPan(event);
      case "panend":
        return this._onPanEnd(event);
      case "pinchstart":
        return eventStartBlocked ? false : this._onPinchStart(event);
      case "pinchmove":
        return this._onPinch(event);
      case "pinchend":
        return this._onPinchEnd(event);
      case "tripanstart":
        return eventStartBlocked ? false : this._onTriplePanStart(event);
      case "tripanmove":
        return this._onTriplePan(event);
      case "tripanend":
        return this._onTriplePanEnd(event);
      case "doubletap":
        return this._onDoubleTap(event);
      case "wheel":
        return this._onWheel(event);
      case "keydown":
        return this._onKeyDown(event);
      default:
        return false;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    });
    return this._controllerState;
  }
  getCenter(event) {
    const { x: x2, y: y2 } = this.props;
    const { offsetCenter } = event;
    return [offsetCenter.x - x2, offsetCenter.y - y2];
  }
  isPointInBounds(pos, event) {
    const { width, height } = this.props;
    if (event && event.handled) {
      return false;
    }
    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
    if (inside && event) {
      event.stopPropagation();
    }
    return inside;
  }
  isFunctionKeyPressed(event) {
    const { srcEvent } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || false;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }
  /**
   * Extract interactivity options
   */
  setProps(props) {
    if (props.dragMode) {
      this.dragMode = props.dragMode;
    }
    this.props = props;
    if (!("transitionInterpolator" in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }
    this.transitionManager.processViewStateChange(props);
    const { inertia } = props;
    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
    const { scrollZoom = true, dragPan = true, dragRotate = true, doubleClickZoom = true, touchZoom = true, touchRotate = false, keyboard = true } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach((eventName) => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;
          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(newControllerState, extraProps = null, interactionState = {}) {
    const viewState = { ...newControllerState.getViewportProps(), ...extraProps };
    const changed = this.controllerState !== newControllerState;
    this.state = newControllerState.getState();
    this._setInteractionState(interactionState);
    if (changed) {
      const oldViewState = this.controllerState && this.controllerState.getViewportProps();
      if (this.onViewStateChange) {
        this.onViewStateChange({ viewState, interactionState: this._interactionState, oldViewState, viewId: this.props.id });
      }
    }
  }
  _onTransition(params) {
    this.onViewStateChange({ ...params, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);
    this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
    if (this.invertPan || this.dragMode === "pan") {
      alternateMode = !alternateMode;
    }
    const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }
  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }
  _onPanMoveEnd(event) {
    const { inertia } = this;
    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [
        pos[0] + event.velocityX * inertia / 2,
        pos[1] + event.velocityY * inertia / 2
      ];
      const newControllerState = this.controllerState.pan({ pos: endPos }).panEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }
    return true;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onPanRotateEnd(event) {
    const { inertia } = this;
    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [
        pos[0] + event.velocityX * inertia / 2,
        pos[1] + event.velocityY * inertia / 2
      ];
      const newControllerState = this.controllerState.rotate({ pos: endPos }).rotateEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  // Default handler for the `wheel` event.
  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    event.srcEvent.preventDefault();
    const { speed = 0.01, smooth = false } = this.scrollZoom === true ? {} : this.scrollZoom;
    const { delta } = event;
    let scale2 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
    if (delta < 0 && scale2 !== 0) {
      scale2 = 1 / scale2;
    }
    const newControllerState = this.controllerState.zoom({ pos, scale: scale2 });
    this.updateViewport(newControllerState, { ...this._getTransitionProps({ around: pos }), transitionDuration: smooth ? 250 : 1 }, {
      isZooming: true,
      isPanning: true
    });
    return true;
  }
  _onTriplePanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.rotateStart({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  _onTriplePan(event) {
    if (!this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onTriplePanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const { inertia } = this;
    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({ pos: endPos });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.zoomStart({ pos }).rotateStart({ pos });
    pinchEventWorkaround._startPinchRotation = event.rotation;
    pinchEventWorkaround._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    let newControllerState = this.controllerState;
    if (this.touchZoom) {
      const { scale: scale2 } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({ pos, scale: scale2 });
    }
    if (this.touchRotate) {
      const { rotation } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
      });
    }
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    pinchEventWorkaround._lastPinchEvent = event;
    return true;
  }
  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const { inertia } = this;
    const { _lastPinchEvent } = pinchEventWorkaround;
    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z = Math.log2(event.scale);
      const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
      const endScale = Math.pow(2, z + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({ pos, scale: endScale }).zoomEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({ around: pos }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }
    pinchEventWorkaround._startPinchRotation = null;
    pinchEventWorkaround._lastPinchEvent = null;
    return true;
  }
  // Default handler for the `doubletap` event.
  _onDoubleTap(event) {
    if (!this.doubleClickZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({ pos, scale: isZoomOut ? 0.5 : 2 });
    this.updateViewport(newControllerState, this._getTransitionProps({ around: pos }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }
  // Default handler for the `keydown` event
  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }
    const funcKey = this.isFunctionKeyPressed(event);
    const { zoomSpeed, moveSpeed, rotateSpeedX, rotateSpeedY } = this.keyboard === true ? {} : this.keyboard;
    const { controllerState } = this;
    let newControllerState;
    const interactionState = {};
    switch (event.srcEvent.code) {
      case "Minus":
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "Equal":
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "ArrowLeft":
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowRight":
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowUp":
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowDown":
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "F":
        break;
      default:
        return false;
    }
    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }
  _getTransitionProps(opts) {
    const { transition } = this;
    if (!transition || !transition.transitionInterpolator) {
      return NO_TRANSITION_PROPS;
    }
    return opts ? {
      ...transition,
      transitionInterpolator: new LinearInterpolator({
        ...opts,
        ...transition.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : transition;
  }
}
class ViewState {
  constructor(props, state) {
    this._viewportProps = this.applyConstraints(props);
    this._state = state;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const PITCH_MOUSE_THRESHOLD = 5;
const PITCH_ACCEL = 1.2;
class MapState extends ViewState {
  constructor(options) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width,
      /** The height of the viewport */
      height,
      /** The latitude at the center of the viewport */
      latitude,
      /** The longitude at the center of the viewport */
      longitude,
      /** The tile zoom level of the map. */
      zoom,
      /** The bearing of the viewport in degrees */
      bearing: bearing2 = 0,
      /** The pitch of the viewport in degrees */
      pitch = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude = 1.5,
      /** Viewport position */
      position = [0, 0, 0],
      /** Viewport constraints */
      maxZoom = 20,
      minZoom = 0,
      maxPitch = 60,
      minPitch = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat,
      /* Center of the zoom when the operation first started */
      startZoomLngLat,
      /* Pointer position when rotation started */
      startRotatePos,
      /** Bearing when current perspective rotate operation started */
      startBearing,
      /** Pitch when current perspective rotate operation started */
      startPitch,
      /** Zoom when current zoom operation started */
      startZoom,
      /** Normalize viewport props to fit map height into viewport */
      normalize: normalize2 = true
    } = options;
    assert(Number.isFinite(longitude));
    assert(Number.isFinite(latitude));
    assert(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing: bearing2,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize: normalize2,
      position
    }, {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    });
    this.makeViewport = options.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos, startPos }) {
    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
    if (!startPanLngLat) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
    const { startRotatePos, startBearing, startPitch } = this.getState();
    if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
      return this;
    }
    let newRotation;
    if (pos) {
      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos, startPos, scale: scale2 }) {
    let { startZoom, startZoomLngLat } = this.getState();
    if (!startZoomLngLat) {
      startZoom = this.getViewportProps().zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomLngLat) {
      return this;
    }
    const { maxZoom, minZoom } = this.getViewportProps();
    let zoom = startZoom + Math.log2(scale2);
    zoom = clamp$1(zoom, minZoom, maxZoom);
    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }
  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }
  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }
  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }
  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }
  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps() };
    const { bearing: bearing2, longitude } = props;
    if (Math.abs(bearing2 - fromProps.bearing) > 180) {
      props.bearing = bearing2 < 0 ? bearing2 + 360 : bearing2 - 360;
    }
    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(props) {
    const { maxZoom, minZoom, zoom } = props;
    props.zoom = clamp$1(zoom, minZoom, maxZoom);
    const { maxPitch, minPitch, pitch } = props;
    props.pitch = clamp$1(pitch, minPitch, maxPitch);
    const { normalize: normalize2 = true } = props;
    if (normalize2) {
      Object.assign(props, normalizeViewportProps(props));
    }
    return props;
  }
  /* Private methods */
  _zoomFromCenter(scale2) {
    const { width, height } = this.getViewportProps();
    return this.zoom({
      pos: [width / 2, height / 2],
      scale: scale2
    });
  }
  _panFromCenter(offset2) {
    const { width, height } = this.getViewportProps();
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset2[0], height / 2 + offset2[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _getNewRotation(pos, startPos, startPitch, startBearing) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const { width, height } = this.getViewportProps();
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;
    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }
    deltaScaleY = clamp$1(deltaScaleY, -1, 1);
    const { minPitch, maxPitch } = this.getViewportProps();
    const bearing2 = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;
    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }
    return {
      pitch,
      bearing: bearing2
    };
  }
}
class MapController extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = MapState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    };
    this.dragMode = "pan";
  }
  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.props;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;
    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...props,
        ...this.state
      }));
    }
  }
}
class MapView extends View {
  constructor(props = {}) {
    super(props);
  }
  get ViewportType() {
    return WebMercatorViewport;
  }
  get ControllerType() {
    return MapController;
  }
}
MapView.displayName = "MapView";
const DEFAULT_LIGHTING_EFFECT = new LightingEffect();
function compareEffects(e1, e22) {
  const o1 = e1.order ?? Infinity;
  const o2 = e22.order ?? Infinity;
  return o1 - o2;
}
class EffectManager {
  constructor(context) {
    this._resolvedEffects = [];
    this._defaultEffects = [];
    this.effects = [];
    this._context = context;
    this._needsRedraw = "Initial render";
    this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(effect) {
    const defaultEffects = this._defaultEffects;
    if (!defaultEffects.find((e) => e.id === effect.id)) {
      const index2 = defaultEffects.findIndex((e) => compareEffects(e, effect) > 0);
      if (index2 < 0) {
        defaultEffects.push(effect);
      } else {
        defaultEffects.splice(index2, 0, effect);
      }
      effect.setup(this._context);
      this._setEffects(this.effects);
    }
  }
  setProps(props) {
    if ("effects" in props) {
      if (!deepEqual(props.effects, this.effects, 1)) {
        this._setEffects(props.effects);
      }
    }
  }
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(effects) {
    const oldEffectsMap = {};
    for (const effect of this.effects) {
      oldEffectsMap[effect.id] = effect;
    }
    const nextEffects = [];
    for (const effect of effects) {
      const oldEffect = oldEffectsMap[effect.id];
      let effectToAdd = effect;
      if (oldEffect && oldEffect !== effect) {
        if (oldEffect.setProps) {
          oldEffect.setProps(effect.props);
          effectToAdd = oldEffect;
        } else {
          oldEffect.cleanup(this._context);
        }
      } else if (!oldEffect) {
        effect.setup(this._context);
      }
      nextEffects.push(effectToAdd);
      delete oldEffectsMap[effect.id];
    }
    for (const removedEffectId in oldEffectsMap) {
      oldEffectsMap[removedEffectId].cleanup(this._context);
    }
    this.effects = nextEffects;
    this._resolvedEffects = nextEffects.concat(this._defaultEffects);
    if (!effects.some((effect) => effect instanceof LightingEffect)) {
      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
    }
    this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const effect of this._resolvedEffects) {
      effect.cleanup(this._context);
    }
    this.effects.length = 0;
    this._resolvedEffects.length = 0;
    this._defaultEffects.length = 0;
  }
}
class DrawLayersPass extends LayersPass {
  shouldDrawLayer(layer) {
    const { operation } = layer.props;
    return operation.includes("draw") || operation.includes("terrain");
  }
}
const TRACE_RENDER_LAYERS$1 = "deckRenderer.renderLayers";
class DeckRenderer {
  constructor(device) {
    this.device = device;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new DrawLayersPass(device);
    this.pickLayersPass = new PickLayersPass(device);
    this.renderCount = 0;
    this._needsRedraw = "Initial render";
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }
  setProps(props) {
    if (this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = "layerFilter changed";
    }
    if (this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = "drawPickingColors changed";
    }
  }
  renderLayers(opts) {
    if (!opts.viewports.length) {
      return;
    }
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    const renderOpts = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...opts
    };
    if (renderOpts.effects) {
      this._preRender(renderOpts.effects, renderOpts);
    }
    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
    if (this.lastPostProcessEffect) {
      renderOpts.clearColor = [0, 0, 0, 0];
      renderOpts.clearCanvas = true;
    }
    const renderStats = layerPass.render({ ...renderOpts, target: outputBuffer });
    if (renderOpts.effects) {
      this._postRender(renderOpts.effects, renderOpts);
    }
    this.renderCount++;
    debug(TRACE_RENDER_LAYERS$1, this, renderStats, opts);
  }
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  finalize() {
    const { renderBuffers } = this;
    for (const buffer of renderBuffers) {
      buffer.delete();
    }
    renderBuffers.length = 0;
  }
  _preRender(effects, opts) {
    this.lastPostProcessEffect = null;
    opts.preRenderStats = opts.preRenderStats || {};
    for (const effect of effects) {
      opts.preRenderStats[effect.id] = effect.preRender(opts);
      if (effect.postRender) {
        this.lastPostProcessEffect = effect.id;
      }
    }
    if (this.lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }
  }
  _resizeRenderBuffers() {
    const { renderBuffers } = this;
    const size = this.device.canvasContext.getDrawingBufferSize();
    if (renderBuffers.length === 0) {
      [0, 1].map((i) => {
        const texture = this.device.createTexture({
          sampler: { minFilter: "linear", magFilter: "linear" }
        });
        renderBuffers.push(this.device.createFramebuffer({
          id: `deck-renderbuffer-${i}`,
          colorAttachments: [texture]
        }));
      });
    }
    for (const buffer of renderBuffers) {
      buffer.resize(size);
    }
  }
  _postRender(effects, opts) {
    const { renderBuffers } = this;
    const params = {
      ...opts,
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1]
    };
    for (const effect of effects) {
      if (effect.postRender) {
        params.target = effect.id === this.lastPostProcessEffect ? opts.target : void 0;
        const buffer = effect.postRender(params);
        params.inputBuffer = buffer;
        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }
}
const NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function getClosestObject({ pickedColors, decodePickingColor, deviceX, deviceY, deviceRadius, deviceRect }) {
  const { x: x2, y: y2, width, height } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i = 0;
  for (let row = 0; row < height; row++) {
    const dy = row + y2 - deviceY;
    const dy2 = dy * dy;
    if (dy2 > minSquareDistanceToCenter) {
      i += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const dx = col + x2 - deviceX;
          const d2 = dx * dx + dy2;
          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }
        i += 4;
      }
    }
  }
  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);
    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return {
        ...pickedObject,
        pickedColor,
        pickedX: x2 + dx,
        pickedY: y2 + dy
      };
    }
    defaultLogger.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects({ pickedColors, decodePickingColor }) {
  const uniqueColors = /* @__PURE__ */ new Map();
  if (pickedColors) {
    for (let i = 0; i < pickedColors.length; i += 4) {
      const pickedLayerIndex = pickedColors[i + 3] - 1;
      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i, i + 4);
        const colorKey = pickedColor.join(",");
        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);
          if (pickedObject) {
            uniqueColors.set(colorKey, {
              ...pickedObject,
              color: pickedColor
            });
          } else {
            defaultLogger.error("Picked non-existent layer. Is picking buffer corrupt?")();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}
function getEmptyPickingInfo({ pickInfo, viewports, pixelRatio, x: x2, y: y2, z }) {
  let pickedViewport = viewports[0];
  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates(pickInfo?.pickedViewports || viewports, { x: x2, y: y2 });
  }
  let coordinate;
  if (pickedViewport) {
    const point2 = [x2 - pickedViewport.x, y2 - pickedViewport.y];
    if (z !== void 0) {
      point2[2] = z;
    }
    coordinate = pickedViewport.unproject(point2);
  }
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x: x2,
    y: y2,
    pixel: [x2, y2],
    coordinate,
    devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const { pickInfo, lastPickedInfo, mode, layers } = opts;
  const { pickedColor, pickedLayer, pickedObjectIndex } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === "hover") {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  const baseInfo = getEmptyPickingInfo(opts);
  const infos = /* @__PURE__ */ new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach((layer) => {
    let info = { ...baseInfo };
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({ layer, info, mode });
    const rootLayer = info.layer;
    if (layer === pickedLayer && mode === "hover") {
      lastPickedInfo.info = info;
    }
    infos.set(rootLayer.id, info);
    if (mode === "hover") {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({ layer, info, mode }) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({ info, mode, sourceLayer });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(viewports, pixel) {
  for (let i = viewports.length - 1; i >= 0; i--) {
    const viewport = viewports[i];
    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }
  return viewports[0];
}
class DeckPicker {
  constructor(device) {
    this._pickable = true;
    this.device = device;
    this.pickLayersPass = new PickLayersPass(device);
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(props) {
    if ("layerFilter" in props) {
      this.layerFilter = props.layerFilter;
    }
    if ("_pickable" in props) {
      this._pickable = props._pickable;
    }
  }
  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.destroy();
    }
    if (this.depthFBO) {
      this.depthFBO.destroy();
    }
  }
  /** Pick the closest info at given coordinate */
  pickObject(opts) {
    return this._pickClosestObject(opts);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: x2, y: y2, layers, viewports }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find((l) => l.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find((v) => v.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x2 - viewport.x, y2 - viewport.y]);
    const info = {
      x: x2,
      y: y2,
      viewport,
      coordinate,
      layer
    };
    return { ...lastPickedInfo, ...info };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    if (!this.pickingFBO) {
      this.pickingFBO = this.device.createFramebuffer({
        colorAttachments: ["rgba8unorm"],
        depthStencilAttachment: "depth16unorm"
      });
      if (this.device.isTextureFormatRenderable("rgba32float")) {
        const depthFBO = this.device.createFramebuffer({
          colorAttachments: ["rgba32float"],
          depthStencilAttachment: "depth16unorm"
        });
        this.depthFBO = depthFBO;
      }
    }
    const { canvas: canvas2 } = this.device.getCanvasContext();
    this.pickingFBO?.resize({ width: canvas2.width, height: canvas2.height });
    this.depthFBO?.resize({ width: canvas2.width, height: canvas2.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }
    const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers, views, viewports, x: x2, y: y2, radius = 0, depth = 1, mode = "query", unproject3D, onViewportActive, effects }) {
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return {
        result: [],
        emptyInfo: getEmptyPickingInfo({ viewports, x: x2, y: y2, pixelRatio })
      };
    }
    this._resizeBuffer();
    const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const devicePixel = [
      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
    ];
    const deviceRadius = Math.round(radius * pixelRatio);
    const { width, height } = this.pickingFBO;
    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    const cullRect = {
      x: x2 - radius,
      y: y2 - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = /* @__PURE__ */ new Set();
    for (let i = 0; i < depth; i++) {
      let pickInfo;
      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: `picking:${mode}`
        });
        pickInfo = getClosestObject({
          ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }
      let z;
      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const { pickedColors: pickedColors2 } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: `picking:${mode}:z`
        }, true);
        if (pickedColors2[3]) {
          z = pickedColors2[0];
        }
      }
      if (pickInfo.pickedLayer && i + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }
      infos = processPickInfo({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x: x2,
        y: y2,
        z,
        pixelRatio
      });
      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }
      if (!pickInfo.pickedColor) {
        break;
      }
    }
    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }
    return { result, emptyInfo: infos.get(null) };
  }
  /** Pick all objects within the given bounding box */
  _pickVisibleObjects({ layers, views, viewports, x: x2, y: y2, width = 1, height = 1, mode = "query", maxObjects = null, onViewportActive, effects }) {
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return [];
    }
    this._resizeBuffer();
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const leftTop = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = this.device.canvasContext.cssToDevicePixels([x2 + width, y2 + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: { x: x2, y: y2, width, height },
      effects,
      pass: `picking:${mode}`
    });
    const pickInfos = getUniqueObjects(pickedResult);
    const uniquePickedObjects = /* @__PURE__ */ new Map();
    const uniqueInfos = [];
    const limitMaxObjects = Number.isFinite(maxObjects);
    for (let i = 0; i < pickInfos.length; i++) {
      if (limitMaxObjects && uniqueInfos.length >= maxObjects) {
        break;
      }
      const pickInfo = pickInfos[i];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x: x2,
        y: y2,
        pixelRatio
      };
      info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });
      const pickedLayerId = info.layer.id;
      if (!uniquePickedObjects.has(pickedLayerId)) {
        uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
      }
      const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
      const pickedObjectKey = info.object ?? info.index;
      if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
        uniqueObjectsInLayer.add(pickedObjectKey);
        uniqueInfos.push(info);
      }
    }
    return uniqueInfos;
  }
  _drawAndSample({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {}
    };
    for (const effect of effects) {
      if (effect.useInPicking) {
        opts.preRenderStats[effect.id] = effect.preRender(opts);
      }
    }
    const { decodePickingColor } = this.pickLayersPass.render(opts);
    const { x: x2, y: y2, width, height } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    this.device.readPixelsToArrayWebGL(pickingFBO, {
      sourceX: x2,
      sourceY: y2,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return { pickedColors, decodePickingColor };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect({ deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight }) {
    const x2 = Math.max(0, deviceX - deviceRadius);
    const y2 = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x2;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y2;
    if (width <= 0 || height <= 0) {
      return null;
    }
    return { x: x2, y: y2, width, height };
  }
}
const PLACEMENTS = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
};
const DEFAULT_PLACEMENT = "top-left";
const ROOT_CONTAINER_ID = "__root";
class WidgetManager {
  constructor({ deck, parentElement }) {
    this.defaultWidgets = [];
    this.widgets = [];
    this.resolvedWidgets = [];
    this.containers = {};
    this.lastViewports = {};
    this.deck = deck;
    this.parentElement = parentElement;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(props) {
    if (props.widgets && !deepEqual(props.widgets, this.widgets, 1)) {
      this._setWidgets(props.widgets);
    }
  }
  finalize() {
    for (const widget of this.getWidgets()) {
      this._remove(widget);
    }
    this.defaultWidgets.length = 0;
    this.resolvedWidgets.length = 0;
    for (const id in this.containers) {
      this.containers[id].remove();
    }
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(widget) {
    if (!this.defaultWidgets.find((w) => w.id === widget.id)) {
      this._add(widget);
      this.defaultWidgets.push(widget);
      this._setWidgets(this.widgets);
    }
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(nextWidgets) {
    const oldWidgetMap = {};
    for (const widget of this.resolvedWidgets) {
      oldWidgetMap[widget.id] = widget;
    }
    this.resolvedWidgets.length = 0;
    for (const widget of this.defaultWidgets) {
      oldWidgetMap[widget.id] = null;
      this.resolvedWidgets.push(widget);
    }
    for (let widget of nextWidgets) {
      const oldWidget = oldWidgetMap[widget.id];
      if (!oldWidget) {
        this._add(widget);
      } else if (
        // Widget placement changed
        oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement
      ) {
        this._remove(oldWidget);
        this._add(widget);
      } else if (widget !== oldWidget) {
        oldWidget.setProps(widget.props);
        widget = oldWidget;
      }
      oldWidgetMap[widget.id] = null;
      this.resolvedWidgets.push(widget);
    }
    for (const id in oldWidgetMap) {
      const oldWidget = oldWidgetMap[id];
      if (oldWidget) {
        this._remove(oldWidget);
      }
    }
    this.widgets = nextWidgets;
  }
  _add(widget) {
    const { viewId = null, placement = DEFAULT_PLACEMENT } = widget;
    const element = widget.onAdd({ deck: this.deck, viewId });
    if (element) {
      this._getContainer(viewId, placement).append(element);
    }
    widget._element = element;
  }
  _remove(widget) {
    widget.onRemove();
    if (widget._element) {
      widget._element.remove();
    }
    widget._element = void 0;
  }
  /* global document */
  _getContainer(viewId, placement) {
    const containerId = viewId || ROOT_CONTAINER_ID;
    let viewContainer = this.containers[containerId];
    if (!viewContainer) {
      viewContainer = document.createElement("div");
      viewContainer.style.pointerEvents = "none";
      viewContainer.style.position = "absolute";
      viewContainer.style.overflow = "hidden";
      this.parentElement?.append(viewContainer);
      this.containers[containerId] = viewContainer;
    }
    let container = viewContainer.querySelector(`.${placement}`);
    if (!container) {
      container = document.createElement("div");
      container.className = placement;
      container.style.position = "absolute";
      container.style.zIndex = "2";
      Object.assign(container.style, PLACEMENTS[placement]);
      viewContainer.append(container);
    }
    return container;
  }
  _updateContainers() {
    const canvasWidth = this.deck.width;
    const canvasHeight = this.deck.height;
    for (const id in this.containers) {
      const viewport = this.lastViewports[id] || null;
      const visible = id === ROOT_CONTAINER_ID || viewport;
      const container = this.containers[id];
      if (visible) {
        container.style.display = "block";
        container.style.left = `${viewport ? viewport.x : 0}px`;
        container.style.top = `${viewport ? viewport.y : 0}px`;
        container.style.width = `${viewport ? viewport.width : canvasWidth}px`;
        container.style.height = `${viewport ? viewport.height : canvasHeight}px`;
      } else {
        container.style.display = "none";
      }
    }
  }
  onRedraw({ viewports, layers }) {
    const viewportsById = viewports.reduce((acc, v) => {
      acc[v.id] = v;
      return acc;
    }, {});
    const { lastViewports } = this;
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (viewId) {
        const viewport = viewportsById[viewId];
        if (viewport) {
          if (widget.onViewportChange && !viewport.equals(lastViewports[viewId])) {
            widget.onViewportChange(viewport);
          }
          widget.onRedraw?.({ viewports: [viewport], layers });
        }
      } else {
        if (widget.onViewportChange) {
          for (const viewport of viewports) {
            if (!viewport.equals(lastViewports[viewport.id])) {
              widget.onViewportChange(viewport);
            }
          }
        }
        widget.onRedraw?.({ viewports, layers });
      }
    }
    this.lastViewports = viewportsById;
    this._updateContainers();
  }
  onHover(info, event) {
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (!viewId || viewId === info.viewport?.id) {
        widget.onHover?.(info, event);
      }
    }
  }
  onEvent(info, event) {
    const eventOptions = EVENTS[event.type];
    if (!eventOptions) {
      return;
    }
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (!viewId || viewId === info.viewport?.id) {
        widget[eventOptions.handler]?.(info, event);
      }
    }
  }
}
const defaultStyle = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class Tooltip {
  constructor() {
    this.id = "default-tooltip";
    this.placement = "fill";
    this.props = {};
    this.isVisible = false;
  }
  onAdd({ deck }) {
    const el = document.createElement("div");
    el.className = "deck-tooltip";
    Object.assign(el.style, defaultStyle);
    this.deck = deck;
    this.element = el;
    return el;
  }
  onRemove() {
    this.deck = void 0;
    this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(viewport) {
    if (this.isVisible && viewport.id === this.lastViewport?.id && viewport !== this.lastViewport) {
      this.setTooltip(null);
    }
  }
  onHover(info) {
    const { deck } = this;
    const getTooltip = deck && deck.props.getTooltip;
    if (!getTooltip) {
      return;
    }
    const displayInfo = getTooltip(info);
    this.lastViewport = info.viewport;
    this.setTooltip(displayInfo, info.x, info.y);
  }
  setTooltip(displayInfo, x2, y2) {
    const el = this.element;
    if (!el) {
      return;
    }
    if (typeof displayInfo === "string") {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = "none";
      return;
    } else {
      if (displayInfo.text) {
        el.innerText = displayInfo.text;
      }
      if (displayInfo.html) {
        el.innerHTML = displayInfo.html;
      }
      if (displayInfo.className) {
        el.className = displayInfo.className;
      }
    }
    this.isVisible = true;
    el.style.display = "block";
    el.style.transform = `translate(${x2}px, ${y2}px)`;
    if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
      Object.assign(el.style, displayInfo.style);
    }
  }
}
var GLEnum;
(function(GLEnum2) {
  GLEnum2[GLEnum2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
  GLEnum2[GLEnum2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
  GLEnum2[GLEnum2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
  GLEnum2[GLEnum2["POINTS"] = 0] = "POINTS";
  GLEnum2[GLEnum2["LINES"] = 1] = "LINES";
  GLEnum2[GLEnum2["LINE_LOOP"] = 2] = "LINE_LOOP";
  GLEnum2[GLEnum2["LINE_STRIP"] = 3] = "LINE_STRIP";
  GLEnum2[GLEnum2["TRIANGLES"] = 4] = "TRIANGLES";
  GLEnum2[GLEnum2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  GLEnum2[GLEnum2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  GLEnum2[GLEnum2["ZERO"] = 0] = "ZERO";
  GLEnum2[GLEnum2["ONE"] = 1] = "ONE";
  GLEnum2[GLEnum2["SRC_COLOR"] = 768] = "SRC_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  GLEnum2[GLEnum2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  GLEnum2[GLEnum2["DST_ALPHA"] = 772] = "DST_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  GLEnum2[GLEnum2["DST_COLOR"] = 774] = "DST_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  GLEnum2[GLEnum2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  GLEnum2[GLEnum2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  GLEnum2[GLEnum2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  GLEnum2[GLEnum2["FUNC_ADD"] = 32774] = "FUNC_ADD";
  GLEnum2[GLEnum2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
  GLEnum2[GLEnum2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
  GLEnum2[GLEnum2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
  GLEnum2[GLEnum2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
  GLEnum2[GLEnum2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
  GLEnum2[GLEnum2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
  GLEnum2[GLEnum2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
  GLEnum2[GLEnum2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
  GLEnum2[GLEnum2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
  GLEnum2[GLEnum2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
  GLEnum2[GLEnum2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
  GLEnum2[GLEnum2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
  GLEnum2[GLEnum2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
  GLEnum2[GLEnum2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
  GLEnum2[GLEnum2["FRONT_FACE"] = 2886] = "FRONT_FACE";
  GLEnum2[GLEnum2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
  GLEnum2[GLEnum2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
  GLEnum2[GLEnum2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
  GLEnum2[GLEnum2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
  GLEnum2[GLEnum2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
  GLEnum2[GLEnum2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
  GLEnum2[GLEnum2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
  GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
  GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
  GLEnum2[GLEnum2["STENCIL_REF"] = 2967] = "STENCIL_REF";
  GLEnum2[GLEnum2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
  GLEnum2[GLEnum2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
  GLEnum2[GLEnum2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
  GLEnum2[GLEnum2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
  GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
  GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
  GLEnum2[GLEnum2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
  GLEnum2[GLEnum2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
  GLEnum2[GLEnum2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
  GLEnum2[GLEnum2["VIEWPORT"] = 2978] = "VIEWPORT";
  GLEnum2[GLEnum2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
  GLEnum2[GLEnum2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
  GLEnum2[GLEnum2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
  GLEnum2[GLEnum2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
  GLEnum2[GLEnum2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
  GLEnum2[GLEnum2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
  GLEnum2[GLEnum2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
  GLEnum2[GLEnum2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
  GLEnum2[GLEnum2["RED_BITS"] = 3410] = "RED_BITS";
  GLEnum2[GLEnum2["GREEN_BITS"] = 3411] = "GREEN_BITS";
  GLEnum2[GLEnum2["BLUE_BITS"] = 3412] = "BLUE_BITS";
  GLEnum2[GLEnum2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
  GLEnum2[GLEnum2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
  GLEnum2[GLEnum2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
  GLEnum2[GLEnum2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
  GLEnum2[GLEnum2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
  GLEnum2[GLEnum2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
  GLEnum2[GLEnum2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
  GLEnum2[GLEnum2["SAMPLES"] = 32937] = "SAMPLES";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
  GLEnum2[GLEnum2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
  GLEnum2[GLEnum2["VENDOR"] = 7936] = "VENDOR";
  GLEnum2[GLEnum2["RENDERER"] = 7937] = "RENDERER";
  GLEnum2[GLEnum2["VERSION"] = 7938] = "VERSION";
  GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
  GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
  GLEnum2[GLEnum2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
  GLEnum2[GLEnum2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
  GLEnum2[GLEnum2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
  GLEnum2[GLEnum2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
  GLEnum2[GLEnum2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  GLEnum2[GLEnum2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
  GLEnum2[GLEnum2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
  GLEnum2[GLEnum2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["CULL_FACE"] = 2884] = "CULL_FACE";
  GLEnum2[GLEnum2["FRONT"] = 1028] = "FRONT";
  GLEnum2[GLEnum2["BACK"] = 1029] = "BACK";
  GLEnum2[GLEnum2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
  GLEnum2[GLEnum2["BLEND"] = 3042] = "BLEND";
  GLEnum2[GLEnum2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  GLEnum2[GLEnum2["DITHER"] = 3024] = "DITHER";
  GLEnum2[GLEnum2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  GLEnum2[GLEnum2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
  GLEnum2[GLEnum2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
  GLEnum2[GLEnum2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
  GLEnum2[GLEnum2["NO_ERROR"] = 0] = "NO_ERROR";
  GLEnum2[GLEnum2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
  GLEnum2[GLEnum2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
  GLEnum2[GLEnum2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
  GLEnum2[GLEnum2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
  GLEnum2[GLEnum2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
  GLEnum2[GLEnum2["CW"] = 2304] = "CW";
  GLEnum2[GLEnum2["CCW"] = 2305] = "CCW";
  GLEnum2[GLEnum2["DONT_CARE"] = 4352] = "DONT_CARE";
  GLEnum2[GLEnum2["FASTEST"] = 4353] = "FASTEST";
  GLEnum2[GLEnum2["NICEST"] = 4354] = "NICEST";
  GLEnum2[GLEnum2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
  GLEnum2[GLEnum2["BYTE"] = 5120] = "BYTE";
  GLEnum2[GLEnum2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  GLEnum2[GLEnum2["SHORT"] = 5122] = "SHORT";
  GLEnum2[GLEnum2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  GLEnum2[GLEnum2["INT"] = 5124] = "INT";
  GLEnum2[GLEnum2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  GLEnum2[GLEnum2["FLOAT"] = 5126] = "FLOAT";
  GLEnum2[GLEnum2["DOUBLE"] = 5130] = "DOUBLE";
  GLEnum2[GLEnum2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  GLEnum2[GLEnum2["ALPHA"] = 6406] = "ALPHA";
  GLEnum2[GLEnum2["RGB"] = 6407] = "RGB";
  GLEnum2[GLEnum2["RGBA"] = 6408] = "RGBA";
  GLEnum2[GLEnum2["LUMINANCE"] = 6409] = "LUMINANCE";
  GLEnum2[GLEnum2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  GLEnum2[GLEnum2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
  GLEnum2[GLEnum2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
  GLEnum2[GLEnum2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
  GLEnum2[GLEnum2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
  GLEnum2[GLEnum2["LINK_STATUS"] = 35714] = "LINK_STATUS";
  GLEnum2[GLEnum2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
  GLEnum2[GLEnum2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
  GLEnum2[GLEnum2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
  GLEnum2[GLEnum2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
  GLEnum2[GLEnum2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
  GLEnum2[GLEnum2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
  GLEnum2[GLEnum2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
  GLEnum2[GLEnum2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
  GLEnum2[GLEnum2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
  GLEnum2[GLEnum2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
  GLEnum2[GLEnum2["NEVER"] = 512] = "NEVER";
  GLEnum2[GLEnum2["LESS"] = 513] = "LESS";
  GLEnum2[GLEnum2["EQUAL"] = 514] = "EQUAL";
  GLEnum2[GLEnum2["LEQUAL"] = 515] = "LEQUAL";
  GLEnum2[GLEnum2["GREATER"] = 516] = "GREATER";
  GLEnum2[GLEnum2["NOTEQUAL"] = 517] = "NOTEQUAL";
  GLEnum2[GLEnum2["GEQUAL"] = 518] = "GEQUAL";
  GLEnum2[GLEnum2["ALWAYS"] = 519] = "ALWAYS";
  GLEnum2[GLEnum2["KEEP"] = 7680] = "KEEP";
  GLEnum2[GLEnum2["REPLACE"] = 7681] = "REPLACE";
  GLEnum2[GLEnum2["INCR"] = 7682] = "INCR";
  GLEnum2[GLEnum2["DECR"] = 7683] = "DECR";
  GLEnum2[GLEnum2["INVERT"] = 5386] = "INVERT";
  GLEnum2[GLEnum2["INCR_WRAP"] = 34055] = "INCR_WRAP";
  GLEnum2[GLEnum2["DECR_WRAP"] = 34056] = "DECR_WRAP";
  GLEnum2[GLEnum2["NEAREST"] = 9728] = "NEAREST";
  GLEnum2[GLEnum2["LINEAR"] = 9729] = "LINEAR";
  GLEnum2[GLEnum2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  GLEnum2[GLEnum2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  GLEnum2[GLEnum2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  GLEnum2[GLEnum2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  GLEnum2[GLEnum2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
  GLEnum2[GLEnum2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
  GLEnum2[GLEnum2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
  GLEnum2[GLEnum2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
  GLEnum2[GLEnum2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  GLEnum2[GLEnum2["TEXTURE"] = 5890] = "TEXTURE";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  GLEnum2[GLEnum2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  GLEnum2[GLEnum2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
  GLEnum2[GLEnum2["TEXTURE0"] = 33984] = "TEXTURE0";
  GLEnum2[GLEnum2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
  GLEnum2[GLEnum2["REPEAT"] = 10497] = "REPEAT";
  GLEnum2[GLEnum2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  GLEnum2[GLEnum2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  GLEnum2[GLEnum2["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
  GLEnum2[GLEnum2["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
  GLEnum2[GLEnum2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  GLEnum2[GLEnum2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  GLEnum2[GLEnum2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  GLEnum2[GLEnum2["INT_VEC2"] = 35667] = "INT_VEC2";
  GLEnum2[GLEnum2["INT_VEC3"] = 35668] = "INT_VEC3";
  GLEnum2[GLEnum2["INT_VEC4"] = 35669] = "INT_VEC4";
  GLEnum2[GLEnum2["BOOL"] = 35670] = "BOOL";
  GLEnum2[GLEnum2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  GLEnum2[GLEnum2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  GLEnum2[GLEnum2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  GLEnum2[GLEnum2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  GLEnum2[GLEnum2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  GLEnum2[GLEnum2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  GLEnum2[GLEnum2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  GLEnum2[GLEnum2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  GLEnum2[GLEnum2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
  GLEnum2[GLEnum2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
  GLEnum2[GLEnum2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
  GLEnum2[GLEnum2["LOW_INT"] = 36339] = "LOW_INT";
  GLEnum2[GLEnum2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
  GLEnum2[GLEnum2["HIGH_INT"] = 36341] = "HIGH_INT";
  GLEnum2[GLEnum2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
  GLEnum2[GLEnum2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
  GLEnum2[GLEnum2["RGBA4"] = 32854] = "RGBA4";
  GLEnum2[GLEnum2["RGB5_A1"] = 32855] = "RGB5_A1";
  GLEnum2[GLEnum2["RGB565"] = 36194] = "RGB565";
  GLEnum2[GLEnum2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
  GLEnum2[GLEnum2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
  GLEnum2[GLEnum2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
  GLEnum2[GLEnum2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  GLEnum2[GLEnum2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
  GLEnum2[GLEnum2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
  GLEnum2[GLEnum2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
  GLEnum2[GLEnum2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
  GLEnum2[GLEnum2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
  GLEnum2[GLEnum2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
  GLEnum2[GLEnum2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
  GLEnum2[GLEnum2["NONE"] = 0] = "NONE";
  GLEnum2[GLEnum2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
  GLEnum2[GLEnum2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
  GLEnum2[GLEnum2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
  GLEnum2[GLEnum2["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
  GLEnum2[GLEnum2["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
  GLEnum2[GLEnum2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
  GLEnum2[GLEnum2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
  GLEnum2[GLEnum2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  GLEnum2[GLEnum2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
  GLEnum2[GLEnum2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
  GLEnum2[GLEnum2["READ_BUFFER"] = 3074] = "READ_BUFFER";
  GLEnum2[GLEnum2["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
  GLEnum2[GLEnum2["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
  GLEnum2[GLEnum2["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
  GLEnum2[GLEnum2["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
  GLEnum2[GLEnum2["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
  GLEnum2[GLEnum2["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
  GLEnum2[GLEnum2["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
  GLEnum2[GLEnum2["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
  GLEnum2[GLEnum2["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
  GLEnum2[GLEnum2["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
  GLEnum2[GLEnum2["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
  GLEnum2[GLEnum2["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
  GLEnum2[GLEnum2["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
  GLEnum2[GLEnum2["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
  GLEnum2[GLEnum2["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
  GLEnum2[GLEnum2["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
  GLEnum2[GLEnum2["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
  GLEnum2[GLEnum2["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
  GLEnum2[GLEnum2["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
  GLEnum2[GLEnum2["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
  GLEnum2[GLEnum2["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
  GLEnum2[GLEnum2["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
  GLEnum2[GLEnum2["RED"] = 6403] = "RED";
  GLEnum2[GLEnum2["RGB8"] = 32849] = "RGB8";
  GLEnum2[GLEnum2["RGBA8"] = 32856] = "RGBA8";
  GLEnum2[GLEnum2["RGB10_A2"] = 32857] = "RGB10_A2";
  GLEnum2[GLEnum2["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
  GLEnum2[GLEnum2["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
  GLEnum2[GLEnum2["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
  GLEnum2[GLEnum2["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
  GLEnum2[GLEnum2["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
  GLEnum2[GLEnum2["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
  GLEnum2[GLEnum2["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
  GLEnum2[GLEnum2["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
  GLEnum2[GLEnum2["SRGB"] = 35904] = "SRGB";
  GLEnum2[GLEnum2["SRGB8"] = 35905] = "SRGB8";
  GLEnum2[GLEnum2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
  GLEnum2[GLEnum2["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
  GLEnum2[GLEnum2["RGBA32F"] = 34836] = "RGBA32F";
  GLEnum2[GLEnum2["RGB32F"] = 34837] = "RGB32F";
  GLEnum2[GLEnum2["RGBA16F"] = 34842] = "RGBA16F";
  GLEnum2[GLEnum2["RGB16F"] = 34843] = "RGB16F";
  GLEnum2[GLEnum2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  GLEnum2[GLEnum2["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
  GLEnum2[GLEnum2["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
  GLEnum2[GLEnum2["RGB9_E5"] = 35901] = "RGB9_E5";
  GLEnum2[GLEnum2["RGBA32UI"] = 36208] = "RGBA32UI";
  GLEnum2[GLEnum2["RGB32UI"] = 36209] = "RGB32UI";
  GLEnum2[GLEnum2["RGBA16UI"] = 36214] = "RGBA16UI";
  GLEnum2[GLEnum2["RGB16UI"] = 36215] = "RGB16UI";
  GLEnum2[GLEnum2["RGBA8UI"] = 36220] = "RGBA8UI";
  GLEnum2[GLEnum2["RGB8UI"] = 36221] = "RGB8UI";
  GLEnum2[GLEnum2["RGBA32I"] = 36226] = "RGBA32I";
  GLEnum2[GLEnum2["RGB32I"] = 36227] = "RGB32I";
  GLEnum2[GLEnum2["RGBA16I"] = 36232] = "RGBA16I";
  GLEnum2[GLEnum2["RGB16I"] = 36233] = "RGB16I";
  GLEnum2[GLEnum2["RGBA8I"] = 36238] = "RGBA8I";
  GLEnum2[GLEnum2["RGB8I"] = 36239] = "RGB8I";
  GLEnum2[GLEnum2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  GLEnum2[GLEnum2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  GLEnum2[GLEnum2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  GLEnum2[GLEnum2["R8"] = 33321] = "R8";
  GLEnum2[GLEnum2["RG8"] = 33323] = "RG8";
  GLEnum2[GLEnum2["R16F"] = 33325] = "R16F";
  GLEnum2[GLEnum2["R32F"] = 33326] = "R32F";
  GLEnum2[GLEnum2["RG16F"] = 33327] = "RG16F";
  GLEnum2[GLEnum2["RG32F"] = 33328] = "RG32F";
  GLEnum2[GLEnum2["R8I"] = 33329] = "R8I";
  GLEnum2[GLEnum2["R8UI"] = 33330] = "R8UI";
  GLEnum2[GLEnum2["R16I"] = 33331] = "R16I";
  GLEnum2[GLEnum2["R16UI"] = 33332] = "R16UI";
  GLEnum2[GLEnum2["R32I"] = 33333] = "R32I";
  GLEnum2[GLEnum2["R32UI"] = 33334] = "R32UI";
  GLEnum2[GLEnum2["RG8I"] = 33335] = "RG8I";
  GLEnum2[GLEnum2["RG8UI"] = 33336] = "RG8UI";
  GLEnum2[GLEnum2["RG16I"] = 33337] = "RG16I";
  GLEnum2[GLEnum2["RG16UI"] = 33338] = "RG16UI";
  GLEnum2[GLEnum2["RG32I"] = 33339] = "RG32I";
  GLEnum2[GLEnum2["RG32UI"] = 33340] = "RG32UI";
  GLEnum2[GLEnum2["R8_SNORM"] = 36756] = "R8_SNORM";
  GLEnum2[GLEnum2["RG8_SNORM"] = 36757] = "RG8_SNORM";
  GLEnum2[GLEnum2["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
  GLEnum2[GLEnum2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
  GLEnum2[GLEnum2["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
  GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
  GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
  GLEnum2[GLEnum2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  GLEnum2[GLEnum2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  GLEnum2[GLEnum2["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
  GLEnum2[GLEnum2["RG"] = 33319] = "RG";
  GLEnum2[GLEnum2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  GLEnum2[GLEnum2["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
  GLEnum2[GLEnum2["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
  GLEnum2[GLEnum2["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
  GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
  GLEnum2[GLEnum2["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
  GLEnum2[GLEnum2["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
  GLEnum2[GLEnum2["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
  GLEnum2[GLEnum2["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
  GLEnum2[GLEnum2["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
  GLEnum2[GLEnum2["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
  GLEnum2[GLEnum2["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
  GLEnum2[GLEnum2["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
  GLEnum2[GLEnum2["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
  GLEnum2[GLEnum2["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
  GLEnum2[GLEnum2["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
  GLEnum2[GLEnum2["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
  GLEnum2[GLEnum2["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
  GLEnum2[GLEnum2["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
  GLEnum2[GLEnum2["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
  GLEnum2[GLEnum2["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
  GLEnum2[GLEnum2["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
  GLEnum2[GLEnum2["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
  GLEnum2[GLEnum2["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
  GLEnum2[GLEnum2["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
  GLEnum2[GLEnum2["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
  GLEnum2[GLEnum2["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
  GLEnum2[GLEnum2["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
  GLEnum2[GLEnum2["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
  GLEnum2[GLEnum2["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
  GLEnum2[GLEnum2["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
  GLEnum2[GLEnum2["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
  GLEnum2[GLEnum2["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
  GLEnum2[GLEnum2["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
  GLEnum2[GLEnum2["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
  GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
  GLEnum2[GLEnum2["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
  GLEnum2[GLEnum2["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
  GLEnum2[GLEnum2["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
  GLEnum2[GLEnum2["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
  GLEnum2[GLEnum2["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
  GLEnum2[GLEnum2["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
  GLEnum2[GLEnum2["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
  GLEnum2[GLEnum2["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
  GLEnum2[GLEnum2["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
  GLEnum2[GLEnum2["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
  GLEnum2[GLEnum2["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
  GLEnum2[GLEnum2["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
  GLEnum2[GLEnum2["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
  GLEnum2[GLEnum2["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
  GLEnum2[GLEnum2["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
  GLEnum2[GLEnum2["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
  GLEnum2[GLEnum2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
  GLEnum2[GLEnum2["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
  GLEnum2[GLEnum2["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
  GLEnum2[GLEnum2["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
  GLEnum2[GLEnum2["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
  GLEnum2[GLEnum2["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
  GLEnum2[GLEnum2["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
  GLEnum2[GLEnum2["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
  GLEnum2[GLEnum2["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
  GLEnum2[GLEnum2["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
  GLEnum2[GLEnum2["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
  GLEnum2[GLEnum2["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
  GLEnum2[GLEnum2["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
  GLEnum2[GLEnum2["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
  GLEnum2[GLEnum2["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
  GLEnum2[GLEnum2["UNSIGNALED"] = 37144] = "UNSIGNALED";
  GLEnum2[GLEnum2["SIGNALED"] = 37145] = "SIGNALED";
  GLEnum2[GLEnum2["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
  GLEnum2[GLEnum2["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
  GLEnum2[GLEnum2["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
  GLEnum2[GLEnum2["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
  GLEnum2[GLEnum2["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
  GLEnum2[GLEnum2["COLOR"] = 6144] = "COLOR";
  GLEnum2[GLEnum2["DEPTH"] = 6145] = "DEPTH";
  GLEnum2[GLEnum2["STENCIL"] = 6146] = "STENCIL";
  GLEnum2[GLEnum2["MIN"] = 32775] = "MIN";
  GLEnum2[GLEnum2["MAX"] = 32776] = "MAX";
  GLEnum2[GLEnum2["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
  GLEnum2[GLEnum2["STREAM_READ"] = 35041] = "STREAM_READ";
  GLEnum2[GLEnum2["STREAM_COPY"] = 35042] = "STREAM_COPY";
  GLEnum2[GLEnum2["STATIC_READ"] = 35045] = "STATIC_READ";
  GLEnum2[GLEnum2["STATIC_COPY"] = 35046] = "STATIC_COPY";
  GLEnum2[GLEnum2["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
  GLEnum2[GLEnum2["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
  GLEnum2[GLEnum2["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
  GLEnum2[GLEnum2["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
  GLEnum2[GLEnum2["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
  GLEnum2[GLEnum2["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
  GLEnum2[GLEnum2["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
  GLEnum2[GLEnum2["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
  GLEnum2[GLEnum2["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
  GLEnum2[GLEnum2["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
  GLEnum2[GLEnum2["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
  GLEnum2[GLEnum2["R16_EXT"] = 33322] = "R16_EXT";
  GLEnum2[GLEnum2["RG16_EXT"] = 33324] = "RG16_EXT";
  GLEnum2[GLEnum2["RGB16_EXT"] = 32852] = "RGB16_EXT";
  GLEnum2[GLEnum2["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
  GLEnum2[GLEnum2["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
  GLEnum2[GLEnum2["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
  GLEnum2[GLEnum2["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
  GLEnum2[GLEnum2["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
  GLEnum2[GLEnum2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
  GLEnum2[GLEnum2["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
  GLEnum2[GLEnum2["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
  GLEnum2[GLEnum2["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
  GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
  GLEnum2[GLEnum2["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
  GLEnum2[GLEnum2["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
  GLEnum2[GLEnum2["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
  GLEnum2[GLEnum2["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
  GLEnum2[GLEnum2["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
  GLEnum2[GLEnum2["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
  GLEnum2[GLEnum2["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
  GLEnum2[GLEnum2["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
  GLEnum2[GLEnum2["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
  GLEnum2[GLEnum2["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
  GLEnum2[GLEnum2["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
  GLEnum2[GLEnum2["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
  GLEnum2[GLEnum2["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
  GLEnum2[GLEnum2["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
  GLEnum2[GLEnum2["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
  GLEnum2[GLEnum2["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
  GLEnum2[GLEnum2["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
  GLEnum2[GLEnum2["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
  GLEnum2[GLEnum2["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
  GLEnum2[GLEnum2["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
  GLEnum2[GLEnum2["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
  GLEnum2[GLEnum2["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
  GLEnum2[GLEnum2["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
  GLEnum2[GLEnum2["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
  GLEnum2[GLEnum2["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
  GLEnum2[GLEnum2["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(GLEnum || (GLEnum = {}));
const GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  // TBD
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  // TBD
  [2930]: true,
  [3024]: true,
  [35725]: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [36006]: null,
  [36007]: null,
  [34229]: null,
  [34964]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32926]: false,
  [32928]: false,
  [32938]: 1,
  [32939]: false,
  [3089]: false,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 4294967295,
  [36005]: 4294967295,
  [2962]: 519,
  [2967]: 0,
  [2963]: 4294967295,
  [34816]: 519,
  [36003]: 0,
  [36004]: 4294967295,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  [2978]: [0, 0, 1024, 1024],
  [36389]: null,
  [36662]: null,
  [36663]: null,
  [35053]: null,
  [35055]: null,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};
const enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
const hint = (gl, value, key) => gl.hint(key, value);
const pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
const bindFramebuffer = (gl, value, key) => {
  const target = key === 36006 ? 36009 : 36008;
  return gl.bindFramebuffer(target, value);
};
const bindBuffer = (gl, value, key) => {
  const bindingMap = {
    [34964]: 34962,
    [36662]: 36662,
    [36663]: 36663,
    [35053]: 35051,
    [35055]: 35052
  };
  const glTarget = bindingMap[key];
  gl.bindBuffer(glTarget, value);
};
function isArray$1(array2) {
  return Array.isArray(array2) || ArrayBuffer.isView(array2) && !(array2 instanceof DataView);
}
const GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: "blendEquation",
  [34877]: "blendEquation",
  [32969]: "blendFunc",
  [32968]: "blendFunc",
  [32971]: "blendFunc",
  [32970]: "blendFunc",
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [35725]: (gl, value) => gl.useProgram(value),
  [36007]: (gl, value) => gl.bindRenderbuffer(36161, value),
  [36389]: (gl, value) => gl.bindTransformFeedback?.(36386, value),
  [34229]: (gl, value) => gl.bindVertexArray(value),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [36006]: bindFramebuffer,
  [36010]: bindFramebuffer,
  // Buffers
  [34964]: bindBuffer,
  [36662]: bindBuffer,
  [36663]: bindBuffer,
  [35053]: bindBuffer,
  [35055]: bindBuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: "polygonOffset",
  [10752]: "polygonOffset",
  [35977]: enable,
  [32926]: enable,
  [32928]: enable,
  [32938]: "sampleCoverage",
  [32939]: "sampleCoverage",
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: "stencilFuncFront",
  [2967]: "stencilFuncFront",
  [2963]: "stencilFuncFront",
  [34816]: "stencilFuncBack",
  [36003]: "stencilFuncBack",
  [36004]: "stencilFuncBack",
  [2964]: "stencilOpFront",
  [2965]: "stencilOpFront",
  [2966]: "stencilOpFront",
  [34817]: "stencilOpBack",
  [34818]: "stencilOpBack",
  [34819]: "stencilOpBack",
  [2978]: (gl, value) => gl.viewport(...value),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  [34383]: enable,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  [10754]: enable,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  [12288]: enable,
  [12289]: enable,
  [12290]: enable,
  [12291]: enable,
  [12292]: enable,
  [12293]: enable,
  [12294]: enable,
  [12295]: enable,
  // PIXEL PACK/UNPACK MODES
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  // Function-style setters
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    const separateModes = typeof args === "number" ? [args, args] : args;
    gl.blendEquationSeparate(...separateModes);
  },
  blendFunc: (gl, args) => {
    const separateFuncs = args?.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...separateFuncs);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray$1(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray$1(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray$1(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
function getValue(glEnum, values, cache2) {
  return values[glEnum] !== void 0 ? values[glEnum] : cache2[glEnum];
}
const GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache2) => gl.blendEquationSeparate(getValue(32777, values, cache2), getValue(34877, values, cache2)),
  blendFunc: (gl, values, cache2) => gl.blendFuncSeparate(getValue(32969, values, cache2), getValue(32968, values, cache2), getValue(32971, values, cache2), getValue(32970, values, cache2)),
  polygonOffset: (gl, values, cache2) => gl.polygonOffset(getValue(32824, values, cache2), getValue(10752, values, cache2)),
  sampleCoverage: (gl, values, cache2) => gl.sampleCoverage(getValue(32938, values, cache2), getValue(32939, values, cache2)),
  stencilFuncFront: (gl, values, cache2) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache2), getValue(2967, values, cache2), getValue(2963, values, cache2)),
  stencilFuncBack: (gl, values, cache2) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache2), getValue(36003, values, cache2), getValue(36004, values, cache2)),
  stencilOpFront: (gl, values, cache2) => gl.stencilOpSeparate(1028, getValue(2964, values, cache2), getValue(2965, values, cache2), getValue(2966, values, cache2)),
  stencilOpBack: (gl, values, cache2) => gl.stencilOpSeparate(1029, getValue(34817, values, cache2), getValue(34818, values, cache2), getValue(34819, values, cache2))
};
const GL_HOOKED_SETTERS = {
  // GENERIC SETTERS
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, hint2) => update({
    [pname]: hint2
  }),
  // SPECIFIC SETTERS
  useProgram: (update, value) => update({
    [35725]: value
  }),
  bindRenderbuffer: (update, target, value) => update({
    [36007]: value
  }),
  bindTransformFeedback: (update, target, value) => update({
    [36389]: value
  }),
  bindVertexArray: (update, value) => update({
    [34229]: value
  }),
  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });
      case 36009:
        return update({ [36006]: framebuffer });
      case 36008:
        return update({ [36010]: framebuffer });
      default:
        return null;
    }
  },
  bindBuffer: (update, target, buffer) => {
    const pname = {
      [34962]: [34964],
      [36662]: [36662],
      [36663]: [36663],
      [35051]: [35053],
      [35052]: [35055]
    }[target];
    if (pname) {
      return update({ [pname]: buffer });
    }
    return { valueChanged: true };
  },
  blendColor: (update, r, g, b, a2) => update({
    [32773]: new Float32Array([r, g, b, a2])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a2) => update({
    [3106]: new Float32Array([r, g, b, a2])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s2) => update({
    [2961]: s2
  }),
  colorMask: (update, r, g, b, a2) => update({
    [3107]: [r, g, b, a2]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert2) => update({
    [32938]: value,
    [32939]: invert2
  }),
  scissor: (update, x2, y2, width, height) => update({
    [3088]: new Int32Array([x2, y2, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x2, y2, width, height) => update({
    [2978]: [x2, y2, width, height]
  })
};
const isEnabled$1 = (gl, key) => gl.isEnabled(key);
const GL_PARAMETER_GETTERS = {
  [3042]: isEnabled$1,
  [2884]: isEnabled$1,
  [2929]: isEnabled$1,
  [3024]: isEnabled$1,
  [32823]: isEnabled$1,
  [32926]: isEnabled$1,
  [32928]: isEnabled$1,
  [3089]: isEnabled$1,
  [2960]: isEnabled$1,
  [35977]: isEnabled$1
};
const NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);
function setGLParameters(gl, parameters) {
  if (isObjectEmpty$1(parameters)) {
    return;
  }
  const compositeSetters = {};
  for (const key in parameters) {
    const glConstant = Number(key);
    const setter = GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === "string") {
        compositeSetters[setter] = true;
      } else {
        setter(gl, parameters[key], glConstant);
      }
    }
  }
  const cache2 = gl.state && gl.state.cache;
  if (cache2) {
    for (const key in compositeSetters) {
      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, parameters, cache2);
    }
  }
}
function getGLParameters(gl, parameters = GL_PARAMETER_DEFAULTS) {
  if (typeof parameters === "number") {
    const key = parameters;
    const getter = GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetGLParameters(gl) {
  setGLParameters(gl, GL_PARAMETER_DEFAULTS);
}
function isObjectEmpty$1(object2) {
  for (const key in object2) {
    return false;
  }
  return true;
}
function deepArrayEqual(x2, y2) {
  if (x2 === y2) {
    return true;
  }
  const isArrayX = Array.isArray(x2) || ArrayBuffer.isView(x2);
  const isArrayY = Array.isArray(y2) || ArrayBuffer.isView(y2);
  if (isArrayX && isArrayY && x2.length === y2.length) {
    for (let i = 0; i < x2.length; ++i) {
      if (x2[i] !== y2[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
class GLState {
  gl;
  program = null;
  stateStack = [];
  enable = true;
  cache;
  log;
  constructor(gl, {
    copyState = false,
    // Copy cache from params (slow) or initialize from WebGL defaults (fast)
    log: log3 = () => {
    }
    // Logging function, called when gl parameter change calls are actually issued
  } = {}) {
    this.gl = gl;
    this.cache = copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
    this.log = log3;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  push(values = {}) {
    this.stateStack.push({});
  }
  pop() {
    assert$3(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    setGLParameters(this.gl, oldValues);
    this.stateStack.pop();
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const key in values) {
      assert$3(key !== void 0);
      const value = values[key];
      const cached = this.cache[key];
      if (!deepArrayEqual(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return { valueChanged, oldValue };
  }
}
function getContextState(gl) {
  return gl.state;
}
function trackContextState(gl, options) {
  const { enable: enable2 = true, copyState } = options;
  assert$3(copyState !== void 0);
  if (!gl.state) {
    gl.state = new GLState(gl, { copyState });
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, "getParameter");
    installGetterOverride(gl, "isEnabled");
  }
  const glState = getContextState(gl);
  glState.enable = enable2;
  return gl;
}
function pushContextState(gl) {
  let glState = getContextState(gl);
  if (!glState) {
    trackContextState(gl, { copyState: false });
    glState = getContextState(gl);
  }
  glState.push();
}
function popContextState(gl) {
  const glState = getContextState(gl);
  assert$3(glState);
  glState.pop();
}
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get2(pname) {
    if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
      return originalGetterFunc(pname);
    }
    const glState = getContextState(gl);
    if (!(pname in glState.cache)) {
      glState.cache[pname] = originalGetterFunc(pname);
    }
    return glState.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      glState.cache[pname]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      originalGetterFunc(pname)
    );
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  if (!gl[functionName]) {
    return;
  }
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set(...params) {
    const glState = getContextState(gl);
    const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    const glState = getContextState(gl);
    if (glState.program !== handle) {
      originalUseProgram(handle);
      glState.program = handle;
    }
  };
}
const DEFAULT_CONTEXT_PROPS = {
  powerPreference: "high-performance",
  // After all, most apps are using WebGL for performance reasons
  // eslint-disable-next-line no-console
  onContextLost: () => console.error("WebGL context lost"),
  // eslint-disable-next-line no-console
  onContextRestored: () => console.info("WebGL context restored")
};
function createBrowserContext(canvas2, props) {
  props = { ...DEFAULT_CONTEXT_PROPS, ...props };
  let errorMessage = null;
  const onCreateError = (error) => errorMessage = error.statusMessage || errorMessage;
  canvas2.addEventListener("webglcontextcreationerror", onCreateError, false);
  let gl = null;
  gl ||= canvas2.getContext("webgl2", props);
  canvas2.removeEventListener("webglcontextcreationerror", onCreateError, false);
  if (!gl) {
    throw new Error(`Failed to create WebGL context: ${errorMessage || "Unknown error"}`);
  }
  if (props.onContextLost) {
    const { onContextLost } = props;
    canvas2.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
  }
  if (props.onContextRestored) {
    const { onContextRestored } = props;
    canvas2.addEventListener("webglcontextrestored", (event) => onContextRestored(event), false);
  }
  return gl;
}
function getWebGLExtension(gl, name2, extensions) {
  if (extensions[name2] === void 0) {
    extensions[name2] = gl.getExtension(name2) || null;
  }
  return extensions[name2];
}
function getDeviceInfo(gl, extensions) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  getWebGLExtension(gl, "WEBGL_debug_renderer_info", extensions);
  const ext = extensions.WEBGL_debug_renderer_info;
  const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
  const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
  const vendor = vendorUnmasked || vendorMasked;
  const renderer = rendererUnmasked || rendererMasked;
  const version2 = gl.getParameter(7938);
  const gpu = identifyGPUVendor(vendor, renderer);
  const gpuBackend = identifyGPUBackend(vendor, renderer);
  const gpuType = identifyGPUType(vendor, renderer);
  const shadingLanguage = "glsl";
  const shadingLanguageVersion = 300;
  return {
    type: "webgl",
    gpu,
    gpuType,
    gpuBackend,
    vendor,
    renderer,
    version: version2,
    shadingLanguage,
    shadingLanguageVersion
  };
}
function identifyGPUVendor(vendor, renderer) {
  if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
    return "nvidia";
  }
  if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
    return "intel";
  }
  if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
    return "apple";
  }
  if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
    return "amd";
  }
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "software";
  }
  return "unknown";
}
function identifyGPUBackend(vendor, renderer) {
  if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
    return "metal";
  }
  if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
    return "opengl";
  }
  return "unknown";
}
function identifyGPUType(vendor, renderer) {
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "cpu";
  }
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  switch (gpuVendor) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function getGLFromVertexType(dataType) {
  switch (dataType) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(dataType));
}
const texture_compression_bc = "texture-compression-bc";
const texture_compression_astc = "texture-compression-astc";
const texture_compression_etc2 = "texture-compression-etc2";
const texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
const texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
const texture_compression_atc_webgl = "texture-compression-atc-webgl";
const float32_renderable = "float32-renderable-webgl";
const float16_renderable = "float16-renderable-webgl";
const rgb9e5ufloat_renderable = "rgb9e5ufloat_renderable-webgl";
const snorm8_renderable = "snorm8-renderable-webgl";
const norm16_renderable = "norm16-renderable-webgl";
const snorm16_renderable = "snorm16-renderable-webgl";
const float32_filterable = "float32-filterable";
const float16_filterable = "float16-filterable-webgl";
const X_S3TC = "WEBGL_compressed_texture_s3tc";
const X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
const X_RGTC = "EXT_texture_compression_rgtc";
const X_BPTC = "EXT_texture_compression_bptc";
const X_ETC2 = "WEBGL_compressed_texture_etc";
const X_ASTC = "WEBGL_compressed_texture_astc";
const X_ETC1 = "WEBGL_compressed_texture_etc1";
const X_PVRTC = "WEBGL_compressed_texture_pvrtc";
const X_ATC = "WEBGL_compressed_texture_atc";
const EXT_texture_norm16 = "EXT_texture_norm16";
const EXT_render_snorm = "EXT_render_snorm";
const EXT_color_buffer_float = "EXT_color_buffer_float";
const TEXTURE_FEATURES = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [EXT_render_snorm],
  "norm16-renderable-webgl": [EXT_texture_norm16],
  "snorm16-renderable-webgl": [EXT_texture_norm16, EXT_render_snorm],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [X_RGTC],
  "texture-compression-bc7-webgl": [X_BPTC],
  "texture-compression-etc2": [X_ETC2],
  "texture-compression-astc": [X_ASTC],
  "texture-compression-etc1-webgl": [X_ETC1],
  "texture-compression-pvrtc-webgl": [X_PVRTC],
  "texture-compression-atc-webgl": [X_ATC]
};
function isTextureFeature(feature) {
  return feature in TEXTURE_FEATURES;
}
function checkTextureFeature(gl, feature, extensions) {
  const textureExtensions = TEXTURE_FEATURES[feature] || [];
  return textureExtensions.every((extension) => getWebGLExtension(gl, extension, extensions));
}
const TEXTURE_FORMATS = {
  // Unsized formats that leave the precision up to the driver. TODO - Fix bpp constants
  "rgb8unorm-unsized": {
    gl: 6407,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6407,
    types: [5121, 33635]
  },
  "rgba8unorm-unsized": {
    gl: 6408,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  // 'r8unorm-unsized': {gl: GL.LUMINANCE, b: 4, c: 2, bpp: 4},
  // 'rgb8unorm-srgb-unsized': {gl: GL.SRGB_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 'rgba8unorm-srgb-unsized': {gl: GL.SRGB_ALPHA_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 8-bit formats
  "r8unorm": { gl: 33321, b: 1, c: 1, rb: true },
  "r8snorm": { gl: 36756, b: 1, c: 1, render: snorm8_renderable },
  "r8uint": { gl: 33330, b: 1, c: 1, rb: true },
  "r8sint": { gl: 33329, b: 1, c: 1, rb: true },
  // 16-bit formats
  "rg8unorm": { gl: 33323, b: 2, c: 2, rb: true },
  "rg8snorm": { gl: 36757, b: 2, c: 2, render: snorm8_renderable },
  "rg8uint": { gl: 33336, b: 2, c: 2, rb: true },
  "rg8sint": { gl: 33335, b: 2, c: 2, rb: true },
  "r16uint": { gl: 33332, b: 2, c: 1, rb: true },
  "r16sint": { gl: 33331, b: 2, c: 1, rb: true },
  "r16float": { gl: 33325, b: 2, c: 1, render: float16_renderable, filter: "float16-filterable-webgl", rb: true },
  "r16unorm-webgl": { gl: 33322, b: 2, c: 1, f: norm16_renderable, rb: true },
  "r16snorm-webgl": { gl: 36760, b: 2, c: 1, f: snorm16_renderable },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, b: 2, c: 4, wgpu: false, rb: true },
  "rgb565unorm-webgl": { gl: 36194, b: 2, c: 4, wgpu: false, rb: true },
  "rgb5a1unorm-webgl": { gl: 32855, b: 2, c: 4, wgpu: false, rb: true },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849, b: 3, c: 3, wgpu: false },
  "rgb8snorm-webgl": { gl: 36758, b: 3, c: 3, wgpu: false },
  // 32-bit formats  
  "rgba8unorm": { gl: 32856, b: 4, c: 2, bpp: 4 },
  "rgba8unorm-srgb": { gl: 35907, b: 4, c: 4, bpp: 4 },
  "rgba8snorm": { gl: 36759, b: 4, c: 4, render: snorm8_renderable },
  "rgba8uint": { gl: 36220, b: 4, c: 4, bpp: 4 },
  "rgba8sint": { gl: 36238, b: 4, c: 4, bpp: 4 },
  // reverse colors, webgpu only
  "bgra8unorm": { b: 4, c: 4 },
  "bgra8unorm-srgb": { b: 4, c: 4 },
  "rg16uint": { gl: 33338, b: 4, c: 1, bpp: 4 },
  "rg16sint": { gl: 33337, b: 4, c: 2, bpp: 4 },
  // When using a WebGL 2 context and the EXT_color_buffer_float WebGL2 extension
  "rg16float": { gl: 33327, bpp: 4, b: 4, c: 2, render: float16_renderable, filter: float16_filterable, rb: true },
  "rg16unorm-webgl": { gl: 33324, b: 2, c: 2, render: norm16_renderable },
  "rg16snorm-webgl": { gl: 36761, b: 2, c: 2, render: snorm16_renderable },
  "r32uint": { gl: 33334, b: 4, c: 1, bpp: 4, rb: true },
  "r32sint": { gl: 33333, b: 4, c: 1, bpp: 4, rb: true },
  "r32float": { gl: 33326, bpp: 4, b: 4, c: 1, render: float32_renderable, filter: float32_filterable },
  // Packed 32-bit formats
  "rgb9e5ufloat": { gl: 35901, b: 4, c: 3, p: 1, render: rgb9e5ufloat_renderable },
  // , filter: true},
  "rg11b10ufloat": { gl: 35898, b: 4, c: 3, p: 1, render: float32_renderable, rb: true },
  "rgb10a2unorm": { gl: 32857, b: 4, c: 4, p: 1, rb: true },
  "rgb10a2uint-webgl": { b: 4, c: 4, gl: 36975, p: 1, wgpu: false, bpp: 4, rb: true },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852, b: 2, c: 3, f: norm16_renderable },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762, b: 2, c: 3, f: norm16_renderable },
  // rgb not renderable
  // 64-bit formats
  "rg32uint": { gl: 33340, b: 8, c: 2, rb: true },
  "rg32sint": { gl: 33339, b: 8, c: 2, rb: true },
  "rg32float": { gl: 33328, b: 8, c: 2, render: float32_renderable, filter: float32_filterable, rb: true },
  "rgba16uint": { gl: 36214, b: 8, c: 4, rb: true },
  "rgba16sint": { gl: 36232, b: 8, c: 4, rb: true },
  "rgba16float": { gl: 34842, b: 8, c: 4, render: float16_renderable, filter: float16_filterable },
  "rgba16unorm-webgl": { gl: 32859, b: 2, c: 4, render: norm16_renderable, rb: true },
  "rgba16snorm-webgl": { gl: 36763, b: 2, c: 4, render: snorm16_renderable },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: 34837,
    render: float32_renderable,
    filter: float32_filterable,
    gl2ext: EXT_color_buffer_float,
    dataFormat: 6407,
    types: [5126]
  },
  // 128-bit formats
  "rgba32uint": { gl: 36208, b: 16, c: 4, rb: true },
  "rgba32sint": { gl: 36226, b: 16, c: 4, rb: true },
  "rgba32float": { gl: 34836, b: 16, c: 4, render: float32_renderable, filter: float32_filterable, rb: true },
  // Depth and stencil formats
  "stencil8": { gl: 36168, b: 1, c: 1, attachment: 36128, rb: true },
  // 8 stencil bits
  "depth16unorm": {
    gl: 33189,
    b: 2,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5123],
    rb: true
  },
  // 16 depth bits
  "depth24plus": {
    gl: 33190,
    b: 3,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5125]
  },
  "depth32float": {
    gl: 36012,
    b: 4,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5126],
    rb: true
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    rb: true,
    depthTexture: true,
    dataFormat: 34041,
    types: [34042]
  },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [34042],
    rb: true
  },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": {
    gl: 36013,
    b: 5,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [36269],
    rb: true
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: X_S3TC, f: texture_compression_bc },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc1-rgba-unorm": { gl: 33777, x: X_S3TC, f: texture_compression_bc },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc2-rgba-unorm": { gl: 33778, x: X_S3TC, f: texture_compression_bc },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc3-rgba-unorm": { gl: 33779, x: X_S3TC, f: texture_compression_bc },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc4-r-unorm": { gl: 36283, x: X_RGTC, f: texture_compression_bc },
  "bc4-r-snorm": { gl: 36284, x: X_RGTC, f: texture_compression_bc },
  "bc5-rg-unorm": { gl: 36285, x: X_RGTC, f: texture_compression_bc },
  "bc5-rg-snorm": { gl: 36286, x: X_RGTC, f: texture_compression_bc },
  "bc6h-rgb-ufloat": { gl: 36495, x: X_BPTC, f: texture_compression_bc },
  "bc6h-rgb-float": { gl: 36494, x: X_BPTC, f: texture_compression_bc },
  "bc7-rgba-unorm": { gl: 36492, x: X_BPTC, f: texture_compression_bc },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: X_BPTC, f: texture_compression_bc },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492, f: texture_compression_etc2 },
  "etc2-rgb8unorm-srgb": { gl: 37494, f: texture_compression_etc2 },
  "etc2-rgb8a1unorm": { gl: 37496, f: texture_compression_etc2 },
  "etc2-rgb8a1unorm-srgb": { gl: 37497, f: texture_compression_etc2 },
  "etc2-rgba8unorm": { gl: 37493, f: texture_compression_etc2 },
  "etc2-rgba8unorm-srgb": { gl: 37495, f: texture_compression_etc2 },
  "eac-r11unorm": { gl: 37488, f: texture_compression_etc2 },
  "eac-r11snorm": { gl: 37489, f: texture_compression_etc2 },
  "eac-rg11unorm": { gl: 37490, f: texture_compression_etc2 },
  "eac-rg11snorm": { gl: 37491, f: texture_compression_etc2 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808, f: texture_compression_astc },
  "astc-4x4-unorm-srgb": { gl: 37840, f: texture_compression_astc },
  "astc-5x4-unorm": { gl: 37809, f: texture_compression_astc },
  "astc-5x4-unorm-srgb": { gl: 37841, f: texture_compression_astc },
  "astc-5x5-unorm": { gl: 37810, f: texture_compression_astc },
  "astc-5x5-unorm-srgb": { gl: 37842, f: texture_compression_astc },
  "astc-6x5-unorm": { gl: 37811, f: texture_compression_astc },
  "astc-6x5-unorm-srgb": { gl: 37843, f: texture_compression_astc },
  "astc-6x6-unorm": { gl: 37812, f: texture_compression_astc },
  "astc-6x6-unorm-srgb": { gl: 37844, f: texture_compression_astc },
  "astc-8x5-unorm": { gl: 37813, f: texture_compression_astc },
  "astc-8x5-unorm-srgb": { gl: 37845, f: texture_compression_astc },
  "astc-8x6-unorm": { gl: 37814, f: texture_compression_astc },
  "astc-8x6-unorm-srgb": { gl: 37846, f: texture_compression_astc },
  "astc-8x8-unorm": { gl: 37815, f: texture_compression_astc },
  "astc-8x8-unorm-srgb": { gl: 37847, f: texture_compression_astc },
  "astc-10x5-unorm": { gl: 37819, f: texture_compression_astc },
  "astc-10x5-unorm-srgb": { gl: 37851, f: texture_compression_astc },
  "astc-10x6-unorm": { gl: 37817, f: texture_compression_astc },
  "astc-10x6-unorm-srgb": { gl: 37849, f: texture_compression_astc },
  "astc-10x8-unorm": { gl: 37818, f: texture_compression_astc },
  "astc-10x8-unorm-srgb": { gl: 37850, f: texture_compression_astc },
  "astc-10x10-unorm": { gl: 37819, f: texture_compression_astc },
  "astc-10x10-unorm-srgb": { gl: 37851, f: texture_compression_astc },
  "astc-12x10-unorm": { gl: 37820, f: texture_compression_astc },
  "astc-12x10-unorm-srgb": { gl: 37852, f: texture_compression_astc },
  "astc-12x12-unorm": { gl: 37821, f: texture_compression_astc },
  "astc-12x12-unorm-srgb": { gl: 37853, f: texture_compression_astc },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840, f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba4unorm-webgl": { gl: 35842, f: texture_compression_pvrtc_webgl },
  "pvrtc-rbg2unorm-webgl": { gl: 35841, f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba2unorm-webgl": { gl: 35843, f: texture_compression_pvrtc_webgl },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196, f: texture_compression_etc1_webgl },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986, f: texture_compression_atc_webgl },
  "atc-rgba-unorm-webgl": { gl: 35986, f: texture_compression_atc_webgl },
  "atc-rgbai-unorm-webgl": { gl: 34798, f: texture_compression_atc_webgl }
};
const DATA_FORMAT_CHANNELS = {
  [6403]: 1,
  [36244]: 1,
  [33319]: 2,
  [33320]: 2,
  [6407]: 3,
  [36248]: 3,
  [6408]: 4,
  [36249]: 4,
  [6402]: 1,
  [34041]: 1,
  [6406]: 1,
  [6409]: 1,
  [6410]: 2
};
const TYPE_SIZES = {
  [5126]: 4,
  [5125]: 4,
  [5124]: 4,
  [5123]: 2,
  [5122]: 2,
  [5131]: 2,
  [5120]: 1,
  [5121]: 1
};
function isTextureFormatSupported(gl, format2, extensions) {
  const info = TEXTURE_FORMATS[format2];
  if (!info) {
    return false;
  }
  if (info.gl === void 0) {
    return false;
  }
  const extension = info.x || info.gl2ext;
  if (extension) {
    return Boolean(getWebGLExtension(gl, extension, extensions));
  }
  return true;
}
function convertTextureFormatToGL(format2) {
  const formatInfo = TEXTURE_FORMATS[format2];
  const webglFormat = formatInfo?.gl;
  if (webglFormat === void 0) {
    throw new Error(`Unsupported texture format ${format2}`);
  }
  return webglFormat;
}
function isTextureFormatFilterable(gl, format2, extensions) {
  if (!isTextureFormatSupported(gl, format2, extensions)) {
    return false;
  }
  if (format2.startsWith("depth") || format2.startsWith("stencil")) {
    return false;
  }
  try {
    const decoded = decodeTextureFormat(format2);
    if (decoded.signed) {
      return false;
    }
  } catch {
    return false;
  }
  if (format2.endsWith("32float")) {
    return Boolean(getWebGLExtension(gl, "OES_texture_float_linear, extensions", extensions));
  }
  if (format2.endsWith("16float")) {
    return Boolean(getWebGLExtension(gl, "OES_texture_half_float_linear, extensions", extensions));
  }
  return true;
}
function isTextureFormatRenderable(gl, format2, extensions) {
  if (!isTextureFormatSupported(gl, format2, extensions)) {
    return false;
  }
  if (typeof format2 === "number") {
    return false;
  }
  return true;
}
function getWebGLTextureParameters(format2) {
  const formatData = TEXTURE_FORMATS[format2];
  const webglFormat = convertTextureFormatToGL(format2);
  const decoded = decodeTextureFormat(format2);
  return {
    format: webglFormat,
    dataFormat: formatData?.dataFormat || getWebGLPixelDataFormat(decoded.format, decoded.integer, decoded.normalized, webglFormat),
    // depth formats don't have a type
    type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : formatData?.types?.[0] || 5121,
    // @ts-expect-error
    compressed: decoded.compressed
  };
}
function getDepthStencilAttachmentWebGL(format2) {
  const info = TEXTURE_FORMATS[format2];
  if (!info?.attachment) {
    throw new Error(`${format2} is not a depth stencil format`);
  }
  return info.attachment;
}
function getTextureFormatBytesPerPixel(format2) {
  const params = getWebGLTextureParameters(format2);
  const channels = DATA_FORMAT_CHANNELS[params.dataFormat] || 4;
  const channelSize = TYPE_SIZES[params.type] || 1;
  return channels * channelSize;
}
function getWebGLPixelDataFormat(dataFormat, integer, normalized, format2) {
  if (format2 === 6408 || format2 === 6407) {
    return format2;
  }
  switch (dataFormat) {
    case "r":
      return integer && !normalized ? 36244 : 6403;
    case "rg":
      return integer && !normalized ? 33320 : 33319;
    case "rgb":
      return integer && !normalized ? 36248 : 6407;
    case "rgba":
      return integer && !normalized ? 36249 : 6408;
    default:
      return 6408;
  }
}
const WEBGL_FEATURES = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth24unorm-stencil8' // GPUTextureFormat 'depth24unorm-stencil8'
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class WebGLDeviceFeatures extends DeviceFeatures {
  gl;
  extensions;
  testedFeatures = /* @__PURE__ */ new Set();
  constructor(gl, extensions, disabledFeatures) {
    super([], disabledFeatures);
    this.gl = gl;
    this.extensions = extensions;
    getWebGLExtension(gl, "EXT_color_buffer_float", extensions);
  }
  *[Symbol.iterator]() {
    const features = this.getFeatures();
    for (const feature of features) {
      if (this.has(feature)) {
        yield feature;
      }
    }
    return [];
  }
  has(feature) {
    if (this.disabledFeatures[feature]) {
      return false;
    }
    if (!this.testedFeatures.has(feature)) {
      this.testedFeatures.add(feature);
      if (isTextureFeature(feature) && checkTextureFeature(this.gl, feature, this.extensions)) {
        this.features.add(feature);
      }
      if (this.getWebGLFeature(feature)) {
        this.features.add(feature);
      }
    }
    return this.features.has(feature);
  }
  // FOR DEVICE
  initializeFeatures() {
    const features = this.getFeatures().filter((feature) => feature !== "polygon-mode-webgl");
    for (const feature of features) {
      this.has(feature);
    }
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(WEBGL_FEATURES), ...Object.keys(TEXTURE_FEATURES)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(feature) {
    const featureInfo = WEBGL_FEATURES[feature];
    const isSupported = typeof featureInfo === "string" ? Boolean(getWebGLExtension(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
    return isSupported;
  }
}
class WebGLDeviceLimits extends DeviceLimits {
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  // WebGL does not support compute shaders
  // PRIVATE
  gl;
  limits = {};
  constructor(gl) {
    super();
    this.gl = gl;
  }
  getParameter(parameter) {
    if (this.limits[parameter] === void 0) {
      this.limits[parameter] = this.gl.getParameter(parameter);
    }
    return this.limits[parameter];
  }
}
function withGLParameters(gl, parameters, func) {
  if (isObjectEmpty(parameters)) {
    return func(gl);
  }
  const { nocatch = true } = parameters;
  pushContextState(gl);
  setGLParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    popContextState(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      popContextState(gl);
    }
  }
  return value;
}
function isObjectEmpty(object2) {
  for (const key in object2) {
    return false;
  }
  return true;
}
function withDeviceAndGLParameters(device, parameters, glParameters, func) {
  if (isObjectEmpty$2(parameters)) {
    return func(device);
  }
  const webglDevice = device;
  pushContextState(webglDevice.gl);
  try {
    setDeviceParameters(device, parameters);
    setGLParameters(webglDevice.gl, glParameters);
    return func(device);
  } finally {
    popContextState(webglDevice.gl);
  }
}
function setDeviceParameters(device, parameters) {
  const webglDevice = device;
  const { gl } = webglDevice;
  if (parameters.cullMode) {
    switch (parameters.cullMode) {
      case "none":
        gl.disable(2884);
        break;
      case "front":
        gl.enable(2884);
        gl.cullFace(1028);
        break;
      case "back":
        gl.enable(2884);
        gl.cullFace(1029);
        break;
    }
  }
  if (parameters.frontFace) {
    gl.frontFace(map("frontFace", parameters.frontFace, {
      ccw: 2305,
      cw: 2304
    }));
  }
  if (parameters.unclippedDepth) {
    if (device.features.has("depth-clip-control")) {
      gl.enable(34383);
    }
  }
  if (parameters.depthBias !== void 0) {
    gl.enable(32823);
    gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
  }
  if (parameters.provokingVertex) {
    if (device.features.has("provoking-vertex-webgl")) {
      const extensions = webglDevice.getExtension("WEBGL_provoking_vertex");
      const ext = extensions.WEBGL_provoking_vertex;
      const vertex = map("provokingVertex", parameters.provokingVertex, {
        first: 36429,
        last: 36430
      });
      ext?.provokingVertexWEBGL(vertex);
    }
  }
  if (parameters.polygonMode || parameters.polygonOffsetLine) {
    if (device.features.has("polygon-mode-webgl")) {
      if (parameters.polygonMode) {
        const extensions = webglDevice.getExtension("WEBGL_polygon_mode");
        const ext = extensions.WEBGL_polygon_mode;
        const mode = map("polygonMode", parameters.polygonMode, {
          fill: 6914,
          line: 6913
        });
        ext?.polygonModeWEBGL(1028, mode);
        ext?.polygonModeWEBGL(1029, mode);
      }
      if (parameters.polygonOffsetLine) {
        gl.enable(10754);
      }
    }
  }
  if (device.features.has("shader-clip-cull-distance-webgl")) {
    if (parameters.clipDistance0) {
      gl.enable(12288);
    }
    if (parameters.clipDistance1) {
      gl.enable(12289);
    }
    if (parameters.clipDistance2) {
      gl.enable(12290);
    }
    if (parameters.clipDistance3) {
      gl.enable(12291);
    }
    if (parameters.clipDistance4) {
      gl.enable(12292);
    }
    if (parameters.clipDistance5) {
      gl.enable(12293);
    }
    if (parameters.clipDistance6) {
      gl.enable(12294);
    }
    if (parameters.clipDistance7) {
      gl.enable(12295);
    }
  }
  if (parameters.depthWriteEnabled !== void 0) {
    gl.depthMask(mapBoolean("depthWriteEnabled", parameters.depthWriteEnabled));
  }
  if (parameters.depthCompare) {
    parameters.depthCompare !== "always" ? gl.enable(2929) : gl.disable(2929);
    gl.depthFunc(convertCompareFunction("depthCompare", parameters.depthCompare));
  }
  if (parameters.stencilWriteMask) {
    const mask = parameters.stencilWriteMask;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, mask);
  }
  if (parameters.stencilReadMask) {
    log.warn("stencilReadMask not supported under WebGL");
  }
  if (parameters.stencilCompare) {
    const mask = parameters.stencilReadMask || 4294967295;
    const glValue = convertCompareFunction("depthCompare", parameters.stencilCompare);
    parameters.stencilCompare !== "always" ? gl.enable(2960) : gl.disable(2960);
    gl.stencilFuncSeparate(1028, glValue, 0, mask);
    gl.stencilFuncSeparate(1029, glValue, 0, mask);
  }
  if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
    const dppass = convertStencilOperation("stencilPassOperation", parameters.stencilPassOperation);
    const sfail = convertStencilOperation("stencilFailOperation", parameters.stencilFailOperation);
    const dpfail = convertStencilOperation("stencilDepthFailOperation", parameters.stencilDepthFailOperation);
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
  }
  if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
    gl.enable(3042);
    const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters.blendColorOperation || "add");
    const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters.blendAlphaOperation || "add");
    gl.blendEquationSeparate(colorEquation, alphaEquation);
    const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters.blendColorSrcFactor || "one");
    const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters.blendColorDstFactor || "zero");
    const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters.blendAlphaSrcFactor || "one");
    const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters.blendAlphaDstFactor || "zero");
    gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
  }
}
function convertCompareFunction(parameter, value) {
  return map(parameter, value, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function convertStencilOperation(parameter, value) {
  return map(parameter, value, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function convertBlendOperationToEquation(parameter, value) {
  return map(parameter, value, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function convertBlendFactorToFunction(parameter, value) {
  return map(parameter, value, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function message(parameter, value) {
  return `Illegal parameter ${value} for ${parameter}`;
}
function map(parameter, value, valueMap) {
  if (!(value in valueMap)) {
    throw new Error(message(parameter, value));
  }
  return valueMap[value];
}
function mapBoolean(parameter, value) {
  return value;
}
function convertSamplerParametersToWebGL(props) {
  const params = {};
  if (props.addressModeU) {
    params[10242] = convertAddressMode(props.addressModeU);
  }
  if (props.addressModeV) {
    params[10243] = convertAddressMode(props.addressModeV);
  }
  if (props.addressModeW) {
    params[32882] = convertAddressMode(props.addressModeW);
  }
  if (props.magFilter) {
    params[10240] = convertMaxFilterMode(props.magFilter);
  }
  if (props.minFilter || props.mipmapFilter) {
    params[10241] = convertMinFilterMode(props.minFilter || "linear", props.mipmapFilter);
  }
  if (props.lodMinClamp !== void 0) {
    params[33082] = props.lodMinClamp;
  }
  if (props.lodMaxClamp !== void 0) {
    params[33083] = props.lodMaxClamp;
  }
  if (props.type === "comparison-sampler") {
    params[34892] = 34894;
  }
  if (props.compare) {
    params[34893] = convertCompareFunction("compare", props.compare);
  }
  if (props.maxAnisotropy) {
    params[34046] = props.maxAnisotropy;
  }
  return params;
}
function convertAddressMode(addressMode) {
  switch (addressMode) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function convertMaxFilterMode(maxFilter) {
  switch (maxFilter) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function convertMinFilterMode(minFilter, mipmapFilter) {
  if (!mipmapFilter) {
    return convertMaxFilterMode(minFilter);
  }
  switch (minFilter) {
    case "nearest":
      return mipmapFilter === "nearest" ? 9984 : 9986;
    case "linear":
      return mipmapFilter === "nearest" ? 9985 : 9987;
  }
}
class WEBGLBuffer extends Buffer {
  device;
  gl;
  handle;
  /** Target in OpenGL defines the type of buffer */
  glTarget;
  /** Usage is a hint on how frequently the buffer will be updates */
  glUsage;
  /** Index type is needed when issuing draw calls, so we pre-compute it */
  glIndexType = 5123;
  /** Number of bytes allocated on the GPU for this buffer */
  byteLength;
  /** Number of bytes used */
  bytesUsed;
  constructor(device, props = {}) {
    super(device, props);
    this.device = device;
    this.gl = this.device.gl;
    const handle = typeof props === "object" ? props.handle : void 0;
    this.handle = handle || this.gl.createBuffer();
    device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
    this.glTarget = getWebGLTarget(this.props.usage);
    this.glUsage = getWebGLUsage(this.props.usage);
    this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123;
    if (props.data) {
      this._initWithData(props.data, props.byteOffset, props.byteLength);
    } else {
      this._initWithByteLength(props.byteLength || 0);
    }
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, byteLength, this.glUsage);
    this.gl.bufferSubData(glTarget, byteOffset, data);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(data, byteOffset, byteLength);
    this.trackAllocatedMemory(byteLength);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(byteLength) {
    assert$3(byteLength >= 0);
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, data, this.glUsage);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(null, 0, byteLength);
    this.trackAllocatedMemory(byteLength);
    return this;
  }
  destroy() {
    if (!this.destroyed && this.handle) {
      this.removeStats();
      this.trackDeallocatedMemory();
      this.gl.deleteBuffer(this.handle);
      this.destroyed = true;
      this.handle = null;
    }
  }
  write(data, byteOffset = 0) {
    const glTarget = 36663;
    this.gl.bindBuffer(glTarget, this.handle);
    {
      this.gl.bufferSubData(glTarget, byteOffset, data);
    }
    this.gl.bindBuffer(glTarget, null);
    this._setDebugData(data, byteOffset, data.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync(byteOffset = 0, byteLength) {
    return this.readSyncWebGL(byteOffset, byteLength);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL(byteOffset = 0, byteLength) {
    byteLength = byteLength ?? this.byteLength - byteOffset;
    const data = new Uint8Array(byteLength);
    const dstOffset = 0;
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
    this.gl.bindBuffer(36662, null);
    this._setDebugData(data, byteOffset, byteLength);
    return data;
  }
}
function getWebGLTarget(usage) {
  if (usage & Buffer.INDEX) {
    return 34963;
  }
  if (usage & Buffer.VERTEX) {
    return 34962;
  }
  if (usage & Buffer.UNIFORM) {
    return 35345;
  }
  return 34962;
}
function getWebGLUsage(usage) {
  if (usage & Buffer.INDEX) {
    return 35044;
  }
  if (usage & Buffer.VERTEX) {
    return 35044;
  }
  if (usage & Buffer.UNIFORM) {
    return 35048;
  }
  return 35044;
}
class WEBGLSampler extends Sampler {
  device;
  handle;
  parameters;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.parameters = convertSamplerParametersToWebGL(props);
    this.handle = this.handle || this.device.gl.createSampler();
    this._setSamplerParameters(this.parameters);
  }
  destroy() {
    if (this.handle) {
      this.device.gl.deleteSampler(this.handle);
      this.handle = void 0;
    }
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(parameters) {
    for (const [pname, value] of Object.entries(parameters)) {
      const param = Number(pname);
      switch (param) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, param, value);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, param, value);
          break;
      }
    }
  }
}
class WEBGLTextureView extends TextureView {
  device;
  gl;
  handle;
  texture;
  constructor(device, props) {
    super(device, { ...Texture.defaultProps, ...props });
    this.device = device;
    this.gl = this.device.gl;
    this.handle = null;
    this.texture = props.texture;
  }
}
const DEFAULT_WEBGL_TEXTURE_PROPS = {
  // deprecated
  parameters: {},
  pixelStore: {},
  pixels: null,
  border: 0,
  dataFormat: void 0,
  textureUnit: void 0,
  target: void 0
};
class WEBGLTexture extends Texture {
  // TODO - remove?
  static FACES = [
    34069,
    34070,
    34071,
    34072,
    34073,
    34074
  ];
  MAX_ATTRIBUTES;
  device;
  gl;
  handle;
  // (TODO - currently unused in WebGL, but WebGL 2 does support sampler objects) */
  sampler = void 0;
  view = void 0;
  // data;
  glFormat = void 0;
  type = void 0;
  dataFormat = void 0;
  mipmaps = void 0;
  /**
   * @note `target` cannot be modified by bind:
   * textures are special because when you first bind them to a target,
   * they get special information. When you first bind a texture as a
   * GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
   * And it will always be a 2D texture; this state cannot be changed ever.
   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
   * */
  target;
  textureUnit = void 0;
  /**
   * Program.draw() checks the loaded flag of all textures to avoid
   * Textures that are still loading from promises
   * Set to true as soon as texture has been initialized with valid data
   */
  loaded = false;
  _video;
  constructor(device, props) {
    super(device, { ...DEFAULT_WEBGL_TEXTURE_PROPS, format: "rgba8unorm", ...props });
    this.device = device;
    this.gl = this.device.gl;
    this.handle = this.props.handle || this.gl.createTexture();
    this.device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
    this.glFormat = 6408;
    this.target = getWebGLTextureTarget(this.props);
    this.loaded = false;
    if (typeof this.props?.data === "string") {
      Object.assign(this.props, { data: loadImage(this.props.data) });
    }
    this.initialize(this.props);
    Object.seal(this);
  }
  destroy() {
    if (this.handle) {
      this.gl.deleteTexture(this.handle);
      this.removeStats();
      this.trackDeallocatedMemory("Texture");
      this.destroyed = true;
    }
  }
  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }
  createView(props) {
    return new WEBGLTextureView(this.device, { ...props, texture: this });
  }
  // eslint-disable-next-line max-statements
  initialize(props = {}) {
    if (this.props.dimension === "cube") {
      return this.initializeCube(props);
    }
    let data = props.data;
    if (data instanceof Promise) {
      data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
        pixels: resolvedImageData,
        data: resolvedImageData
      })));
      return this;
    }
    const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
      this._video = null;
      data.addEventListener("loadeddata", () => this.initialize(props));
      return this;
    }
    const { parameters = {} } = props;
    const { pixels = null, pixelStore = {}, textureUnit = void 0, mipmaps = true } = props;
    if (!data) {
      data = pixels;
    }
    let { width, height, dataFormat, type, compressed = false } = props;
    const { depth = 0 } = props;
    const glFormat = convertTextureFormatToGL(props.format);
    ({ width, height, compressed, dataFormat, type } = this._deduceParameters({
      format: props.format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    this.width = width;
    this.height = height;
    this.glFormat = glFormat;
    this.type = type;
    this.dataFormat = dataFormat;
    this.textureUnit = textureUnit;
    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(33984 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }
    this.mipmaps = mipmaps;
    this.setImageData({
      data,
      width,
      height,
      depth,
      format: props.format,
      type,
      dataFormat,
      // @ts-expect-error
      parameters: pixelStore,
      compressed
    });
    this.setSampler(props.sampler);
    this._setSamplerParameters(parameters);
    this.view = this.createView({ ...this.props, mipLevelCount: 1, arrayLayerCount: 1 });
    if (mipmaps && this.device.isTextureFormatFilterable(props.format)) {
      this.generateMipmap();
    }
    if (isVideo) {
      this._video = {
        video: data,
        parameters,
        // @ts-expect-error
        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
      };
    }
    return this;
  }
  initializeCube(props) {
    const { mipmaps = true, parameters = {} } = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;
      if (mipmaps) {
        this.generateMipmap(props);
      }
      this.setSampler(props.sampler);
      this._setSamplerParameters(parameters);
    });
    return this;
  }
  setSampler(sampler = {}) {
    let samplerProps;
    if (sampler instanceof WEBGLSampler) {
      this.sampler = sampler;
      samplerProps = sampler.props;
    } else {
      this.sampler = new WEBGLSampler(this.device, sampler);
      samplerProps = sampler;
    }
    const parameters = convertSamplerParametersToWebGL(samplerProps);
    this._setSamplerParameters(parameters);
    return this;
  }
  /**
   * If size has changed, reinitializes with current format
   * @note note clears image and mipmaps
   */
  resize(options) {
    const { height, width, mipmaps = false } = options;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        mipmaps
      });
    }
    return this;
  }
  /** Update external texture (video frame) */
  update() {
    if (this._video) {
      const { video, parameters, lastTime } = this._video;
      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
        return;
      }
      this.setSubImageData({
        data: video,
        parameters
      });
      if (this.mipmaps) {
        this.generateMipmap();
      }
      this._video.lastTime = video.currentTime;
    }
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(params = {}) {
    this.mipmaps = true;
    this.gl.bindTexture(this.target, this.handle);
    withGLParameters(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }
  /*
   * Allocates storage
   * @param {*} pixels -
   *  null - create empty texture of specified format
   *  Typed array - init from image data in typed array
   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
   *  HTMLImageElement|Image - Inits with content of image. Auto width/height
   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
   *  HTMLVideoElement - Creates video texture. Auto width/height
   *
   * @param  width -
   * @param  height -
   * @param  mipMapLevel -
   * @param {GLenum} format - format of image data.
   * @param {GLenum} type
   *  - format of array (autodetect from type) or
   *  - (WEBGL2) format of buffer
   * @param {Number} offset - (WEBGL2) offset from start of buffer
   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
   */
  // eslint-disable-next-line max-statements, complexity
  setImageData(options) {
    if (this.props.dimension === "3d" || this.props.dimension === "2d-array") {
      return this.setImageData3D(options);
    }
    this.trackDeallocatedMemory("Texture");
    const { target = this.target, pixels = null, level = 0, glFormat = this.glFormat, offset: offset2 = 0, parameters = {} } = options;
    let { data = null, type = this.type, width = this.width, height = this.height, dataFormat = this.dataFormat, compressed = false } = options;
    if (!data) {
      data = pixels;
    }
    ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
      format: this.props.format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    const { gl } = this;
    gl.bindTexture(this.target, this.handle);
    let dataType = null;
    ({ data, dataType } = this._getDataType({ data, compressed }));
    withGLParameters(this.gl, parameters, () => {
      switch (dataType) {
        case "null":
          gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, data);
          break;
        case "typed-array":
          gl.texImage2D(
            target,
            level,
            glFormat,
            width,
            height,
            0,
            // border (must be 0)
            dataFormat,
            type,
            data,
            offset2
          );
          break;
        case "buffer":
          this.device.gl.bindBuffer(35052, data.handle || data);
          this.device.gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, offset2);
          this.device.gl.bindBuffer(35052, null);
          break;
        case "browser-object":
          gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, data);
          break;
        case "compressed":
          for (const [levelIndex, levelData] of data.entries()) {
            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, 0, levelData.data);
          }
          break;
        default:
          assert$3(false, "Unknown image data type");
      }
    });
    if (data && data.byteLength) {
      this.trackAllocatedMemory(data.byteLength, "Texture");
    } else {
      const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * bytesPerPixel, "Texture");
    }
    this.loaded = true;
    return this;
  }
  /**
   * Redefines an area of an existing texture
   * Note: does not allocate storage
   * Redefines an area of an existing texture
   */
  setSubImageData({ target = this.target, pixels = null, data = null, x: x2 = 0, y: y2 = 0, width = this.width, height = this.height, level = 0, glFormat = this.glFormat, type = this.type, dataFormat = this.dataFormat, compressed = false, offset: offset2 = 0, parameters = {} }) {
    ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
      format: this.props.format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    assert$3(this.depth === 1, "texSubImage not supported for 3D textures");
    if (!data) {
      data = pixels;
    }
    if (data && data.data) {
      const ndarray = data;
      data = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }
    if (data instanceof WEBGLBuffer) {
      data = data.handle;
    }
    this.gl.bindTexture(this.target, this.handle);
    withGLParameters(this.gl, parameters, () => {
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x2, y2, width, height, glFormat, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data, offset2);
      } else if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
        this.device.gl.bindBuffer(35052, data);
        this.device.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, offset2);
        this.device.gl.bindBuffer(35052, null);
      } else {
        this.device.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data);
      }
    });
    this.gl.bindTexture(this.target, null);
  }
  /**
   * Defines a two-dimensional texture image or cube-map texture image with
   * pixels from the current framebuffer (rather than from client memory).
   * (gl.copyTexImage2D wrapper)
   *
   * Note that binding a texture into a Framebuffer's color buffer and
   * rendering can be faster.
   */
  copyFramebuffer(opts = {}) {
    log.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
    return null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(textureUnit = this.textureUnit) {
    const { gl } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }
  unbind(textureUnit = this.textureUnit) {
    const { gl } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, null);
    return textureUnit;
  }
  // PRIVATE METHODS
  _getDataType({ data, compressed = false }) {
    if (compressed) {
      return { data, dataType: "compressed" };
    }
    if (data === null) {
      return { data, dataType: "null" };
    }
    if (ArrayBuffer.isView(data)) {
      return { data, dataType: "typed-array" };
    }
    if (data instanceof WEBGLBuffer) {
      return { data: data.handle, dataType: "buffer" };
    }
    if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
      return { data, dataType: "buffer" };
    }
    return { data, dataType: "browser-object" };
  }
  // HELPER METHODS
  _deduceParameters(opts) {
    const { format: format2, data } = opts;
    let { width, height, dataFormat, type, compressed } = opts;
    const parameters = getWebGLTextureParameters(format2);
    dataFormat = dataFormat || parameters.dataFormat;
    type = type || parameters.type;
    compressed = compressed || parameters.compressed;
    ({ width, height } = this._deduceImageSize(data, width, height));
    return { dataFormat, type, compressed, width, height, format: format2, data };
  }
  // eslint-disable-next-line complexity
  _deduceImageSize(data, width, height) {
    let size;
    if (typeof ImageData !== "undefined" && data instanceof ImageData) {
      size = { width: data.width, height: data.height };
    } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
      size = { width: data.naturalWidth, height: data.naturalHeight };
    } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
      size = { width: data.width, height: data.height };
    } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
      size = { width: data.width, height: data.height };
    } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
      size = { width: data.videoWidth, height: data.videoHeight };
    } else if (!data) {
      size = { width: width >= 0 ? width : 1, height: height >= 0 ? height : 1 };
    } else {
      size = { width, height };
    }
    assert$3(size, "Could not deduced texture size");
    assert$3(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
    assert$3(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
    return size;
  }
  // CUBE MAP METHODS
  /* eslint-disable max-statements, max-len */
  async setCubeMapImageData(options) {
    const { gl } = this;
    const { width, height, pixels, data, format: format2 = 6408, type = 5121 } = options;
    const imageDataMap = pixels || data;
    const resolvedFaces = await Promise.all(WEBGLTexture.FACES.map((face) => {
      const facePixels = imageDataMap[face];
      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
    }));
    this.bind();
    WEBGLTexture.FACES.forEach((face, index2) => {
      if (resolvedFaces[index2].length > 1 && this.props.mipmaps !== false) {
        log.warn(`${this.id} has mipmap and multiple LODs.`)();
      }
      resolvedFaces[index2].forEach((image, lodLevel) => {
        if (width && height) {
          gl.texImage2D(face, lodLevel, format2, width, height, 0, format2, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format2, format2, type, image);
        }
      });
    });
    this.unbind();
  }
  /** @todo update this method to accept LODs */
  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      format: format2 = 6408,
      type = 5121
      // generateMipmap = false // TODO
    } = options;
    const { gl } = this;
    const imageData = pixels || data;
    this.bind();
    if (imageData instanceof Promise) {
      imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format2, width, height, 0, format2, type, imageData);
    } else {
      gl.texImage2D(face, 0, format2, format2, type, imageData);
    }
    return this;
  }
  /** Image 3D copies from Typed Array or WebGLBuffer */
  setImageData3D(options) {
    const {
      level = 0,
      dataFormat,
      format: format2,
      type,
      // = GL.UNSIGNED_BYTE,
      width,
      height,
      depth = 1,
      offset: offset2 = 0,
      data,
      parameters = {}
    } = options;
    this.trackDeallocatedMemory("Texture");
    this.gl.bindTexture(this.target, this.handle);
    const webglTextureFormat = getWebGLTextureParameters(format2);
    withGLParameters(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data)) {
        this.gl.texImage3D(
          this.target,
          level,
          webglTextureFormat.format,
          width,
          height,
          depth,
          0,
          webglTextureFormat.dataFormat,
          webglTextureFormat.type,
          // dataType: getWebGL,
          data
        );
      }
      if (data instanceof WEBGLBuffer) {
        this.gl.bindBuffer(35052, data.handle);
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, 0, format2, type, offset2);
      }
    });
    if (data && data.byteLength) {
      this.trackAllocatedMemory(data.byteLength, "Texture");
    } else {
      const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * this.depth * bytesPerPixel, "Texture");
    }
    this.loaded = true;
    return this;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(parameters) {
    if (isObjectEmpty$2(parameters)) {
      return;
    }
    logParameters(parameters);
    this.gl.bindTexture(this.target, this.handle);
    for (const [pname, pvalue] of Object.entries(parameters)) {
      const param = Number(pname);
      const value = pvalue;
      switch (param) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.target, param, value);
          break;
        default:
          this.gl.texParameteri(this.target, param, value);
          break;
      }
    }
    this.gl.bindTexture(this.target, null);
    return;
  }
}
function getWebGLTextureTarget(props) {
  switch (props.dimension) {
    // supported in WebGL
    case "2d":
      return 3553;
    case "cube":
      return 34067;
    // supported in WebGL2
    case "2d-array":
      return 35866;
    case "3d":
      return 32879;
    // not supported in any WebGL version
    case "1d":
    case "cube-array":
    default:
      throw new Error(props.dimension);
  }
}
function logParameters(parameters) {
  log.log(1, "texture sampler parameters", parameters)();
}
class WEBGLFramebuffer extends Framebuffer {
  device;
  gl;
  handle;
  get texture() {
    return this.colorAttachments[0];
  }
  constructor(device, props) {
    super(device, props);
    const isDefaultFramebuffer = props.handle === null;
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
    if (!isDefaultFramebuffer) {
      device.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props });
      this.autoCreateAttachmentTextures();
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      for (let i = 0; i < this.colorAttachments.length; ++i) {
        const attachment = this.colorAttachments[i];
        const attachmentPoint = 36064 + i;
        if (attachment) {
          this._attachOne(attachmentPoint, attachment);
        }
      }
      if (this.depthStencilAttachment) {
        this._attachOne(getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format), this.depthStencilAttachment);
      }
      if (props.check !== false) {
        const status = this.gl.checkFramebufferStatus(36160);
        if (status !== 36053) {
          throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
        }
      }
      this.gl.bindFramebuffer(36160, prevHandle);
    }
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy();
    if (!this.destroyed && this.handle !== null) {
      this.gl.deleteFramebuffer(this.handle);
    }
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  createDepthStencilTexture(format2) {
    return new WEBGLTexture(this.device, {
      id: `${this.id}-depth-stencil`,
      format: format2,
      width: this.width,
      height: this.height,
      mipmaps: false
    });
  }
  /**
   * Attachment resize is expected to be a noop if size is same
   */
  resizeAttachments(width, height) {
    if (this.handle === null) {
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }
    if (width === void 0) {
      width = this.gl.drawingBufferWidth;
    }
    if (height === void 0) {
      height = this.gl.drawingBufferHeight;
    }
    for (const colorAttachment of this.colorAttachments) {
      colorAttachment.texture.resize({ width, height });
    }
    if (this.depthStencilAttachment) {
      this.depthStencilAttachment.texture.resize({ width, height });
    }
    return this;
  }
  /** Attach one attachment */
  _attachOne(attachmentPoint, attachment) {
    if (Array.isArray(attachment)) {
      const [texture, layer = 0, level = 0] = attachment;
      this._attachTexture(attachmentPoint, texture, layer, level);
      return texture;
    }
    if (attachment instanceof WEBGLTexture) {
      this._attachTexture(attachmentPoint, attachment, 0, 0);
      return attachment;
    }
    if (attachment instanceof WEBGLTextureView) {
      const textureView = attachment;
      this._attachTexture(attachmentPoint, textureView.texture, textureView.props.baseMipLevel, textureView.props.baseArrayLayer);
      return attachment.texture;
    }
    throw new Error("attach");
  }
  // TODO - we do not seem to need render buffers in WebGL 2
  // protected _attachWEBGLRenderbuffer(attachment: GL, renderbuffer: WEBGLRenderbuffer): void {
  //   this.gl.framebufferRenderbuffer(
  //     GL.FRAMEBUFFER,
  //     attachment,
  //     GL.RENDERBUFFER,
  //     renderbuffer.handle
  //   );
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTexture(attachment, texture, layer, level) {
    const { gl } = this.device;
    gl.bindTexture(texture.target, texture.handle);
    switch (texture.target) {
      case 35866:
      case 32879:
        gl.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;
      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;
      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;
      default:
        assert$3(false, "Illegal texture type");
    }
    gl.bindTexture(texture.target, null);
  }
}
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  switch (status) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${status}`;
  }
}
class WebGLCanvasContext extends CanvasContext {
  device;
  presentationSize;
  _framebuffer = null;
  constructor(device, props) {
    super(props);
    this.device = device;
    this.presentationSize = [-1, -1];
    this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
    this.update();
  }
  getCurrentFramebuffer() {
    this.update();
    this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
    return this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const size = this.getPixelSize();
    const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
    if (sizeChanged) {
      this.presentationSize = size;
      this.resize();
    }
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(options) {
    if (!this.device.gl)
      return;
    if (this.canvas) {
      const devicePixelRatio = this.getDevicePixelRatio(options?.useDevicePixels);
      this.setDevicePixelRatio(devicePixelRatio, options);
      return;
    }
  }
  commit() {
  }
}
const DEFAULT_SPECTOR_PROPS = {
  spector: log.get("spector") || log.get("spectorjs")
};
const SPECTOR_CDN_URL = "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js";
const LOG_LEVEL$1 = 1;
let spector = null;
let initialized = false;
async function loadSpectorJS(props) {
  if (!globalThis.SPECTOR) {
    try {
      await loadScript(SPECTOR_CDN_URL);
    } catch (error) {
      log.warn(String(error));
    }
  }
}
function initializeSpectorJS(props) {
  props = { ...DEFAULT_SPECTOR_PROPS, ...props };
  if (!props?.spector) {
    return null;
  }
  if (!spector && globalThis.SPECTOR) {
    log.probe(LOG_LEVEL$1, "SPECTOR found and initialized")();
    spector = new globalThis.SPECTOR.Spector();
    if (globalThis.luma) {
      globalThis.luma.spector = spector;
    }
  }
  if (!spector) {
    return null;
  }
  if (!initialized) {
    initialized = true;
    spector.spyCanvases();
    spector?.onCaptureStarted.add((capture) => log.info("Spector capture started:", capture)());
    spector?.onCapture.add((capture) => {
      log.info("Spector capture complete:", capture)();
      spector?.getResultUI();
      spector?.resultView.display();
      spector?.resultView.addCapture(capture);
    });
  }
  if (props?.canvas) {
    if (typeof props.spector === "string" && props.spector !== props.canvas.id) {
      return spector;
    }
    spector?.startCapture(props?.canvas, 500);
    new Promise((resolve) => setTimeout(resolve, 2e3)).then((_) => {
      log.info("Spector capture stopped after 2 seconds")();
      spector?.stopCapture();
    });
  }
  return spector;
}
const WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function getWebGLContextData(gl) {
  gl.luma = gl.luma || {};
  return gl.luma;
}
async function loadWebGLDeveloperTools() {
  if (isBrowser$1() && !globalThis.WebGLDebugUtils) {
    globalThis.global = globalThis.global || globalThis;
    globalThis.global.module = {};
    await loadScript(WEBGL_DEBUG_CDN_URL);
  }
}
function makeDebugContext(gl, props = {}) {
  if (!gl) {
    return null;
  }
  return props.debug ? getDebugContext(gl, props) : getRealContext(gl);
}
function getRealContext(gl) {
  const data = getWebGLContextData(gl);
  return data.realContext ? data.realContext : gl;
}
function getDebugContext(gl, props) {
  if (!globalThis.WebGLDebugUtils) {
    log.warn("webgl-debug not loaded")();
    return gl;
  }
  const data = getWebGLContextData(gl);
  if (data.debugContext) {
    return data.debugContext;
  }
  globalThis.WebGLDebugUtils.init({ ...GLEnum, ...gl });
  const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
  for (const key in GLEnum) {
    if (!(key in glDebug) && typeof GLEnum[key] === "number") {
      glDebug[key] = GLEnum[key];
    }
  }
  class WebGLDebugContext {
  }
  Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
  Object.setPrototypeOf(WebGLDebugContext, glDebug);
  const debugContext = Object.create(WebGLDebugContext);
  data.realContext = gl;
  data.debugContext = debugContext;
  debugContext.debug = true;
  return debugContext;
}
function getFunctionString(functionName, functionArgs) {
  functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
  let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
  args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
  return `gl.${functionName}(${args})`;
}
function onGLError(props, err, functionName, args) {
  args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
  const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
  const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
  const message2 = `${errorMessage} in gl.${functionName}(${functionArgs})`;
  log.error(message2)();
  debugger;
  if (props.throwOnError) {
    throw new Error(message2);
  }
}
function onValidateGLFunc(props, functionName, functionArgs) {
  let functionString = "";
  if (log.level >= 1) {
    functionString = getFunctionString(functionName, functionArgs);
    log.log(1, functionString)();
  }
  if (props.break && props.break.length > 0) {
    functionString = functionString || getFunctionString(functionName, functionArgs);
    const isBreakpoint = props.break.every((breakOn) => functionString.indexOf(breakOn) !== -1);
    if (isBreakpoint) {
      debugger;
    }
  }
  for (const arg of functionArgs) {
    if (arg === void 0) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      if (props.throwOnError) {
        throw new Error(`Undefined argument: ${functionString}`);
      } else {
        log.error(`Undefined argument: ${functionString}`)();
        debugger;
      }
    }
  }
}
function parseShaderCompilerLog(errLog) {
  const lines = errLog.split(/\r?\n/);
  const messages = [];
  for (const line of lines) {
    if (line.length <= 1) {
      continue;
    }
    const segments = line.split(":");
    if (segments.length === 2) {
      const [messageType2, message2] = segments;
      messages.push({
        message: message2.trim(),
        type: getMessageType(messageType2),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [messageType, linePosition, lineNumber, ...rest] = segments;
    let lineNum = parseInt(lineNumber, 10);
    if (isNaN(lineNum)) {
      lineNum = 0;
    }
    let linePos = parseInt(linePosition, 10);
    if (isNaN(linePos)) {
      linePos = 0;
    }
    messages.push({
      message: rest.join(":").trim(),
      type: getMessageType(messageType),
      lineNum,
      linePos
      // TODO
    });
  }
  return messages;
}
function getMessageType(messageType) {
  const MESSAGE_TYPES = ["warning", "error", "info"];
  const lowerCaseType = messageType.toLowerCase();
  return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
}
class WEBGLShader extends Shader {
  device;
  handle;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    switch (this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    if (this.handle) {
      this.removeStats();
      this.device.gl.deleteShader(this.handle);
      this.destroyed = true;
    }
  }
  async getCompilationInfo() {
    await this._waitForCompilationComplete();
    return this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const log3 = this.device.gl.getShaderInfoLog(this.handle);
    return parseShaderCompilerLog(log3);
  }
  getTranslatedSource() {
    const extensions = this.device.getExtension("WEBGL_debug_shaders");
    const ext = extensions.WEBGL_debug_shaders;
    return ext?.getTranslatedShaderSource(this.handle);
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(source) {
    const addGLSLVersion = (source2) => source2.startsWith("#version ") ? source2 : `#version 100
${source2}`;
    source = addGLSLVersion(source);
    const { gl } = this.device;
    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);
    if (log.level === 0) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      this._getCompilationStatus();
      this.debugShader();
      if (this.compilationStatus === "error") {
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      }
      return;
    }
    log.once(1, "Shader compilation is asynchronous")();
    await this._waitForCompilationComplete();
    log.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
    this._getCompilationStatus();
    this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
    const DELAY_MS = 10;
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await waitMs(DELAY_MS);
      return;
    }
    const { gl } = this.device;
    for (; ; ) {
      const complete = gl.getShaderParameter(this.handle, 37297);
      if (complete) {
        return;
      }
      await waitMs(DELAY_MS);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
const GL_DEPTH_BUFFER_BIT$1 = 256;
const GL_STENCIL_BUFFER_BIT$1 = 1024;
const GL_COLOR_BUFFER_BIT$1 = 16384;
const GL_COLOR = 6144;
const COLOR_CHANNELS = [1, 2, 4, 8];
class WEBGLRenderPass extends RenderPass {
  device;
  /** Parameters that should be applied before each draw call */
  glParameters;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    pushContextState(this.device.gl);
    this.setParameters(this.props.parameters);
    this.clear();
  }
  end() {
    popContextState(this.device.gl);
  }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(parameters = {}) {
    const glParameters = { ...this.glParameters };
    if (this.props.framebuffer) {
      glParameters.framebuffer = this.props.framebuffer;
    }
    if (this.props.depthReadOnly) {
      glParameters.depthMask = !this.props.depthReadOnly;
    }
    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
    glParameters[35977] = this.props.discard;
    if (parameters.viewport) {
      if (parameters.viewport.length >= 6) {
        glParameters.viewport = parameters.viewport.slice(0, 4);
        glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];
      } else {
        glParameters.viewport = parameters.viewport;
      }
    }
    if (parameters.scissorRect) {
      glParameters.scissorTest = true;
      glParameters.scissor = parameters.scissorRect;
    }
    if (parameters.blendConstant) {
      glParameters.blendColor = parameters.blendConstant;
    }
    if (parameters.stencilReference) {
      console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
      parameters[2967] = parameters.stencilReference;
    }
    if (parameters.colorMask) {
      glParameters.colorMask = COLOR_CHANNELS.map((channel) => Boolean(channel & parameters.colorMask));
    }
    this.glParameters = glParameters;
    setGLParameters(this.device.gl, glParameters);
  }
  beginOcclusionQuery(queryIndex) {
    const webglQuerySet = this.props.occlusionQuerySet;
    webglQuerySet?.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    const webglQuerySet = this.props.occlusionQuerySet;
    webglQuerySet?.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const glParameters = { ...this.glParameters };
    let clearMask = 0;
    if (this.props.clearColor !== false) {
      clearMask |= GL_COLOR_BUFFER_BIT$1;
      glParameters.clearColor = this.props.clearColor;
    }
    if (this.props.clearDepth !== false) {
      clearMask |= GL_DEPTH_BUFFER_BIT$1;
      glParameters.clearDepth = this.props.clearDepth;
    }
    if (this.props.clearStencil !== false) {
      clearMask |= GL_STENCIL_BUFFER_BIT$1;
      glParameters.clearStencil = this.props.clearStencil;
    }
    if (clearMask !== 0) {
      withGLParameters(this.device.gl, glParameters, () => {
        this.device.gl.clear(clearMask);
      });
    }
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
    withGLParameters(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (value.constructor) {
        case Int32Array:
          this.device.gl.clearBufferiv(GL_COLOR, drawBuffer, value);
          break;
        case Uint32Array:
          this.device.gl.clearBufferuiv(GL_COLOR, drawBuffer, value);
          break;
        case Float32Array:
        default:
          this.device.gl.clearBufferfv(GL_COLOR, drawBuffer, value);
          break;
      }
    });
  }
}
const ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType, options) {
  const { clamped = true } = options || {};
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
const DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
const PROP_CHECKS = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
class Accessor {
  offset;
  stride;
  type;
  size;
  divisor;
  normalized;
  integer;
  buffer;
  index;
  static getBytesPerElement(accessor) {
    const ArrayType2 = getTypedArrayFromGLType(accessor.type || 5126);
    return ArrayType2.BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(accessor) {
    assert$3(accessor.size);
    const ArrayType2 = getTypedArrayFromGLType(accessor.type || 5126);
    return ArrayType2.BYTES_PER_ELEMENT * accessor.size;
  }
  // Combines (merges) a list of accessors. On top of default values
  // Usually [programAccessor, bufferAccessor, appAccessor]
  // All props will be set in the returned object.
  // TODO check for conflicts between values in the supplied accessors
  static resolve(...accessors) {
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }
  constructor(...accessors) {
    accessors.forEach((accessor) => this._assign(accessor));
    Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  // ACCESSORS
  // TODO - remove>
  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }
  // PRIVATE
  // eslint-disable-next-line complexity, max-statements
  _assign(props = {}) {
    props = checkProps("Accessor", props, PROP_CHECKS);
    if (props.type !== void 0) {
      this.type = props.type;
      if (props.type === 5124 || props.type === 5125) {
        this.integer = true;
      }
    }
    if (props.size !== void 0) {
      this.size = props.size;
    }
    if (props.offset !== void 0) {
      this.offset = props.offset;
    }
    if (props.stride !== void 0) {
      this.stride = props.stride;
    }
    if (props.normalize !== void 0) {
      this.normalized = props.normalize;
    }
    if (props.normalized !== void 0) {
      this.normalized = props.normalized;
    }
    if (props.integer !== void 0) {
      this.integer = props.integer;
    }
    if (props.divisor !== void 0) {
      this.divisor = props.divisor;
    }
    if (props.buffer !== void 0) {
      this.buffer = props.buffer;
    }
    if (props.index !== void 0) {
      if (typeof props.index === "boolean") {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }
    if (props.instanced !== void 0) {
      this.divisor = props.instanced ? 1 : 0;
    }
    if (props.isInstanced !== void 0) {
      this.divisor = props.isInstanced ? 1 : 0;
    }
    if (this.offset === void 0)
      delete this.offset;
    if (this.stride === void 0)
      delete this.stride;
    if (this.type === void 0)
      delete this.type;
    if (this.size === void 0)
      delete this.size;
    if (this.divisor === void 0)
      delete this.divisor;
    if (this.normalized === void 0)
      delete this.normalized;
    if (this.integer === void 0)
      delete this.integer;
    if (this.buffer === void 0)
      delete this.buffer;
    if (this.index === void 0)
      delete this.index;
    return this;
  }
}
function isSamplerUniform(type) {
  return SAMPLER_TYPES.includes(type);
}
const SAMPLER_TYPES = [
  35678,
  35680,
  35679,
  35682,
  36289,
  36292,
  36293,
  36298,
  36299,
  36300,
  36303,
  36306,
  36307,
  36308,
  36311
];
const COMPOSITE_GL_TYPES = {
  [5126]: [5126, 1, "float", "f32", "float32"],
  [35664]: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  [35665]: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  [35666]: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  [5124]: [5124, 1, "int", "i32", "sint32"],
  [35667]: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  [35668]: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  [35669]: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  [5125]: [5125, 1, "uint", "u32", "uint32"],
  [36294]: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  [36295]: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  [36296]: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  [35670]: [5126, 1, "bool", "f32", "float32"],
  [35671]: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  [35672]: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  [35673]: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  [35674]: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  [35685]: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  [35686]: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  [35687]: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  [35675]: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  [35688]: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  [35689]: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  [35690]: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  [35676]: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function decodeGLUniformType(glUniformType) {
  const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
  if (!typeAndSize) {
    throw new Error("uniform");
  }
  const [glType, components, , format2] = typeAndSize;
  return { format: format2, components, glType };
}
function decodeGLAttributeType(glAttributeType) {
  const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
  if (!typeAndSize) {
    throw new Error("attribute");
  }
  const [, components, , shaderType, vertexFormat] = typeAndSize;
  const attributeType = shaderType;
  return { attributeType, vertexFormat, components };
}
function getShaderLayout(gl, program) {
  const shaderLayout = {
    attributes: [],
    bindings: []
  };
  shaderLayout.attributes = readAttributeDeclarations(gl, program);
  const uniformBlocks = readUniformBlocks(gl, program);
  for (const uniformBlock of uniformBlocks) {
    const uniforms2 = uniformBlock.uniforms.map((uniform) => ({
      name: uniform.name,
      format: uniform.format,
      byteOffset: uniform.byteOffset,
      byteStride: uniform.byteStride,
      arrayLength: uniform.arrayLength
    }));
    shaderLayout.bindings.push({
      type: "uniform",
      name: uniformBlock.name,
      location: uniformBlock.location,
      visibility: (uniformBlock.vertex ? 1 : 0) & (uniformBlock.fragment ? 2 : 0),
      minBindingSize: uniformBlock.byteLength,
      uniforms: uniforms2
    });
  }
  const uniforms = readUniformBindings(gl, program);
  let textureUnit = 0;
  for (const uniform of uniforms) {
    if (isSamplerUniform(uniform.type)) {
      const { viewDimension, sampleType } = getSamplerInfo(uniform.type);
      shaderLayout.bindings.push({
        type: "texture",
        name: uniform.name,
        location: textureUnit,
        viewDimension,
        sampleType
      });
      uniform.textureUnit = textureUnit;
      textureUnit += 1;
    }
  }
  if (uniforms.length) {
    shaderLayout.uniforms = uniforms;
  }
  const varyings = readVaryings(gl, program);
  if (varyings?.length) {
    shaderLayout.varyings = varyings;
  }
  return shaderLayout;
}
function readAttributeDeclarations(gl, program) {
  const attributes = [];
  const count2 = gl.getProgramParameter(program, 35721);
  for (let index2 = 0; index2 < count2; index2++) {
    const activeInfo = gl.getActiveAttrib(program, index2);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const {
      name: name2,
      type: compositeType
      /* , size*/
    } = activeInfo;
    const location = gl.getAttribLocation(program, name2);
    if (location >= 0) {
      const { attributeType } = decodeGLAttributeType(compositeType);
      const stepMode = /instance/i.test(name2) ? "instance" : "vertex";
      attributes.push({
        name: name2,
        location,
        stepMode,
        type: attributeType
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  attributes.sort((a2, b) => a2.location - b.location);
  return attributes;
}
function readVaryings(gl, program) {
  const varyings = [];
  const count2 = gl.getProgramParameter(program, 35971);
  for (let location = 0; location < count2; location++) {
    const activeInfo = gl.getTransformFeedbackVarying(program, location);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name: name2, type: compositeType, size } = activeInfo;
    const { glType, components } = decodeGLUniformType(compositeType);
    const accessor = new Accessor({ type: glType, size: size * components });
    const varying = { location, name: name2, accessor };
    varyings.push(varying);
  }
  varyings.sort((a2, b) => a2.location - b.location);
  return varyings;
}
function readUniformBindings(gl, program) {
  const uniforms = [];
  const uniformCount = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < uniformCount; i++) {
    const activeInfo = gl.getActiveUniform(program, i);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name: rawName, size, type } = activeInfo;
    const { name: name2, isArray: isArray2 } = parseUniformName(rawName);
    let webglLocation = gl.getUniformLocation(program, name2);
    const uniformInfo = {
      // WebGL locations are uniquely typed but just numbers
      location: webglLocation,
      name: name2,
      size,
      type,
      isArray: isArray2
    };
    uniforms.push(uniformInfo);
    if (uniformInfo.size > 1) {
      for (let j = 0; j < uniformInfo.size; j++) {
        const elementName = `${name2}[${j}]`;
        webglLocation = gl.getUniformLocation(program, elementName);
        const arrayElementUniformInfo = {
          ...uniformInfo,
          name: elementName,
          location: webglLocation
        };
        uniforms.push(arrayElementUniformInfo);
      }
    }
  }
  return uniforms;
}
function readUniformBlocks(gl, program) {
  const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);
  const uniformBlocks = [];
  const blockCount = gl.getProgramParameter(program, 35382);
  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
    const blockInfo = {
      name: gl.getActiveUniformBlockName(program, blockIndex) || "",
      location: getBlockParameter(blockIndex, 35391),
      byteLength: getBlockParameter(blockIndex, 35392),
      vertex: getBlockParameter(blockIndex, 35396),
      fragment: getBlockParameter(blockIndex, 35398),
      uniformCount: getBlockParameter(blockIndex, 35394),
      uniforms: []
    };
    const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
    const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383);
    const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384);
    const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387);
    const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388);
    for (let i = 0; i < blockInfo.uniformCount; ++i) {
      const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      blockInfo.uniforms.push({
        name: activeInfo.name,
        format: decodeGLUniformType(uniformType[i]).format,
        type: uniformType[i],
        arrayLength: uniformArrayLength[i],
        byteOffset: uniformOffset[i],
        byteStride: uniformStride[i]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    uniformBlocks.push(blockInfo);
  }
  uniformBlocks.sort((a2, b) => a2.location - b.location);
  return uniformBlocks;
}
const SAMPLER_UNIFORMS_GL_TO_GPU = {
  [35678]: ["2d", "float"],
  [35680]: ["cube", "float"],
  [35679]: ["3d", "float"],
  [35682]: ["3d", "depth"],
  [36289]: ["2d-array", "float"],
  [36292]: ["2d-array", "depth"],
  [36293]: ["cube", "float"],
  [36298]: ["2d", "sint"],
  [36299]: ["3d", "sint"],
  [36300]: ["cube", "sint"],
  [36303]: ["2d-array", "uint"],
  [36306]: ["2d", "uint"],
  [36307]: ["3d", "uint"],
  [36308]: ["cube", "uint"],
  [36311]: ["2d-array", "uint"]
};
function getSamplerInfo(type) {
  const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
  if (!sampler) {
    throw new Error("sampler");
  }
  const [viewDimension, sampleType] = sampler;
  return { viewDimension, sampleType };
}
function parseUniformName(name2) {
  if (name2[name2.length - 1] !== "]") {
    return {
      name: name2,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches2 = UNIFORM_NAME_REGEXP.exec(name2);
  if (!matches2 || matches2.length < 2) {
    throw new Error(`Failed to parse GLSL uniform name ${name2}`);
  }
  return {
    name: matches2[1],
    length: matches2[2] ? 1 : 0,
    isArray: Boolean(matches2[2])
  };
}
function setUniform(gl, location, type, value) {
  const gl2 = gl;
  let uniformValue = value;
  if (uniformValue === true) {
    uniformValue = 1;
  }
  if (uniformValue === false) {
    uniformValue = 0;
  }
  const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
  switch (type) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof value !== "number") {
        throw new Error("samplers must be set to integers");
      }
      return gl.uniform1i(location, value);
    case 5126:
      return gl.uniform1fv(location, arrayValue);
    case 35664:
      return gl.uniform2fv(location, arrayValue);
    case 35665:
      return gl.uniform3fv(location, arrayValue);
    case 35666:
      return gl.uniform4fv(location, arrayValue);
    case 5124:
      return gl.uniform1iv(location, arrayValue);
    case 35667:
      return gl.uniform2iv(location, arrayValue);
    case 35668:
      return gl.uniform3iv(location, arrayValue);
    case 35669:
      return gl.uniform4iv(location, arrayValue);
    case 35670:
      return gl.uniform1iv(location, arrayValue);
    case 35671:
      return gl.uniform2iv(location, arrayValue);
    case 35672:
      return gl.uniform3iv(location, arrayValue);
    case 35673:
      return gl.uniform4iv(location, arrayValue);
    // WEBGL2 - unsigned integers
    case 5125:
      return gl2.uniform1uiv(location, arrayValue, 1);
    case 36294:
      return gl2.uniform2uiv(location, arrayValue, 2);
    case 36295:
      return gl2.uniform3uiv(location, arrayValue, 3);
    case 36296:
      return gl2.uniform4uiv(location, arrayValue, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return gl.uniformMatrix2fv(location, false, arrayValue);
    case 35675:
      return gl.uniformMatrix3fv(location, false, arrayValue);
    case 35676:
      return gl.uniformMatrix4fv(location, false, arrayValue);
    // WebGL2 - rectangular matrices
    case 35685:
      return gl2.uniformMatrix2x3fv(location, false, arrayValue);
    case 35686:
      return gl2.uniformMatrix2x4fv(location, false, arrayValue);
    case 35687:
      return gl2.uniformMatrix3x2fv(location, false, arrayValue);
    case 35688:
      return gl2.uniformMatrix3x4fv(location, false, arrayValue);
    case 35689:
      return gl2.uniformMatrix4x2fv(location, false, arrayValue);
    case 35690:
      return gl2.uniformMatrix4x3fv(location, false, arrayValue);
  }
  throw new Error("Illegal uniform");
}
function getGLDrawMode(topology) {
  switch (topology) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "line-loop-webgl":
      return 2;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    case "triangle-fan-webgl":
      return 6;
    default:
      throw new Error(topology);
  }
}
function getGLPrimitive(topology) {
  switch (topology) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "line-loop-webgl":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    case "triangle-fan-webgl":
      return 4;
    default:
      throw new Error(topology);
  }
}
const LOG_PROGRAM_PERF_PRIORITY = 4;
class WEBGLRenderPipeline extends RenderPipeline {
  /** The WebGL device that created this render pipeline */
  device;
  /** Handle to underlying WebGL program */
  handle;
  /** vertex shader */
  vs;
  /** fragment shader */
  fs;
  /** The layout extracted from shader by WebGL introspection APIs */
  introspectedLayout;
  /** Uniforms set on this model */
  uniforms = {};
  /** Bindings set on this model */
  bindings = {};
  /** WebGL varyings */
  varyings = null;
  _uniformCount = 0;
  _uniformSetters = {};
  // TODO are these used?
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.handle = this.props.handle || this.device.gl.createProgram();
    this.device.setSpectorMetadata(this.handle, { id: this.props.id });
    this.vs = cast$1(props.vs);
    this.fs = cast$1(props.fs);
    const { varyings, bufferMode = 35981 } = props;
    if (varyings && varyings.length > 0) {
      this.varyings = varyings;
      this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._linkShaders();
    log.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
    this.introspectedLayout = getShaderLayout(this.device.gl, this.handle);
    log.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
    this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);
    switch (this.props.topology) {
      case "triangle-fan-webgl":
      case "line-loop-webgl":
        log.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
        break;
    }
  }
  destroy() {
    if (this.handle) {
      this.device.gl.deleteProgram(this.handle);
      this.destroyed = true;
    }
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(bindings, options) {
    for (const [name2, value] of Object.entries(bindings)) {
      const binding = this.shaderLayout.bindings.find((binding2) => binding2.name === name2) || this.shaderLayout.bindings.find((binding2) => binding2.name === `${name2}Uniforms`);
      if (!binding) {
        const validBindings = this.shaderLayout.bindings.map((binding2) => `"${binding2.name}"`).join(", ");
        if (!options?.disableWarnings) {
          log.warn(`Unknown binding "${name2}" in render pipeline "${this.id}", expected one of ${validBindings}`)();
        }
        continue;
      }
      if (!value) {
        log.warn(`Unsetting binding "${name2}" in render pipeline "${this.id}"`)();
      }
      switch (binding.type) {
        case "uniform":
          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
            throw new Error("buffer value");
          }
          break;
        case "texture":
          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error("texture value");
          }
          break;
        case "sampler":
          log.warn(`Ignoring sampler ${name2}`)();
          break;
        default:
          throw new Error(binding.type);
      }
      this.bindings[name2] = value;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(options) {
    const {
      renderPass,
      parameters = this.props.parameters,
      topology = this.props.topology,
      vertexArray,
      vertexCount,
      // indexCount,
      instanceCount,
      isInstanced = false,
      firstVertex = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback
    } = options;
    const glDrawMode = getGLDrawMode(topology);
    const isIndexed = Boolean(vertexArray.indexBuffer);
    const glIndexType = vertexArray.indexBuffer?.glIndexType;
    if (this.linkStatus !== "success") {
      log.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
      return false;
    }
    if (!this._areTexturesRenderable() || vertexCount === 0) {
      log.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
      return false;
    }
    if (vertexCount === 0) {
      log.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)();
      return true;
    }
    this.device.gl.useProgram(this.handle);
    vertexArray.bindBeforeRender(renderPass);
    if (transformFeedback) {
      transformFeedback.begin(this.props.topology);
    }
    this._applyBindings();
    this._applyUniforms();
    const webglRenderPass = renderPass;
    withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {
      if (isIndexed && isInstanced) {
        this.device.gl.drawElementsInstanced(
          glDrawMode,
          vertexCount || 0,
          // indexCount?
          glIndexType,
          firstVertex,
          instanceCount || 0
        );
      } else if (isIndexed) {
        this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
      } else if (isInstanced) {
        this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
      } else {
        this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
      }
      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    vertexArray.unbindAfterRender(renderPass);
    return true;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(uniforms) {
    const { bindings } = splitUniformsAndBindings(uniforms);
    Object.keys(bindings).forEach((name2) => {
      log.warn(`Unsupported value "${JSON.stringify(bindings[name2])}" used in setUniforms() for key ${name2}. Use setBindings() instead?`)();
    });
    Object.assign(this.uniforms, uniforms);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl } = this.device;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    gl.linkProgram(this.handle);
    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    if (log.level === 0) ;
    if (!this.device.features.has("compilation-status-async-webgl")) {
      const status2 = this._getLinkStatus();
      this._reportLinkStatus(status2);
      return;
    }
    log.once(1, "RenderPipeline linking is asynchronous")();
    await this._waitForLinkComplete();
    log.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const status = this._getLinkStatus();
    this._reportLinkStatus(status);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  _reportLinkStatus(status) {
    switch (status) {
      case "success":
        return;
      default:
        if (this.vs.compilationStatus === "error") {
          this.vs.debugShader();
          throw new Error(`Error during compilation of shader ${this.vs.id}`);
        }
        if (this.fs?.compilationStatus === "error") {
          this.fs.debugShader();
          throw new Error(`Error during compilation of shader ${this.fs.id}`);
        }
        throw new Error(`Error during ${status}: ${this.device.gl.getProgramInfoLog(this.handle)}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl } = this.device;
    const linked = gl.getProgramParameter(this.handle, 35714);
    if (!linked) {
      this.linkStatus = "error";
      return "linking";
    }
    gl.validateProgram(this.handle);
    const validated = gl.getProgramParameter(this.handle, 35715);
    if (!validated) {
      this.linkStatus = "error";
      return "validation";
    }
    this.linkStatus = "success";
    return "success";
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
    const DELAY_MS = 10;
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await waitMs(DELAY_MS);
      return;
    }
    const { gl } = this.device;
    for (; ; ) {
      const complete = gl.getProgramParameter(this.handle, 37297);
      if (complete) {
        return;
      }
      await waitMs(DELAY_MS);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const [, texture] of Object.entries(this.bindings)) {
      if (texture instanceof WEBGLTexture) {
        texture.update();
        texturesRenderable = texturesRenderable && texture.loaded;
      }
    }
    return texturesRenderable;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success") {
      return;
    }
    const { gl } = this.device;
    gl.useProgram(this.handle);
    let textureUnit = 0;
    let uniformBufferIndex = 0;
    for (const binding of this.shaderLayout.bindings) {
      const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
      if (!value) {
        throw new Error(`No value for binding ${binding.name} in ${this.id}`);
      }
      switch (binding.type) {
        case "uniform":
          const { name: name2 } = binding;
          const location = gl.getUniformBlockIndex(this.handle, name2);
          if (location === 4294967295) {
            throw new Error(`Invalid uniform block name ${name2}`);
          }
          gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
          if (value instanceof WEBGLBuffer) {
            gl.bindBufferBase(35345, uniformBufferIndex, value.handle);
          } else {
            gl.bindBufferRange(
              35345,
              uniformBufferIndex,
              // @ts-expect-error
              value.buffer.handle,
              // @ts-expect-error
              value.offset || 0,
              // @ts-expect-error
              value.size || value.buffer.byteLength - value.offset
            );
          }
          uniformBufferIndex += 1;
          break;
        case "texture":
          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error("texture");
          }
          let texture;
          if (value instanceof WEBGLTextureView) {
            texture = value.texture;
          } else if (value instanceof WEBGLTexture) {
            texture = value;
          } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {
            log.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")();
            texture = value.colorAttachments[0].texture;
          } else {
            throw new Error("No texture");
          }
          gl.activeTexture(33984 + textureUnit);
          gl.bindTexture(texture.target, texture.handle);
          textureUnit += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${binding.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const uniformLayout of this.shaderLayout.uniforms || []) {
      const { name: name2, location, type, textureUnit } = uniformLayout;
      const value = this.uniforms[name2] ?? textureUnit;
      if (value !== void 0) {
        setUniform(this.device.gl, location, type, value);
      }
    }
  }
}
function cast(value) {
  return value;
}
class WEBGLCommandBuffer extends CommandBuffer {
  device;
  commands = [];
  constructor(device) {
    super(device, {});
    this.device = device;
  }
  submitCommands(commands = this.commands) {
    for (const command of commands) {
      switch (command.name) {
        case "copy-buffer-to-buffer":
          _copyBufferToBuffer(this.device, command.options);
          break;
        case "copy-buffer-to-texture":
          _copyBufferToTexture(this.device, command.options);
          break;
        case "copy-texture-to-buffer":
          _copyTextureToBuffer(this.device, command.options);
          break;
        case "copy-texture-to-texture":
          _copyTextureToTexture(this.device, command.options);
          break;
      }
    }
  }
}
function _copyBufferToBuffer(device, options) {
  const source = cast(options.source);
  const destination = cast(options.destination);
  device.gl.bindBuffer(36662, source.handle);
  device.gl.bindBuffer(36663, destination.handle);
  device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
  device.gl.bindBuffer(36662, null);
  device.gl.bindBuffer(36663, null);
}
function _copyBufferToTexture(device, options) {
  throw new Error("Not implemented");
}
function _copyTextureToBuffer(device, options) {
  const {
    /** Texture to copy to/from. */
    source,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect = "all",
    /** Width to copy */
    width = options.source.width,
    /** Height to copy */
    height = options.source.height,
    depthOrArrayLayers = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin = [0, 0],
    /** Destination buffer */
    destination,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage
  } = options;
  if (aspect !== "all") {
    throw new Error("not supported");
  }
  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
    throw new Error("not implemented");
  }
  const { framebuffer, destroyFramebuffer } = getFramebuffer$2(source);
  let prevHandle;
  try {
    const webglBuffer = destination;
    const sourceWidth = width || framebuffer.width;
    const sourceHeight = height || framebuffer.height;
    const sourceParams = getWebGLTextureParameters(framebuffer.texture.props.format);
    const sourceFormat = sourceParams.dataFormat;
    const sourceType = sourceParams.type;
    device.gl.bindBuffer(35051, webglBuffer.handle);
    prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
    device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
  } finally {
    device.gl.bindBuffer(35051, null);
    if (prevHandle !== void 0) {
      device.gl.bindFramebuffer(36160, prevHandle);
    }
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
}
function _copyTextureToTexture(device, options) {
  const {
    /** Texture to copy to/from. */
    source,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin = [0, 0],
    /** Texture to copy to/from. */
    destination
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = options;
  let {
    width = options.destination.width,
    height = options.destination.height
    // depthOrArrayLayers = 0
  } = options;
  const { framebuffer, destroyFramebuffer } = getFramebuffer$2(source);
  const [sourceX, sourceY] = origin;
  const [destinationX, destinationY, destinationZ] = destinationOrigin;
  const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
  let texture = null;
  let textureTarget;
  if (destination instanceof WEBGLTexture) {
    texture = destination;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    textureTarget = texture.target;
  } else {
    throw new Error("invalid destination");
  }
  switch (textureTarget) {
    case 3553:
    case 34067:
      device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);
      break;
    case 35866:
    case 32879:
      device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);
      break;
  }
  if (texture) {
    texture.unbind();
  }
  device.gl.bindFramebuffer(36160, prevHandle);
  if (destroyFramebuffer) {
    framebuffer.destroy();
  }
}
function getFramebuffer$2(source) {
  if (source instanceof Texture) {
    const { width, height, id } = source;
    const framebuffer = source.device.createFramebuffer({
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [source]
    });
    return { framebuffer, destroyFramebuffer: true };
  }
  return { framebuffer: source, destroyFramebuffer: false };
}
class WEBGLCommandEncoder extends CommandEncoder {
  device;
  commandBuffer;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.commandBuffer = new WEBGLCommandBuffer(device);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
  }
  copyBufferToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
  }
  copyTextureToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
  }
  copyTextureToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
  }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  resolveQuerySet(querySet, destination, options) {
  }
}
class WEBGLVertexArray extends VertexArray {
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  device;
  handle;
  /** Attribute 0 buffer constant */
  buffer = null;
  bufferValue = null;
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(device) {
    return getBrowser() === "Chrome";
  }
  // Create a VertexArray
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.handle = this.device.gl.createVertexArray();
  }
  destroy() {
    super.destroy();
    if (this.buffer) {
      this.buffer?.destroy();
    }
    if (this.handle) {
      this.device.gl.deleteVertexArray(this.handle);
      this.handle = void 0;
    }
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(indexBuffer) {
    const buffer = indexBuffer;
    if (buffer && buffer.glTarget !== 34963) {
      throw new Error("Use .setBuffer()");
    }
    this.device.gl.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);
    this.indexBuffer = buffer;
    this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(location, attributeBuffer) {
    const buffer = attributeBuffer;
    if (buffer.glTarget === 34963) {
      throw new Error("Use .setIndexBuffer()");
    }
    const { size, type, stride, offset: offset2, normalized, integer, divisor } = this._getAccessor(location);
    this.device.gl.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(34962, buffer.handle);
    if (integer) {
      this.device.gl.vertexAttribIPointer(location, size, type, stride, offset2);
    } else {
      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset2);
    }
    this.device.gl.bindBuffer(34962, null);
    this.device.gl.enableVertexAttribArray(location);
    this.device.gl.vertexAttribDivisor(location, divisor || 0);
    this.attributes[location] = buffer;
    this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(location, value) {
    this._enable(location, false);
    this.attributes[location] = value;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle);
    this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let location = 0; location < this.maxVertexAttributes; ++location) {
      const constant2 = this.attributes[location];
      if (ArrayBuffer.isView(constant2)) {
        this.device.setConstantAttributeWebGL(location, constant2);
      }
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(location) {
    const attributeInfo = this.attributeInfos[location];
    if (!attributeInfo) {
      throw new Error(`Unknown attribute location ${location}`);
    }
    const glType = getGLFromVertexType(attributeInfo.bufferDataType);
    return {
      size: attributeInfo.bufferComponents,
      type: glType,
      stride: attributeInfo.byteStride,
      offset: attributeInfo.byteOffset,
      normalized: attributeInfo.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: attributeInfo.integer,
      divisor: attributeInfo.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(location, enable2 = true) {
    const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
    const canDisableAttribute = canDisableAttributeZero || location !== 0;
    if (enable2 || canDisableAttribute) {
      location = Number(location);
      this.device.gl.bindVertexArray(this.handle);
      if (enable2) {
        this.device.gl.enableVertexAttribArray(location);
      } else {
        this.device.gl.disableVertexAttribArray(location);
      }
      this.device.gl.bindVertexArray(null);
    }
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(elementCount, value) {
    const constantValue = normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    if (this.buffer && byteLength !== this.buffer.byteLength) {
      throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
    }
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || this.device.createBuffer({ byteLength });
    updateNeeded = updateNeeded || !compareConstantArrayValues$1(constantValue, this.bufferValue);
    if (updateNeeded) {
      const typedArray = getScratchArray(value.constructor, length);
      fillArray$1({ target: typedArray, source: constantValue, start: 0, count: length });
      this.buffer.write(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
}
function normalizeConstantArrayValue(arrayValue) {
  if (Array.isArray(arrayValue)) {
    return new Float32Array(arrayValue);
  }
  return arrayValue;
}
function compareConstantArrayValues$1(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i = 0; i < v1.length; ++i) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
}
class WEBGLTransformFeedback extends TransformFeedback {
  device;
  gl;
  handle;
  /**
   * NOTE: The Model already has this information while drawing, but
   * TransformFeedback currently needs it internally, to look up
   * varying information outside of a draw() call.
   */
  layout;
  buffers = {};
  unusedBuffers = {};
  /**
   * Allows us to avoid a Chrome bug where a buffer that is already bound to a
   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
   */
  bindOnUse = true;
  _bound = false;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || this.gl.createTransformFeedback();
    this.layout = this.props.layout;
    if (props.buffers) {
      this.setBuffers(props.buffers);
    }
    Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle);
    super.destroy();
  }
  begin(topology = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle);
    if (this.bindOnUse) {
      this._bindBuffers();
    }
    this.gl.beginTransformFeedback(getGLPrimitive(topology));
  }
  end() {
    this.gl.endTransformFeedback();
    if (this.bindOnUse) {
      this._unbindBuffers();
    }
    this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(buffers) {
    this.buffers = {};
    this.unusedBuffers = {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
  }
  setBuffer(locationOrName, bufferOrRange) {
    const location = this._getVaryingIndex(locationOrName);
    const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
    if (location < 0) {
      this.unusedBuffers[locationOrName] = buffer;
      log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
      return;
    }
    this.buffers[location] = { buffer, byteLength, byteOffset };
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteLength);
    }
  }
  getBuffer(locationOrName) {
    if (isIndex(locationOrName)) {
      return this.buffers[locationOrName] || null;
    }
    const location = this._getVaryingIndex(locationOrName);
    return location >= 0 ? this.buffers[location] : null;
  }
  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== "function") {
      this.gl.bindTransformFeedback(36386, funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this.gl.bindTransformFeedback(36386, this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this.gl.bindTransformFeedback(36386, null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(bufferOrRange) {
    if (bufferOrRange instanceof WEBGLBuffer) {
      return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
    }
    const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
    return { buffer, byteOffset, byteLength };
  }
  _getVaryingIndex(locationOrName) {
    if (isIndex(locationOrName)) {
      return Number(locationOrName);
    }
    for (const varying of this.layout.varyings) {
      if (locationOrName === varying.name) {
        return varying.location;
      }
    }
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const bufferIndex in this.buffers) {
      const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
    }
  }
  _unbindBuffers() {
    for (const bufferIndex in this.buffers) {
      this.gl.bindBufferBase(35982, Number(bufferIndex), null);
    }
  }
  _bindBuffer(index2, buffer, byteOffset = 0, byteLength) {
    const handle = buffer && buffer.handle;
    if (!handle || byteLength === void 0) {
      this.gl.bindBufferBase(35982, index2, handle);
    } else {
      this.gl.bindBufferRange(35982, index2, handle, byteOffset, byteLength);
    }
  }
}
function isIndex(value) {
  if (typeof value === "number") {
    return Number.isInteger(value);
  }
  return /^\d+$/.test(value);
}
class WEBGLQuerySet extends QuerySet {
  device;
  handle;
  target = null;
  _queryPending = false;
  _pollingPromise = null;
  get [Symbol.toStringTag]() {
    return "Query";
  }
  // Create a query class
  constructor(device, props) {
    super(device, props);
    this.device = device;
    if (props.count > 1) {
      throw new Error("WebGL QuerySet can only have one value");
    }
    this.handle = this.device.gl.createQuery();
    Object.seal(this);
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(options) {
    return this._begin(options?.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    const value = await this.pollQuery();
    return [value];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(target) {
    if (this._queryPending) {
      return;
    }
    this.target = target;
    this.device.gl.beginQuery(this.target, this.handle);
    return;
  }
  // ends the current query
  _end() {
    if (this._queryPending) {
      return;
    }
    if (this.target) {
      this.device.gl.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }
    return;
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }
    const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);
    if (resultAvailable) {
      this._queryPending = false;
    }
    return resultAvailable;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(limit = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise) {
      return this._pollingPromise;
    }
    let counter2 = 0;
    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter2++ > limit) {
          reject("Timed out");
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };
      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }
}
function glFormatToComponents(format2) {
  switch (format2) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      assert$3(false);
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      assert$3(false);
      return 0;
  }
}
function readPixelsToArray(source, options) {
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408,
    sourceAttachment = 36064
    // TODO - support gl.readBuffer
  } = options || {};
  let {
    target = null,
    // following parameters are auto deduced if not provided
    sourceWidth,
    sourceHeight,
    sourceType
  } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer$1(source);
  assert$3(framebuffer);
  const { gl, handle } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const attachment = sourceAttachment - 36064;
  sourceType = sourceType || framebuffer.colorAttachments[attachment]?.texture?.type || 5121;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || getGLTypeFromTypedArray(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return target;
}
function readPixelsToBuffer(source, options) {
  const { target, sourceX = 0, sourceY = 0, sourceFormat = 6408, targetByteOffset = 0 } = options || {};
  let { sourceWidth, sourceHeight, sourceType } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer$1(source);
  assert$3(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const webglFramebuffer = framebuffer;
  sourceType = sourceType || 5121;
  let webglBufferTarget = target;
  if (!webglBufferTarget) {
    const components = glFormatToComponents(sourceFormat);
    const byteCount = glTypeToBytes(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
  }
  const commandEncoder = source.device.createCommandEncoder();
  commandEncoder.copyTextureToBuffer({
    source,
    width: sourceWidth,
    height: sourceHeight,
    origin: [sourceX, sourceY],
    destination: webglBufferTarget,
    byteOffset: targetByteOffset
  });
  commandEncoder.destroy();
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return webglBufferTarget;
}
function getFramebuffer$1(source) {
  if (!(source instanceof Framebuffer)) {
    return { framebuffer: toFramebuffer(source), deleteFramebuffer: true };
  }
  return { framebuffer: source, deleteFramebuffer: false };
}
function toFramebuffer(texture, props) {
  const { device, width, height, id } = texture;
  const framebuffer = device.createFramebuffer({
    ...props,
    id: `framebuffer-for-${id}`,
    width,
    height,
    colorAttachments: [texture]
  });
  return framebuffer;
}
function getPixelArray(pixelArray, type, format2, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || 5121;
  const ArrayType2 = getTypedArrayFromGLType(type, { clamped: false });
  const components = glFormatToComponents(format2);
  return new ArrayType2(width * height * components);
}
const GL_DEPTH_BUFFER_BIT = 256;
const GL_STENCIL_BUFFER_BIT = 1024;
const GL_COLOR_BUFFER_BIT = 16384;
const ERR_ARGUMENTS = "clear: bad arguments";
function clear(device, options) {
  const { framebuffer = null, color: color2 = null, depth = null, stencil = null } = options || {};
  const parameters = {};
  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }
  let clearFlags = 0;
  if (color2) {
    clearFlags |= GL_COLOR_BUFFER_BIT;
    if (color2 !== true) {
      parameters.clearColor = color2;
    }
  }
  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }
  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }
  assert$3(clearFlags !== 0, ERR_ARGUMENTS);
  const gl = device.gl;
  withGLParameters(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}
const LOG_LEVEL = 1;
class WebGLDevice extends Device {
  //
  // Public `Device` API
  //
  /** type of this device */
  static type = "webgl";
  /** type of this device */
  type = "webgl";
  /** The underlying WebGL context */
  handle;
  features;
  limits;
  info;
  canvasContext;
  lost;
  _resolveContextLost;
  //
  // Static methods, expected to be present by `luma.createDevice()`
  //
  /** Check if WebGL 2 is available */
  static isSupported() {
    return typeof WebGL2RenderingContext !== "undefined";
  }
  /**
   * Get a device instance from a GL context
   * Creates and instruments the device if not already created
   * @param gl
   * @returns
   */
  static attach(gl) {
    if (gl instanceof WebGLDevice) {
      return gl;
    }
    if (gl?.device instanceof Device) {
      return gl.device;
    }
    if (!isWebGL(gl)) {
      throw new Error("Invalid WebGL2RenderingContext");
    }
    return new WebGLDevice({ gl });
  }
  static async create(props = {}) {
    log.groupCollapsed(LOG_LEVEL, "WebGLDevice created")();
    const promises = [];
    if (props.debug) {
      promises.push(loadWebGLDeveloperTools());
    }
    if (props.spector) {
      promises.push(loadSpectorJS());
    }
    if (typeof props.canvas === "string") {
      promises.push(CanvasContext.pageLoaded);
    }
    const results = await Promise.allSettled(promises);
    for (const result of results) {
      if (result.status === "rejected") {
        log.error(`Failed to initialize debug libraries ${result.reason}`)();
      }
    }
    log.probe(LOG_LEVEL + 1, "DOM is loaded")();
    if (props.gl?.device) {
      log.warn("reattaching existing device")();
      return WebGLDevice.attach(props.gl);
    }
    const device = new WebGLDevice(props);
    const message2 = `Created ${device.type}${device.debug ? " debug" : ""} context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
    log.probe(LOG_LEVEL, message2)();
    log.table(LOG_LEVEL, device.info)();
    log.groupEnd(LOG_LEVEL)();
    return device;
  }
  //
  // Public API
  //
  constructor(props) {
    super({ ...props, id: props.id || uid("webgl-device") });
    const device = props.gl?.device;
    if (device) {
      throw new Error(`WebGL context already attached to device ${device.id}`);
    }
    const canvas2 = props.gl?.canvas || props.canvas;
    const autoResize = !props.gl;
    this.canvasContext = new WebGLCanvasContext(this, { ...props, autoResize, canvas: canvas2 });
    this.lost = new Promise((resolve) => {
      this._resolveContextLost = resolve;
    });
    let gl = props.gl || null;
    gl ||= createBrowserContext(this.canvasContext.canvas, {
      ...props,
      onContextLost: (event) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
      })
    });
    if (!gl) {
      throw new Error("WebGL context creation failed");
    }
    this.handle = gl;
    this.gl = gl;
    this.gl.device = this;
    this.gl._version = 2;
    if (props.spector) {
      this.spectorJS = initializeSpectorJS({ ...this.props, canvas: this.handle.canvas });
    }
    this.info = getDeviceInfo(this.gl, this._extensions);
    this.limits = new WebGLDeviceLimits(this.gl);
    this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props.disabledFeatures);
    if (this.props.initalizeFeatures) {
      this.features.initializeFeatures();
    }
    if (autoResize) {
      this.canvasContext.resize();
    }
    const { enable: enable2 = true, copyState = false } = props;
    trackContextState(this.gl, {
      enable: enable2,
      copyState
    });
    if (props.debug) {
      this.gl = makeDebugContext(this.gl, { ...props, throwOnError: true });
      this.debug = true;
      log.level = Math.max(log.level, 1);
      log.warn("WebGL debug mode activated. Performance reduced.")();
    }
  }
  /**
   * Destroys the context
   * @note Has no effect for WebGL browser contexts, there is no browser API for destroying contexts
   */
  destroy() {
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  getSize() {
    return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
  }
  isTextureFormatSupported(format2) {
    return isTextureFormatSupported(this.gl, format2, this._extensions);
  }
  isTextureFormatFilterable(format2) {
    return isTextureFormatFilterable(this.gl, format2, this._extensions);
  }
  isTextureFormatRenderable(format2) {
    return isTextureFormatRenderable(this.gl, format2, this._extensions);
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(props) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(props) {
    const newProps = this._getBufferProps(props);
    return new WEBGLBuffer(this, newProps);
  }
  _createTexture(props) {
    return new WEBGLTexture(this, props);
  }
  createExternalTexture(props) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(props) {
    return new WEBGLSampler(this, props);
  }
  createShader(props) {
    return new WEBGLShader(this, props);
  }
  createFramebuffer(props) {
    return new WEBGLFramebuffer(this, props);
  }
  createVertexArray(props) {
    return new WEBGLVertexArray(this, props);
  }
  createTransformFeedback(props) {
    return new WEBGLTransformFeedback(this, props);
  }
  createQuerySet(props) {
    return new WEBGLQuerySet(this, props);
  }
  createRenderPipeline(props) {
    return new WEBGLRenderPipeline(this, props);
  }
  beginRenderPass(props) {
    return new WEBGLRenderPass(this, props);
  }
  createComputePipeline(props) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(props) {
    throw new Error("ComputePass not supported in WebGL");
  }
  renderPass = null;
  createCommandEncoder(props) {
    return new WEBGLCommandEncoder(this, props);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    this.renderPass?.end();
    this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(source, options) {
    return readPixelsToArray(source, options);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(source, options) {
    return readPixelsToBuffer(source, options);
  }
  setParametersWebGL(parameters) {
    setGLParameters(this.gl, parameters);
  }
  getParametersWebGL(parameters) {
    return getGLParameters(this.gl, parameters);
  }
  withParametersWebGL(parameters, func) {
    return withGLParameters(this.gl, parameters, func);
  }
  clearWebGL(options) {
    clear(this, options);
  }
  resetWebGL() {
    log.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")();
    resetGLParameters(this.gl);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /** WebGL2 context. */
  gl;
  debug = false;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** State used by luma.gl classes - TODO - not used? */
  _extensions = {};
  _polyfilled = false;
  /** Instance of Spector.js (if initialized) */
  spectorJS;
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    let deviceLossTriggered = false;
    const extensions = this.getExtension("WEBGL_lose_context");
    const ext = extensions.WEBGL_lose_context;
    if (ext) {
      deviceLossTriggered = true;
      ext.loseContext();
    }
    this._resolveContextLost?.({
      reason: "destroyed",
      message: "Application triggered context loss"
    });
    return deviceLossTriggered;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    pushContextState(this.gl);
  }
  /** Restores previously saved context state */
  popState() {
    popContextState(this.gl);
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(handle, props) {
    handle.__SPECTOR_Metadata = props;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(value, gl) {
    gl = gl || this.gl2 || this.gl;
    const number2 = Number(value);
    for (const key in gl) {
      if (gl[key] === number2) {
        return `GL.${key}`;
      }
    }
    return String(value);
  }
  /** Store constants */
  _constants;
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(location, constant2) {
    const maxVertexAttributes = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
    const currentConstant = this._constants[location];
    if (currentConstant && compareConstantArrayValues(currentConstant, constant2)) {
      log.info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();
    }
    this._constants[location] = constant2;
    switch (constant2.constructor) {
      case Float32Array:
        setConstantFloatArray(this, location, constant2);
        break;
      case Int32Array:
        setConstantIntArray(this, location, constant2);
        break;
      case Uint32Array:
        setConstantUintArray(this, location, constant2);
        break;
      default:
        assert$3(false);
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(name2) {
    getWebGLExtension(this.gl, name2, this._extensions);
    return this._extensions;
  }
}
function isWebGL(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function setConstantFloatArray(device, location, array2) {
  switch (array2.length) {
    case 1:
      device.gl.vertexAttrib1fv(location, array2);
      break;
    case 2:
      device.gl.vertexAttrib2fv(location, array2);
      break;
    case 3:
      device.gl.vertexAttrib3fv(location, array2);
      break;
    case 4:
      device.gl.vertexAttrib4fv(location, array2);
      break;
    default:
      assert$3(false);
  }
}
function setConstantIntArray(device, location, array2) {
  device.gl.vertexAttribI4iv(location, array2);
}
function setConstantUintArray(device, location, array2) {
  device.gl.vertexAttribI4uiv(location, array2);
}
function compareConstantArrayValues(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i = 0; i < v1.length; ++i) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
}
var hammer$1 = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
var hasRequiredHammer;
function requireHammer() {
  if (hasRequiredHammer) return hammer$1.exports;
  hasRequiredHammer = 1;
  (function(module) {
    (function(window2, document2, exportName, undefined$1) {
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round2 = Math.round;
      var abs = Math.abs;
      var now2 = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined$1) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      function deprecate(method, name2, message2) {
        var deprecationMessage = "DEPRECATED METHOD: " + name2 + "\n" + message2 + " AT \n";
        return function() {
          var e = new Error("get-stack-trace");
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log3 = window2.console && (window2.console.warn || window2.console.log);
          if (log3) {
            log3.call(window2.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign2;
      if (typeof Object.assign !== "function") {
        assign2 = function assign3(target) {
          if (target === undefined$1 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index2 = 1; index2 < arguments.length; index2++) {
            var source = arguments[index2];
            if (source !== undefined$1 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign2 = Object.assign;
      }
      var extend2 = deprecate(function extend3(dest, src, merge2) {
        var keys2 = Object.keys(src);
        var i = 0;
        while (i < keys2.length) {
          if (!merge2 || merge2 && dest[keys2[i]] === undefined$1) {
            dest[keys2[i]] = src[keys2[i]];
          }
          i++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge = deprecate(function merge2(dest, src) {
        return extend2(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign2(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined$1 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }
      function inStr(str, find2) {
        return str.indexOf(find2) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find2, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find2);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find2 || !findByKey && src[i] === find2) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray3(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = src[i][key];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        {
          {
            results = results.sort(function sortUniqueArray(a2, b) {
              return a2[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix2, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix2 = VENDOR_PREFIXES[i];
          prop = prefix2 ? prefix2 + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined$1;
      }
      var _uniqueId = 1;
      function uniqueId3() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window2;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined$1;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START2 = 1;
      var INPUT_MOVE2 = 2;
      var INPUT_END2 = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input2(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input2.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type2;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type2 = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type2 = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type2 = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type2 = MouseInput;
        } else {
          Type2 = TouchMouseInput;
        }
        return new Type2(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now2();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset2 = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset2 = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset2.x);
        input.deltaY = prevDelta.y + (center.y - offset2.y);
      }
      function computeIntervalInputData(session, input) {
        var last2 = session.lastInterval || input, deltaTime = input.timeStamp - last2.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last2.velocity === undefined$1)) {
          var deltaX = input.deltaX - last2.deltaX;
          var deltaY = input.deltaY - last2.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last2.velocity;
          velocityX = last2.velocityX;
          velocityY = last2.velocityY;
          direction = last2.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round2(input.pointers[i].clientX),
            clientY: round2(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now2(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round2(pointers[0].clientX),
            y: round2(pointers[0].clientY)
          };
        }
        var x2 = 0, y2 = 0, i = 0;
        while (i < pointersLength) {
          x2 += pointers[i].clientX;
          y2 += pointers[i].clientY;
          i++;
        }
        return {
          x: round2(x2 / pointersLength),
          y: round2(y2 / pointersLength)
        };
      }
      function getVelocity(deltaTime, x2, y2) {
        return {
          x: x2 / deltaTime || 0,
          y: y2 / deltaTime || 0
        };
      }
      function getDirection(x2, y2) {
        if (x2 === y2) {
          return DIRECTION_NONE;
        }
        if (abs(x2) >= abs(y2)) {
          return x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x2 = p2[props[0]] - p1[props[0]], y2 = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x2 * x2 + y2 * y2);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x2 = p2[props[0]] - p1[props[0]], y2 = p2[props[1]] - p1[props[1]];
        return Math.atan2(y2, x2) * 180 / Math.PI;
      }
      function getRotation(start2, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start2[1], start2[0], PROPS_CLIENT_XY);
      }
      function getScale(start2, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start2[0], start2[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP2 = {
        mousedown: INPUT_START2,
        mousemove: INPUT_MOVE2,
        mouseup: INPUT_END2
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input2.apply(this, arguments);
      }
      inherit(MouseInput, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP2[ev.type];
          if (eventType & INPUT_START2 && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE2 && ev.which !== 1) {
            eventType = INPUT_END2;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END2) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START2,
        pointermove: INPUT_MOVE2,
        pointerup: INPUT_END2,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent && !window2.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input2.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch3 = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START2 && (ev.button === 0 || isTouch3)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input2.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input2, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START2) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray3(ev.touches);
        var changed = toArray3(ev.changedTouches);
        if (type & (INPUT_END2 | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier");
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input2.apply(this, arguments);
      }
      inherit(TouchInput, Input2, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray3(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray3(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START2) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier"),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input2.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input2, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch3 = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch3) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START2) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x2 = eventData.srcEvent.clientX, y2 = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x2 - t.x), dy = Math.abs(y2 - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window2.CSS && window2.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign2({}, this.defaults, options || {});
        this.id = uniqueId3();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          assign2(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index2 = inArray(this.requireFail, otherRecognizer);
          if (index2 > -1) {
            this.requireFail.splice(index2, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign2({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END2) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction; // What happens here?????
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance2 = input.distance;
          var direction = input.direction;
          var x2 = input.deltaX;
          var y2 = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x2 === 0 ? DIRECTION_NONE : x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x2 != this.pX;
              distance2 = Math.abs(input.deltaX);
            } else {
              direction = y2 === 0 ? DIRECTION_NONE : y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y2 != this.pY;
              distance2 = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance2 > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START2) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END2) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END2) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now2();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START2 && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END2) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer2(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer2.defaults.preset);
        return new Manager2(element, options);
      }
      Hammer2.VERSION = "2.0.7";
      Hammer2.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager2(element, options) {
        this.options = assign2({}, Hammer2.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager2.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          assign2(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index2 = inArray(recognizers, recognizer);
            if (index2 !== -1) {
              recognizers.splice(index2, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
          if (events === undefined$1) {
            return;
          }
          if (handler === undefined$1) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
          if (events === undefined$1) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add2) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name2) {
          prop = prefixed(element.style, name2);
          if (add2) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add2) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign2(Hammer2, {
        INPUT_START: INPUT_START2,
        INPUT_MOVE: INPUT_MOVE2,
        INPUT_END: INPUT_END2,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager: Manager2,
        Input: Input2,
        TouchAction,
        TouchInput,
        MouseInput,
        PointerEventInput,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge,
        extend: extend2,
        assign: assign2,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer2;
      if (module.exports) {
        module.exports = Hammer2;
      } else {
        window2[exportName] = Hammer2;
      }
    })(window, document, "Hammer");
  })(hammer$1);
  return hammer$1.exports;
}
var hammerExports = requireHammer();
const hammer = /* @__PURE__ */ getDefaultExportFromCjs(hammerExports);
const hammerjs = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hammer
}, [hammerExports]);
const INPUT_START = 1;
const INPUT_MOVE = 2;
const INPUT_END = 4;
const MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
function some(array2, predict) {
  for (let i = 0; i < array2.length; i++) {
    if (predict(array2[i])) {
      return true;
    }
  }
  return false;
}
function enhancePointerEventInput(PointerEventInput) {
  const oldHandler = PointerEventInput.prototype.handler;
  PointerEventInput.prototype.handler = function handler(ev) {
    const store = this.store;
    if (ev.button > 0 && ev.type === "pointerdown") {
      if (!some(store, (e) => e.pointerId === ev.pointerId)) {
        store.push(ev);
      }
    }
    oldHandler.call(this, ev);
  };
}
function enhanceMouseInput(MouseInput) {
  MouseInput.prototype.handler = function handler(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];
    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.buttons === 0) {
      eventType = INPUT_END;
    }
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: "mouse",
      srcEvent: ev
    });
  };
}
enhancePointerEventInput(hammerExports.PointerEventInput);
enhanceMouseInput(hammerExports.MouseInput);
const Manager = hammerExports.Manager;
class Input {
  constructor(element, callback, options) {
    this.element = element;
    this.callback = callback;
    this.options = { enable: true, ...options };
  }
}
const RECOGNIZERS = hammerjs ? [
  [hammerjs.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
  [hammerjs.Rotate, { enable: false }],
  [hammerjs.Pinch, { enable: false }],
  [hammerjs.Swipe, { enable: false }],
  [hammerjs.Pan, { threshold: 0, enable: false }],
  [hammerjs.Press, { enable: false }],
  [hammerjs.Tap, { event: "doubletap", taps: 2, enable: false }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [hammerjs.Tap, { event: "anytap", enable: false }],
  [hammerjs.Tap, { enable: false }]
] : null;
const RECOGNIZER_COMPATIBLE_MAP = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
};
const RECOGNIZER_FALLBACK_MAP = {
  doubletap: ["tap"]
};
const BASIC_EVENT_ALIASES = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
};
const INPUT_EVENT_TYPES = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
};
const EVENT_RECOGNIZER_MAP = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
};
const GESTURE_EVENT_ALIASES = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
};
const userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
const window_ = typeof window !== "undefined" ? window : global;
let passiveSupported = false;
try {
  const options = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      passiveSupported = true;
      return true;
    }
  };
  window_.addEventListener("test", null, options);
  window_.removeEventListener("test", null);
} catch (err) {
  passiveSupported = false;
}
const firefox = userAgent.indexOf("firefox") !== -1;
const { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
const EVENT_TYPE$1 = "wheel";
const WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const WHEEL_DELTA_PER_LINE = 40;
const SHIFT_MULTIPLIER = 0.25;
class WheelInput extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      let value = event.deltaY;
      if (window_.WheelEvent) {
        if (firefox && event.deltaMode === window_.WheelEvent.DOM_DELTA_PIXEL) {
          value /= window_.devicePixelRatio;
        }
        if (event.deltaMode === window_.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }
      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }
      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }
      this.callback({
        type: EVENT_TYPE$1,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        delta: -value,
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    this.events = (this.options.events || []).concat(WHEEL_EVENTS);
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE$1) {
      this.options.enable = enabled;
    }
  }
}
const { MOUSE_EVENTS: MOUSE_EVENTS$1 } = INPUT_EVENT_TYPES;
const MOVE_EVENT_TYPE = "pointermove";
const OVER_EVENT_TYPE = "pointerover";
const OUT_EVENT_TYPE = "pointerout";
const ENTER_EVENT_TYPE = "pointerenter";
const LEAVE_EVENT_TYPE = "pointerleave";
class MoveInput extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleEnterEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    };
    this.pressed = false;
    const { enable: enable2 } = this.options;
    this.enableMoveEvent = enable2;
    this.enableLeaveEvent = enable2;
    this.enableEnterEvent = enable2;
    this.enableOutEvent = enable2;
    this.enableOverEvent = enable2;
    this.events = (this.options.events || []).concat(MOUSE_EVENTS$1);
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === MOVE_EVENT_TYPE) {
      this.enableMoveEvent = enabled;
    }
    if (eventType === OVER_EVENT_TYPE) {
      this.enableOverEvent = enabled;
    }
    if (eventType === OUT_EVENT_TYPE) {
      this.enableOutEvent = enabled;
    }
    if (eventType === ENTER_EVENT_TYPE) {
      this.enableEnterEvent = enabled;
    }
    if (eventType === LEAVE_EVENT_TYPE) {
      this.enableLeaveEvent = enabled;
    }
  }
  handleOverEvent(event) {
    if (this.enableOverEvent) {
      if (event.type === "mouseover") {
        this._emit(OVER_EVENT_TYPE, event);
      }
    }
  }
  handleOutEvent(event) {
    if (this.enableOutEvent) {
      if (event.type === "mouseout") {
        this._emit(OUT_EVENT_TYPE, event);
      }
    }
  }
  handleEnterEvent(event) {
    if (this.enableEnterEvent) {
      if (event.type === "mouseenter") {
        this._emit(ENTER_EVENT_TYPE, event);
      }
    }
  }
  handleLeaveEvent(event) {
    if (this.enableLeaveEvent) {
      if (event.type === "mouseleave") {
        this._emit(LEAVE_EVENT_TYPE, event);
      }
    }
  }
  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case "mousedown":
          if (event.button >= 0) {
            this.pressed = true;
          }
          break;
        case "mousemove":
          if (event.buttons === 0) {
            this.pressed = false;
          }
          if (!this.pressed) {
            this._emit(MOVE_EVENT_TYPE, event);
          }
          break;
        case "mouseup":
          this.pressed = false;
          break;
      }
    }
  }
  _emit(type, event) {
    this.callback({
      type,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: "mouse",
      target: event.target
    });
  }
}
const { KEY_EVENTS } = INPUT_EVENT_TYPES; // HERE ???????
const DOWN_EVENT_TYPE = "keydown";
const UP_EVENT_TYPE = "keyup";
class KeyInput extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      const targetElement = event.target || event.srcElement;
      if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
        return;
      }
      if (this.enableDownEvent && event.type === "keydown") {
        this.callback({
          type: DOWN_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
      if (this.enableUpEvent && event.type === "keyup") {
        this.callback({
          type: UP_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    };
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = (this.options.events || []).concat(KEY_EVENTS);
    element.tabIndex = this.options.tabIndex || 0;
    element.style.outline = "none";
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === DOWN_EVENT_TYPE) {
      this.enableDownEvent = enabled;
    }
    if (eventType === UP_EVENT_TYPE) {
      this.enableUpEvent = enabled;
    }
  }
}
const EVENT_TYPE = "contextmenu";
class ContextmenuInput extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    element.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }
}
const DOWN_EVENT = 1;
const MOVE_EVENT = 2;
const UP_EVENT = 4;
const MOUSE_EVENTS = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
const MOUSE_EVENT_BUTTON_LEFT = 0;
const MOUSE_EVENT_BUTTON_MIDDLE = 1;
const MOUSE_EVENT_BUTTON_RIGHT = 2;
const MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
function whichButtons(event) {
  const eventType = MOUSE_EVENTS[event.srcEvent.type];
  if (!eventType) {
    return null;
  }
  const { buttons, button } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return { leftButton, middleButton, rightButton };
}
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  if (!center) {
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  const scaleX2 = rect.width / rootElement.offsetWidth || 1;
  const scaleY2 = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY2
  };
  return { center, offsetCenter };
}
const DEFAULT_OPTIONS$1 = {
  srcElement: "root",
  priority: 0
};
class EventRegistrar {
  constructor(eventManager) {
    this.handleEvent = (event) => {
      if (this.isEmpty()) {
        return;
      }
      const mjolnirEvent = this._normalizeEvent(event);
      let target = event.srcEvent.target;
      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);
        if (mjolnirEvent.handled) {
          return;
        }
        target = target.parentNode;
      }
      this._emit(mjolnirEvent, "root");
    };
    this.eventManager = eventManager;
    this.handlers = [];
    this.handlersByElement = /* @__PURE__ */ new Map();
    this._active = false;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(type, handler, options, once = false, passive = false) {
    const { handlers, handlersByElement } = this;
    let opts = DEFAULT_OPTIONS$1;
    if (typeof options === "string" || options && options.addEventListener) {
      opts = { ...DEFAULT_OPTIONS$1, srcElement: options };
    } else if (options) {
      opts = { ...DEFAULT_OPTIONS$1, ...options };
    }
    let entries = handlersByElement.get(opts.srcElement);
    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }
    const entry = {
      type,
      handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };
    if (once) {
      entry.once = true;
    }
    if (passive) {
      entry.passive = true;
    }
    handlers.push(entry);
    this._active = this._active || !entry.passive;
    let insertPosition = entries.length - 1;
    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }
      insertPosition--;
    }
    entries.splice(insertPosition + 1, 0, entry);
  }
  remove(type, handler) {
    const { handlers, handlersByElement } = this;
    for (let i = handlers.length - 1; i >= 0; i--) {
      const entry = handlers[i];
      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);
        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }
    this._active = handlers.some((entry) => !entry.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);
    if (entries) {
      let immediatePropagationStopped = false;
      const stopPropagation = () => {
        event.handled = true;
      };
      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };
      const entriesToRemove = [];
      for (let i = 0; i < entries.length; i++) {
        const { type, handler, once } = entries[i];
        handler({
          ...event,
          // @ts-ignore
          type,
          stopPropagation,
          stopImmediatePropagation
        });
        if (once) {
          entriesToRemove.push(entries[i]);
        }
        if (immediatePropagationStopped) {
          break;
        }
      }
      for (let i = 0; i < entriesToRemove.length; i++) {
        const { type, handler } = entriesToRemove[i];
        this.remove(type, handler);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(event) {
    const rootElement = this.eventManager.getElement();
    return {
      ...event,
      ...whichButtons(event),
      ...getOffsetPosition(event, rootElement),
      preventDefault: () => {
        event.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: false,
      rootElement
    };
  }
}
const DEFAULT_OPTIONS = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class EventManager {
  constructor(element = null, options) {
    this._onBasicInput = (event) => {
      const { srcEvent } = event;
      const alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        this.manager.emit(alias, event);
      }
    };
    this._onOtherEvent = (event) => {
      this.manager.emit(event.type, event);
    };
    this.options = { ...DEFAULT_OPTIONS, ...options };
    this.events = /* @__PURE__ */ new Map();
    this.setElement(element);
    const { events } = this.options;
    if (events) {
      this.on(events);
    }
  }
  getElement() {
    return this.element;
  }
  setElement(element) {
    if (this.element) {
      this.destroy();
    }
    this.element = element;
    if (!element) {
      return;
    }
    const { options } = this;
    const ManagerClass = options.Manager;
    this.manager = new ManagerClass(element, {
      touchAction: options.touchAction,
      recognizers: options.recognizers || RECOGNIZERS
    }).on("hammer.input", this._onBasicInput);
    if (!options.recognizers) {
      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name2) => {
        const recognizer = this.manager.get(name2);
        if (recognizer) {
          RECOGNIZER_COMPATIBLE_MAP[name2].forEach((otherName) => {
            recognizer.recognizeWith(otherName);
          });
        }
      });
    }
    for (const recognizerName in options.recognizerOptions) {
      const recognizer = this.manager.get(recognizerName);
      if (recognizer) {
        const recognizerOption = options.recognizerOptions[recognizerName];
        delete recognizerOption.enable;
        recognizer.set(recognizerOption);
      }
    }
    this.wheelInput = new WheelInput(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new MoveInput(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new KeyInput(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
      enable: false
    });
    for (const [eventAlias, eventRegistrar] of this.events) {
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
        this.manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
  }
  // Tear down internal event management implementations.
  destroy() {
    if (this.element) {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
      this.wheelInput = null;
      this.moveInput = null;
      this.keyInput = null;
      this.contextmenuInput = null;
      this.manager = null;
      this.element = null;
    }
  }
  /** Register an event handler function to be called on `event` */
  on(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false);
  }
  once(event, handler, opts) {
    this._addEventHandler(event, handler, opts, true);
  }
  watch(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false, true);
  }
  off(event, handler) {
    this._removeEventHandler(event, handler);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(name2, enabled) {
    const { manager } = this;
    if (!manager) {
      return;
    }
    const recognizer = manager.get(name2);
    if (recognizer && recognizer.options.enable !== enabled) {
      recognizer.set({ enable: enabled });
      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name2];
      if (fallbackRecognizers && !this.options.recognizers) {
        fallbackRecognizers.forEach((otherName) => {
          const otherRecognizer = manager.get(otherName);
          if (enabled) {
            otherRecognizer.requireFailure(name2);
            recognizer.dropRequireFailure(otherName);
          } else {
            otherRecognizer.dropRequireFailure(name2);
          }
        });
      }
    }
    this.wheelInput.enableEventType(name2, enabled);
    this.moveInput.enableEventType(name2, enabled);
    this.keyInput.enableEventType(name2, enabled);
    this.contextmenuInput.enableEventType(name2, enabled);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(event, handler, opts, once, passive) {
    if (typeof event !== "string") {
      opts = handler;
      for (const eventName in event) {
        this._addEventHandler(eventName, event[eventName], opts, once, passive);
      }
      return;
    }
    const { manager, events } = this;
    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    let eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      eventRegistrar = new EventRegistrar(this);
      events.set(eventAlias, eventRegistrar);
      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      if (manager) {
        manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
    eventRegistrar.add(event, handler, opts, once, passive);
    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(event, handler) {
    if (typeof event !== "string") {
      for (const eventName in event) {
        this._removeEventHandler(eventName, event[eventName]);
      }
      return;
    }
    const { events } = this;
    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    const eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      return;
    }
    eventRegistrar.remove(event, handler);
    if (eventRegistrar.isEmpty()) {
      const { recognizerName } = eventRegistrar;
      let isRecognizerUsed = false;
      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }
      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }
}
function noop$1() {
}
const getCursor = ({ isDragging }) => isDragging ? "grabbing" : "grab";
const defaultProps$b = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: { type: "webgl" },
  gl: null,
  glOptions: {},
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: true,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: noop$1,
  onWebGLInitialized: noop$1,
  onResize: noop$1,
  onViewStateChange: noop$1,
  onInteractionStateChange: noop$1,
  onBeforeRender: noop$1,
  onAfterRender: noop$1,
  onLoad: noop$1,
  onError: (error) => defaultLogger.error(error.message, error.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor,
  getTooltip: null,
  debug: false,
  drawPickingColors: false
};
class Deck {
  constructor(props) {
    this.width = 0;
    this.height = 0;
    this.userData = {};
    this.device = null;
    this.canvas = null;
    this.viewManager = null;
    this.layerManager = null;
    this.effectManager = null;
    this.deckRenderer = null;
    this.deckPicker = null;
    this.eventManager = null;
    this.widgetManager = null;
    this.tooltip = null;
    this.animationLoop = null;
    this.cursorState = {
      isHovering: false,
      isDragging: false
    };
    this.stats = new Stats({ id: "deck.gl" });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this._needsRedraw = "Initial render";
    this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    };
    this._lastPointerDownInfo = null;
    this._onPointerMove = (event) => {
      const { _pickRequest } = this;
      if (event.type === "pointerleave") {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;
        if (!pos) {
          return;
        }
        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }
      if (this.layerManager) {
        this.layerManager.context.mousePosition = { x: _pickRequest.x, y: _pickRequest.y };
      }
      _pickRequest.event = event;
    };
    this._onEvent = (event) => {
      const eventOptions = EVENTS[event.type];
      const pos = event.offsetCenter;
      if (!eventOptions || !pos || !this.layerManager) {
        return;
      }
      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const { layer } = info;
      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      const rootHandler = this.props[eventOptions.handler];
      let handled = false;
      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }
      if (!handled) {
        rootHandler?.(info, event);
        this.widgetManager.onEvent(info, event);
      }
    };
    this._onPointerDown = (event) => {
      const pos = event.offsetCenter;
      const pickedInfo = this._pick("pickObject", "pickObject Time", {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    };
    this.props = { ...defaultProps$b, ...props };
    props = this.props;
    if (props.viewState && props.initialViewState) {
      defaultLogger.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
    }
    this.viewState = this.props.initialViewState;
    if (props.device) {
      this.device = props.device;
    } else if (props.gl) {
      if (props.gl instanceof WebGLRenderingContext) {
        defaultLogger.error("WebGL1 context not supported.")();
      }
      this.device = WebGLDevice.attach(props.gl);
    }
    let deviceOrPromise = this.device;
    if (!deviceOrPromise) {
      luma.registerDevices([WebGLDevice]);
      deviceOrPromise = luma.createDevice({
        ...props.deviceProps,
        canvas: this._createCanvas(props)
      });
    }
    this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);
    this.setProps(props);
    if (props._typedArrayManagerProps) {
      defaultTypedArrayManager.setOptions(props._typedArrayManagerProps);
    }
    this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    this.animationLoop?.stop();
    this.animationLoop?.destroy();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;
    this.layerManager?.finalize();
    this.layerManager = null;
    this.viewManager?.finalize();
    this.viewManager = null;
    this.effectManager?.finalize();
    this.effectManager = null;
    this.deckRenderer?.finalize();
    this.deckRenderer = null;
    this.deckPicker?.finalize();
    this.deckPicker = null;
    this.eventManager?.destroy();
    this.eventManager = null;
    this.widgetManager?.finalize();
    this.widgetManager = null;
    if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {
      this.canvas.parentElement?.removeChild(this.canvas);
      this.canvas = null;
    }
  }
  /** Partially update props */
  setProps(props) {
    this.stats.get("setProps Time").timeStart();
    if ("onLayerHover" in props) {
      defaultLogger.removed("onLayerHover", "onHover")();
    }
    if ("onLayerClick" in props) {
      defaultLogger.removed("onLayerClick", "onClick")();
    }
    if (props.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {
      this.viewState = props.initialViewState;
    }
    Object.assign(this.props, props);
    this._setCanvasSize(this.props);
    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    this.animationLoop?.setProps(resolvedProps);
    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
      this.widgetManager.setProps(resolvedProps);
    }
    this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    if (!this.layerManager) {
      return false;
    }
    if (this.props._animate) {
      return "Deck._animate";
    }
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(reason) {
    if (!this.layerManager) {
      return;
    }
    let redrawReason = this.needsRedraw({ clearRedrawFlags: true });
    redrawReason = reason || redrawReason;
    if (!redrawReason) {
      return;
    }
    this.stats.get("Redraw Count").incrementCount();
    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    assert(this.viewManager);
    return this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(rect) {
    assert(this.viewManager);
    return this.viewManager.getViewports(rect);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(opts) {
    const infos = this._pick("pickObject", "pickObject Time", opts).result;
    return infos.length ? infos[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(opts) {
    return this._pick("pickObjects", "pickObjects Time", opts);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({ resourceId: id, data: resources[id], forceUpdate });
    }
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(effect) {
    this.effectManager.addDefaultEffect(effect);
  }
  _addDefaultShaderModule(module) {
    this.layerManager.addDefaultShaderModule(module);
  }
  _removeDefaultShaderModule(module) {
    this.layerManager?.removeDefaultShaderModule(module);
  }
  _pick(method, statKey, opts) {
    assert(this.deckPicker);
    const { stats } = this;
    stats.get("Pick Count").incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }
  /** Resolve props.canvas to element */
  _createCanvas(props) {
    let canvas2 = props.canvas;
    if (typeof canvas2 === "string") {
      canvas2 = document.getElementById(canvas2);
      assert(canvas2);
    }
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      canvas2.id = props.id || "deckgl-overlay";
      const parent = props.parent || document.body;
      parent.appendChild(canvas2);
    }
    Object.assign(canvas2.style, props.style);
    return canvas2;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(props) {
    if (!this.canvas) {
      return;
    }
    const { width, height } = props;
    if (width || width === 0) {
      const cssWidth = Number.isFinite(width) ? `${width}px` : width;
      this.canvas.style.width = cssWidth;
    }
    if (height || height === 0) {
      const cssHeight = Number.isFinite(height) ? `${height}px` : height;
      this.canvas.style.position = props.style?.position || "absolute";
      this.canvas.style.height = cssHeight;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    const { canvas: canvas2 } = this;
    if (!canvas2) {
      return;
    }
    const newWidth = canvas2.clientWidth ?? canvas2.width;
    const newHeight = canvas2.clientHeight ?? canvas2.height;
    if (newWidth !== this.width || newHeight !== this.height) {
      this.width = newWidth;
      this.height = newHeight;
      this.viewManager?.setProps({ width: newWidth, height: newHeight });
      this.layerManager?.activateViewport(this.getViewports()[0]);
      this.props.onResize({ width: newWidth, height: newHeight });
    }
  }
  _createAnimationLoop(deviceOrPromise, props) {
    const {
      // width,
      // height,
      gl,
      // deviceProps,
      // glOptions,
      // debug,
      onError,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels
    } = props;
    return new AnimationLoop({
      device: deviceOrPromise,
      useDevicePixels,
      // TODO v9
      autoResizeDrawingBuffer: !gl,
      // do not auto resize external context
      autoResizeViewport: false,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (context) => this._setDevice(context.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views } = this.props;
    const normalizedViews = Array.isArray(views) ? views : (
      // If null, default to a full screen map view port
      views ? [views] : [new MapView({ id: "default-view" })]
    );
    if (normalizedViews.length && this.props.controller) {
      normalizedViews[0].props.controller = this.props.controller;
    }
    return normalizedViews;
  }
  _onContextLost() {
    const { onError } = this.props;
    if (this.animationLoop && onError) {
      onError(new Error("WebGL context is lost"));
    }
  }
  /** Actually run picking */
  _pickAndCallback() {
    const { _pickRequest } = this;
    if (_pickRequest.event) {
      const { result, emptyInfo } = this._pick("pickObject", "pickObject Time", _pickRequest);
      this.cursorState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;
      for (const info of result) {
        pickedInfo = info;
        handled = info.layer?.onHover(info, _pickRequest.event) || handled;
      }
      if (!handled) {
        this.props.onHover?.(pickedInfo, _pickRequest.event);
        this.widgetManager.onHover(pickedInfo, _pickRequest.event);
      }
      _pickRequest.event = null;
    }
  }
  _updateCursor() {
    const container = this.props.parent || this.canvas;
    if (container) {
      container.style.cursor = this.props.getCursor(this.cursorState);
    }
  }
  _setDevice(device) {
    this.device = device;
    if (!this.animationLoop) {
      return;
    }
    if (!this.canvas) {
      this.canvas = this.device.canvasContext?.canvas;
    }
    this.device.setParametersWebGL({
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthTest: true,
      depthFunc: 515
    });
    this.props.onDeviceInitialized(this.device);
    if (this.device instanceof WebGLDevice) {
      this.props.onWebGLInitialized(this.device.gl);
    }
    const timeline = new Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new EventManager(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const eventType in EVENTS) {
      this.eventManager.on(eventType, this._onEvent);
    }
    this.viewManager = new ViewManager({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new LayerManager(this.device, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new EffectManager({
      deck: this,
      device: this.device
    });
    this.deckRenderer = new DeckRenderer(this.device);
    this.deckPicker = new DeckPicker(this.device);
    this.widgetManager = new WidgetManager({
      deck: this,
      parentElement: this.canvas?.parentElement
    });
    this.widgetManager.addDefault(new Tooltip());
    this.setProps(this.props);
    this._updateCanvasSize();
    this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(redrawReason, renderOptions) {
    const { device, gl } = this.layerManager.context;
    this.props.onBeforeRender({ device, gl });
    const opts = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...renderOptions
    };
    this.deckRenderer?.renderLayers(opts);
    if (opts.pass === "screen") {
      this.widgetManager.onRedraw({
        viewports: opts.viewports,
        layers: opts.layers
      });
    }
    this.props.onAfterRender({ device, gl });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats();
    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();
      this.stats.reset();
      defaultLogger.table(4, this.metrics)();
      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }
    this._updateCanvasSize();
    this._updateCursor();
    this.layerManager.updateLayers();
    this._pickAndCallback();
    this.redraw();
    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }
  // Callbacks
  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;
    if (this.viewState) {
      this.viewState = { ...this.viewState, [params.viewId]: viewState };
      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({ viewState: this.viewState });
        }
      }
    }
  }
  _onInteractionStateChange(interactionState) {
    this.cursorState.isDragging = interactionState.isDragging || false;
    this.props.onInteractionStateChange(interactionState);
  }
  _getFrameStats() {
    const { stats } = this;
    stats.get("frameRate").timeEnd();
    stats.get("frameRate").timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
    stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics, stats } = this;
    metrics.fps = stats.get("frameRate").getHz();
    metrics.setPropsTime = stats.get("setProps Time").time;
    metrics.updateAttributesTime = stats.get("Update Attributes").time;
    metrics.framesRedrawn = stats.get("Redraw Count").count;
    metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
    metrics.pickCount = stats.get("Pick Count").count;
    metrics.gpuTime = stats.get("GPU Time").time;
    metrics.cpuTime = stats.get("CPU Time").time;
    metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
    metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
    const memoryStats = luma.stats.get("Memory Usage");
    metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
    metrics.textureMemory = memoryStats.get("Texture Memory").count;
    metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
    metrics.gpuMemory = memoryStats.get("GPU Memory").count;
  }
}
Deck.defaultProps = defaultProps$b;
Deck.VERSION = VERSION$1;
function typedArrayFromDataType(type) {
  switch (type) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return getTypedArrayFromDataType(type);
  }
}
const dataTypeFromTypedArray = getDataTypeFromTypedArray;
function getBufferAttributeLayout(name2, accessor) {
  return {
    attribute: name2,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: accessor.size > 1 ? `${accessor.type}x${accessor.size}` : accessor.type,
    byteOffset: accessor.offset || 0
    // Note stride is set on the top level
  };
}
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function bufferLayoutEqual(accessor1, accessor2) {
  return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);
}
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    defaultLogger.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  }
  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset2 = (
    // offsets defined by the attribute
    vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + // offsets defined by external buffers if any
    (baseAccessor.offset || 0)
  );
  return {
    ...shaderAttributeOptions,
    offset: offset2,
    stride
  };
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: {
      ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}
class DataColumn {
  /* eslint-disable max-statements */
  constructor(device, opts, state) {
    this._buffer = null;
    this.device = device;
    this.id = opts.id || "";
    this.size = opts.size || 1;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === "float64";
    let { defaultValue } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    let bufferType;
    if (doublePrecision) {
      bufferType = "float32";
    } else if (!logicalType && opts.isIndexed) {
      bufferType = "uint32";
    } else {
      bufferType = logicalType || "float32";
    }
    let defaultType = typedArrayFromDataType(logicalType || bufferType);
    this.doublePrecision = doublePrecision;
    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }
    this.value = null;
    this.settings = {
      ...opts,
      defaultType,
      defaultValue,
      logicalType,
      type: bufferType,
      normalized: bufferType.includes("norm"),
      size: this.size,
      bytesPerElement: defaultType.BYTES_PER_ELEMENT
    };
    this.state = {
      ...state,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const accessor = this.getAccessor();
    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }
    return 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(n) {
    this.state.numInstances = n;
  }
  delete() {
    if (this._buffer) {
      this._buffer.delete();
      this._buffer = null;
    }
    defaultTypedArrayManager.release(this.state.allocatedValue);
  }
  getBuffer() {
    if (this.state.constant) {
      return null;
    }
    return this.state.externalBuffer || this._buffer;
  }
  getValue(attributeName = this.id, options = null) {
    const result = {};
    if (this.state.constant) {
      const value = this.value;
      if (options) {
        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
        const offset2 = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;
        const size = shaderAttributeDef.size || this.size;
        result[attributeName] = value.subarray(offset2, offset2 + size);
      } else {
        result[attributeName] = value;
      }
    } else {
      result[attributeName] = this.getBuffer();
    }
    if (this.doublePrecision) {
      if (this.value instanceof Float64Array) {
        result[`${attributeName}64Low`] = result[attributeName];
      } else {
        result[`${attributeName}64Low`] = new Float32Array(this.size);
      }
    }
    return result;
  }
  _getBufferLayout(attributeName = this.id, options = null) {
    const accessor = this.getAccessor();
    const attributes = [];
    const result = {
      name: this.id,
      byteStride: getStride(accessor),
      attributes
    };
    if (this.doublePrecision) {
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});
      attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...doubleShaderAttributeDefs.high }), getBufferAttributeLayout(`${attributeName}64Low`, {
        ...accessor,
        ...doubleShaderAttributeDefs.low
      }));
    } else if (options) {
      const shaderAttributeDef = resolveShaderAttribute(accessor, options);
      attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...shaderAttributeDef }));
    } else {
      attributes.push(getBufferAttributeLayout(attributeName, accessor));
    }
    return result;
  }
  setAccessor(accessor) {
    this.state.bufferAccessor = accessor;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }
    let result = null;
    if (this.state.constant && this.value) {
      const min2 = Array.from(this.value);
      result = [min2, min2];
    } else {
      const { value, numInstances, size } = this;
      const len = numInstances * size;
      if (value && len && value.length >= len) {
        const min2 = new Array(size).fill(Infinity);
        const max2 = new Array(size).fill(-Infinity);
        for (let i = 0; i < len; ) {
          for (let j = 0; j < size; j++) {
            const v = value[i++];
            if (v < min2[j])
              min2[j] = v;
            if (v > max2[j])
              max2[j] = v;
          }
        }
        result = [min2, max2];
      }
    }
    this.state.bounds = result;
    return result;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(data) {
    const { state } = this;
    let opts;
    if (ArrayBuffer.isView(data)) {
      opts = { value: data };
    } else if (data instanceof Buffer) {
      opts = { buffer: data };
    } else {
      opts = data;
    }
    const accessor = { ...this.settings, ...opts };
    if (ArrayBuffer.isView(opts.value)) {
      if (!opts.type) {
        const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;
        if (is64Bit) {
          accessor.type = "float32";
        } else {
          const type = dataTypeFromTypedArray(opts.value);
          accessor.type = accessor.normalized ? type.replace("int", "norm") : type;
        }
      }
      accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
    }
    state.bounds = null;
    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);
      if (this.settings.normalized) {
        value = this.normalizeConstant(value);
      }
      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
      if (!hasChanged) {
        return false;
      }
      state.externalBuffer = null;
      state.constant = true;
      this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);
    } else if (opts.buffer) {
      const buffer = opts.buffer;
      state.externalBuffer = buffer;
      state.constant = false;
      this.value = opts.value || null;
    } else if (opts.value) {
      this._checkExternalBuffer(opts);
      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      let { buffer } = this;
      const stride = getStride(accessor);
      const byteOffset = (accessor.vertexOffset || 0) * stride;
      if (this.doublePrecision && value instanceof Float64Array) {
        value = toDoublePrecisionArray(value, accessor);
      }
      if (this.settings.isIndexed) {
        const ArrayType2 = this.settings.defaultType;
        if (value.constructor !== ArrayType2) {
          value = new ArrayType2(value);
        }
      }
      const requiredBufferSize = value.byteLength + byteOffset + stride * 2;
      if (!buffer || buffer.byteLength < requiredBufferSize) {
        buffer = this._createBuffer(requiredBufferSize);
      }
      buffer.write(value, byteOffset);
    }
    this.setAccessor(accessor);
    return true;
  }
  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const value = this.value;
    const { startOffset = 0, endOffset } = opts;
    this.buffer.write(this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
      size: this.size,
      startIndex: startOffset,
      endIndex: endOffset
    }) : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(numInstances, copy2 = false) {
    const { state } = this;
    const oldValue = state.allocatedValue;
    const value = defaultTypedArrayManager.allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: copy2
    });
    this.value = value;
    const { byteOffset } = this;
    let { buffer } = this;
    if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {
      buffer = this._createBuffer(value.byteLength + byteOffset);
      if (copy2 && oldValue) {
        buffer.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);
      }
    }
    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    this.setAccessor(this.settings);
    return true;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(opts) {
    const { value } = opts;
    if (!ArrayBuffer.isView(value)) {
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    }
    const ArrayType2 = this.settings.defaultType;
    let illegalArrayType = false;
    if (this.doublePrecision) {
      illegalArrayType = value.BYTES_PER_ELEMENT < 4;
    }
    if (illegalArrayType) {
      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
    }
    if (!(value instanceof ArrayType2) && this.settings.normalized && !("normalized" in opts)) {
      defaultLogger.warn(`Attribute ${this.id} is normalized`)();
    }
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(value) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(value).map((x2) => (x2 + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(value).map((x2) => (x2 + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(value).map((x2) => x2 / 255);
      case "unorm16":
        return new Float32Array(value).map((x2) => x2 / 65535);
      default:
        return value;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(value, out, start2) {
    const { defaultValue, size } = this.settings;
    if (Number.isFinite(value)) {
      out[start2] = value;
      return out;
    }
    if (!value) {
      let i = size;
      while (--i >= 0) {
        out[start2 + i] = defaultValue[i];
      }
      return out;
    }
    switch (size) {
      case 4:
        out[start2 + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
      case 3:
        out[start2 + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
      case 2:
        out[start2 + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
      case 1:
        out[start2 + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;
      default:
        let i = size;
        while (--i >= 0) {
          out[start2 + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }
    }
    return out;
  }
  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }
    const { size } = this;
    for (let i = 0; i < size; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }
    return true;
  }
  _createBuffer(byteLength) {
    if (this._buffer) {
      this._buffer.destroy();
    }
    const { isIndexed, type } = this.settings;
    this._buffer = this.device.createBuffer({
      ...this._buffer?.props,
      id: this.id,
      usage: isIndexed ? Buffer.INDEX : Buffer.VERTEX,
      indexType: isIndexed ? type : void 0,
      byteLength
    });
    return this._buffer;
  }
}
const EMPTY_ARRAY$2 = [];
const placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY$2;
  const objectInfo = {
    index: -1,
    data,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  if (!data) {
    iterable = EMPTY_ARRAY$2;
  } else if (typeof data[Symbol.iterator] === "function") {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return { iterable, objectInfo };
}
function isAsyncIterable(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const { size, stride, offset: offset2, startIndices, nested } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset2 ? offset2 / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_, { index: index2, target }) => {
    if (!startIndices) {
      const sourceIndex = index2 * elementStride + elementOffset;
      for (let j = 0; j < size; j++) {
        target[j] = typedArray[sourceIndex + j];
      }
      return target;
    }
    const startIndex = startIndices[index2];
    const endIndex = startIndices[index2 + 1] || vertexCount;
    let result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        target = new Array(size);
        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        result[i - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        for (let j = 0; j < size; j++) {
          result[targetIndex++] = typedArray[sourceIndex + j];
        }
      }
    }
    return result;
  };
}
const EMPTY = [];
const FULL = [[0, Infinity]];
function add(rangeList, range3) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range3[0] < 0) {
    range3[0] = 0;
  }
  if (range3[0] >= range3[1]) {
    return rangeList;
  }
  const newRangeList = [];
  const len = rangeList.length;
  let insertPosition = 0;
  for (let i = 0; i < len; i++) {
    const range0 = rangeList[i];
    if (range0[1] < range3[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range3[1]) {
      newRangeList.push(range0);
    } else {
      range3 = [Math.min(range0[0], range3[0]), Math.max(range0[1], range3[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range3);
  return newRangeList;
}
const DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: (t) => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = { type: "interpolation", duration: userSettings };
  }
  const type = userSettings.type || "interpolation";
  return {
    ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}
class Attribute2 extends DataColumn {
  constructor(device, opts) {
    super(device, opts, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      layoutChanged: false,
      updateRanges: FULL
    });
    this.constant = false;
    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
    Object.seal(this.settings);
    Object.seal(this.state);
    this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(layout) {
    this.state.startIndices = layout;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags = false } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(accessor) {
    var _a2;
    (_a2 = this.state).layoutChanged || (_a2.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));
    super.setAccessor(accessor);
  }
  getUpdateTriggers() {
    const { accessor } = this.settings;
    return [this.id].concat(typeof accessor !== "function" && accessor || []);
  }
  supportsTransition() {
    return Boolean(this.settings.transition);
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }
    const { accessor } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? (
      // @ts-ignore
      opts[accessor.find((a2) => opts[a2])]
    ) : (
      // @ts-ignore
      opts[accessor]
    );
    return normalizeTransitionSettings(userSettings, layerSettings);
  }
  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);
    if (dataRange) {
      const { startRow = 0, endRow = Infinity } = dataRange;
      this.state.updateRanges = add(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = FULL;
    }
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = EMPTY;
  }
  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }
  allocate(numInstances) {
    const { state, settings } = this;
    if (settings.noAlloc) {
      return false;
    }
    if (settings.update) {
      super.allocate(numInstances, state.updateRanges !== FULL);
      return true;
    }
    return false;
  }
  updateBuffer({ numInstances, data, props, context }) {
    if (!this.needsUpdate()) {
      return false;
    }
    const { state: { updateRanges }, settings: { update, noAlloc } } = this;
    let updated = true;
    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, { data, startRow, endRow, props, numInstances });
      }
      if (!this.value) ;
      else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({ startOffset, endOffset });
        }
      }
      this._checkAttributeArray();
    } else {
      updated = false;
    }
    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(value) {
    if (value === void 0 || typeof value === "function") {
      return false;
    }
    const hasChanged = this.setData({ constant: true, value });
    if (hasChanged) {
      this.setNeedsRedraw();
    }
    this.clearNeedsUpdate();
    return true;
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(buffer) {
    const { state } = this;
    if (!buffer) {
      state.lastExternalBuffer = null;
      return false;
    }
    this.clearNeedsUpdate();
    if (state.lastExternalBuffer === buffer) {
      return true;
    }
    state.lastExternalBuffer = buffer;
    this.setNeedsRedraw();
    this.setData(buffer);
    return true;
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(buffer, startIndices = null) {
    const { state, settings } = this;
    if (!buffer) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }
    if (settings.noAlloc) {
      return false;
    }
    if (state.binaryValue === buffer) {
      this.clearNeedsUpdate();
      return true;
    }
    state.binaryValue = buffer;
    this.setNeedsRedraw();
    const needsUpdate = settings.transform || startIndices !== this.startIndices;
    if (needsUpdate) {
      if (ArrayBuffer.isView(buffer)) {
        buffer = { value: buffer };
      }
      const binaryValue = buffer;
      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
        size: binaryValue.size || this.size,
        stride: binaryValue.stride,
        offset: binaryValue.offset,
        startIndices,
        nested: needsNormalize
      });
      return false;
    }
    this.clearNeedsUpdate();
    this.setData(buffer);
    return true;
  }
  getVertexOffset(row) {
    const { startIndices } = this;
    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
    return vertexIndex * this.size;
  }
  getValue() {
    const shaderAttributeDefs = this.settings.shaderAttributes;
    const result = super.getValue();
    if (!shaderAttributeDefs) {
      return result;
    }
    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }
    return result;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(modelInfo) {
    this.state.layoutChanged = false;
    const shaderAttributeDefs = this.settings.shaderAttributes;
    const result = super._getBufferLayout();
    const { stepMode } = this.settings;
    if (stepMode === "dynamic") {
      result.stepMode = modelInfo ? modelInfo.isInstanced ? "instance" : "vertex" : "instance";
    } else {
      result.stepMode = stepMode ?? "vertex";
    }
    if (!shaderAttributeDefs) {
      return result;
    }
    for (const shaderAttributeName in shaderAttributeDefs) {
      const map2 = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);
      result.attributes.push(...map2.attributes);
    }
    return result;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(attribute, { data, startRow, endRow, props, numInstances }) {
    if (attribute.constant) {
      return;
    }
    const { settings, state, value, size, startIndices } = attribute;
    const { accessor, transform } = settings;
    const accessorFunc = state.binaryAccessor || // @ts-ignore
    (typeof accessor === "function" ? accessor : props[accessor]);
    assert(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
    let i = attribute.getVertexOffset(startRow);
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object2 of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object2, objectInfo);
      if (transform) {
        objectValue = transform.call(this, objectValue);
      }
      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i;
          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);
            startIndex += size;
          }
        } else if (objectValue && objectValue.length > size) {
          value.set(objectValue, i);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);
          fillArray({
            target: value,
            source: objectInfo.target,
            start: i,
            count: numVertices
          });
        }
        i += numVertices * size;
      } else {
        attribute._normalizeValue(objectValue, value, i);
        i += size;
      }
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === "function";
    if (!hasUpdater) {
      throw new Error(`Attribute ${this.id} missing update or accessor`);
    }
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value } = this;
    const limit = Math.min(4, this.size);
    if (value && value.length >= limit) {
      let valid = true;
      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);
        case 3:
          valid = valid && Number.isFinite(value[2]);
        case 2:
          valid = valid && Number.isFinite(value[1]);
        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;
        default:
          valid = false;
      }
      if (!valid) {
        throw new Error(`Illegal attribute generated for ${this.id}`);
      }
    }
  }
}
function padArrayChunk(options) {
  const { source, target, start: start2 = 0, size, getData } = options;
  const end = options.end || target.length;
  const sourceLength = source.length;
  const targetLength = end - start2;
  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start2);
    return;
  }
  target.set(source, start2);
  if (!getData) {
    return;
  }
  let i = sourceLength;
  while (i < targetLength) {
    const datum = getData(i, source);
    for (let j = 0; j < size; j++) {
      target[start2 + i] = datum[j] || 0;
      i++;
    }
  }
}
function padArray({ source, target, size, getData, sourceStartIndices, targetStartIndices }) {
  if (!sourceStartIndices || !targetStartIndices) {
    padArrayChunk({
      source,
      target,
      size,
      getData
    });
    return target;
  }
  let sourceIndex = 0;
  let targetIndex = 0;
  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));
  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (let i = 1; i < n; i++) {
    const nextSourceIndex = sourceStartIndices[i] * size;
    const nextTargetIndex = targetStartIndices[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target.length) {
    padArrayChunk({
      // @ts-ignore
      source: [],
      target,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }
  return target;
}
function cloneAttribute(attribute) {
  const { device, settings, value } = attribute;
  const newAttribute = new Attribute2(device, settings);
  newAttribute.setData({
    value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: settings.normalized
  });
  return newAttribute;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${size}"`);
  }
}
function getFloat32VertexFormat(size) {
  switch (size) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const { doublePrecision, settings, value, size } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  let maxVertexOffset = 0;
  const { shaderAttributes } = attribute.settings;
  if (shaderAttributes) {
    for (const shaderAttribute of Object.values(shaderAttributes)) {
      maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);
    }
  }
  return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;
}
function matchBuffer({ device, source, target }) {
  if (!target || target.byteLength < source.byteLength) {
    target?.destroy();
    target = device.createBuffer({
      byteLength: source.byteLength,
      usage: source.usage
    });
  }
  return target;
}
function padBuffer({ device, buffer, attribute, fromLength, toLength, fromStartIndices, getData = (x2) => x2 }) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const isConstant = attribute.isConstant;
  if (!hasStartIndices && buffer && fromLength >= toLength) {
    return buffer;
  }
  const ArrayType2 = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;
  const toData = isConstant ? attribute.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new ArrayType2(attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType2.BYTES_PER_ELEMENT).buffer)
  );
  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;
    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }
  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i + byteOffset, i + byteOffset + size), chunk);
  const source = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);
  const target = new Float32Array(toLength);
  padArray({
    source,
    target,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });
  if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {
    buffer?.destroy();
    buffer = device.createBuffer({
      byteLength: target.byteLength + targetByteOffset,
      usage: 35050
    });
  }
  buffer.write(target, targetByteOffset);
  return buffer;
}
class GPUTransitionBase {
  constructor({ device, attribute, timeline }) {
    this.buffers = [];
    this.currentLength = 0;
    this.device = device;
    this.transition = new Transition(timeline);
    this.attribute = attribute;
    this.attributeInTransition = cloneAttribute(attribute);
    this.currentStartIndices = attribute.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances, duration = Infinity) {
    this.settings = transitionSettings;
    this.currentStartIndices = this.attribute.startIndices;
    this.currentLength = getAttributeBufferLength(this.attribute, numInstances);
    this.transition.start({ ...transitionSettings, duration });
  }
  update() {
    const updated = this.transition.update();
    if (updated) {
      this.onUpdate();
    }
    return updated;
  }
  setBuffer(buffer) {
    this.attributeInTransition.setData({
      buffer,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const buffer of this.buffers) {
      buffer.destroy();
    }
    this.buffers.length = 0;
  }
}
class GPUInterpolationTransition extends GPUTransitionBase {
  constructor({ device, attribute, timeline }) {
    super({ device, attribute, timeline });
    this.type = "interpolation";
    this.transform = getTransform$1(device, attribute);
  }
  start(transitionSettings, numInstances) {
    const prevLength = this.currentLength;
    const prevStartIndices = this.currentStartIndices;
    super.start(transitionSettings, numInstances, transitionSettings.duration);
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers, attribute } = this;
    cycleBuffers(buffers);
    buffers[0] = padBuffer({
      device: this.device,
      buffer: buffers[0],
      attribute,
      fromLength: prevLength,
      toLength: this.currentLength,
      fromStartIndices: prevStartIndices,
      getData: transitionSettings.enter
    });
    buffers[1] = matchBuffer({
      device: this.device,
      source: buffers[0],
      target: buffers[1]
    });
    this.setBuffer(buffers[1]);
    const { transform } = this;
    const model = transform.model;
    let vertexCount = Math.floor(this.currentLength / attribute.size);
    if (useFp64(attribute)) {
      vertexCount /= 2;
    }
    model.setVertexCount(vertexCount);
    if (attribute.isConstant) {
      model.setAttributes({ aFrom: buffers[0] });
      model.setConstantAttributes({ aTo: attribute.value });
    } else {
      model.setAttributes({
        aFrom: buffers[0],
        aTo: attribute.getBuffer()
      });
    }
    transform.transformFeedback.setBuffers({ vCurrent: buffers[1] });
  }
  onUpdate() {
    const { duration, easing } = this.settings;
    const { time: time2 } = this.transition;
    let t = time2 / duration;
    if (easing) {
      t = easing(t);
    }
    const { model } = this.transform;
    model.setUniforms({ time: t });
    this.transform.run({ discard: true });
  }
  delete() {
    super.delete();
    this.transform.destroy();
  }
}
const vs$5 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`;
const vs64 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function useFp64(attribute) {
  return attribute.doublePrecision && attribute.value instanceof Float64Array;
}
function getTransform$1(device, attribute) {
  const attributeSize = attribute.size;
  const attributeType = getAttributeTypeFromSize(attributeSize);
  const inputFormat = getFloat32VertexFormat(attributeSize);
  const bufferLayout = attribute.getBufferLayout();
  if (useFp64(attribute)) {
    return new BufferTransform(device, {
      vs: vs64,
      bufferLayout: [
        {
          name: "aFrom",
          byteStride: 8 * attributeSize,
          attributes: [
            { attribute: "aFrom", format: inputFormat, byteOffset: 0 },
            { attribute: "aFrom64Low", format: inputFormat, byteOffset: 4 * attributeSize }
          ]
        },
        {
          name: "aTo",
          byteStride: 8 * attributeSize,
          attributes: [
            { attribute: "aTo", format: inputFormat, byteOffset: 0 },
            { attribute: "aTo64Low", format: inputFormat, byteOffset: 4 * attributeSize }
          ]
        }
      ],
      modules: [fp64arithmetic],
      defines: {
        ATTRIBUTE_TYPE: attributeType,
        ATTRIBUTE_SIZE: attributeSize
      },
      // Default uniforms are not set without this
      moduleSettings: {},
      varyings: ["vCurrent", "vCurrent64Low"],
      // @ts-expect-error WebGLRenderPipeline only prop TODO - support in RenderPipeline?
      bufferMode: 35980,
      disableWarnings: true
    });
  }
  return new BufferTransform(device, {
    vs: vs$5,
    bufferLayout: [
      { name: "aFrom", format: inputFormat },
      { name: "aTo", format: bufferLayout.attributes[0].format }
    ],
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vCurrent"],
    disableWarnings: true
  });
}
class GPUSpringTransition extends GPUTransitionBase {
  constructor({ device, attribute, timeline }) {
    super({ device, attribute, timeline });
    this.type = "spring";
    this.texture = getTexture(device);
    this.framebuffer = getFramebuffer(device, this.texture);
    this.transform = getTransform(device, attribute);
  }
  start(transitionSettings, numInstances) {
    const prevLength = this.currentLength;
    const prevStartIndices = this.currentStartIndices;
    super.start(transitionSettings, numInstances);
    const { buffers, attribute } = this;
    for (let i = 0; i < 2; i++) {
      buffers[i] = padBuffer({
        device: this.device,
        buffer: buffers[i],
        attribute,
        fromLength: prevLength,
        toLength: this.currentLength,
        fromStartIndices: prevStartIndices,
        getData: transitionSettings.enter
      });
    }
    buffers[2] = matchBuffer({
      device: this.device,
      source: buffers[0],
      target: buffers[2]
    });
    this.setBuffer(buffers[1]);
    const { model } = this.transform;
    model.setVertexCount(Math.floor(this.currentLength / attribute.size));
    if (attribute.isConstant) {
      model.setConstantAttributes({ aTo: attribute.value });
    } else {
      model.setAttributes({ aTo: attribute.getBuffer() });
    }
  }
  onUpdate() {
    const { buffers, transform, framebuffer, transition } = this;
    const settings = this.settings;
    transform.model.setAttributes({
      aPrev: buffers[0],
      aCur: buffers[1]
    });
    transform.transformFeedback.setBuffers({ vNext: buffers[2] });
    transform.model.setUniforms({
      stiffness: settings.stiffness,
      damping: settings.damping
    });
    transform.run({
      framebuffer,
      discard: false,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    });
    cycleBuffers(buffers);
    this.setBuffer(buffers[1]);
    const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;
    if (!isTransitioning) {
      transition.end();
    }
  }
  delete() {
    super.delete();
    this.transform.destroy();
    this.texture.destroy();
    this.framebuffer.destroy();
  }
}
const vs$4 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`;
const fs$6 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function getTransform(device, attribute) {
  const attributeType = getAttributeTypeFromSize(attribute.size);
  const format2 = getFloat32VertexFormat(attribute.size);
  return new BufferTransform(device, {
    vs: vs$4,
    fs: fs$6,
    bufferLayout: [
      { name: "aPrev", format: format2 },
      { name: "aCur", format: format2 },
      { name: "aTo", format: attribute.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    defines: { ATTRIBUTE_TYPE: attributeType },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function getTexture(device) {
  return device.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: false,
    // dataFormat: GL.RGBA,
    width: 1,
    height: 1
  });
}
function getFramebuffer(device, texture) {
  return device.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [texture]
  });
}
const TRANSITION_TYPES$1 = {
  interpolation: GPUInterpolationTransition,
  spring: GPUSpringTransition
};
class AttributeTransitionManager {
  constructor(device, { id, timeline }) {
    if (!device)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = id;
    this.device = device;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
  }
  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes, transitions, numInstances }) {
    this.numInstances = numInstances || 1;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings)
        continue;
      this._updateAttribute(attributeName, attribute, settings);
    }
    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];
      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(attributeName) {
    const transition = this.transitions[attributeName];
    return transition && transition.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const animatedAttributes = {};
    for (const attributeName in this.transitions) {
      const transition = this.transitions[attributeName];
      if (transition.inProgress) {
        animatedAttributes[attributeName] = transition.attributeInTransition;
      }
    }
    return animatedAttributes;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0) {
      return false;
    }
    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();
      if (updated) {
        this.needsRedraw = true;
      }
    }
    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(attributeName) {
    this.transitions[attributeName].delete();
    delete this.transitions[attributeName];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(attributeName, attribute, settings) {
    const transition = this.transitions[attributeName];
    let isNew = !transition || transition.type !== settings.type;
    if (isNew) {
      if (transition) {
        this._removeTransition(attributeName);
      }
      const TransitionType = TRANSITION_TYPES$1[settings.type];
      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          device: this.device
        });
      } else {
        defaultLogger.error(`unsupported transition type '${settings.type}'`)();
        isNew = false;
      }
    }
    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }
}
const TRACE_INVALIDATE = "attributeManager.invalidate";
const TRACE_UPDATE_START = "attributeManager.updateStart";
const TRACE_UPDATE_END = "attributeManager.updateEnd";
const TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
const TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
const TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
class AttributeManager {
  constructor(device, { id = "attribute-manager", stats, timeline } = {}) {
    this.mergeBoundsMemoized = memoize2(mergeBounds);
    this.id = id;
    this.device = device;
    this.attributes = {};
    this.updateTriggers = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new AttributeTransitionManager(device, {
      id: `${id}-transitions`,
      timeline
    });
    Object.seal(this);
  }
  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = true;
  }
  // Adds attributes
  add(attributes) {
    this._add(attributes);
  }
  // Adds attributes
  addInstanced(attributes) {
    this._add(attributes, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(attributeNameArray) {
    for (const name2 of attributeNameArray) {
      if (this.attributes[name2] !== void 0) {
        this.attributes[name2].delete();
        delete this.attributes[name2];
      }
    }
  }
  // Marks an attribute for update
  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }
  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }
    debug(TRACE_INVALIDATE, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data, numInstances, startIndices = null, transitions, props = {}, buffers = {}, context = {} }) {
    let updated = false;
    debug(TRACE_UPDATE_START, this);
    if (this.stats) {
      this.stats.get("Update Attributes").timeStart();
    }
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;
      if (props[attributeName]) {
        defaultLogger.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
      }
      if (attribute.setExternalBuffer(buffers[attributeName])) ;
      else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) ;
      else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) ;
      else if (attribute.needsUpdate()) {
        updated = true;
        this._updateAttribute({
          attribute,
          numInstances,
          data,
          props,
          context
        });
      }
      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
    }
    if (updated) {
      debug(TRACE_UPDATE_END, this, numInstances);
    }
    if (this.stats) {
      this.stats.get("Update Attributes").timeEnd();
    }
    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(attributeNames) {
    const bounds = attributeNames.map((attributeName) => this.attributes[attributeName]?.getBounds());
    return this.mergeBoundsMemoized(bounds);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(opts = { clearChangedFlags: false }) {
    const { attributes, attributeTransitionManager } = this;
    const changedAttributes = { ...attributeTransitionManager.getAttributes() };
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }
    return changedAttributes;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(modelInfo) {
    return Object.values(this.getAttributes()).map((attribute) => attribute.getBufferLayout(modelInfo));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(attributes, overrideOptions) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const props = {
        ...attribute,
        id: attributeName,
        size: attribute.isIndexed && 1 || attribute.size || 1,
        ...overrideOptions
      };
      this.attributes[attributeName] = new Attribute2(this.device, props);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const triggers = {};
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach((triggerName) => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }
        triggers[triggerName].push(attributeName);
      });
    }
    this.updateTriggers = triggers;
  }
  _invalidateTrigger(triggerName, dataRange) {
    const { attributes, updateTriggers } = this;
    const invalidatedAttributes = updateTriggers[triggerName];
    if (invalidatedAttributes) {
      invalidatedAttributes.forEach((name2) => {
        const attribute = attributes[name2];
        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }
    return invalidatedAttributes;
  }
  _updateAttribute(opts) {
    const { attribute, numInstances } = opts;
    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
    if (attribute.constant) {
      attribute.setConstantValue(attribute.value);
      return;
    }
    if (attribute.allocate(numInstances)) {
      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }
    const updated = attribute.updateBuffer(opts);
    if (updated) {
      this.needsRedraw = true;
      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }
}
class CPUInterpolationTransition extends Transition {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time: time2, settings: { fromValue, toValue, duration, easing } } = this;
    const t = easing(time2 / duration);
    this._value = lerp$1(fromValue, toValue, t);
  }
}
const EPSILON = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];
    for (let i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;
    for (let i = 0; i < value1.length; i++) {
      const d = value1[i] - value2[i];
      distanceSquare += d * d;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value2);
}
class CPUSpringTransition extends Transition {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue, toValue, damping, stiffness } = this.settings;
    const { _prevValue = fromValue, _currValue = fromValue } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance(nextValue, toValue);
    const velocity = distance(nextValue, _currValue);
    if (delta < EPSILON && velocity < EPSILON) {
      nextValue = toValue;
      this.end();
    }
    this._prevValue = _currValue;
    this._currValue = nextValue;
  }
}
const TRANSITION_TYPES = {
  interpolation: CPUInterpolationTransition,
  spring: CPUSpringTransition
};
class UniformTransitionManager {
  constructor(timeline) {
    this.transitions = /* @__PURE__ */ new Map();
    this.timeline = timeline;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(key, fromValue, toValue, settings) {
    const { transitions } = this;
    if (transitions.has(key)) {
      const transition2 = transitions.get(key);
      const { value = transition2.settings.fromValue } = transition2;
      fromValue = value;
      this.remove(key);
    }
    settings = normalizeTransitionSettings(settings);
    if (!settings) {
      return;
    }
    const TransitionType = TRANSITION_TYPES[settings.type];
    if (!TransitionType) {
      defaultLogger.error(`unsupported transition type '${settings.type}'`)();
      return;
    }
    const transition = new TransitionType(this.timeline);
    transition.start({
      ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition);
  }
  remove(key) {
    const { transitions } = this;
    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }
  update() {
    const propsInTransition = {};
    for (const [key, transition] of this.transitions) {
      transition.update();
      propsInTransition[key] = transition.value;
      if (!transition.inProgress) {
        this.remove(key);
      }
    }
    return propsInTransition;
  }
  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }
}
function validateProps(props) {
  const propTypes2 = props[PROP_TYPES_SYMBOL];
  for (const propName in propTypes2) {
    const propType = propTypes2[propName];
    const { validate: validate2 } = propType;
    if (validate2 && !validate2(props[propName], propType)) {
      throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[PROP_TYPES_SYMBOL],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }
  const result = {};
  const propTypes2 = props[PROP_TYPES_SYMBOL];
  let changed = false;
  for (const key in props.transitions) {
    const propType = propTypes2[key];
    const type = propType && propType.type;
    const isTransitionable = type === "number" || type === "color" || type === "array";
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }
  return changed ? result : false;
}
function compareProps({ newProps, oldProps, ignoreProps = {}, propTypes: propTypes2 = {}, triggerName = "props" }) {
  if (oldProps === newProps) {
    return false;
  }
  if (typeof newProps !== "object" || newProps === null) {
    return `${triggerName} changed shallowly`;
  }
  if (typeof oldProps !== "object" || oldProps === null) {
    return `${triggerName} changed shallowly`;
  }
  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return `${triggerName}.${key} added`;
      }
      const changed = comparePropValues(newProps[key], oldProps[key], propTypes2[key]);
      if (changed) {
        return `${triggerName}.${key} ${changed}`;
      }
    }
  }
  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return `${triggerName}.${key} dropped`;
      }
      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes2[key]);
        if (changed) {
          return `${triggerName}.${key} ${changed}`;
        }
      }
    }
  }
  return false;
}
function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;
  if (equal && !equal(newProp, oldProp, propType)) {
    return "changed deeply";
  }
  if (!equal) {
    equal = newProp && oldProp && newProp.equals;
    if (equal && !equal.call(newProp, oldProp)) {
      return "changed deeply";
    }
  }
  if (!equal && oldProp !== newProp) {
    return "changed shallowly";
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  let dataChanged = false;
  const { dataComparator, _dataDiff } = props;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = "Data comparator detected a change";
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = "A new data container was supplied";
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return { all: true };
  }
  if ("all" in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, "all");
    if (diffReason) {
      return { all: true };
    }
  }
  const reason = {};
  let changed = false;
  for (const triggerName in props.updateTriggers) {
    if (triggerName !== "all") {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }
  return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }
  const oldExtensions = oldProps.extensions;
  const { extensions } = props;
  if (extensions === oldExtensions) {
    return false;
  }
  if (!oldExtensions || !extensions) {
    return true;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (let i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}
const ERR_NOT_OBJECT = "count(): argument not an object";
const ERR_NOT_CONTAINER = "count(): argument not a container";
function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === "function") {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && value.constructor === Object;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function mergeShaders(target, source) {
  if (!source) {
    return target;
  }
  const result = { ...target, ...source };
  if ("defines" in source) {
    result.defines = { ...target.defines, ...source.defines };
  }
  if ("modules" in source) {
    result.modules = (target.modules || []).concat(source.modules);
    if (source.modules.some((module) => module.name === "project64")) {
      const index2 = result.modules.findIndex((module) => module.name === "project32");
      if (index2 >= 0) {
        result.modules.splice(index2, 1);
      }
    }
  }
  if ("inject" in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      const mergedInjection = { ...target.inject };
      for (const key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}
const DEFAULT_TEXTURE_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
const internalTextures = {};
function createTexture(owner, device, image, sampler) {
  if (image instanceof Texture) {
    return image;
  } else if (image.constructor && image.constructor.name !== "Object") {
    image = { data: image };
  }
  let samplerParameters = null;
  if (image.compressed) {
    samplerParameters = {
      minFilter: "linear",
      mipmapFilter: image.data.length > 1 ? "nearest" : "linear"
    };
  }
  const texture = device.createTexture({
    ...image,
    sampler: {
      ...DEFAULT_TEXTURE_PARAMETERS,
      ...samplerParameters,
      ...sampler
    }
  });
  internalTextures[texture.id] = owner;
  return texture;
}
function destroyTexture(owner, texture) {
  if (!texture || !(texture instanceof Texture)) {
    return;
  }
  if (internalTextures[texture.id] === owner) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}
const TYPE_DEFINITIONS = {
  boolean: {
    validate(value, propType) {
      return true;
    },
    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
    }
  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);
    },
    equal(value1, value2, propType) {
      return deepEqual(value1, value2, 1);
    }
  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf(value);
      return valueType === "function" || valueType === getTypeOf(propType.value);
    },
    equal(value1, value2, propType) {
      if (typeof value2 === "function") {
        return true;
      }
      return deepEqual(value1, value2, 1);
    }
  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value);
    },
    equal(value1, value2, propType) {
      const { compare } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual(value1, value2, depth) : value1 === value2;
    }
  },
  object: {
    equal(value1, value2, propType) {
      if (propType.ignore) {
        return true;
      }
      const { compare } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual(value1, value2, depth) : value1 === value2;
    }
  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === "function";
    },
    equal(value1, value2, propType) {
      const shouldIgnore = !propType.compare && propType.ignore !== false;
      return shouldIgnore || value1 === value2;
    }
  },
  data: {
    transform: (value, propType, component) => {
      if (!value) {
        return value;
      }
      const { dataTransform } = component.props;
      if (dataTransform) {
        return dataTransform(value);
      }
      if (typeof value.shape === "string" && value.shape.endsWith("-table") && Array.isArray(value.data)) {
        return value.data;
      }
      return value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      const context = component.context;
      if (!context || !context.device) {
        return null;
      }
      return createTexture(component.id, context.device, value, {
        ...propType.parameters,
        ...component.props.textureParameters
      });
    },
    release: (value, propType, component) => {
      destroyTexture(component.id, value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes2 = {};
  const defaultProps2 = {};
  const deprecatedProps = {};
  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef?.deprecatedFor;
    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType(propName, propDef);
      propTypes2[propName] = propType;
      defaultProps2[propName] = propType.value;
    }
  }
  return { propTypes: propTypes2, defaultProps: defaultProps2, deprecatedProps };
}
function parsePropType(name2, propDef) {
  switch (getTypeOf(propDef)) {
    case "object":
      return normalizePropDefinition(name2, propDef);
    case "array":
      return normalizePropDefinition(name2, { type: "array", value: propDef, compare: false });
    case "boolean":
      return normalizePropDefinition(name2, { type: "boolean", value: propDef });
    case "number":
      return normalizePropDefinition(name2, { type: "number", value: propDef });
    case "function":
      return normalizePropDefinition(name2, { type: "function", value: propDef, compare: true });
    default:
      return { name: name2, type: "unknown", value: propDef };
  }
}
function normalizePropDefinition(name2, propDef) {
  if (!("type" in propDef)) {
    if (!("value" in propDef)) {
      return { name: name2, type: "object", value: propDef };
    }
    return { name: name2, type: getTypeOf(propDef.value), ...propDef };
  }
  return { name: name2, ...TYPE_DEFINITIONS[propDef.type], ...propDef };
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf(value) {
  if (isArray(value)) {
    return "array";
  }
  if (value === null) {
    return "null";
  }
  return typeof value;
}
function createProps(component, propObjects) {
  let extensions;
  for (let i = propObjects.length - 1; i >= 0; i--) {
    const props = propObjects[i];
    if ("extensions" in props) {
      extensions = props.extensions;
    }
  }
  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[COMPONENT_SYMBOL] = component;
  propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
  for (let i = 0; i < propObjects.length; ++i) {
    const props = propObjects[i];
    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
const MergedDefaultPropsCacheKey = "_mergedDefaultProps";
function getPropsPrototype(componentClass, extensions) {
  if (!(componentClass instanceof Component.constructor))
    return {};
  let cacheKey = MergedDefaultPropsCacheKey;
  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;
      if (ExtensionClass) {
        cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
      }
    }
  }
  const defaultProps2 = getOwnProperty(componentClass, cacheKey);
  if (!defaultProps2) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }
  return defaultProps2;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;
  if (!parent) {
    return null;
  }
  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
  const componentPropDefs = parsePropTypes(componentDefaultProps);
  const defaultProps2 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes2 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps?.[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);
    if (extensionDefaultProps) {
      Object.assign(defaultProps2, extensionDefaultProps);
      Object.assign(propTypes2, extensionDefaultProps[PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
    }
  }
  createPropsPrototype(defaultProps2, componentClass);
  addAsyncPropsToPropPrototype(defaultProps2, propTypes2);
  addDeprecatedPropsToPropPrototype(defaultProps2, deprecatedProps);
  defaultProps2[PROP_TYPES_SYMBOL] = propTypes2;
  defaultProps2[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
  if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
    componentClass._propTypes = propTypes2;
  }
  return defaultProps2;
}
function createPropsPrototype(defaultProps2, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps2, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: true,
      value: id
    }
  });
}
function addDeprecatedPropsToPropPrototype(defaultProps2, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps2, propName, {
      enumerable: false,
      set(newValue) {
        const nameStr = `${this.id}: ${propName}`;
        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }
        defaultLogger.deprecated(nameStr, deprecatedProps[propName].join("/"))();
      }
    });
  }
}
function addAsyncPropsToPropPrototype(defaultProps2, propTypes2) {
  const defaultValues = {};
  const descriptors = {};
  for (const propName in propTypes2) {
    const propType = propTypes2[propName];
    const { name: name2, value } = propType;
    if (propType.async) {
      defaultValues[name2] = value;
      descriptors[name2] = getDescriptorForAsyncProp(name2);
    }
  }
  defaultProps2[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps2[ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps2, descriptors);
}
function getDescriptorForAsyncProp(name2) {
  return {
    enumerable: true,
    // Save the provided value for async props in a special map
    set(newValue) {
      if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable(newValue)) {
        this[ASYNC_ORIGINAL_SYMBOL][name2] = newValue;
      } else {
        this[ASYNC_RESOLVED_SYMBOL][name2] = newValue;
      }
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[ASYNC_RESOLVED_SYMBOL]) {
        if (name2 in this[ASYNC_RESOLVED_SYMBOL]) {
          const value = this[ASYNC_RESOLVED_SYMBOL][name2];
          return value || this[ASYNC_DEFAULTS_SYMBOL][name2];
        }
        if (name2 in this[ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
          if (state && state.hasAsyncProp(name2)) {
            return state.getAsyncProp(name2) || this[ASYNC_DEFAULTS_SYMBOL][name2];
          }
        }
      }
      return this[ASYNC_DEFAULTS_SYMBOL][name2];
    }
  };
}
function hasOwnProperty(object2, prop) {
  return Object.prototype.hasOwnProperty.call(object2, prop);
}
function getOwnProperty(object2, prop) {
  return hasOwnProperty(object2, prop) && object2[prop];
}
function getComponentName(componentClass) {
  const componentName = componentClass.componentName;
  if (!componentName) {
    defaultLogger.warn(`${componentClass.name}.componentName not specified`)();
  }
  return componentName || componentClass.name;
}
let counter = 0;
class Component {
  constructor(...propObjects) {
    this.props = createProps(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
  }
  // clone this layer with modified props
  clone(newProps) {
    const { props } = this;
    const asyncProps = {};
    for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
      }
    }
    return new this.constructor({ ...props, ...asyncProps, ...newProps });
  }
}
Component.componentName = "Component";
Component.defaultProps = {};
const EMPTY_PROPS = Object.freeze({});
class ComponentState {
  constructor(component) {
    this.component = component;
    this.asyncProps = {};
    this.onAsyncPropUpdated = () => {
    };
    this.oldProps = null;
    this.oldAsyncProps = null;
  }
  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }
    this.asyncProps = {};
    this.component = null;
    this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }
  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }
  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }
    return false;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(props) {
    this.component = props[COMPONENT_SYMBOL] || this.component;
    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
      resolvedValues[propName] = this.getAsyncProp(propName);
    }
    for (const propName in originalValues) {
      const value = originalValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(propName, url) {
    return null;
  }
  _onResolve(propName, value) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(propName, error) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }
    if (typeof value === "string") {
      value = this._fetch(propName, value);
    }
    if (value instanceof Promise) {
      this._watchPromise(propName, value);
      return;
    }
    if (isAsyncIterable(value)) {
      this._resolveAsyncIterable(propName, value);
      return;
    }
    this._setPropValue(propName, value);
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];
    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }
    asyncProp.lastValue = value;
    return true;
  }
  // Set normal, non-async value
  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
      this._freezeAsyncOldProps();
      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then((data) => {
        if (!this.component) {
          return;
        }
        data = this._postProcessValue(asyncProp, data);
        this._setAsyncPropValue(propName, data, loadCount);
        this._onResolve(propName, data);
      }).catch((error) => {
        this._onError(propName, error);
      });
    }
  }
  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== "data") {
      this._setPropValue(propName, iterable);
      return;
    }
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      return;
    }
    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data = [];
    let count2 = 0;
    for await (const chunk of iterable) {
      if (!this.component) {
        return;
      }
      const { dataTransform } = this.component.props;
      if (dataTransform) {
        data = dataTransform(chunk, data);
      } else {
        data = data.concat(chunk);
      }
      Object.defineProperty(data, "__diff", {
        enumerable: false,
        value: [{ startRow: count2, endRow: data.length }]
      });
      count2 = data.length;
      this._setAsyncPropValue(propName, data, loadCount);
    }
    this._onResolve(propName, data);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;
    if (propType && this.component) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }
      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }
    return value;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      const propTypes2 = this.component && this.component.props[PROP_TYPES_SYMBOL];
      this.asyncProps[propName] = {
        type: propTypes2 && propTypes2[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class LayerState extends ComponentState {
  constructor({ attributeManager, layer }) {
    super(layer);
    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.needsUpdate = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(propName, url) {
    const layer = this.layer;
    const fetch2 = layer?.props.fetch;
    if (fetch2) {
      return fetch2(url, { propName, layer });
    }
    return super._fetch(propName, url);
  }
  _onResolve(propName, value) {
    const layer = this.layer;
    if (layer) {
      const onDataLoad = layer.props.onDataLoad;
      if (propName === "data" && onDataLoad) {
        onDataLoad(value, { propName, layer });
      }
    }
  }
  _onError(propName, error) {
    const layer = this.layer;
    if (layer) {
      layer.raiseError(error, `loading ${propName} of ${this.layer}`);
    }
  }
}
const TRACE_CHANGE_FLAG = "layer.changeFlag";
const TRACE_INITIALIZE = "layer.initialize";
const TRACE_UPDATE = "layer.update";
const TRACE_FINALIZE = "layer.finalize";
const TRACE_MATCHED = "layer.matched";
const MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
const EMPTY_ARRAY$1 = Object.freeze([]);
const areViewportsEqual = memoize2(({ oldViewport, viewport }) => {
  return oldViewport.equals(viewport);
});
let pickingColorCache = new Uint8ClampedArray(0);
const defaultProps$a = {
  // data: Special handling for null, see below
  data: { type: "data", value: EMPTY_ARRAY$1, async: true },
  dataComparator: { type: "function", value: null, optional: true },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (data) => data && data.__diff,
    optional: true
  },
  dataTransform: { type: "function", value: null, optional: true },
  onDataLoad: { type: "function", value: null, optional: true },
  onError: { type: "function", value: null, optional: true },
  fetch: {
    type: "function",
    value: (url, { propName, layer, loaders, loadOptions, signal }) => {
      const { resourceManager } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;
      if (signal) {
        loadOptions = {
          ...loadOptions,
          fetch: {
            ...loadOptions?.fetch,
            signal
          }
        };
      }
      let inResourceManager = resourceManager.contains(url);
      if (!inResourceManager && !loadOptions) {
        resourceManager.add({ resourceId: url, data: load(url, loaders), persistent: false });
        inResourceManager = true;
      }
      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: (data) => layer.internalState?.reloadAsyncProp(propName, data),
          consumerId: layer.id,
          requestId: propName
        });
      }
      return load(url, loaders, loadOptions);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: true,
  pickable: false,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: true },
  onClick: { type: "function", value: null, optional: true },
  onDragStart: { type: "function", value: null, optional: true },
  onDrag: { type: "function", value: null, optional: true },
  onDragEnd: { type: "function", value: null, optional: true },
  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: true },
  modelMatrix: { type: "array", value: null, compare: true, optional: true },
  wrapLongitude: false,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: true, compare: 2 },
  loadOptions: { type: "object", value: null, optional: true, ignore: true },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: true, ignore: true },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex }) => [0, -layerIndex * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
class Layer extends Component {
  constructor() {
    super(...arguments);
    this.internalState = null;
    this.lifecycle = LIFECYCLE.NO_STATE;
    this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let layer = this;
    while (layer.parent) {
      layer = layer.parent;
    }
    return layer;
  }
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return `${className}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(xyz) {
    assert(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    const worldPosition = getWorldPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x2, y2, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x2, y2] : [x2, y2, z];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(xy) {
    assert(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return viewport.unproject(xy);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(xyz, params) {
    assert(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return projectPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return false;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(partialState) {
    this.setChangeFlags({ stateChanged: true });
    Object.assign(this.state, partialState);
    this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    if (this.internalState) {
      this.internalState.needsRedraw = true;
    }
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    if (this.internalState) {
      this.context.layerManager.setNeedsUpdate(String(this));
      this.internalState.needsUpdate = true;
    }
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const state = this.state;
    return state && (state.models || state.model && [state.model]) || [];
  }
  // TODO deprecate in favour of setShaderModuleProps
  /** Update shader module parameters */
  setModuleParameters(moduleParameters) {
    for (const model of this.getModels()) {
      model.updateModuleSettings(moduleParameters);
    }
  }
  /** Update shader input parameters */
  setShaderModuleProps(...props) {
    for (const model of this.getModels()) {
      model.shaderInputs.setProps(...props);
    }
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem } = this.props;
    return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
  }
  // Event handling
  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent) || false;
    }
    return false;
  }
  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent) || false;
    }
    return false;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(i, target = []) {
    target[0] = i + 1 & 255;
    target[1] = i + 1 >> 8 & 255;
    target[2] = i + 1 >> 8 >> 8 & 255;
    return target;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(color2) {
    assert(color2 instanceof Uint8Array);
    const [i1, i2, i3] = color2;
    const index2 = i1 + i2 * 256 + i3 * 65536 - 1;
    return index2;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    if (Number.isFinite(this.props.numInstances)) {
      return this.props.numInstances;
    }
    if (this.state && this.state.numInstances !== void 0) {
      return this.state.numInstances;
    }
    return count(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    if (this.props.startIndices) {
      return this.props.startIndices;
    }
    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }
    return null;
  }
  // Default implementation
  getBounds() {
    return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
  }
  getShaders(shaders) {
    shaders = mergeShaders(shaders, {
      disableWarnings: true,
      modules: this.context.defaultShaderModules
    });
    for (const extension of this.props.extensions) {
      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
    }
    return shaders;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(params) {
    return params.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(params) {
    const attributeManager = this.getAttributeManager();
    const { dataChanged } = params.changeFlags;
    if (dataChanged && attributeManager) {
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }
    if (attributeManager) {
      const { props } = params;
      const hasPickingBuffer = this.internalState.hasPickingBuffer;
      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
      if (hasPickingBuffer !== needsPickingBuffer) {
        this.internalState.hasPickingBuffer = needsPickingBuffer;
        const { pickingColors, instancePickingColors } = attributeManager.attributes;
        const pickingColorsAttribute = pickingColors || instancePickingColors;
        if (pickingColorsAttribute) {
          if (needsPickingBuffer && pickingColorsAttribute.constant) {
            pickingColorsAttribute.constant = false;
            attributeManager.invalidate(pickingColorsAttribute.id);
          }
          if (!pickingColorsAttribute.value && !needsPickingBuffer) {
            pickingColorsAttribute.constant = true;
            pickingColorsAttribute.value = [0, 0, 0];
          }
        }
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(context) {
    for (const model of this.getModels()) {
      model.destroy();
    }
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.finalize();
    }
    if (this.context) {
      this.context.resourceManager.unsubscribe({ consumerId: this.id });
    }
    if (this.internalState) {
      this.internalState.uniformTransitions.clear();
      this.internalState.finalize();
    }
  }
  // If state has a model, draw it with supplied uniforms
  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts);
    }
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info, mode, sourceLayer }) {
    const { index: index2 } = info;
    if (index2 >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index2];
      }
    }
    return info;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(error, message2) {
    if (message2) {
      error = new Error(`${message2}: ${error.message}`, { cause: error });
    }
    if (!this.props.onError?.(error)) {
      this.context?.onError?.(error, this);
    }
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(opts = { clearRedrawFlags: false }) {
    return this._getNeedsRedraw(opts);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    if (!this.internalState) {
      return false;
    }
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    return this.internalState?.uniformTransitions.active || false;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(viewport) {
    if (!this.internalState) {
      return;
    }
    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;
    if (!oldViewport || !areViewportsEqual({ oldViewport, viewport })) {
      this.setChangeFlags({ viewportChanged: true });
      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(name2 = "all") {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    if (name2 === "all") {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name2);
    }
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(changedAttributes) {
    let bufferLayoutChanged = false;
    for (const id in changedAttributes) {
      if (changedAttributes[id].layoutChanged()) {
        bufferLayoutChanged = true;
      }
    }
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);
    }
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    const props = this.props;
    const numInstances = this.getNumInstances();
    const startIndices = this.getStartIndices();
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: props.data.attributes,
      context: this
    });
    const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
    this.updateAttributes(changedAttributes);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions } = this.internalState;
    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);
      for (const key in propsInTransition) {
        Object.defineProperty(props, key, { value: propsInTransition[key] });
      }
      return props;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(attribute, { numInstances }) {
    if (attribute.constant) {
      return;
    }
    const cacheSize = Math.floor(pickingColorCache.length / 4);
    this.internalState.usesPickingColorCache = true;
    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        defaultLogger.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
      }
      pickingColorCache = defaultTypedArrayManager.allocate(pickingColorCache, numInstances, {
        size: 4,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 4);
      const pickingColor = [];
      for (let i = cacheSize; i < newCacheSize; i++) {
        this.encodePickingColor(i, pickingColor);
        pickingColorCache[i * 4 + 0] = pickingColor[0];
        pickingColorCache[i * 4 + 1] = pickingColor[1];
        pickingColorCache[i * 4 + 2] = pickingColor[2];
      }
    }
    attribute.value = pickingColorCache.subarray(0, numInstances * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {
    if (!Object.keys(changedAttributes).length) {
      return;
    }
    if (bufferLayoutChanged) {
      const attributeManager = this.getAttributeManager();
      model.setBufferLayout(attributeManager.getBufferLayouts(model));
      changedAttributes = attributeManager.getAttributes();
    }
    const excludeAttributes = model.userData?.excludeAttributes || {};
    const attributeBuffers = {};
    const constantAttributes = {};
    for (const name2 in changedAttributes) {
      if (excludeAttributes[name2]) {
        continue;
      }
      const values = changedAttributes[name2].getValue();
      for (const attributeName in values) {
        const value = values[attributeName];
        if (value instanceof Buffer) {
          if (changedAttributes[name2].settings.isIndexed) {
            model.setIndexBuffer(value);
          } else {
            attributeBuffers[attributeName] = value;
          }
        } else if (value) {
          constantAttributes[attributeName] = value;
        }
      }
    }
    model.setAttributes(attributeBuffers);
    model.setConstantAttributes(constantAttributes);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (!("attributes" in data)) {
      this._disablePickingIndex(objectIndex);
      return;
    }
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
    if (externalColorAttribute && externalColorAttribute.value) {
      const values = externalColorAttribute.value;
      const objectColor = this.encodePickingColor(objectIndex);
      for (let index2 = 0; index2 < data.length; index2++) {
        const i = colors.getVertexOffset(index2);
        if (values[i] === objectColor[0] && values[i + 1] === objectColor[1] && values[i + 2] === objectColor[2]) {
          this._disablePickingIndex(index2);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(objectIndex) {
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    const start2 = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.write(new Uint8Array(end - start2), start2);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    if (
      // @ts-ignore (TS2531) this method is only called internally with internalState defined
      this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer
    ) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }
    colors.updateSubBuffer({ startOffset: 0 });
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    assert(!this.internalState);
    assert(Number.isFinite(this.props.coordinateSystem));
    debug(TRACE_INITIALIZE, this);
    const attributeManager = this._getAttributeManager();
    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: "uint8",
          size: 4,
          noAlloc: true,
          // Updaters are always called with `this` pointing to the layer
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateInstancePickingColors
        }
      });
    }
    this.internalState = new LayerState({
      attributeManager,
      layer: this
    });
    this._clearChangeFlags();
    this.state = {};
    Object.defineProperty(this.state, "attributeManager", {
      get: () => {
        defaultLogger.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
        return attributeManager;
      }
    });
    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
    this.initializeState(this.context);
    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: true,
      extensionsChanged: true
    });
    this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(oldLayer) {
    debug(TRACE_MATCHED, this, this === oldLayer);
    const { state, internalState } = oldLayer;
    if (this === oldLayer) {
      return;
    }
    this.internalState = internalState;
    this.state = state;
    this.internalState.setAsyncProps(this.props);
    this._diffProps(this.props, this.internalState.getOldProps());
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    debug(TRACE_UPDATE, this, stateNeedsUpdate);
    if (!stateNeedsUpdate) {
      return;
    }
    const currentProps = this.props;
    const context = this.context;
    const internalState = this.internalState;
    const currentViewport = context.viewport;
    const propsInTransition = this._updateUniformTransition();
    internalState.propsInTransition = propsInTransition;
    context.viewport = internalState.viewport || currentViewport;
    this.props = propsInTransition;
    try {
      const updateParams = this._getUpdateParams();
      const oldModels = this.getModels();
      if (context.device) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {
        }
      }
      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }
      const modelChanged = this.getModels()[0] !== oldModels[0];
      this._postUpdate(updateParams, modelChanged);
    } finally {
      context.viewport = currentViewport;
      this.props = currentProps;
      this._clearChangeFlags();
      internalState.needsUpdate = false;
      internalState.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    debug(TRACE_FINALIZE, this);
    this.finalizeState(this.context);
    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, this.context, extension);
    }
  }
  // Calculates uniforms
  _drawLayer({ renderPass, moduleParameters = null, uniforms = {}, parameters = {} }) {
    this._updateAttributeTransition();
    const currentProps = this.props;
    const context = this.context;
    this.props = this.internalState.propsInTransition || currentProps;
    const opacity = this.props.opacity;
    uniforms.opacity = Math.pow(opacity, 1 / 2.2);
    try {
      if (moduleParameters) {
        const { isActive, isAttribute } = moduleParameters.picking;
        this.setModuleParameters(moduleParameters);
        this.setShaderModuleProps({ picking: { isActive, isAttribute } });
      }
      const { getPolygonOffset } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      context.device.setParametersWebGL({ polygonOffset: offsets });
      for (const model of this.getModels()) {
        model.setParameters(parameters);
      }
      context.device.withParametersWebGL(parameters, () => {
        const opts = { renderPass, moduleParameters, uniforms, parameters, context };
        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }
        this.draw(opts);
      });
    } finally {
      this.props = currentProps;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    return this.internalState?.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(flags) {
    if (!this.internalState) {
      return;
    }
    const { changeFlags } = this.internalState;
    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;
        switch (key) {
          case "dataChanged":
            const dataChangedReason = flags[key];
            const prevDataChangedReason = changeFlags[key];
            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
              flagChanged = true;
            }
          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }
        }
        if (flagChanged) {
          debug(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }
    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(newProps, oldProps) {
    const changeFlags = diffProps(newProps, oldProps);
    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }
    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions?.[key]);
      }
    }
    return this.setChangeFlags(changeFlags);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    validateProps(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(info) {
    const picking2 = {
      // @ts-expect-error stricter luma gl types
      highlightedObjectColor: info.picked ? info.color : null
    };
    const { highlightColor } = this.props;
    if (info.picked && typeof highlightColor === "function") {
      picking2.highlightColor = highlightColor(info);
    }
    this.setShaderModuleProps({ picking: picking2 });
    this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const context = this.context;
    return new AttributeManager(context.device, {
      id: this.props.id,
      stats: context.stats,
      timeline: context.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(updateParams, forceUpdate) {
    const { props, oldProps } = updateParams;
    this.setNeedsRedraw();
    this._updateAttributes();
    const model = this.state.model;
    if (model?.isInstanced) {
      model.setInstanceCount(this.getNumInstances());
    }
    const { autoHighlight, highlightedObjectIndex, highlightColor } = props;
    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const picking2 = {};
      if (Array.isArray(highlightColor)) {
        picking2.highlightColor = highlightColor;
      }
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
        picking2.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }
      this.setShaderModuleProps({ picking: picking2 });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }
    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
    redraw = redraw || attributeManagerNeedsRedraw;
    if (redraw) {
      for (const extension of this.props.extensions) {
        extension.onNeedsRedraw.call(this, extension);
      }
    }
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    return redraw;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }
}
Layer.defaultProps = defaultProps$a;
Layer.layerName = "Layer";
const TRACE_RENDER_LAYERS = "compositeLayer.renderLayers";
class CompositeLayer extends Layer {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return true;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(context) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({ info }) {
    const { object: object2 } = info;
    const isDataWrapped = object2 && object2.__source && object2.__source.parent && object2.__source.parent.id === this.id;
    if (!isDataWrapped) {
      return info;
    }
    info.object = object2.__source.object;
    info.index = object2.__source.index;
    return info;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(context) {
    return true;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(subLayerId, data) {
    return data && data.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(subLayerId, DefaultLayerClass) {
    const { _subLayerProps: overridingProps } = this.props;
    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(accessor) {
    if (typeof accessor === "function") {
      const objectInfo = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (x2, i) => {
        if (x2 && x2.__source) {
          objectInfo.index = x2.__source.index;
          return accessor(x2.__source.object, objectInfo);
        }
        return accessor(x2, i);
      };
    }
    return accessor;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(sublayerProps = {}) {
    const { opacity, pickable, visible, parameters, getPolygonOffset, highlightedObjectIndex, autoHighlight, highlightColor, coordinateSystem, coordinateOrigin, wrapLongitude, positionFormat, modelMatrix, extensions, fetch: fetch2, operation, _subLayerProps: overridingProps } = this.props;
    const newProps = {
      id: "",
      updateTriggers: {},
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch: fetch2,
      operation
    };
    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || "sublayer";
    if (overridingSublayerProps) {
      const propTypes2 = this.props[PROP_TYPES_SYMBOL];
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes2[key];
        if (propType && propType.type === "accessor") {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }
    Object.assign(
      newProps,
      sublayerProps,
      // experimental feature that allows users to override sublayer props via parent layer prop
      overridingSublayerProps
    );
    newProps.id = `${this.props.id}-${sublayerId}`;
    newProps.updateTriggers = {
      all: this.props.updateTriggers?.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };
    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);
      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }
    return newProps;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(updateParams, forceUpdate) {
    let subLayers = this.internalState.subLayers;
    const shouldUpdate = !subLayers || this.needsUpdate();
    if (shouldUpdate) {
      const subLayersList = this.renderLayers();
      subLayers = flatten(subLayersList, Boolean);
      this.internalState.subLayers = subLayers;
    }
    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);
    for (const layer of subLayers) {
      layer.parent = this;
    }
  }
}
CompositeLayer.layerName = "CompositeLayer";
class LayerExtension {
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
  }
  constructor(opts) {
    if (opts) {
      this.opts = opts;
    }
  }
  /** Returns true if two extensions are equivalent */
  equals(extension) {
    if (this === extension) {
      return true;
    }
    return this.constructor === extension.constructor && deepEqual(this.opts, extension.opts, 1);
  }
  /** Only called if attached to a primitive layer */
  getShaders(extension) {
    return null;
  }
  /** Only called if attached to a CompositeLayer */
  getSubLayerProps(extension) {
    const { defaultProps: defaultProps2 } = extension.constructor;
    const newProps = {
      updateTriggers: {}
    };
    for (const key in defaultProps2) {
      if (key in this.props) {
        const propDef = defaultProps2[key];
        const propValue = this.props[key];
        newProps[key] = propValue;
        if (propDef && propDef.type === "accessor") {
          newProps.updateTriggers[key] = this.props.updateTriggers[key];
          if (typeof propValue === "function") {
            newProps[key] = this.getSubLayerAccessor(propValue);
          }
        }
      }
    }
    return newProps;
  }
  /* eslint-disable @typescript-eslint/no-empty-function */
  initializeState(context, extension) {
  }
  updateState(params, extension) {
  }
  onNeedsRedraw(extension) {
  }
  getNeedsPickingBuffer(extension) {
    return false;
  }
  draw(params, extension) {
  }
  finalizeState(context, extension) {
  }
}
LayerExtension.defaultProps = {};
LayerExtension.extensionName = "LayerExtension";
class Tesselator {
  constructor(opts) {
    this.indexStarts = [0];
    this.vertexStarts = [0];
    this.vertexCount = 0;
    this.instanceCount = 0;
    const { attributes = {} } = opts;
    this.typedArrayManager = defaultTypedArrayManager;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
  }
  /* Public methods */
  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const { data, buffers = {}, getGeometry, geometryBuffer, positionFormat, dataChanged, normalize: normalize2 = true } = this.opts;
    this.data = data;
    this.getGeometry = getGeometry;
    this.positionSize = // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat
    geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize2;
    if (geometryBuffer) {
      assert(data.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
      if (!normalize2) {
        buffers.vertexPositions = geometryBuffer;
      }
    }
    this.geometryBuffer = buffers.vertexPositions;
    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }
  updatePartialGeometry({ startRow, endRow }) {
    this._rebuildGeometry({ startRow, endRow });
  }
  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;
    if (!ArrayBuffer.isView(value)) {
      return null;
    }
    return getAccessorFromBuffer(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }
  /* Private utility methods */
  _allocate(instanceCount, copy2) {
    const { attributes, buffers, _attributeDefs, typedArrayManager } = this;
    for (const name2 in _attributeDefs) {
      if (name2 in buffers) {
        typedArrayManager.release(attributes[name2]);
        attributes[name2] = null;
      } else {
        const def = _attributeDefs[name2];
        def.copy = copy2;
        attributes[name2] = typedArrayManager.allocate(attributes[name2], instanceCount, def);
      }
    }
  }
  /**
   * Visit all objects
   * `data` is expected to be an iterable consistent with the base Layer expectation
   */
  _forEachGeometry(visitor, startRow, endRow) {
    const { data, getGeometry } = this;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object2 of iterable) {
      objectInfo.index++;
      const geometry2 = getGeometry ? getGeometry(object2, objectInfo) : null;
      visitor(geometry2, objectInfo.index);
    }
  }
  /* eslint-disable complexity,max-statements */
  _rebuildGeometry(dataRange) {
    if (!this.data) {
      return;
    }
    let { indexStarts, vertexStarts, instanceCount } = this;
    const { data, geometryBuffer } = this;
    const { startRow = 0, endRow = Infinity } = dataRange || {};
    const normalizedData = {};
    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }
    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry2, dataIndex) => {
        const normalizedGeometry = geometry2 && this.normalizeGeometry(geometry2);
        normalizedData[dataIndex] = normalizedGeometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
      }, startRow, endRow);
      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else {
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || 0;
      if (ArrayBuffer.isView(geometryBuffer)) {
        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
      } else if (geometryBuffer instanceof Buffer) {
        const byteStride = this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
      } else if (geometryBuffer.buffer) {
        const byteStride = geometryBuffer.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
      } else if (geometryBuffer.value) {
        const bufferValue = geometryBuffer.value;
        const elementStride = (
          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize
          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize
        );
        instanceCount = instanceCount || bufferValue.length / elementStride;
      }
    }
    this._allocate(instanceCount, Boolean(dataRange));
    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};
    this._forEachGeometry((geometry2, dataIndex) => {
      const normalizedGeometry = normalizedData[dataIndex] || geometry2;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(normalizedGeometry, context);
    }, startRow, endRow);
    this.vertexCount = indexStarts[indexStarts.length - 1];
  }
}
const TILE_SIZE = 512;
const DEGREES_TO_RADIANS = Math.PI / 180;
function getDeckInstance({ map: map2, gl, deck }) {
  if (map2.__deck) {
    return map2.__deck;
  }
  const customRender = deck?.props._customRender;
  const onLoad = deck?.props.onLoad;
  const deckProps = getInterleavedProps({
    ...deck?.props,
    _customRender: () => {
      map2.triggerRepaint();
      customRender?.("");
    }
  });
  let deckInstance;
  if (!deck || deck.props.gl === gl) {
    Object.assign(deckProps, {
      gl,
      width: null,
      height: null,
      touchAction: "unset",
      viewState: getViewState(map2)
    });
    if (deck?.isInitialized) {
      watchMapMove(deck, map2);
    } else {
      deckProps.onLoad = () => {
        onLoad?.();
        watchMapMove(deckInstance, map2);
      };
    }
  }
  if (deck) {
    deckInstance = deck;
    deck.setProps(deckProps);
    deck.userData.isExternal = true;
  } else {
    deckInstance = new Deck(deckProps);
    map2.on("remove", () => {
      removeDeckInstance(map2);
    });
  }
  deckInstance.userData.mapboxLayers = /* @__PURE__ */ new Set();
  map2.__deck = deckInstance;
  map2.on("render", () => {
    if (deckInstance.isInitialized)
      afterRender(deckInstance, map2);
  });
  return deckInstance;
}
function watchMapMove(deck, map2) {
  const _handleMapMove = () => {
    if (deck.isInitialized) {
      onMapMove(deck, map2);
    } else {
      map2.off("move", _handleMapMove);
    }
  };
  map2.on("move", _handleMapMove);
}
function removeDeckInstance(map2) {
  map2.__deck?.finalize();
  map2.__deck = null;
}
function getInterleavedProps(currProps) {
  const nextProps = {
    ...currProps,
    // TODO: remove with withParametersWebGL
    parameters: {
      depthMask: true,
      depthTest: true,
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthFunc: 515,
      blendEquation: 32774,
      ...currProps.parameters
    },
    // @ts-ignore views prop is hidden by the types because it is not expected to work the same way as in standalone Deck, see documentation
    views: currProps.views || [new MapView({ id: "mapbox" })]
  };
  return nextProps;
}
function addLayer(deck, layer) {
  deck.userData.mapboxLayers.add(layer);
  updateLayers(deck);
}
function removeLayer(deck, layer) {
  deck.userData.mapboxLayers.delete(layer);
  updateLayers(deck);
}
function updateLayer(deck, layer) {
  updateLayers(deck);
}
function drawLayer(deck, map2, layer) {
  let { currentViewport } = deck.userData;
  let clearStack = false;
  if (!currentViewport) {
    currentViewport = getViewport(deck, map2, true);
    deck.userData.currentViewport = currentViewport;
    clearStack = true;
  }
  if (!deck.isInitialized) {
    return;
  }
  deck._drawLayers("mapbox-repaint", {
    viewports: [currentViewport],
    layerFilter: ({ layer: deckLayer }) => layer.id === deckLayer.id || deckLayer.props.operation.includes("terrain"),
    clearStack,
    clearCanvas: false
  });
}
function getViewState(map2) {
  const { lng, lat } = map2.getCenter();
  const viewState = {
    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
    // https://github.com/visgl/deck.gl/issues/6894
    longitude: (lng + 540) % 360 - 180,
    latitude: lat,
    zoom: map2.getZoom(),
    bearing: map2.getBearing(),
    pitch: map2.getPitch(),
    padding: map2.getPadding(),
    repeat: map2.getRenderWorldCopies()
  };
  if (map2.getTerrain?.()) {
    centerCameraOnTerrain(map2, viewState);
  }
  return viewState;
}
function centerCameraOnTerrain(map2, viewState) {
  if (map2.getFreeCameraOptions) {
    const { position } = map2.getFreeCameraOptions();
    if (!position || position.z === void 0) {
      return;
    }
    const height = map2.transform.height;
    const { longitude, latitude, pitch } = viewState;
    const cameraX = position.x * TILE_SIZE;
    const cameraY = (1 - position.y) * TILE_SIZE;
    const cameraZ = position.z * TILE_SIZE;
    const center = lngLatToWorld([longitude, latitude]);
    const dx = cameraX - center[0];
    const dy = cameraY - center[1];
    const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);
    const pitchRadians = pitch * DEGREES_TO_RADIANS;
    const altitudePixels = 1.5 * height;
    const scale2 = pitchRadians < 1e-3 ? (
      // Pitch angle too small to deduce the look at point, assume elevation is 0
      altitudePixels * Math.cos(pitchRadians) / cameraZ
    ) : altitudePixels * Math.sin(pitchRadians) / cameraToCenterDistanceGround;
    viewState.zoom = Math.log2(scale2);
    const cameraZFromSurface = altitudePixels * Math.cos(pitchRadians) / scale2;
    const surfaceElevation = cameraZ - cameraZFromSurface;
    viewState.position = [0, 0, surfaceElevation / unitsPerMeter(latitude)];
  } else if (typeof map2.transform.elevation === "number") {
    viewState.position = [0, 0, map2.transform.elevation];
  }
}
function getViewport(deck, map2, useMapboxProjection = true) {
  return new WebMercatorViewport({
    id: "mapbox",
    x: 0,
    y: 0,
    width: deck.width,
    height: deck.height,
    ...getViewState(map2),
    nearZMultiplier: useMapboxProjection ? (
      // match mapbox-gl@>=1.3.0's projection matrix
      0.02
    ) : (
      // use deck.gl's own default
      0.1
    ),
    nearZ: map2.transform._nearZ / map2.transform.height,
    farZ: map2.transform._farZ / map2.transform.height
  });
}
function afterRender(deck, map2) {
  const { mapboxLayers, isExternal } = deck.userData;
  if (isExternal) {
    const mapboxLayerIds = Array.from(mapboxLayers, (layer) => layer.id);
    const deckLayers = flatten(deck.props.layers, Boolean);
    const hasNonMapboxLayers = deckLayers.some((layer) => layer && !mapboxLayerIds.includes(layer.id));
    let viewports = deck.getViewports();
    const mapboxViewportIdx = viewports.findIndex((vp) => vp.id === "mapbox");
    const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;
    if (hasNonMapboxLayers || hasNonMapboxViews) {
      if (mapboxViewportIdx >= 0) {
        viewports = viewports.slice();
        viewports[mapboxViewportIdx] = getViewport(deck, map2, false);
      }
      deck._drawLayers("mapbox-repaint", {
        viewports,
        layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (params.viewport.id !== "mapbox" || !mapboxLayerIds.includes(params.layer.id)),
        clearCanvas: false
      });
    }
  }
  deck.userData.currentViewport = null;
}
function onMapMove(deck, map2) {
  deck.setProps({
    viewState: getViewState(map2)
  });
  deck.needsRedraw({ clearRedrawFlags: true });
}
function updateLayers(deck) {
  if (deck.userData.isExternal) {
    return;
  }
  const layers = [];
  deck.userData.mapboxLayers.forEach((deckLayer) => {
    const LayerType = deckLayer.props.type;
    const layer = new LayerType(deckLayer.props);
    layers.push(layer);
  });
  deck.setProps({ layers });
}
class MapboxLayer {
  /* eslint-disable no-this-before-super */
  constructor(props) {
    if (!props.id) {
      throw new Error("Layer must have an unique id");
    }
    this.id = props.id;
    this.type = "custom";
    this.renderingMode = props.renderingMode || "3d";
    this.map = null;
    this.deck = null;
    this.props = props;
  }
  /* Mapbox custom layer methods */
  onAdd(map2, gl) {
    this.map = map2;
    this.deck = getDeckInstance({ map: map2, gl, deck: this.props.deck });
    addLayer(this.deck, this);
  }
  onRemove() {
    if (this.deck) {
      removeLayer(this.deck, this);
    }
  }
  setProps(props) {
    Object.assign(this.props, props, { id: this.id });
    if (this.deck) {
      updateLayer(this.deck);
    }
  }
  render() {
    drawLayer(this.deck, this.map, this);
  }
}
const UNDEFINED_BEFORE_ID = "__UNDEFINED__";
function resolveLayers(map2, deck, oldLayers, newLayers) {
  if (!map2 || !deck || !map2.style || !map2.style._loaded) {
    return;
  }
  const layers = flatten(newLayers, Boolean);
  if (oldLayers !== newLayers) {
    const prevLayers = flatten(oldLayers, Boolean);
    const prevLayerIds = new Set(prevLayers.map((l) => l.id));
    for (const layer of layers) {
      prevLayerIds.delete(layer.id);
    }
    for (const id of prevLayerIds) {
      if (map2.getLayer(id)) {
        map2.removeLayer(id);
      }
    }
  }
  for (const layer of layers) {
    const mapboxLayer = map2.getLayer(layer.id);
    if (mapboxLayer) {
      const layerInstance = mapboxLayer.implementation || mapboxLayer;
      layerInstance.setProps(layer.props);
    } else {
      map2.addLayer(
        new MapboxLayer({ id: layer.id, deck }),
        // @ts-expect-error beforeId is not defined in LayerProps
        layer.props.beforeId
      );
    }
  }
  const mapLayers = map2.style._order;
  const layerGroups = {};
  for (const layer of layers) {
    let { beforeId } = layer.props;
    if (!beforeId || !mapLayers.includes(beforeId)) {
      beforeId = UNDEFINED_BEFORE_ID;
    }
    layerGroups[beforeId] = layerGroups[beforeId] || [];
    layerGroups[beforeId].push(layer.id);
  }
  for (const beforeId in layerGroups) {
    const layerGroup = layerGroups[beforeId];
    let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);
    let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? void 0 : beforeId;
    for (let i = layerGroup.length - 1; i >= 0; i--) {
      const layerId = layerGroup[i];
      const layerIndex = mapLayers.indexOf(layerId);
      if (layerIndex !== lastLayerIndex - 1) {
        map2.moveLayer(layerId, lastLayerId);
        if (layerIndex > lastLayerIndex) {
          lastLayerIndex++;
        }
      }
      lastLayerIndex--;
      lastLayerId = layerId;
    }
  }
}
class MapboxOverlay {
  constructor(props) {
    this._handleStyleChange = () => {
      resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);
    };
    this._updateContainerSize = () => {
      if (this._map && this._container) {
        const { clientWidth, clientHeight } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${clientWidth}px`,
          height: `${clientHeight}px`
        });
      }
    };
    this._updateViewState = () => {
      const deck = this._deck;
      if (deck) {
        deck.setProps({ viewState: getViewState(this._map) });
        if (deck.isInitialized) {
          deck.redraw();
        }
      }
    };
    this._handleMouseEvent = (event) => {
      const deck = this._deck;
      if (!deck || !deck.isInitialized) {
        return;
      }
      const mockEvent = {
        type: event.type,
        offsetCenter: event.point,
        srcEvent: event
      };
      const lastDown = this._lastMouseDownPoint;
      if (!event.point && lastDown) {
        mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;
        mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;
        mockEvent.offsetCenter = {
          x: lastDown.x + mockEvent.deltaX,
          y: lastDown.y + mockEvent.deltaY
        };
      }
      switch (mockEvent.type) {
        case "mousedown":
          deck._onPointerDown(mockEvent);
          this._lastMouseDownPoint = {
            ...event.point,
            clientX: event.originalEvent.clientX,
            clientY: event.originalEvent.clientY
          };
          break;
        case "dragstart":
          mockEvent.type = "panstart";
          deck._onEvent(mockEvent);
          break;
        case "drag":
          mockEvent.type = "panmove";
          deck._onEvent(mockEvent);
          break;
        case "dragend":
          mockEvent.type = "panend";
          deck._onEvent(mockEvent);
          break;
        case "click":
          mockEvent.tapCount = 1;
          deck._onEvent(mockEvent);
          break;
        case "dblclick":
          mockEvent.type = "click";
          mockEvent.tapCount = 2;
          deck._onEvent(mockEvent);
          break;
        case "mousemove":
          mockEvent.type = "pointermove";
          deck._onPointerMove(mockEvent);
          break;
        case "mouseout":
          mockEvent.type = "pointerleave";
          deck._onPointerMove(mockEvent);
          break;
        default:
          return;
      }
    };
    const { interleaved = false, ...otherProps } = props;
    this._interleaved = interleaved;
    this._props = otherProps;
  }
  /** Update (partial) props of the underlying Deck instance. */
  setProps(props) {
    if (this._interleaved && props.layers) {
      resolveLayers(this._map, this._deck, this._props.layers, props.layers);
    }
    Object.assign(this._props, props);
    if (this._deck) {
      this._deck.setProps(this._interleaved ? getInterleavedProps(this._props) : this._props);
    }
  }
  /** Called when the control is added to a map */
  onAdd(map2) {
    this._map = map2;
    return this._interleaved ? this._onAddInterleaved(map2) : this._onAddOverlaid(map2);
  }
  _onAddOverlaid(map2) {
    const container = document.createElement("div");
    Object.assign(container.style, {
      position: "absolute",
      left: 0,
      top: 0,
      textAlign: "initial",
      pointerEvents: "none"
    });
    this._container = container;
    this._deck = new Deck({
      ...this._props,
      parent: container,
      viewState: getViewState(map2)
    });
    map2.on("resize", this._updateContainerSize);
    map2.on("render", this._updateViewState);
    map2.on("mousedown", this._handleMouseEvent);
    map2.on("dragstart", this._handleMouseEvent);
    map2.on("drag", this._handleMouseEvent);
    map2.on("dragend", this._handleMouseEvent);
    map2.on("mousemove", this._handleMouseEvent);
    map2.on("mouseout", this._handleMouseEvent);
    map2.on("click", this._handleMouseEvent);
    map2.on("dblclick", this._handleMouseEvent);
    this._updateContainerSize();
    return container;
  }
  _onAddInterleaved(map2) {
    const gl = map2.painter.context.gl;
    if (gl instanceof WebGLRenderingContext) {
      defaultLogger.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")();
    }
    this._deck = getDeckInstance({
      map: map2,
      gl,
      deck: new Deck({
        ...this._props,
        gl
      })
    });
    map2.on("styledata", this._handleStyleChange);
    resolveLayers(map2, this._deck, [], this._props.layers);
    return document.createElement("div");
  }
  /** Called when the control is removed from a map */
  onRemove() {
    const map2 = this._map;
    if (map2) {
      if (this._interleaved) {
        this._onRemoveInterleaved(map2);
      } else {
        this._onRemoveOverlaid(map2);
      }
    }
    this._deck = void 0;
    this._map = void 0;
    this._container = void 0;
  }
  _onRemoveOverlaid(map2) {
    map2.off("resize", this._updateContainerSize);
    map2.off("render", this._updateViewState);
    map2.off("mousedown", this._handleMouseEvent);
    map2.off("dragstart", this._handleMouseEvent);
    map2.off("drag", this._handleMouseEvent);
    map2.off("dragend", this._handleMouseEvent);
    map2.off("mousemove", this._handleMouseEvent);
    map2.off("mouseout", this._handleMouseEvent);
    map2.off("click", this._handleMouseEvent);
    map2.off("dblclick", this._handleMouseEvent);
    this._deck?.finalize();
  }
  _onRemoveInterleaved(map2) {
    map2.off("styledata", this._handleStyleChange);
    resolveLayers(map2, this._deck, this._props.layers, []);
    removeDeckInstance(map2);
  }
  getDefaultPosition() {
    return "top-left";
  }
  /** Forwards the Deck.pickObject method */
  pickObject(params) {
    assert(this._deck);
    return this._deck.pickObject(params);
  }
  /** Forwards the Deck.pickMultipleObjects method */
  pickMultipleObjects(params) {
    assert(this._deck);
    return this._deck.pickMultipleObjects(params);
  }
  /** Forwards the Deck.pickObjects method */
  pickObjects(params) {
    assert(this._deck);
    return this._deck.pickObjects(params);
  }
  /** Remove from map and releases all resources */
  finalize() {
    if (this._map) {
      this._map.removeControl(this);
    }
  }
  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
  getCanvas() {
    if (!this._map) {
      return null;
    }
    return this._interleaved ? this._map.getCanvas() : this._deck.getCanvas();
  }
}
function BearingMarkers({ tracks, trackGroups }) {
  const renderBearingMarkers = reactExports.useCallback(() => {
    const allNodes = generateNodeFeatures(tracks, trackGroups);
    const groupedMarkers = {};
    allNodes.features.forEach((node) => {
      const [lng, lat] = node.geometry.coordinates;
      const { trackId } = node.properties;
      const isTrackGroup = trackGroups.some((g) => g.id === trackId);
      const key = `${lng.toFixed(COORD_PRECISION)},${lat.toFixed(COORD_PRECISION)}`;
      if (!groupedMarkers[key]) {
        groupedMarkers[key] = {
          nodes: [node],
          isTrackGroup
        };
      } else {
        groupedMarkers[key].nodes.push(node);
        if (isTrackGroup) {
          groupedMarkers[key].isTrackGroup = true;
        }
      }
    });
    return Object.values(groupedMarkers).map(({ nodes, isTrackGroup }) => {
      const [lng, lat] = nodes[0].geometry.coordinates;
      const { id } = nodes[0].properties;
      const bearings = nodes.map((node) => node.properties.bearing);
      const markerLabel = bearings.length > 1 ? bearings.map((b) => `${b.toFixed(2)}°`).join(", ") : `${bearings[0].toFixed(2)}°`;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Marker,
        {
          longitude: lng,
          latitude: lat,
          offset: [0, -15],
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "px-0.5 text-[8px] font-semibold items-center justify-center leading-none bg-transparent max-w-[100px] overflow-hidden text-ellipsis select-none pointer-events-none",
              style: {
                color: isTrackGroup ? "#cc9900" : "#0080ff",
                borderBottom: `1px solid ${isTrackGroup ? "#cc9900" : "#0080ff"}`,
                textOverflow: "ellipsis"
              },
              children: markerLabel
            }
          )
        },
        id
      );
    });
  }, [tracks, trackGroups]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderBearingMarkers() });
}
function BuildingIntersectionMarkers({ zoom }) {
  const previewTracks = usePreviewTracks();
  const tracks = useTracks();
  const buildingDetector = useBuildingDetector();
  const { currentNavigationState } = useUi();
  const isConstructionPanel = currentNavigationState?.type === "construction";
  let collisionDetails = previewTracks.validation.buildingCollisionDetails;
  if ((!collisionDetails || collisionDetails.length === 0) && buildingDetector) {
    const blueprintTracks = tracks.filter((track) => track.buildType === "blueprint");
    if (blueprintTracks.length > 0) {
      const collisionResult = validateBuildingCollision(blueprintTracks, buildingDetector);
      if (collisionResult.collisionDetails) {
        collisionDetails = collisionResult.collisionDetails;
      }
    }
  }
  const markerData = reactExports.useMemo(() => {
    const markers = [];
    const processedBuildings = /* @__PURE__ */ new Set();
    collisionDetails?.forEach((detail) => {
      detail.buildings.forEach((building) => {
        const buildingId = building.id.toString();
        if (processedBuildings.has(buildingId)) return;
        processedBuildings.add(buildingId);
        const center = calculatePolygonCenter(building.polygon);
        if (!center || center.length !== 2 || isNaN(center[0]) || isNaN(center[1])) {
          console.warn("Invalid center coordinates for building:", building.id, center);
          return;
        }
        const cost = calculateBuildingDemolitionCost(building);
        markers.push({
          id: buildingId,
          center,
          cost,
          costM: Math.round(cost / 1e6)
          // Cost in millions
        });
      });
    });
    return markers.sort((a2, b) => a2.cost - b.cost);
  }, [collisionDetails]);
  if (!isConstructionPanel) return null;
  if (!collisionDetails || collisionDetails.length === 0) return null;
  if (zoom <= 15) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: markerData.map((marker) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Marker,
    {
      longitude: marker.center[0],
      latitude: marker.center[1],
      anchor: "center",
      className: "pointer-events-none",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-sm px-0.5 flex items-center gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(PiBulldozer, { className: "dark:text-yellow-200 text-yellow-800" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium text-destructive", children: formatCurrency(marker.cost) })
      ] })
    },
    marker.id
  )) });
}
function calculatePolygonCenter(polygon) {
  const outerRing = polygon[0];
  let sumLng = 0;
  let sumLat = 0;
  let pointCount = 0;
  for (const point2 of outerRing) {
    sumLng += point2[0];
    sumLat += point2[1];
    pointCount++;
  }
  return [sumLng / pointCount, sumLat / pointCount];
}
const vs$3 = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;
uniform int sizeUnits;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;
const fs$5 = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float alphaCutoff;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * opacity * vColor.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
const DEFAULT_CANVAS_WIDTH = 1024;
const DEFAULT_BUFFER$1 = 4;
const noop = () => {
};
const DEFAULT_SAMPLER_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  // LINEAR is the default value but explicitly set it here
  magFilter: "linear",
  // minimize texture boundary artifacts
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
const MISSING_ICON = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
function nextPowOfTwo$1(number2) {
  return Math.pow(2, Math.ceil(Math.log2(number2)));
}
function resizeImage(ctx2, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return { data: imageData, width, height };
  }
  ctx2.canvas.height = height;
  ctx2.canvas.width = width;
  ctx2.clearRect(0, 0, width, height);
  ctx2.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return { data: ctx2.canvas, width, height };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, sampler) {
  const { width: oldWidth, height: oldHeight, device } = texture;
  const newTexture = device.createTexture({ format: "rgba8unorm", width, height, sampler });
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyTextureToTexture({
    source: texture,
    destination: newTexture,
    width: oldWidth,
    height: oldHeight
  });
  commandEncoder.finish();
  texture.destroy();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const { icon, xOffset } = columns[i];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping$1({ icons, buffer, mapping = {}, xOffset = 0, yOffset = 0, rowHeight = 0, canvasWidth }) {
  let columns = [];
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const { height, width } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo$1(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const { iterable, objectInfo } = createIterable(data);
  for (const object2 of iterable) {
    objectInfo.index++;
    const icon = getIcon(object2, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = { ...icon, source: object2, sourceIndex: objectInfo.index };
    }
  }
  return icons;
}
class IconManager {
  constructor(device, { onUpdate = noop, onError = noop }) {
    this._loadOptions = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._textureParameters = null;
    this._pendingCount = 0;
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._rowHeight = 0;
    this._buffer = DEFAULT_BUFFER$1;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
    this.device = device;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    this._texture?.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || MISSING_ICON;
  }
  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, textureParameters }) {
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== void 0) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      this._texture?.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._textureParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    if (!this._autoPacking || typeof document === "undefined") {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping$1({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = this.device.createTexture({
          format: "rgba8unorm",
          width: this._canvasWidth,
          height: this._canvasHeight,
          sampler: this._textureParameters || DEFAULT_SAMPLER_PARAMETERS
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_SAMPLER_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement("canvas");
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx2 = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      load(icon.url, this._loadOptions).then((imageData) => {
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const { x: x2, y: y2, width: maxWidth, height: maxHeight } = iconDef;
        const { data, width, height } = resizeImage(ctx2, imageData, maxWidth, maxHeight);
        this._texture.setSubImageData({
          data,
          x: x2 + (maxWidth - width) / 2,
          y: y2 + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch((error) => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
}
const DEFAULT_COLOR$4 = [0, 0, 0, 255];
const defaultProps$9 = {
  iconAtlas: { type: "image", value: null, async: true },
  iconMapping: { type: "object", value: {}, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  billboard: true,
  sizeUnits: "pixels",
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getIcon: { type: "accessor", value: (x2) => x2.icon },
  getColor: { type: "accessor", value: DEFAULT_COLOR$4 },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  onIconError: { type: "function", value: null, optional: true },
  textureParameters: { type: "object", ignore: true, value: null }
};
class IconLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: vs$3, fs: fs$5, modules: [project32, picking] });
  }
  initializeState() {
    this.state = {
      iconManager: new IconManager(this.context.device, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: "uint8",
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR$4
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      }
    });
  }
  /* eslint-disable max-statements, complexity */
  updateState(params) {
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
    const { iconManager } = this.state;
    if (typeof iconAtlas === "string") {
      return;
    }
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate("getIcon");
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  /* eslint-enable max-statements, complexity */
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({ uniforms }) {
    const { sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
    const { iconManager } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      const model = this.state.model;
      model.setBindings({ iconsTexture });
      model.setUniforms(uniforms);
      model.setUniforms({
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          // The size must be explicitly passed here otherwise luma.gl
          // will default to assuming that positions are 3D (x,y,z)
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    const onIconError = this.getCurrentLayer()?.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      defaultLogger.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const { width, height, anchorX = width / 2, anchorY = height / 2 } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const { x: x2, y: y2, width, height } = this.state.iconManager.getIconMapping(icon);
    return [x2, y2, width, height];
  }
}
IconLayer.defaultProps = defaultProps$9;
IconLayer.layerName = "IconLayer";
const vs$2 = `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;
uniform bool antialiasing;
uniform bool billboard;
uniform int radiusUnits;
uniform int lineWidthUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),
radiusMinPixels, radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),
lineWidthMinPixels, lineWidthMaxPixels
);
outerRadiusPixels += stroked * lineWidthPixels / 2.0;
float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
if (billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;
const fs$4 = `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
uniform bool filled;
uniform float stroked;
uniform bool antialiasing;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (stroked > 0.5) {
float isLine = antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (filled) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (!filled) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
const DEFAULT_COLOR$3 = [0, 0, 0, 255];
const defaultProps$8 = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR$3 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR$3 },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
class ScatterplotLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: vs$2, fs: fs$4, modules: [project32, picking] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      stroked: stroked ? 1 : 0,
      filled,
      billboard,
      antialiasing,
      radiusUnits: UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
}
ScatterplotLayer.defaultProps = defaultProps$8;
ScatterplotLayer.layerName = "ScatterplotLayer";
const WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
const DimIndex = {
  x: 0,
  y: 1,
  z: 2
};
function getPolygonSignedArea(points, options = {}) {
  const { start: start2 = 0, end = points.length, plane = "xy" } = options;
  const dim = options.size || 2;
  let area = 0;
  const i0 = DimIndex[plane[0]];
  const i1 = DimIndex[plane[1]];
  for (let i = start2, j = end - dim; i < end; i += dim) {
    area += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);
    j = i;
  }
  return area / 2;
}
function reversePolygon(points, options) {
  const { start: start2 = 0, end = points.length, size = 2 } = options;
  const numPoints = (end - start2) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i = 0; i < numSwaps; ++i) {
    const b1 = start2 + i * size;
    const b2 = start2 + (numPoints - 1 - i) * size;
    for (let j = 0; j < size; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i = 0; i < size; i++) {
      if (target[startIndex - size + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i = 0; i < size; i++) {
    target[startIndex + i] = source[i];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i = 0; i < size; i++) {
    target[i] = source[i];
  }
}
function getPointAtIndex(positions, index2, size, offset2, out = []) {
  const startI = offset2 + index2 * size;
  for (let i = 0; i < size; i++) {
    out[i] = positions[startI + i];
  }
  return out;
}
function intersect(a2, b, edge, bbox2, out = []) {
  let t;
  let snap;
  if (edge & 8) {
    t = (bbox2[3] - a2[1]) / (b[1] - a2[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox2[1] - a2[1]) / (b[1] - a2[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox2[2] - a2[0]) / (b[0] - a2[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox2[0] - a2[0]) / (b[0] - a2[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i = 0; i < a2.length; i++) {
    out[i] = (snap & 1) === i ? bbox2[snap] : t * (b[i] - a2[i]) + a2[i];
  }
  return out;
}
function bitCode(p2, bbox2) {
  let code = 0;
  if (p2[0] < bbox2[0])
    code |= 1;
  else if (p2[0] > bbox2[2])
    code |= 2;
  if (p2[1] < bbox2[1])
    code |= 4;
  else if (p2[1] > bbox2[3])
    code |= 8;
  return code;
}
function cutPolylineByGrid(positions, options) {
  const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a2 = getPointAtIndex(positions, 0, size, startIndex);
  let b;
  let codeB;
  const cell = getGridCell(a2, gridResolution, gridOffset, []);
  const scratchPoint = [];
  push(part, a2);
  for (let i = 1; i < numPoints; i++) {
    b = getPointAtIndex(positions, i, size, startIndex, b);
    codeB = bitCode(b, cell);
    while (codeB) {
      intersect(a2, b, codeB, cell, scratchPoint);
      const codeAlt = bitCode(scratchPoint, cell);
      if (codeAlt) {
        intersect(a2, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      push(part, scratchPoint);
      copy(a2, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a2);
      }
      codeB = bitCode(b, cell);
    }
    push(part, b);
    copy(a2, b);
  }
  return broken ? result : result[0];
}
const TYPE_INSIDE = 0;
const TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
  const result = [];
  const queue = [
    {
      pos: positions,
      types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
      holes: holeIndices || []
    }
  ];
  const bbox2 = [[], []];
  let cell = [];
  while (queue.length) {
    const { pos, types, holes } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox2);
    cell = getGridCell(bbox2[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox2[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
      const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
      queue.push(polygonLow, polygonHigh);
      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = { positions: pos };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox2, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p2;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox2[3] : prev[0] - bbox2[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i = 0; i < numPoints; i++) {
    p2 = getPointAtIndex(positions, i, size, startIndex, p2);
    side = Math.sign(edge & 8 ? p2[1] - bbox2[3] : p2[0] - bbox2[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p2, edge, bbox2, scratchPoint);
      push(resultLow, scratchPoint) && typesLow.push(prevType);
      push(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p2) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p2) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy(prev, p2);
    prevSide = side;
    prevType = type;
  }
  return [
    lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
    highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
  ];
}
function getGridCell(p2, gridResolution, gridOffset, out) {
  const left = Math.floor((p2[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p2[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < endIndex; i += size) {
    const x2 = positions[i];
    const y2 = positions[i + 1];
    minX = x2 < minX ? x2 : minX;
    maxX = x2 > maxX ? x2 : maxX;
    minY = y2 < minY ? y2 : minY;
    maxY = y2 > maxY ? y2 : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }
  return arr1;
}
const DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize2 = true } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const { size = 2, normalize: normalize2 = true, edgeTypes = false } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i = startIndex + 1; i < endIndex; i += size) {
    const lat = Math.abs(positions[i]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p2 = getPointAtIndex(positions, 0, size, startIndex);
    p2[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p2);
    p2[1] = Math.sign(p2[1]) * maxLatitude;
    push(positions, p2);
    p2[0] = firstLng;
    push(positions, p2);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i = startIndex; i < endIndex; i += size) {
    lng = positions[i];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i = 0; i < pointCount; i++) {
    positions[i * size] += delta;
  }
}
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length = path.length * size;
    flatPath = new Array(length);
    for (let i = 0; i < path.length; i++) {
      for (let j = 0; j < size; j++) {
        flatPath[i * size + j] = path[i][j] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, { size, gridResolution });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, { size });
  }
  return flatPath;
}
const START_CAP = 1;
const END_CAP = 2;
const INVALID = 4;
class PathTesselator extends Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        // Padding covers shaderAttributes for last segment in largest case fp64
        // additional vertex + hi & low parts, 3 * 6
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: { size: 1, type: Uint8ClampedArray }
      }
    });
  }
  /** Get packed attribute by name */
  get(attributeName) {
    return this.attributes[attributeName];
  }
  /* Implement base Tesselator interface */
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /* Implement base Tesselator interface */
  normalizeGeometry(path) {
    if (this.normalize) {
      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  /* Implement base Tesselator interface */
  getGeometrySize(path) {
    if (isCut$1(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  /* Implement base Tesselator interface */
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut$1(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const { vertexStart, geometrySize } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const { positions } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const { vertexStart, geometrySize } = context;
    const p2 = new Array(3);
    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p2);
      positions[i * 3] = p2[0];
      positions[i * 3 + 1] = p2[1];
      positions[i * 3 + 2] = p2[2];
    }
  }
  // Utilities
  /** Returns the number of points in the path */
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  /** Returns a point on the path at the specified index */
  getPointOnPath(path, index2, target = []) {
    const { positionSize } = this;
    if (index2 * positionSize >= path.length) {
      index2 += 1 - path.length / positionSize;
    }
    const i = index2 * positionSize;
    target[0] = path[i];
    target[1] = path[i + 1];
    target[2] = positionSize === 3 && path[i + 2] || 0;
    return target;
  }
  // Returns true if the first and last points are identical
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const { positionSize } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
}
function isCut$1(path) {
  return Array.isArray(path[0]);
}
const vs$1 = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float capType;
uniform float miterLimit;
uniform bool billboard;
uniform int widthUnits;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = capType;
} else {
vJointType = jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels) / 2.0);
vec3 width;
if (billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
const fs$3 = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
uniform float miterLimit;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
const DEFAULT_COLOR$2 = [0, 0, 0, 255];
const defaultProps$7 = {
  widthUnits: "meters",
  widthScale: { type: "number", min: 0, value: 1 },
  widthMinPixels: { type: "number", min: 0, value: 0 },
  widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  jointRounded: false,
  capRounded: false,
  miterLimit: { type: "number", min: 0, value: 4 },
  billboard: false,
  _pathType: null,
  getPath: { type: "accessor", value: (object2) => object2.path },
  getColor: { type: "accessor", value: DEFAULT_COLOR$2 },
  getWidth: { type: "accessor", value: 1 },
  // deprecated props
  rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
};
const ATTRIBUTE_TRANSITION$1 = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
class PathLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: vs$1, fs: fs$3, modules: [project32, picking] });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      vertexPositions: {
        size: 3,
        // Start filling buffer from 1 vertex in
        vertexOffset: 1,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION$1,
        accessor: "getPath",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: "uint8",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: ATTRIBUTE_TRANSITION$1,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        accessor: "getColor",
        transition: ATTRIBUTE_TRANSITION$1,
        defaultValue: DEFAULT_COLOR$2
      },
      instancePickingColors: {
        size: 4,
        type: "uint8",
        accessor: (object2, { index: index2, target: value }) => this.encodePickingColor(object2 && object2.__source ? object2.__source.index : index2, value)
      }
    });
    this.setState({
      pathTesselator: new PathTesselator({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const { pathTesselator } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === "loop",
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index: index2 } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d) => d.__source.index === index2);
    }
    return info;
  }
  /** Override base Layer method */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { jointRounded, capRounded, billboard, miterLimit, widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const SEGMENT_INDICES = [
      // start corner
      0,
      1,
      2,
      // body
      1,
      4,
      2,
      1,
      3,
      4,
      // end corner
      3,
      5,
      4
    ];
    const SEGMENT_POSITIONS = [
      // bevel start corner
      0,
      0,
      // start inner corner
      0,
      -1,
      // start outer corner
      0,
      1,
      // end inner corner
      1,
      -1,
      // end outer corner
      1,
      1,
      // bevel end corner
      1,
      0
    ];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("positions");
  }
  calculateSegmentTypes(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("segmentTypes");
  }
}
PathLayer.defaultProps = defaultProps$7;
PathLayer.layerName = "PathLayer";
var earcut$1 = { exports: {} };
var hasRequiredEarcut;
function requireEarcut() {
  if (hasRequiredEarcut) return earcut$1.exports;
  hasRequiredEarcut = 1;
  earcut$1.exports = earcut2;
  earcut$1.exports.default = earcut2;
  function earcut2(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x2, y2, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x2 = data[i];
        y2 = data[i + 1];
        if (x2 < minX) minX = x2;
        if (y2 < minY) minY = y2;
        if (x2 > maxX) maxX = x2;
        if (y2 > maxY) maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start2, end, dim, clockwise) {
    var i, last2;
    if (clockwise === signedArea(data, start2, end, dim) > 0) {
      for (i = start2; i < end; i += dim) last2 = insertNode(i, data[i], data[i + 1], last2);
    } else {
      for (i = end - dim; i >= start2; i -= dim) last2 = insertNode(i, data[i], data[i + 1], last2);
    }
    if (last2 && equals2(last2, last2.next)) {
      removeNode(last2);
      last2 = last2.next;
    }
    return last2;
  }
  function filterPoints(start2, end) {
    if (!start2) return start2;
    if (!end) end = start2;
    var p2 = start2, again;
    do {
      again = false;
      if (!p2.steiner && (equals2(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end = p2.prev;
        if (p2 === p2.next) break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    var a2 = ear.prev, b = ear, c2 = ear.next;
    if (area(a2, b, c2) >= 0) return false;
    var ax = a2.x, bx = b.x, cx = c2.x, ay = a2.y, by = b.y, cy = c2.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p2 = c2.next;
    while (p2 !== a2) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
      p2 = p2.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    var a2 = ear.prev, b = ear, c2 = ear.next;
    if (area(a2, b, c2) >= 0) return false;
    var ax = a2.x, bx = b.x, cx = c2.x, ay = a2.y, by = b.y, cy = c2.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p2 = ear.prevZ, n = ear.nextZ;
    while (p2 && p2.z >= minZ && n && n.z <= maxZ) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
      p2 = p2.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }
    while (p2 && p2.z >= minZ) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
      p2 = p2.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start2, triangles, dim) {
    var p2 = start2;
    do {
      var a2 = p2.prev, b = p2.next.next;
      if (!equals2(a2, b) && intersects(a2, p2, p2.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
        triangles.push(a2.i / dim | 0);
        triangles.push(p2.i / dim | 0);
        triangles.push(b.i / dim | 0);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start2 = b;
      }
      p2 = p2.next;
    } while (p2 !== start2);
    return filterPoints(p2);
  }
  function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
    var a2 = start2;
    do {
      var b = a2.next.next;
      while (b !== a2.prev) {
        if (a2.i !== b.i && isValidDiagonal(a2, b)) {
          var c2 = splitPolygon(a2, b);
          a2 = filterPoints(a2, a2.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a2 = a2.next;
    } while (a2 !== start2);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start2, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start2 = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start2, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareX(a2, b) {
    return a2.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
    do {
      if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          m2 = p2.x < p2.next.x ? p2 : p2.next;
          if (x2 === hx) return m2;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m2) return null;
    var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
    p2 = m2;
    do {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        tan = Math.abs(hy - p2.y) / (hx - p2.x);
        if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
          m2 = p2;
          tanMin = tan;
        }
      }
      p2 = p2.next;
    } while (p2 !== stop);
    return m2;
  }
  function sectorContainsSector(m2, p2) {
    return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
  }
  function indexCurve(start2, minX, minY, invSize) {
    var p2 = start2;
    do {
      if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start2);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  }
  function sortLinked(list) {
    var i, p2, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p2 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        q = p2;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
            e = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail) tail.nextZ = e;
          else list = e;
          e.prevZ = tail;
          tail = e;
        }
        p2 = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x2, y2, minX, minY, invSize) {
    x2 = (x2 - minX) * invSize | 0;
    y2 = (y2 - minY) * invSize | 0;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y2 = (y2 | y2 << 8) & 16711935;
    y2 = (y2 | y2 << 4) & 252645135;
    y2 = (y2 | y2 << 2) & 858993459;
    y2 = (y2 | y2 << 1) & 1431655765;
    return x2 | y2 << 1;
  }
  function getLeftmost(start2) {
    var p2 = start2, leftmost = start2;
    do {
      if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start2);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function isValidDiagonal(a2, b) {
    return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && // dones't intersect other edges
    (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && // locally visible
    (area(a2.prev, a2, b.prev) || area(a2, b.prev, b)) || // does not create opposite-facing sectors
    equals2(a2, b) && area(a2.prev, a2, a2.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p2, q, r) {
    return (q.y - p2.y) * (r.x - q.x) - (q.x - p2.x) * (r.y - q.y);
  }
  function equals2(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    var o1 = sign2(area(p1, q1, p2));
    var o2 = sign2(area(p1, q1, q2));
    var o3 = sign2(area(p2, q2, p1));
    var o4 = sign2(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true;
    if (o1 === 0 && onSegment(p1, p2, q1)) return true;
    if (o2 === 0 && onSegment(p1, q2, q1)) return true;
    if (o3 === 0 && onSegment(p2, p1, q2)) return true;
    if (o4 === 0 && onSegment(p2, q1, q2)) return true;
    return false;
  }
  function onSegment(p2, q, r) {
    return q.x <= Math.max(p2.x, r.x) && q.x >= Math.min(p2.x, r.x) && q.y <= Math.max(p2.y, r.y) && q.y >= Math.min(p2.y, r.y);
  }
  function sign2(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a2, b) {
    var p2 = a2;
    do {
      if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a2, b)) return true;
      p2 = p2.next;
    } while (p2 !== a2);
    return false;
  }
  function locallyInside(a2, b) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b, a2.next) >= 0 && area(a2, a2.prev, b) >= 0 : area(a2, b, a2.prev) < 0 || area(a2, a2.next, b) < 0;
  }
  function middleInside(a2, b) {
    var p2 = a2, inside = false, px = (a2.x + b.x) / 2, py = (a2.y + b.y) / 2;
    do {
      if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
        inside = !inside;
      p2 = p2.next;
    } while (p2 !== a2);
    return inside;
  }
  function splitPolygon(a2, b) {
    var a22 = new Node2(a2.i, a2.x, a2.y), b2 = new Node2(b.i, b.x, b.y), an = a2.next, bp = b.prev;
    a2.next = b;
    b.prev = a2;
    a22.next = an;
    an.prev = a22;
    b2.next = a22;
    a22.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x2, y2, last2) {
    var p2 = new Node2(i, x2, y2);
    if (!last2) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last2.next;
      p2.prev = last2;
      last2.next.prev = p2;
      last2.next = p2;
    }
    return p2;
  }
  function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
  }
  function Node2(i, x2, y2) {
    this.i = i;
    this.x = x2;
    this.y = y2;
    this.prev = null;
    this.next = null;
    this.z = 0;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  earcut2.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start2 = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start2, end, dim));
      }
    }
    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
      var a2 = triangles[i] * dim;
      var b = triangles[i + 1] * dim;
      var c2 = triangles[i + 2] * dim;
      trianglesArea += Math.abs(
        (data[a2] - data[c2]) * (data[b + 1] - data[a2 + 1]) - (data[a2] - data[b]) * (data[c2 + 1] - data[a2 + 1])
      );
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };
  function signedArea(data, start2, end, dim) {
    var sum = 0;
    for (var i = start2, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  earcut2.flatten = function(data) {
    var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
      }
      if (i > 0) {
        holeIndex += data[i - 1].length;
        result.holes.push(holeIndex);
      }
    }
    return result;
  };
  return earcut$1.exports;
}
var earcutExports = requireEarcut();
const earcut = /* @__PURE__ */ getDefaultExportFromCjs(earcutExports);
const OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
const HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
const windingOptions = {};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return { positions, holeIndices };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area = 0;
  for (let i = 0; i < numVerts; i++) {
    const j = (i + 1) % numVerts;
    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];
    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];
  }
  return Math.abs(area / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i = 0; i < numVerts; i++) {
    const o = i * 3;
    const x2 = positions[o + 0];
    const y2 = positions[o + 1];
    const z = positions[o + 2];
    positions[o + xIndex] = x2;
    positions[o + yIndex] = y2;
    positions[o + zIndex] = z;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n = positions.length;
    positions = positions.slice();
    const p2 = [];
    for (let i = 0; i < n; i += positionSize) {
      p2[0] = positions[i];
      p2[1] = positions[i + 1];
      if (is3d) {
        p2[2] = positions[i + 2];
      }
      const xy = preproject(p2);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
      if (is3d) {
        positions[i + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) ;
    else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 2, 0, 1);
    }
  }
  return earcut(positions, holeIndices, positionSize);
}
class PolygonTesselator extends Tesselator {
  constructor(opts) {
    const { fp64, IndexType = Uint32Array } = opts;
    super({
      ...opts,
      attributes: {
        positions: { size: 3, type: fp64 ? Float64Array : Float32Array },
        vertexValid: { type: Uint16Array, size: 1 },
        indices: { type: IndexType, size: 1 }
      }
    });
  }
  /** Get attribute by name */
  get(attributeName) {
    const { attributes } = this;
    if (attributeName === "indices") {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  /** Override base Tesselator method */
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error("missing indices buffer");
    }
  }
  /** Implement base Tesselator interface */
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = normalize(polygon, this.positionSize);
      if (this.opts.resolution) {
        return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  /** Implement base Tesselator interface */
  getGeometrySize(polygon) {
    if (isCut(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return getPositions(polygon).length / this.positionSize;
  }
  /** Override base Tesselator method */
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /** Implement base Tesselator interface */
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      const normalizedPolygon = polygon;
      this._updateIndices(normalizedPolygon, context);
      this._updatePositions(normalizedPolygon, context);
      this._updateVertexValid(normalizedPolygon, context);
    }
  }
  // Flatten the indices array
  _updateIndices(polygon, { geometryIndex, vertexStart: offset2, indexStart }) {
    const { attributes, indexStarts, typedArrayManager } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i = indexStart;
    const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j = 0; j < indices.length; j++) {
      target[i++] = indices[j] + offset2;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(polygon, { vertexStart, geometrySize }) {
    const { attributes: { positions }, positionSize } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = getPositions(polygon);
    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {
      const x2 = polygonPositions[j * positionSize];
      const y2 = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
      positions[i * 3] = x2;
      positions[i * 3 + 1] = y2;
      positions[i * 3 + 2] = z;
    }
  }
  _updateVertexValid(polygon, { vertexStart, geometrySize }) {
    const { positionSize } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
}
function isCut(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}
const main = `uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;
in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project_uCommonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (extruded) {
pos.z += props.elevations * elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * opacity);
} else {
vColor = vec4(colors.rgb, colors.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
const vsTop = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${main}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;
const vsSide = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${main}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`;
const fs$2 = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
const DEFAULT_COLOR$1 = [0, 0, 0, 255];
const defaultProps$6 = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  _full3d: false,
  elevationScale: { type: "number", min: 0, value: 1 },
  getPolygon: { type: "accessor", value: (f) => f.polygon },
  getElevation: { type: "accessor", value: 1e3 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR$1 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR$1 },
  material: true
};
const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
class SolidPolygonLayer extends Layer {
  getShaders(type) {
    return super.getShaders({
      vs: type === "top" ? vsTop : vsSide,
      fs: fs$2,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [project32, gouraudLighting, picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const { viewport } = this.context;
    let { coordinateSystem } = this.props;
    const { _full3d } = this.props;
    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new PolygonTesselator({
        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
        // Provide a preproject function if the coordinates are in lnglat
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: Uint32Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(["instancePickingColors"]);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateIndices,
        noAlloc
      },
      vertexPositions: {
        size: 3,
        type: "float64",
        stepMode: "dynamic",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getPolygon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          nextVertexPositions: {
            vertexOffset: 1
          }
        }
      },
      instanceVertexValid: {
        size: 1,
        type: "uint16",
        stepMode: "instance",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getElevation"
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR$1
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR$1
      },
      pickingColors: {
        size: 4,
        type: "uint8",
        stepMode: "dynamic",
        accessor: (object2, { index: index2, target: value }) => this.encodePickingColor(object2 && object2.__source ? object2.__source.index : index2, value)
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index: index2 } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d) => d.__source.index === index2);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { extruded, filled, wireframe, elevationScale } = this.props;
    const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
    const renderUniforms = {
      ...uniforms,
      extruded: Boolean(extruded),
      elevationScale
    };
    if (wireframeModel && wireframe) {
      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      wireframeModel.setUniforms(renderUniforms);
      wireframeModel.draw(this.context.renderPass);
    }
    if (sideModel && filled) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.setUniforms(renderUniforms);
      sideModel.draw(this.context.renderPass);
    }
    if (topModel && filled) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.setUniforms(renderUniforms);
      topModel.draw(this.context.renderPass);
    }
  }
  updateState(updateParams) {
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const { props, oldProps, changeFlags } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      this.state.models?.forEach((model) => model.destroy());
      this.setState(this._getModels());
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({ props, oldProps, changeFlags }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const { polygonTesselator } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels() {
    const { id, filled, extruded } = this.props;
    let topModel;
    let sideModel;
    let wireframeModel;
    if (filled) {
      const shaders = this.getShaders("top");
      shaders.defines.NON_INSTANCED_MODEL = 1;
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: false });
      topModel = new Model(this.context.device, {
        ...shaders,
        id: `${id}-top`,
        topology: "triangle-list",
        uniforms: {
          isWireframe: false
        },
        bufferLayout,
        isIndexed: true,
        userData: {
          excludeAttributes: { instanceVertexValid: true }
        }
      });
    }
    if (extruded) {
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: true });
      sideModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-side`,
        bufferLayout,
        uniforms: {
          isWireframe: false
        },
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            // top right - top left - bottom right - bottom left
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
      wireframeModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-wireframe`,
        bufferLayout,
        uniforms: {
          isWireframe: true
        },
        geometry: new Geometry({
          topology: "line-strip",
          attributes: {
            // top right - top left - bottom left - bottom right
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
    }
    return {
      models: [sideModel, wireframeModel, topModel].filter(Boolean),
      topModel,
      sideModel,
      wireframeModel
    };
  }
  calculateIndices(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get("indices");
  }
  calculatePositions(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get("positions");
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get("vertexValid");
  }
}
SolidPolygonLayer.defaultProps = defaultProps$6;
SolidPolygonLayer.layerName = "SolidPolygonLayer";
function replaceInRange({ data, getIndex, dataRange, replace }) {
  const { startRow = 0, endRow = Infinity } = dataRange;
  const count2 = data.length;
  let replaceStart = count2;
  let replaceEnd = count2;
  for (let i = 0; i < count2; i++) {
    const row = getIndex(data[i]);
    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }
    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }
  let index2 = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
  for (let i = 0; i < replace.length; i++) {
    data[index2++] = replace[i];
  }
  if (endChunk) {
    for (let i = 0; i < endChunk.length; i++) {
      data[index2++] = endChunk[i];
    }
    data.length = index2;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}
const defaultLineColor = [0, 0, 0, 255];
const defaultFillColor = [0, 0, 0, 255];
const defaultProps$5 = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: { type: "accessor", value: (f) => f.polygon },
  // Polygon fill color
  getFillColor: { type: "accessor", value: defaultFillColor },
  // Point, line and polygon outline color
  getLineColor: { type: "accessor", value: defaultLineColor },
  // Line and polygon outline accessors
  getLineWidth: { type: "accessor", value: 1 },
  // Polygon extrusion accessor
  getElevation: { type: "accessor", value: 1e3 },
  // Optional material for 'lighting' shader module
  material: true
};
class PolygonLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      paths: [],
      pathsDiff: null
    };
    if (this.props.getLineDashArray) {
      defaultLogger.removed("getLineDashArray", "PathStyleExtension")();
    }
  }
  updateState({ changeFlags }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
        data: paths,
        getIndex: (p2) => p2.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({ paths, pathsDiff });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const { data, getPolygon, positionFormat, _normalize } = this.props;
    const paths = [];
    const positionSize = positionFormat === "XY" ? 2 : 3;
    const { startRow, endRow } = dataRange;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object2 of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object2, objectInfo);
      if (_normalize) {
        polygon = normalize(polygon, positionSize);
      }
      const { holeIndices } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i = 0; i <= holeIndices.length; i++) {
          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
          paths.push(this.getSubLayerRow({ path }, object2, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({ path: positions }, object2, objectInfo.index));
      }
    }
    return paths;
  }
  /* eslint-disable complexity */
  renderLayers() {
    const { data, _dataDiff, stroked, filled, extruded, wireframe, _normalize, _windingOrder, elevationScale, transitions, positionFormat } = this.props;
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified } = this.props;
    const { getFillColor, getLineColor, getLineWidth, getLineDashArray, getElevation, getPolygon, updateTriggers, material } = this.props;
    const { paths, pathsDiff } = this.state;
    const FillLayer = this.getSubLayerClass("fill", SolidPolygonLayer);
    const StrokeLayer = this.getSubLayerClass("stroke", PathLayer);
    const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: "fill",
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        // using a legacy API to invalid lineColor attributes
        // if (extruded && wireframe) has changed
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      // Already normalized
      _pathType: "loop",
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: "stroke",
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: (x2) => x2.path
    });
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer,
      polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer
    ];
  }
}
PolygonLayer.layerName = "PolygonLayer";
PolygonLayer.defaultProps = defaultProps$5;
function binaryToFeatureForAccesor(data, index2) {
  if (!data) {
    return null;
  }
  const featureIndex = "startIndices" in data ? data.startIndices[index2] : index2;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: { ...data.properties[propertiesIndex] }
  };
  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 4);
    const pickingColor = [];
    for (let i = 0; i < featureIds.length; i++) {
      encodePickingColor(featureIds[i], pickingColor);
      pickingColors[key][i * 4 + 0] = pickingColor[0];
      pickingColors[key][i * 4 + 1] = pickingColor[1];
      pickingColors[key][i * 4 + 2] = pickingColor[2];
      pickingColors[key][i * 4 + 3] = 255;
    }
  }
  return pickingColors;
}
const fs$1 = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float gamma;
uniform bool sdf;
uniform float alphaCutoff;
uniform float sdfBuffer;
uniform float outlineBuffer;
uniform vec4 outlineColor;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf) {
float distance = alpha;
alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);
if (outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
color = mix(outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
const DEFAULT_BUFFER = 192 / 256;
const EMPTY_ARRAY = [];
const defaultProps$4 = {
  getIconOffsets: { type: "accessor", value: (x2) => x2.offsets },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: { type: "color", value: [0, 0, 0, 255] }
};
class MultiIconLayer extends IconLayer {
  getShaders() {
    return { ...super.getShaders(), fs: fs$1 };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: "uint8",
        size: 3,
        accessor: (object2, { index: index2, target: value }) => this.encodePickingColor(index2, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    let { outlineColor } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map((x2) => x2 / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      defaultLogger.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
    }
  }
  draw(params) {
    const { sdf, smoothing, outlineWidth } = this.props;
    const { outlineColor } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1;
    params.uniforms = {
      ...params.uniforms,
      // Refer the following doc about gamma and buffer
      // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817
      sdfBuffer: DEFAULT_BUFFER,
      outlineBuffer,
      gamma: smoothing,
      sdf: Boolean(sdf),
      outlineColor
    };
    super.draw(params);
    if (sdf && outlineWidth) {
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      const model = this.state.model;
      if (iconsTexture) {
        model.setUniforms({ outlineBuffer: DEFAULT_BUFFER });
        model.draw(this.context.renderPass);
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }
}
MultiIconLayer.defaultProps = defaultProps$4;
MultiIconLayer.layerName = "MultiIconLayer";
const INF = 1e20;
class TinySDF {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = "sans-serif",
    fontWeight = "normal",
    fontStyle = "normal"
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;
    const size = this.size = fontSize + buffer * 4;
    const canvas2 = this._createCanvas(size);
    const ctx2 = this.ctx = canvas2.getContext("2d", { willReadFrequently: true });
    ctx2.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx2.textBaseline = "alphabetic";
    ctx2.textAlign = "left";
    ctx2.fillStyle = "black";
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = canvas2.height = size;
    return canvas2;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len);
    const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
    if (glyphWidth === 0 || glyphHeight === 0) return glyph;
    const { ctx: ctx2, buffer, gridInner, gridOuter } = this;
    ctx2.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx2.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx2.getImageData(buffer, buffer, glyphWidth, glyphHeight);
    gridOuter.fill(INF, 0, len);
    gridInner.fill(0, 0, len);
    for (let y2 = 0; y2 < glyphHeight; y2++) {
      for (let x2 = 0; x2 < glyphWidth; x2++) {
        const a2 = imgData.data[4 * (y2 * glyphWidth + x2) + 3] / 255;
        if (a2 === 0) continue;
        const j = (y2 + buffer) * width + x2 + buffer;
        if (a2 === 1) {
          gridOuter[j] = 0;
          gridInner[j] = INF;
        } else {
          const d = 0.5 - a2;
          gridOuter[j] = d > 0 ? d * d : 0;
          gridInner[j] = d < 0 ? d * d : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i = 0; i < len; i++) {
      const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
      data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
    }
    return glyph;
  }
}
function edt(data, x0, y0, width, height, gridSize, f, v, z) {
  for (let x2 = x0; x2 < x0 + width; x2++) edt1d(data, y0 * gridSize + x2, gridSize, height, f, v, z);
  for (let y2 = y0; y2 < y0 + height; y2++) edt1d(data, y2 * gridSize + x0, 1, width, f, v, z);
}
function edt1d(grid, offset2, stride, length, f, v, z) {
  v[0] = 0;
  z[0] = -INF;
  z[1] = INF;
  f[0] = grid[offset2];
  for (let q = 1, k2 = 0, s2 = 0; q < length; q++) {
    f[q] = grid[offset2 + q * stride];
    const q2 = q * q;
    do {
      const r = v[k2];
      s2 = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
    } while (s2 <= z[k2] && --k2 > -1);
    k2++;
    v[k2] = q;
    z[k2] = s2;
    z[k2 + 1] = INF;
  }
  for (let q = 0, k2 = 0; q < length; q++) {
    while (z[k2 + 1] < q) k2++;
    const r = v[k2];
    const qr = q - r;
    grid[offset2 + q * stride] = f[r] + qr * qr;
  }
}
const MISSING_CHAR_WIDTH = 32;
const SINGLE_LINE = [];
function nextPowOfTwo(number2) {
  return Math.pow(2, Math.ceil(Math.log2(number2)));
}
function buildMapping({ characterSet, getFontWidth, fontHeight, buffer, maxCanvasWidth, mapping = {}, xOffset = 0, yOffset = 0 }) {
  let row = 0;
  let x2 = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x2 + width + buffer * 2 > maxCanvasWidth) {
        x2 = 0;
        row++;
      }
      mapping[char] = {
        x: x2 + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x2 += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x2,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = text[i];
    width += mapping[character]?.layoutWidth || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const textWidth = getTextWidth(text, i, i + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        target.push(i);
      }
      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    if (text[i] === " ") {
      groupEndCharIndex = i + 1;
    } else if (text[i + 1] === " " || i + 1 === endIndex) {
      groupEndCharIndex = i + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x2 = 0;
  let rowHeight = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = line[i];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i] = x2 + frame.layoutWidth / 2;
      x2 += frame.layoutWidth;
    } else {
      defaultLogger.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
      leftOffsets[i] = x2;
      x2 += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x2;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x2 = new Array(numCharacters);
  const y2 = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i = 0; i <= numCharacters; i++) {
    const char = characters[i];
    if (char === "\n" || i === numCharacters) {
      lineEndIndex = i;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x2, rowSize);
        for (let j = rowStart; j < rowEnd; j++) {
          const char2 = characters[j];
          const layoutOffsetY = iconMapping[char2]?.layoutOffsetY || 0;
          y2[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x2[lineStartIndex] = 0;
      y2[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return { x: x2, y: y2, rowWidth, size };
}
function getTextFromBuffer({ value, length, stride, offset: offset2, startIndices, characterSet }) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset2 ? offset2 / bytesPerElement : 0;
  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType2 = value.constructor;
    codes = new ArrayType2(characterCount);
    for (let i = 0; i < characterCount; i++) {
      codes[i] = value[i * elementStride + elementOffset];
    }
  }
  for (let index2 = 0; index2 < length; index2++) {
    const startIndex = startIndices[index2];
    const endIndex = startIndices[index2 + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index2] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return { texts, characterCount };
}
class LRUCache {
  constructor(limit = 5) {
    this._cache = {};
    this._order = [];
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index2 = this._order.indexOf(key);
    if (index2 >= 0) {
      this._order.splice(index2, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
}
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
const DEFAULT_FONT_SETTINGS = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
const MAX_CANVAS_WIDTH = 1024;
const BASELINE_SCALE = 0.9;
const HEIGHT_SCALE = 1.2;
const CACHE_LIMIT = 3;
let cache = new LRUCache(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
function setTextStyle(ctx2, fontFamily, fontSize, fontWeight) {
  ctx2.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx2.fillStyle = "#000";
  ctx2.textBaseline = "alphabetic";
  ctx2.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  defaultLogger.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache = new LRUCache(limit);
}
class FontAtlasManager {
  constructor() {
    this.props = { ...DEFAULT_FONT_SETTINGS };
  }
  get atlas() {
    return this._atlas;
  }
  // TODO - cut during v9 porting as types reveal this is not correct
  // get texture(): Texture | undefined {
  //   return this._atlas;
  // }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const { fontSize, buffer } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }
  // eslint-disable-next-line max-statements
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    let canvas2 = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      canvas2.width = MAX_CANVAS_WIDTH;
    }
    const ctx2 = canvas2.getContext("2d", { willReadFrequently: true });
    setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
    const { mapping, canvasHeight, xOffset, yOffset } = buildMapping({
      getFontWidth: (char) => ctx2.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    });
    if (canvas2.height !== canvasHeight) {
      const imageData = ctx2.getImageData(0, 0, canvas2.width, canvas2.height);
      canvas2.height = canvasHeight;
      ctx2.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new TinySDF({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: `${fontWeight}`
      });
      for (const char of characterSet) {
        const { data, width, height, glyphTop } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx2.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx2.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx2.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas2,
      width: canvas2.width,
      height: canvas2.height
    };
  }
  _getKey() {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    if (sdf) {
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
    }
    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
  }
}
const vs = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform bool billboard;
uniform float opacity;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec4 padding;
uniform int sizeUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;
const fs = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
uniform bool stroked;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec2 pixelPosition = uv * dimensions;
if (stroked) {
float distToEdge = min(
min(pixelPosition.x, dimensions.x - pixelPosition.x),
min(pixelPosition.y, dimensions.y - pixelPosition.y)
);
float isBorder = smoothedge(distToEdge, vLineWidth);
fragColor = mix(vFillColor, vLineColor, isBorder);
} else {
fragColor = vFillColor;
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
const defaultProps$3 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  padding: { type: "array", value: [0, 0, 0, 0] },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
  getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineWidth: { type: "accessor", value: 1 }
};
class TextBackgroundLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs, fs, modules: [project32, picking] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { changeFlags } = params;
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
    let { padding } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      billboard,
      stroked: Boolean(getLineWidth),
      padding,
      sizeUnits: UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [0, 0, 1, 0, 1, 1, 0, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-fan-webgl",
        vertexCount: 4,
        attributes: {
          positions: { size: 2, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
}
TextBackgroundLayer.defaultProps = defaultProps$3;
TextBackgroundLayer.layerName = "TextBackgroundLayer";
const TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
const ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_LINE_HEIGHT = 1;
const defaultProps$2 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
  getBorderColor: { type: "accessor", value: DEFAULT_COLOR },
  getBorderWidth: { type: "accessor", value: 0 },
  backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
  characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: { type: "number", value: 0, min: 0 },
  outlineColor: { type: "color", value: DEFAULT_COLOR },
  fontSettings: { type: "object", value: {}, compare: 1 },
  // auto wrapping options
  wordBreak: "break-word",
  maxWidth: { type: "number", value: -1 },
  getText: { type: "accessor", value: (x2) => x2.text },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR },
  getSize: { type: "accessor", value: 32 },
  getAngle: { type: "accessor", value: 0 },
  getTextAnchor: { type: "accessor", value: "middle" },
  getAlignmentBaseline: { type: "accessor", value: "center" },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  // deprecated
  backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
class TextLayer extends CompositeLayer {
  constructor() {
    super(...arguments);
    this.getBoundingRect = (object2, objectInfo) => {
      let { size: [width, height] } = this.transformParagraph(object2, objectInfo);
      const { fontSize } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object2, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object2, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    };
    this.getIconOffsets = (object2, objectInfo) => {
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const { x: x2, y: y2, rowWidth, size: [width, height] } = this.transformParagraph(object2, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object2, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object2, objectInfo) : getAlignmentBaseline];
      const numCharacters = x2.length;
      const offsets = new Array(numCharacters * 2);
      let index2 = 0;
      for (let i = 0; i < numCharacters; i++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
        offsets[index2++] = (anchorX - 1) * width / 2 + rowOffset + x2[i];
        offsets[index2++] = (anchorY - 1) * height / 2 + y2[i];
      }
      return offsets;
    };
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new FontAtlasManager()
    };
    if (this.props.maxWidth > 0) {
      defaultLogger.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
    }
  }
  // eslint-disable-next-line complexity
  updateState(params) {
    const { props, oldProps, changeFlags } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({ info }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  /** Returns true if font has changed */
  _updateFontAtlas() {
    const { fontSettings, fontFamily, fontWeight } = this.props;
    const { fontAtlasManager, characterSet } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  // Text strings are variable width objects
  // Count characters and start offsets
  _updateText() {
    const { data, characterSet } = this.props;
    const textBuffer = data.attributes?.getText;
    let { getText } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
    if (textBuffer && startIndices) {
      const { texts, characterCount } = getTextFromBuffer({
        ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
        // @ts-ignore if data.attribute is defined then length is expected
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_, { index: index2 }) => texts[index2];
    } else {
      const { iterable, objectInfo } = createIterable(data);
      startIndices = [0];
      numInstances = 0;
      for (const object2 of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object2, objectInfo) || "");
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  /** There are two size systems in this layer:
  
      + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
        The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
        in layer props is roughly equivalent to font-size: 24px in CSS.
      + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
        which depends on how large each character is drawn into the font atlas. This is controlled by
        fontSettings.fontSize (default 64) and most users do not set it manually.
        These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
  
      All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
  /** Calculate the size and position of each character in a text string.
   * Values are in texture size */
  transformParagraph(object2, objectInfo) {
    const { fontAtlasManager } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const { wordBreak, lineHeight, maxWidth } = this.props;
    const paragraph = getText(object2, objectInfo) || "";
    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const { startIndices, numInstances, getText, fontAtlasManager: { scale: scale2, atlas, mapping }, styleVersion } = this.state;
    const { data, _dataDiff, getPosition: getPosition2, getColor: getColor2, getSize, getAngle, getPixelOffset, getBackgroundColor, getBorderColor, getBorderWidth, backgroundPadding, background, billboard, fontSettings, outlineWidth, outlineColor, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, transitions, updateTriggers } = this.props;
    const CharactersLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
    const BackgroundLayerClass = this.getSubLayerClass("background", TextBackgroundLayer);
    return [
      background && new BackgroundLayerClass({
        // background props
        getFillColor: getBackgroundColor,
        getLineColor: getBorderColor,
        getLineWidth: getBorderWidth,
        padding: backgroundPadding,
        // props shared with characters layer
        getPosition: getPosition2,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getSize: transitions.getSize,
          getFillColor: transitions.getBackgroundColor,
          getLineColor: transitions.getBorderColor,
          getLineWidth: transitions.getBorderWidth,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getSize: updateTriggers.getSize,
          getFillColor: updateTriggers.getBackgroundColor,
          getLineColor: updateTriggers.getBorderColor,
          getLineWidth: updateTriggers.getBorderWidth,
          getPixelOffset: updateTriggers.getPixelOffset,
          getBoundingRect: {
            getText: updateTriggers.getText,
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data: (
          // @ts-ignore (2339) attribute is not defined on all data types
          data.attributes && data.attributes.background ? (
            // @ts-ignore (2339) attribute is not defined on all data types
            { length: data.length, attributes: data.attributes.background }
          ) : data
        ),
        _dataDiff,
        // Maintain the same background behavior as <=8.3. Remove in v9?
        autoHighlight: false,
        getBoundingRect: this.getBoundingRect
      }),
      new CharactersLayerClass({
        sdf: fontSettings.sdf,
        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
        outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
        outlineColor,
        iconAtlas: atlas,
        iconMapping: mapping,
        getPosition: getPosition2,
        getColor: getColor2,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale: sizeScale * scale2,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale2,
        sizeMaxPixels: sizeMaxPixels * scale2,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: updateTriggers.getText,
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data,
        _dataDiff,
        startIndices,
        numInstances,
        getIconOffsets: this.getIconOffsets,
        getIcon: getText
      })
    ];
  }
  static set fontAtlasCacheLimit(limit) {
    setFontAtlasCacheLimit(limit);
  }
}
TextLayer.defaultProps = defaultProps$2;
TextLayer.layerName = "TextLayer";
const POINT_LAYER = {
  circle: {
    type: ScatterplotLayer,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: IconLayer,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: TextLayer,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
};
const LINE_LAYER = {
  type: PathLayer,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
};
const POLYGON_LAYER = {
  type: SolidPolygonLayer,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function getDefaultProps({ type, props }) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const { transitions, updateTriggers } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  defaultLogger.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      defaultLogger.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{ geometry: geojson }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const { startRow = 0, endRow = features.length } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const { geometry: geometry2 } = feature;
    if (!geometry2) {
      continue;
    }
    if (geometry2.type === "GeometryCollection") {
      defaultLogger.assert(Array.isArray(geometry2.geometries), "GeoJSON does not have geometries array");
      const { geometries } = geometry2;
      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry2, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry2, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const { type, coordinates } = geometry2;
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
  if (!validateGeometry(type, coordinates)) {
    defaultLogger.warn(`${type} coordinates are malformed`)();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry: geometry2
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point2) => {
        pointFeatures.push(wrapFeature({
          geometry: { type: "Point", coordinates: point2 }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry: geometry2
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry: geometry2
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: { type: "Polygon", coordinates: polygon }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: { type: "LineString", coordinates: path }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
  }
}
const COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  defaultLogger.assert(nestLevel, `Unknown GeoJSON type ${type}`);
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f) {
  return f.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const { points, lines, polygons } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}
const FEATURE_TYPES = ["points", "linestrings", "polygons"];
const defaultProps$1 = {
  ...getDefaultProps(POINT_LAYER.circle),
  ...getDefaultProps(POINT_LAYER.icon),
  ...getDefaultProps(POINT_LAYER.text),
  ...getDefaultProps(LINE_LAYER),
  ...getDefaultProps(POLYGON_LAYER),
  // Overwrite sub layer defaults
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: { type: "object", value: null },
  iconMapping: { type: "object", value: {} },
  getIcon: { type: "accessor", value: (f) => f.properties.icon },
  getText: { type: "accessor", value: (f) => f.properties.text },
  // Self props
  pointType: "circle",
  // TODO: deprecated, remove in v9
  getRadius: { deprecatedFor: "getPointRadius" }
};
class GeoJsonLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {},
      featuresDiff: {}
    };
  }
  updateState({ props, changeFlags }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const { data } = this.props;
    const binary = data && "points" in data && "polygons" in data && "lines" in data;
    this.setState({ binary });
    if (binary) {
      this._updateStateBinary({ props, changeFlags });
    } else {
      this._updateStateJSON({ props, changeFlags });
    }
  }
  _updateStateBinary({ props, changeFlags }) {
    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
    this.setState({ layerProps });
  }
  _updateStateJSON({ props, changeFlags }) {
    const features = getGeojsonFeatures(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push(replaceInRange({
            data: newFeatures[key],
            getIndex: (f) => f.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = separateGeojsonFeatures(features, wrapFeature);
    }
    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index: index2, sourceLayer } = info;
    info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith(`${this.id}-${ft}-`));
    if (index2 >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index2];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = `${this.id}-points-`;
    const sourceIsPoints = info.featureType === "points";
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    const { extruded, wireframe } = this.props;
    const { layerProps } = this.state;
    const id = "polygons-fill";
    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    const { extruded, stroked } = this.props;
    const { layerProps } = this.state;
    const polygonStrokeLayerId = "polygons-stroke";
    const lineStringsLayerId = "linestrings";
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = forwardProps(this, LINE_LAYER.props);
      return [
        PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
          id: polygonStrokeLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygonsOutline),
        LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
          id: lineStringsLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.lines)
      ];
    }
    return null;
  }
  _renderPointLayers() {
    const { pointType } = this.props;
    const { layerProps, binary } = this.state;
    let { highlightedObjectIndex } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex((d) => d.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split("+"));
    const pointLayers = [];
    for (const type of types) {
      const id = `points-${type}`;
      const PointLayerMapping = POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = forwardProps(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === "text" && binary) {
          const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            // @ts-expect-error TODO - type binary data
            data: { ...pointsLayerProps.data, attributes: rest }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const { extruded } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer,
      lineLayers,
      pointLayers,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer
    ];
  }
  getSubLayerAccessor(accessor) {
    const { binary } = this.state;
    if (!binary || typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object2, info) => {
      const { data, index: index2 } = info;
      const feature = binaryToFeatureForAccesor(data, index2);
      return accessor(feature, info);
    };
  }
}
GeoJsonLayer.layerName = "GeoJsonLayer";
GeoJsonLayer.defaultProps = defaultProps$1;
function DeckglBuildingCollisionLayer() {
  const previewTracks = usePreviewTracks();
  const tracks = useTracks();
  const buildingDetector = useBuildingDetector();
  const { currentNavigationState } = useUi();
  let collidingBuildings = getCollidingBuildings(previewTracks.validation.buildingCollisionDetails);
  if (!collidingBuildings && buildingDetector) {
    const blueprintTracks = tracks.filter((track) => track.buildType === "blueprint");
    if (blueprintTracks.length > 0) {
      const collisionResult = validateBuildingCollision(blueprintTracks, buildingDetector);
      if (collisionResult.collisionDetails) {
        collidingBuildings = getCollidingBuildings(collisionResult.collisionDetails);
      }
    }
  }
  const id = "building-collision";
  const isConstructionPanel = currentNavigationState?.type === "construction";
  if (!collidingBuildings || false || collidingBuildings.length === 0 || !isConstructionPanel) {
    return [];
  }
  const buildingPolygons = [];
  collidingBuildings.forEach((building) => {
    buildingPolygons.push({
      polygon: building.polygon,
      foundationDepth: building.foundationDepth,
      buildingId: building.id
    });
  });
  const buildingCollisionProps = {
    data: buildingPolygons,
    getPolygon: (d) => d.polygon,
    getFillColor: [255, 255, 0, 120],
    // Yellow with transparency
    getLineColor: [255, 0, 0, 255],
    // Red outline
    getLineWidth: 3,
    lineWidthMinPixels: 2,
    lineWidthMaxPixels: 4,
    pickable: true,
    filled: true,
    stroked: true,
    wireframe: false,
    extruded: false
  };
  return [
    new PolygonLayer({
      id: `${id}-colliding-buildings`,
      ...buildingCollisionProps
    }),
    new PolygonLayer({
      id: `${id}-colliding-buildings-top`,
      beforeId: "buildings-3d",
      ...buildingCollisionProps
    })
  ];
}
function getCollidingBuildings(collisionDetails) {
  if (!collisionDetails || collisionDetails.length === 0) {
    return null;
  }
  const buildingMap = /* @__PURE__ */ new Map();
  collisionDetails.forEach((detail) => {
    detail.buildings.forEach((building) => {
      buildingMap.set(building.id, building);
    });
  });
  return Array.from(buildingMap.values());
}
function _0x1375(_0x5a6b3e, _0x4d91b4) {
  const _0x13f1bf = _0x5d0e();
  return _0x1375 = function(_0x40ca832, _0x4e5ef22) {
    _0x40ca832 = _0x40ca832 - 244;
    let _0x10384c = _0x13f1bf[_0x40ca832];
    return _0x10384c;
  }, _0x1375(_0x5a6b3e, _0x4d91b4);
}
function _0x5d0e() {
  const _0x19f265 = ["6kRkFqJ", "9735312hPexca", "__proto__", "apply", "length", "11ZLcuIx", "trace", "1336WwgGGc", "2514320DGOFGV", "738HbqBJs", "28gUqfMe", "substring", "prototype", "339FsejUD", "14572jnkBcP", "8168AYGNaH", "toString", '{}.constructor("return this")( )', "return (function() ", "console", "replace", "constructor", "bind", "2122043YtSJbU", "608105TdugLq", "error", "exception"];
  _0x5d0e = function() {
    return _0x19f265;
  };
  return _0x5d0e();
}
(function(_0x34fa33, _0x30840f) {
  const _0x51414d = _0x1375, _0x316e31 = _0x34fa33();
  while (!![]) {
    try {
      const _0x28d5a5 = -parseInt(_0x51414d(270)) / 1 * (-parseInt(_0x51414d(266)) / 2) + -parseInt(_0x51414d(269)) / 3 * (-parseInt(_0x51414d(263)) / 4) + parseInt(_0x51414d(253)) / 5 * (-parseInt(_0x51414d(256)) / 6) + -parseInt(_0x51414d(252)) / 7 + parseInt(_0x51414d(244)) / 8 * (-parseInt(_0x51414d(265)) / 9) + -parseInt(_0x51414d(264)) / 10 + -parseInt(_0x51414d(261)) / 11 * (-parseInt(_0x51414d(257)) / 12);
      if (_0x28d5a5 === _0x30840f) break;
      else _0x316e31["push"](_0x316e31["shift"]());
    } catch (_0x4658f0) {
      _0x316e31["push"](_0x316e31["shift"]());
    }
  }
})(_0x5d0e, 293102);
const _0x4e5ef2 = /* @__PURE__ */ (function() {
  let _0x49583f = !![];
  return function(_0x1aad4d, _0x34e9a0) {
    const _0x3c2695 = _0x49583f ? function() {
      const _0xbf183b = _0x1375;
      if (_0x34e9a0) {
        const _0x2962c3 = _0x34e9a0[_0xbf183b(259)](_0x1aad4d, arguments);
        return _0x34e9a0 = null, _0x2962c3;
      }
    } : function() {
    };
    return _0x49583f = ![], _0x3c2695;
  };
})(), _0x40ca83 = _0x4e5ef2(void 0, function() {
  const _0x37a0f0 = _0x1375;
  let _0x4bc785;
  try {
    const _0x255ecb = Function(_0x37a0f0(247) + _0x37a0f0(246) + ");");
    _0x4bc785 = _0x255ecb();
  } catch (_0x26d4f7) {
    _0x4bc785 = window;
  }
  const _0x35785f = _0x4bc785[_0x37a0f0(248)] = _0x4bc785[_0x37a0f0(248)] || {}, _0x52ef16 = ["log", "warn", "info", _0x37a0f0(254), _0x37a0f0(255), "table", _0x37a0f0(262)];
  for (let _0x49b9f8 = 0; _0x49b9f8 < _0x52ef16[_0x37a0f0(260)]; _0x49b9f8++) {
    const _0x47b579 = _0x4e5ef2[_0x37a0f0(250)][_0x37a0f0(268)]["bind"](_0x4e5ef2), _0xee27a6 = _0x52ef16[_0x49b9f8], _0xd4e2a0 = _0x35785f[_0xee27a6] || _0x47b579;
    _0x47b579[_0x37a0f0(258)] = _0x4e5ef2["bind"](_0x4e5ef2), _0x47b579[_0x37a0f0(245)] = _0xd4e2a0[_0x37a0f0(245)][_0x37a0f0(251)](_0xd4e2a0), _0x35785f[_0xee27a6] = _0x47b579;
  }
});
_0x40ca83();
function hexToRgb(_0x38728b) {
  const _0x2359bf = _0x1375, _0x10691e = _0x38728b[_0x2359bf(249)]("#", "");
  return [parseInt(_0x10691e["substring"](0, 2), 16), parseInt(_0x10691e[_0x2359bf(267)](2, 4), 16), parseInt(_0x10691e[_0x2359bf(267)](4, 6), 16)];
}
function DeckGLDebugOffsetLinesLayers() {
  const layersToShow = useLayersToShow();
  const debugOffsetLines = useDebugOffsetLines();
  if (!debugOffsetLines || !layersToShow.debugOffsetLines) {
    return [];
  }
  const layers = [];
  layers.push(
    new GeoJsonLayer({
      id: "debug-offset-routes",
      data: debugOffsetLines.routes,
      getLineColor: (f) => [...hexToRgb(f.properties.color), 200],
      getLineWidth: 8,
      lineWidthMinPixels: 2,
      lineCapRounded: true,
      lineJointRounded: true,
      updateTriggers: {
        getLineColor: [debugOffsetLines.routes]
      }
    })
  );
  layers.push(
    new ScatterplotLayer({
      id: "debug-offset-intersections",
      data: debugOffsetLines.intersections.features,
      getPosition: (f) => f.geometry.coordinates,
      getFillColor: [255, 0, 0, 255],
      // Red
      getLineColor: [255, 255, 255, 255],
      // White outline
      getRadius: 8,
      lineWidthMinPixels: 2,
      stroked: true,
      filled: true,
      updateTriggers: {
        getPosition: [debugOffsetLines.intersections]
      }
    })
  );
  return layers;
}
(function(_0x5f6014, _0x184b51) {
  const _0xd8fcec = _0x3990, _0x41dd42 = _0x5f6014();
  while (!![]) {
    try {
      const _0xc30b23 = -parseInt(_0xd8fcec(309)) / 1 + parseInt(_0xd8fcec(315)) / 2 * (-parseInt(_0xd8fcec(318)) / 3) + -parseInt(_0xd8fcec(301)) / 4 * (-parseInt(_0xd8fcec(317)) / 5) + parseInt(_0xd8fcec(313)) / 6 + -parseInt(_0xd8fcec(325)) / 7 * (parseInt(_0xd8fcec(331)) / 8) + -parseInt(_0xd8fcec(316)) / 9 * (parseInt(_0xd8fcec(327)) / 10) + parseInt(_0xd8fcec(300)) / 11;
      if (_0xc30b23 === _0x184b51) break;
      else _0x41dd42["push"](_0x41dd42["shift"]());
    } catch (_0x3e9b85) {
      _0x41dd42["push"](_0x41dd42["shift"]());
    }
  }
})(_0x9768, 558385);
const _0x3c1015 = /* @__PURE__ */ (function() {
  let _0x3c4032 = !![];
  return function(_0x2fba89, _0x4627e6) {
    const _0x102775 = _0x3c4032 ? function() {
      const _0x3f49e6 = _0x3990;
      if (_0x4627e6) {
        const _0x14e238 = _0x4627e6[_0x3f49e6(314)](_0x2fba89, arguments);
        return _0x4627e6 = null, _0x14e238;
      }
    } : function() {
    };
    return _0x3c4032 = ![], _0x102775;
  };
})(), _0x3b920c = _0x3c1015(void 0, function() {
  const _0x29ee0f = _0x3990, _0x2a0d87 = function() {
    const _0x3a19b0 = _0x3990;
    let _0x42422b;
    try {
      _0x42422b = Function(_0x3a19b0(307) + _0x3a19b0(320) + ");")();
    } catch (_0x268dd9) {
      _0x42422b = window;
    }
    return _0x42422b;
  }, _0x25e1ba = _0x2a0d87(), _0x110675 = _0x25e1ba["console"] = _0x25e1ba[_0x29ee0f(305)] || {}, _0x10972e = [_0x29ee0f(304), _0x29ee0f(333), _0x29ee0f(321), _0x29ee0f(322), _0x29ee0f(326), "table", _0x29ee0f(302)];
  for (let _0x3c2f20 = 0; _0x3c2f20 < _0x10972e[_0x29ee0f(308)]; _0x3c2f20++) {
    const _0x5b85d8 = _0x3c1015[_0x29ee0f(323)][_0x29ee0f(319)][_0x29ee0f(306)](_0x3c1015), _0x9914ef = _0x10972e[_0x3c2f20], _0x3b0492 = _0x110675[_0x9914ef] || _0x5b85d8;
    _0x5b85d8[_0x29ee0f(299)] = _0x3c1015[_0x29ee0f(306)](_0x3c1015), _0x5b85d8["toString"] = _0x3b0492[_0x29ee0f(310)]["bind"](_0x3b0492), _0x110675[_0x9914ef] = _0x5b85d8;
  }
});
_0x3b920c();
function _0x3990(_0x5098a6, _0x524a70) {
  const _0x35531f = _0x9768();
  return _0x3990 = function(_0x3b920c2, _0x3c10152) {
    _0x3b920c2 = _0x3b920c2 - 299;
    let _0x459ddb = _0x35531f[_0x3b920c2];
    return _0x459ddb;
  }, _0x3990(_0x5098a6, _0x524a70);
}
const routePathCache = /* @__PURE__ */ new Map();
function _0x9768() {
  const _0x2a330a = ["2xhlgzk", "27UQXNgs", "65xMRZaT", "2692431pxNYan", "prototype", '{}.constructor("return this")( )', "info", "error", "constructor", "has", "7720377HtVMXK", "exception", "2638490PXhSsB", "LineString", "get", "status", "8RrnPJn", "Feature", "warn", "__proto__", "31335634WMqoON", "70940DWNYbG", "trace", "Failed to fetch route path for pop ", "log", "console", "bind", "return (function() ", "length", "439823qbrTns", "toString", "json", "Error fetching route path for pop ", "4265364oRGmNu", "apply"];
  _0x9768 = function() {
    return _0x2a330a;
  };
  return _0x9768();
}
async function getRoutePathForPop(_0x1b235e, _0x1e54e6) {
  const _0x5212f6 = _0x3990, _0x1a5a1a = _0x1b235e + ":" + _0x1e54e6;
  if (routePathCache[_0x5212f6(324)](_0x1a5a1a)) return routePathCache[_0x5212f6(329)](_0x1a5a1a);
  try {
    const _0x445953 = "map://paths/" + _0x1b235e + "/" + _0x1e54e6, _0x2865fa = await fetch(_0x445953);
    if (!_0x2865fa["ok"]) return _0x2865fa[_0x5212f6(330)] !== 404 && console[_0x5212f6(333)](_0x5212f6(303) + _0x1e54e6 + ": " + _0x2865fa["status"]), null;
    const { coordinates: _0x556f4b } = await _0x2865fa[_0x5212f6(311)](), _0x3e2753 = { "type": _0x5212f6(332), "geometry": { "type": _0x5212f6(328), "coordinates": _0x556f4b }, "properties": { "popId": _0x1e54e6 } };
    return routePathCache["set"](_0x1a5a1a, _0x3e2753), _0x3e2753;
  } catch (_0x37b9d9) {
    return console[_0x5212f6(322)](_0x5212f6(312) + _0x1e54e6 + ":", _0x37b9d9), null;
  }
}
const OPACITY = 255;
const SELECTED_POINT_SIZE = 100;
const DEFAULT_MODE_SHARE = 1 / 3;
function DeckglDemandLayer() {
  const {
    currentNavigationState,
    pushNavigationState,
    demandMapMode,
    isDemandStatsPinned,
    pinnedDemandStatsView,
    userActionObj
  } = useUi();
  const demandData = useDemandData();
  const { cityCode } = useCity();
  const ignoreClick = userActionObj.ignoreClick || false;
  const showDemandLayers = isDemandStatsPinned || currentNavigationState?.type === "demand-stats" || currentNavigationState?.type === "demand-point-details" || currentNavigationState?.type === "pop-details";
  const mapMode = demandMapMode;
  function clickDemandPoint(id) {
    if (ignoreClick) return;
    const viewToUse = currentNavigationState?.view || (isDemandStatsPinned ? pinnedDemandStatsView : "homes");
    pushNavigationState(
      {
        type: "demand-point-details",
        itemId: id,
        view: viewToUse
      },
      {
        ignoreLastItemIfSameType: true
      }
    );
  }
  const popDetailsLayers = usePopDetailsLayers(
    currentNavigationState?.type === "pop-details" ? currentNavigationState : null,
    demandData,
    clickDemandPoint,
    showDemandLayers,
    cityCode
  );
  if (popDetailsLayers) {
    return popDetailsLayers;
  }
  const selectedDemandPointId = currentNavigationState?.itemId;
  const selectedDemandPoint = selectedDemandPointId && typeof selectedDemandPointId === "string" ? demandData.points.get(selectedDemandPointId) : null;
  const isViewingHomes = currentNavigationState?.view ? currentNavigationState.view === "homes" : isDemandStatsPinned ? pinnedDemandStatsView === "homes" : true;
  const travelDataByPoint = selectedDemandPoint ? calculatePopsTravelData(selectedDemandPoint, demandData.popsMap, isViewingHomes) : {};
  const demandPointFeatures = transformDemandPointsToFeatures(
    demandData.points,
    selectedDemandPoint || null,
    travelDataByPoint,
    isViewingHomes
  );
  return [
    new GeoJsonLayer({
      id: "demand-points",
      data: demandPointFeatures,
      getPointRadius: (d) => d.properties.size,
      getFillColor: (d) => {
        const color2 = getModeShareColor(
          d.properties.drivingShare,
          d.properties.walkingShare,
          d.properties.transitShare,
          mapMode
        );
        return [color2[0], color2[1], color2[2], d.properties.opacity * 255];
      },
      getLineColor: (d) => [0, 0, 0, d.properties.opacity * 255],
      getLineWidth: (d) => d.properties.selected ? 20 : 4,
      lineWidthUnits: "meters",
      stroked: true,
      filled: true,
      pickable: true,
      opacity: isDemandStatsPinned ? 0.33 : 1,
      onClick: (info) => clickDemandPoint(info.object.properties.id),
      updateTriggers: {
        data: [isViewingHomes, selectedDemandPointId],
        getFillColor: [mapMode, selectedDemandPointId, isViewingHomes],
        getPointRadius: [selectedDemandPointId, isViewingHomes],
        getLineColor: [selectedDemandPointId, isViewingHomes],
        getLineWidth: [selectedDemandPointId, isViewingHomes]
      },
      visible: showDemandLayers
    })
  ];
}
function calculatePopsTravelData(selectedDemandPoint, popsMap, isViewingHomes) {
  const travelDataByPoint = {};
  for (const pop of Array.from(popsMap.values())) {
    let targetPointId = null;
    if (isViewingHomes && pop.residenceId === selectedDemandPoint.id) {
      targetPointId = pop.jobId;
    } else if (!isViewingHomes && pop.jobId === selectedDemandPoint.id) {
      targetPointId = pop.residenceId;
    }
    if (targetPointId) {
      if (!travelDataByPoint[targetPointId]) {
        travelDataByPoint[targetPointId] = {
          count: 0,
          drivingShare: 0,
          walkingShare: 0,
          transitShare: 0
        };
      }
      const data = travelDataByPoint[targetPointId];
      data.count += pop.size;
      const modeChoice = pop.lastCommute?.modeChoice;
      if (modeChoice) {
        data.drivingShare += modeChoice.driving || 0;
        data.walkingShare += modeChoice.walking || 0;
        data.transitShare += modeChoice.transit || 0;
      } else {
        const defaultShare = pop.size * DEFAULT_MODE_SHARE;
        data.drivingShare += defaultShare;
        data.walkingShare += defaultShare;
        data.transitShare += defaultShare;
      }
    }
  }
  for (const pointData of Object.values(travelDataByPoint)) {
    const total = pointData.drivingShare + pointData.walkingShare + pointData.transitShare;
    if (total > 0) {
      pointData.drivingShare /= total;
      pointData.walkingShare /= total;
      pointData.transitShare /= total;
    }
  }
  return travelDataByPoint;
}
function calculatePointSize(point2, selectedDemandPoint, travelData, isViewingHomes) {
  if (selectedDemandPoint) {
    if (point2.id === selectedDemandPoint.id) {
      return SELECTED_POINT_SIZE;
    }
    if (travelData && travelData.count > 0) {
      return Math.sqrt(travelData.count / Math.PI) * 20;
    }
    return 0;
  }
  const commuterCount = isViewingHomes ? point2.residents : point2.jobs;
  const scaleFactor = isViewingHomes ? 5 : 2;
  return Math.sqrt(commuterCount / Math.PI) * scaleFactor;
}
function getPointModeShare(point2, selectedDemandPoint, travelData, isViewingHomes) {
  if (selectedDemandPoint && travelData && travelData.count > 0) {
    return {
      drivingShare: travelData.drivingShare,
      walkingShare: travelData.walkingShare,
      transitShare: travelData.transitShare
    };
  }
  const modeShare = isViewingHomes ? point2.residentModeShare : point2.workerModeShare;
  if (modeShare && (modeShare.driving > 0 || modeShare.walking > 0 || modeShare.transit > 0)) {
    const total = modeShare.driving + modeShare.walking + modeShare.transit;
    return {
      drivingShare: modeShare.driving / total,
      walkingShare: modeShare.walking / total,
      transitShare: modeShare.transit / total
    };
  }
  return { drivingShare: 0, walkingShare: 0, transitShare: 0 };
}
function transformDemandPointsToFeatures(demandPoints, selectedDemandPoint, travelDataByPoint, isViewingHomes) {
  return Array.from(demandPoints.values()).map((point2) => {
    const travelData = travelDataByPoint[point2.id];
    const size = calculatePointSize(point2, selectedDemandPoint, travelData, isViewingHomes);
    const { drivingShare, walkingShare, transitShare } = getPointModeShare(
      point2,
      selectedDemandPoint,
      travelData,
      isViewingHomes
    );
    return {
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: point2.location
      },
      properties: {
        id: point2.id,
        selected: point2.id === selectedDemandPoint?.id,
        size,
        drivingShare,
        walkingShare,
        transitShare,
        opacity: size > 0 ? 1 : 0
      }
    };
  });
}
function usePopDetailsLayers(navigationState, demandData, clickDemandPoint, showDemandLayers, cityCode) {
  const [routePath, setRoutePath] = reactExports.useState(null);
  const selectedPopId = navigationState?.itemId;
  const selectedPop = selectedPopId ? demandData.popsMap.get(selectedPopId) : null;
  reactExports.useEffect(() => {
    if (!selectedPop || !cityCode) {
      setRoutePath(null);
      return;
    }
    getRoutePathForPop(cityCode, selectedPop.id).then(setRoutePath);
  }, [cityCode, selectedPop, selectedPop?.id]);
  if (!navigationState || !selectedPop) {
    return null;
  }
  const homeDemandPoint = demandData.points.get(selectedPop.residenceId);
  const jobDemandPoint = demandData.points.get(selectedPop.jobId);
  if (!homeDemandPoint || !jobDemandPoint) {
    throw new Error("Pop details state has no home and/or job demand point");
  }
  const demandPointFeatures = [homeDemandPoint, jobDemandPoint].map((point2) => ({
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: point2.location
    },
    properties: {
      id: point2.id
    }
  }));
  const commuteLineData = routePath ? [routePath] : [
    {
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: [homeDemandPoint.location, jobDemandPoint.location]
      },
      properties: { id: "pop-details-fallback" }
    }
  ];
  return [
    new GeoJsonLayer({
      id: "pop-details-demand-points",
      data: demandPointFeatures,
      getFillColor: [128, 128, 128, 154],
      getLineColor: [0, 0, 0, 255],
      getPointRadius: 15,
      pointRadiusUnits: "pixels",
      getLineWidth: 1,
      lineWidthUnits: "pixels",
      lineWidthMinPixels: 1,
      stroked: true,
      filled: true,
      pickable: true,
      visible: showDemandLayers,
      onClick: (info) => clickDemandPoint(info.object.properties.id)
    }),
    new GeoJsonLayer({
      id: "pop-details-commute-path",
      data: commuteLineData,
      getLineColor: [255, 0, 0, 255],
      getLineWidth: 4,
      lineWidthUnits: "pixels",
      lineWidthMinPixels: 2,
      pickable: false,
      visible: showDemandLayers
    }),
    new IconLayer({
      id: "pop-details-icons",
      data: [
        {
          id: "home",
          position: homeDemandPoint.location,
          icon: {
            url: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyIDJMMiAxMHYxMmgyMFYxMEwxMiAyeiIgZmlsbD0id2hpdGUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMSIvPgo8cmVjdCB4PSI5IiB5PSIxNiIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMSIvPgo8L3N2Zz4K",
            width: 24,
            height: 24
          },
          color: [255, 255, 255, 255]
        },
        {
          id: "work",
          position: jobDemandPoint.location,
          icon: {
            url: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMiIgeT0iNiIgd2lkdGg9IjIwIiBoZWlnaHQ9IjE0IiBmaWxsPSJ3aGl0ZSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxIi8+CjxyZWN0IHg9IjYiIHk9IjIiIHdpZHRoPSIxMiIgaGVpZ2h0PSI0IiBmaWxsPSJ3aGl0ZSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxIi8+CjxsaW5lIHgxPSI4IiB5MT0iMTIiIHgyPSIxNiIgeTI9IjEyIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjEiLz4KPC9zdmc+Cg==",
            width: 24,
            height: 24
          },
          color: [255, 255, 255, 255]
        }
      ],
      getIcon: (d) => d.icon,
      getPosition: (d) => d.position,
      getColor: (d) => d.color,
      getSize: 16,
      pickable: true,
      onClick: (info) => clickDemandPoint(info.object.id),
      visible: showDemandLayers
    })
  ];
}
function getModeShareColor(drivingShare, walkingShare, transitShare, mapMode) {
  if (mapMode === "all") {
    if (drivingShare === 0 && walkingShare === 0 && transitShare === 0) {
      return [100, 100, 100, 255];
    }
    return [drivingShare * 255, walkingShare * 255, transitShare * 255, OPACITY];
  }
  const modeShareMap = {
    driving: drivingShare,
    walking: walkingShare,
    transit: transitShare
  };
  const share = modeShareMap[mapMode];
  const lowColor = hexToRgb(DEMAND_COLORS.low);
  const highColor = hexToRgb(DEMAND_COLORS.high);
  return [
    Math.round(lowColor[0] + (highColor[0] - lowColor[0]) * share),
    Math.round(lowColor[1] + (highColor[1] - lowColor[1]) * share),
    Math.round(lowColor[2] + (highColor[2] - lowColor[2]) * share),
    OPACITY
  ];
}
function DeckglHoveredPointLayer() {
  const hoveredPoint = useHoveredPoint();
  const visible = hoveredPoint?.snappedInfo !== null;
  if (!hoveredPoint?.coords || !visible) return [];
  const feature = {
    type: "FeatureCollection",
    features: [
      {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: hoveredPoint?.coords
        },
        properties: {}
      }
    ]
  };
  return [
    new GeoJsonLayer({
      id: "hovered-point",
      data: feature,
      pointRadiusMinPixels: 6,
      getFillColor: [255, 102, 0, 77],
      // rgba(255, 102, 0, 0.3)
      getLineColor: [255, 102, 0, 255],
      getLineWidth: 3,
      lineWidthUnits: "pixels",
      stroked: true,
      filled: true,
      pickable: false
    })
  ];
}
const _0x5564f7 = _0x5dd9;
(function(_0x207b6e, _0x561dd0) {
  const _0x11566a = _0x5dd9, _0x541ca7 = _0x207b6e();
  while (!![]) {
    try {
      const _0x2b4f45 = -parseInt(_0x11566a(150)) / 1 * (-parseInt(_0x11566a(155)) / 2) + parseInt(_0x11566a(148)) / 3 + -parseInt(_0x11566a(153)) / 4 + parseInt(_0x11566a(163)) / 5 + parseInt(_0x11566a(164)) / 6 * (-parseInt(_0x11566a(158)) / 7) + parseInt(_0x11566a(149)) / 8 * (-parseInt(_0x11566a(152)) / 9) + -parseInt(_0x11566a(165)) / 10;
      if (_0x2b4f45 === _0x561dd0) break;
      else _0x541ca7["push"](_0x541ca7["shift"]());
    } catch (_0x333a86) {
      _0x541ca7["push"](_0x541ca7["shift"]());
    }
  }
})(_0x11f0, 667038);
const _0x249f0b = /* @__PURE__ */ (function() {
  let _0x3db275 = !![];
  return function(_0x4107ac, _0x2ab341) {
    const _0x235f52 = _0x3db275 ? function() {
      const _0x362712 = _0x5dd9;
      if (_0x2ab341) {
        const _0x29971d = _0x2ab341[_0x362712(147)](_0x4107ac, arguments);
        return _0x2ab341 = null, _0x29971d;
      }
    } : function() {
    };
    return _0x3db275 = ![], _0x235f52;
  };
})(), _0x4bc0d2 = _0x249f0b(void 0, function() {
  const _0x142074 = _0x5dd9;
  let _0x14288b;
  try {
    const _0x5b96b6 = Function(_0x142074(146) + _0x142074(144) + ");");
    _0x14288b = _0x5b96b6();
  } catch (_0x65716c) {
    _0x14288b = window;
  }
  const _0x100910 = _0x14288b[_0x142074(151)] = _0x14288b[_0x142074(151)] || {}, _0x2c33b7 = [_0x142074(154), _0x142074(157), "info", "error", _0x142074(160), _0x142074(145), "trace"];
  for (let _0x215de4 = 0; _0x215de4 < _0x2c33b7[_0x142074(162)]; _0x215de4++) {
    const _0x5ad3d7 = _0x249f0b["constructor"]["prototype"][_0x142074(143)](_0x249f0b), _0x1d5ac1 = _0x2c33b7[_0x215de4], _0xdcfee9 = _0x100910[_0x1d5ac1] || _0x5ad3d7;
    _0x5ad3d7["__proto__"] = _0x249f0b[_0x142074(143)](_0x249f0b), _0x5ad3d7[_0x142074(161)] = _0xdcfee9[_0x142074(161)]["bind"](_0xdcfee9), _0x100910[_0x1d5ac1] = _0x5ad3d7;
  }
});
function _0x11f0() {
  const _0x267787 = ["\n            // Apply opacity to all segments\n            fragColor.a *= opacity;\n        ", "\n            in float instanceOffsets;  // The segment-specific offset value\n            in float instanceSegmentIndices;\n            flat out float vSegmentIndex;\n            flat out float vSegmentNum;\n        ", "bind", '{}.constructor("return this")( )', "table", "return (function() ", "apply", "2494362TWVUTe", "8fBtEED", "158665UdnbQH", "console", "827784prxKDR", "1065192JhKMua", "log", "6yqmhFk", "\n            uniform pathStyleUniforms {\n                float debug;\n            } pathStyle;\n            flat in float vSegmentIndex;\n            flat in float vSegmentNum;\n        ", "warn", "21hLnEvp", "\n            // Use the segment-specific offset directly\n            float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n            size *= offsetWidth;\n        ", "exception", "toString", "length", "4725820RxdoRB", "1246650OlgtbF", "6039760tuYchv", "\n            float dist = abs(vPathPosition.x);\n            // Smooth transition at the edges (from 0.8 to 1.2 for a slightly wider antialiasing band)\n            float opacity = 1.0 - smoothstep(0.8, 1.2, dist);\n            if (opacity < 0.001) {\n                discard;\n            }\n        "];
  _0x11f0 = function() {
    return _0x267787;
  };
  return _0x11f0();
}
function _0x5dd9(_0x505364, _0x397cae) {
  const _0x43f5f7 = _0x11f0();
  return _0x5dd9 = function(_0x4bc0d22, _0x249f0b2) {
    _0x4bc0d22 = _0x4bc0d22 - 141;
    let _0x28dd61 = _0x43f5f7[_0x4bc0d22];
    return _0x28dd61;
  }, _0x5dd9(_0x505364, _0x397cae);
}
_0x4bc0d2();
const variableOffsetShaders = { "inject": { "vs:#decl": _0x5564f7(142), "vs:DECKGL_FILTER_SIZE": _0x5564f7(159), "vs:#main-end": "\n            vSegmentIndex = instanceSegmentIndices;\n            \n            // Use the segment-specific offset directly\n            float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n            float offsetDir = sign(instanceOffsets);\n            vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\n            vPathPosition.y *= offsetWidth;\n            vPathLength *= offsetWidth;\n        ", "fs:#decl": _0x5564f7(156), "fs:#main-start": _0x5564f7(166), "fs:#main-end": _0x5564f7(141) } };
const _0x79c2 = _0x35ff;
(function(_0x34f1b0, _0xceb824) {
  const _0xc131c0 = _0x35ff, _0x29138e = _0x34f1b0();
  while (!![]) {
    try {
      const _0x3a8bfe = -parseInt(_0xc131c0(164)) / 1 + -parseInt(_0xc131c0(178)) / 2 + -parseInt(_0xc131c0(184)) / 3 * (parseInt(_0xc131c0(189)) / 4) + -parseInt(_0xc131c0(165)) / 5 * (parseInt(_0xc131c0(191)) / 6) + -parseInt(_0xc131c0(188)) / 7 * (-parseInt(_0xc131c0(177)) / 8) + parseInt(_0xc131c0(168)) / 9 + parseInt(_0xc131c0(159)) / 10;
      if (_0x3a8bfe === _0xceb824) break;
      else _0x29138e["push"](_0x29138e["shift"]());
    } catch (_0x126a15) {
      _0x29138e["push"](_0x29138e["shift"]());
    }
  }
})(_0x36e9, 636824);
function _0x35ff(_0x216cfe, _0x393d57) {
  const _0x4abdfc = _0x36e9();
  return _0x35ff = function(_0x568c932, _0x1af2f72) {
    _0x568c932 = _0x568c932 - 148;
    let _0x35c470 = _0x4abdfc[_0x568c932];
    return _0x35c470;
  }, _0x35ff(_0x216cfe, _0x393d57);
}
const _0x1af2f7 = /* @__PURE__ */ (function() {
  let _0x1a740e = !![];
  return function(_0x30ccba, _0x2d644d) {
    const _0x4afae8 = _0x1a740e ? function() {
      const _0x51ec35 = _0x35ff;
      if (_0x2d644d) {
        const _0x41866a = _0x2d644d[_0x51ec35(176)](_0x30ccba, arguments);
        return _0x2d644d = null, _0x41866a;
      }
    } : function() {
    };
    return _0x1a740e = ![], _0x4afae8;
  };
})(), _0x568c93 = _0x1af2f7(void 0, function() {
  const _0x41077d = _0x35ff;
  let _0x5eb884;
  try {
    const _0x5c106f = Function(_0x41077d(187) + _0x41077d(174) + ");");
    _0x5eb884 = _0x5c106f();
  } catch (_0x495f5d) {
    _0x5eb884 = window;
  }
  const _0x16c653 = _0x5eb884[_0x41077d(172)] = _0x5eb884[_0x41077d(172)] || {}, _0x8379fc = [_0x41077d(148), _0x41077d(166), _0x41077d(173), _0x41077d(185), _0x41077d(179), _0x41077d(150), _0x41077d(161)];
  for (let _0x4a1af4 = 0; _0x4a1af4 < _0x8379fc[_0x41077d(175)]; _0x4a1af4++) {
    const _0x448cd4 = _0x1af2f7[_0x41077d(162)][_0x41077d(157)]["bind"](_0x1af2f7), _0x4fa85b = _0x8379fc[_0x4a1af4], _0xfb1faa = _0x16c653[_0x4fa85b] || _0x448cd4;
    _0x448cd4[_0x41077d(182)] = _0x1af2f7[_0x41077d(186)](_0x1af2f7), _0x448cd4[_0x41077d(154)] = _0xfb1faa["toString"]["bind"](_0xfb1faa), _0x16c653[_0x4fa85b] = _0x448cd4;
  }
});
_0x568c93();
function _0x36e9() {
  const _0x5eff25 = ["9tXXEzZ", "error", "bind", "return (function() ", "1491PMjtxl", "467644OftIuj", "offset", "3812634RompZg", "i32", "log", "getAttributeManager", "table", "opts", "state", "getSegmentOffsets", "toString", "defaultProps", "pathTesselator", "prototype", "value", "16902190HHhPiG", "isEnabled", "trace", "constructor", "segmentOffsets", "288766CtqGjO", "5tfHpFz", "warn", "CustomLineExtension", "2563452TyeWrB", "updateState", "f32", "addInstanced", "console", "info", '{}.constructor("return this")( )', "length", "apply", "15560QIASlk", "955140Lzosyz", "exception", "pathStyle", "accessor", "__proto__", "extensionName"];
  _0x36e9 = function() {
    return _0x5eff25;
  };
  return _0x36e9();
}
const defaultProps = { "getSegmentOffsets": { "type": _0x79c2(181), "value": { "segmentOffsets": new Float32Array([0]) } } };
class CustomLineExtension extends LayerExtension {
  static [_0x79c2(155)] = defaultProps;
  static [_0x79c2(183)] = _0x79c2(167);
  constructor({ offset: offset2 = ![] } = {}) {
    super({ "offset": offset2 });
  }
  [_0x79c2(160)](_0x2aa788) {
    const _0xd7fa8a = _0x79c2;
    return _0xd7fa8a(156) in _0x2aa788[_0xd7fa8a(152)];
  }
  ["getShaders"](_0x2acade) {
    const _0x2740cf = _0x79c2;
    if (!_0x2acade[_0x2740cf(160)](this)) return null;
    let _0x53caa6 = {};
    _0x2acade[_0x2740cf(151)][_0x2740cf(190)] && (_0x53caa6 = mergeShaders(_0x53caa6, variableOffsetShaders));
    const { inject: _0x3fa0af } = _0x53caa6, _0x3fb9e3 = { "name": _0x2740cf(180), "inject": _0x3fa0af, "uniformTypes": { "dashAlignMode": _0x2740cf(170), "dashGapPickable": _0x2740cf(192) } };
    return { "modules": [_0x3fb9e3] };
  }
  ["initializeState"](_0x467e38, _0x4a314d) {
    const _0x18cf99 = _0x79c2, _0x151e1c = this[_0x18cf99(149)]();
    if (!_0x151e1c || !_0x4a314d[_0x18cf99(160)](this)) return;
    _0x4a314d[_0x18cf99(151)][_0x18cf99(190)] && _0x151e1c[_0x18cf99(171)]({ "instanceOffsets": { "size": 1, "accessor": _0x18cf99(153), "transform": (_0x4e327) => {
      const _0x90bb40 = _0x18cf99;
      return Array["isArray"](_0x4e327[_0x90bb40(163)]) ? new Float32Array(_0x4e327[_0x90bb40(163)]) : _0x4e327[_0x90bb40(163)];
    } }, "instanceSegmentIndices": { "size": 1, "vertexOffset": 0, "update": (_0x564b8b) => {
      const _0x4b60e3 = _0x18cf99, _0x236fc2 = this[_0x4b60e3(152)], _0x9f789d = _0x236fc2[_0x4b60e3(156)]["instanceCount"], _0xea8ee9 = new Float32Array(_0x9f789d);
      for (let _0x547be4 = 0; _0x547be4 < _0x9f789d; _0x547be4++) {
        _0xea8ee9[_0x547be4] = _0x547be4;
      }
      _0x564b8b[_0x4b60e3(158)] = _0xea8ee9;
    } } });
  }
  [_0x79c2(169)](_0x176be6, _0x3bf339) {
    const _0x3280fe = _0x79c2;
    if (!_0x3bf339[_0x3280fe(160)](this)) return;
  }
}
(function(_0x33bbd4, _0x300bf6) {
  const _0x1396bd = _0x55bb, _0xd8a21e = _0x33bbd4();
  while (!![]) {
    try {
      const _0x39de36 = -parseInt(_0x1396bd(230)) / 1 * (-parseInt(_0x1396bd(237)) / 2) + -parseInt(_0x1396bd(242)) / 3 + parseInt(_0x1396bd(241)) / 4 + -parseInt(_0x1396bd(247)) / 5 * (parseInt(_0x1396bd(240)) / 6) + -parseInt(_0x1396bd(251)) / 7 + parseInt(_0x1396bd(235)) / 8 * (parseInt(_0x1396bd(239)) / 9) + parseInt(_0x1396bd(234)) / 10;
      if (_0x39de36 === _0x300bf6) break;
      else _0xd8a21e["push"](_0xd8a21e["shift"]());
    } catch (_0x72a031) {
      _0xd8a21e["push"](_0xd8a21e["shift"]());
    }
  }
})(_0x486a, 363855);
const _0x4ac6fd = /* @__PURE__ */ (function() {
  let _0x24e250 = !![];
  return function(_0x4abb5b, _0x387888) {
    const _0x33a1a2 = _0x24e250 ? function() {
      if (_0x387888) {
        const _0x316dc0 = _0x387888["apply"](_0x4abb5b, arguments);
        return _0x387888 = null, _0x316dc0;
      }
    } : function() {
    };
    return _0x24e250 = ![], _0x33a1a2;
  };
})(), _0x29d3f2 = _0x4ac6fd(void 0, function() {
  const _0x31ebf4 = _0x55bb, _0x43f90d = function() {
    const _0x1f9ce4 = _0x55bb;
    let _0x2b803b;
    try {
      _0x2b803b = Function(_0x1f9ce4(236) + _0x1f9ce4(229) + ");")();
    } catch (_0x12d9c2) {
      _0x2b803b = window;
    }
    return _0x2b803b;
  }, _0x360c29 = _0x43f90d(), _0x1a5342 = _0x360c29["console"] = _0x360c29[_0x31ebf4(249)] || {}, _0x45936e = [_0x31ebf4(231), _0x31ebf4(233), _0x31ebf4(228), _0x31ebf4(226), _0x31ebf4(232), _0x31ebf4(248), _0x31ebf4(252)];
  for (let _0x19ef02 = 0; _0x19ef02 < _0x45936e["length"]; _0x19ef02++) {
    const _0x2a60aa = _0x4ac6fd["constructor"][_0x31ebf4(246)][_0x31ebf4(244)](_0x4ac6fd), _0x1bf51d = _0x45936e[_0x19ef02], _0x521e8e = _0x1a5342[_0x1bf51d] || _0x2a60aa;
    _0x2a60aa[_0x31ebf4(227)] = _0x4ac6fd[_0x31ebf4(244)](_0x4ac6fd), _0x2a60aa[_0x31ebf4(245)] = _0x521e8e[_0x31ebf4(245)][_0x31ebf4(244)](_0x521e8e), _0x1a5342[_0x1bf51d] = _0x2a60aa;
  }
});
function _0x55bb(_0x57d86e, _0x15db59) {
  const _0x201d44 = _0x486a();
  return _0x55bb = function(_0x29d3f22, _0x4ac6fd2) {
    _0x29d3f22 = _0x29d3f22 - 226;
    let _0x3ae340 = _0x201d44[_0x29d3f22];
    return _0x3ae340;
  }, _0x55bb(_0x57d86e, _0x15db59);
}
_0x29d3f2();
function _0x486a() {
  const _0x4de542 = ["trace", "error", "__proto__", "info", '{}.constructor("return this")( )', "18385pUsBuX", "log", "exception", "warn", "1908450PAZmpq", "155224KQxuGY", "return (function() ", "2DAFWpk", "max", "144OIVkEJ", "1182rlmRJl", "2418032RWkPMt", "954120mrwKQi", "round", "bind", "toString", "prototype", "3505XkXaIK", "table", "console", "min", "2129358zikyBj"];
  _0x486a = function() {
    return _0x4de542;
  };
  return _0x486a();
}
function getColor$1({ zoom: _0x4f7eb7, baseColorRgb: _0x43768d, zoomWindow: _0x2acfcc, opacityModifier = 1 }) {
  const _0x26d916 = _0x55bb, _0x390ed2 = _0x43768d, [_0x4a7db0, _0x5ebec0] = _0x2acfcc ?? [0, 100], _0x1f31f4 = (_0x4f7eb7 - _0x4a7db0) / (_0x5ebec0 - _0x4a7db0), _0x433c00 = Math[_0x26d916(250)](1, Math[_0x26d916(238)](0, _0x1f31f4)), _0x35bc59 = Math[_0x26d916(243)](_0x433c00 * 255 * opacityModifier);
  return [..._0x390ed2, _0x35bc59];
}
function getOpacityColor({ baseColorRgb: _0x2c265d, opacityModifier = 1 }) {
  const _0xce5bed = _0x55bb, _0x3d1901 = _0x2c265d, _0x75b597 = Math[_0xce5bed(243)](255 * opacityModifier);
  return [..._0x3d1901, _0x75b597];
}
function DeckGLInterlinedRoutesLayers({ zoom }) {
  const layersToShow = useLayersToShow();
  const interlinedRoutesFeatureCollection = useInterlinedFeatureCollection().features.filter(
    (f) => f.properties.type === "parallelRoute"
  );
  const { selectedRouteId } = useUi();
  function getSegmentOffsets(f) {
    const offsets = f.properties.offset || [];
    return {
      segmentOffsets: new Float32Array(offsets)
    };
  }
  const visible = layersToShow.parallelRoutes;
  const commonLayerProps = {
    data: interlinedRoutesFeatureCollection,
    getLineColor: (f) => {
      if (!f.properties.routeIds.includes(selectedRouteId) && selectedRouteId !== null) {
        return [...hexToRgb(COLORS.DARK.unSelectedRoute), 180];
      }
      return getOpacityColor({ baseColorRgb: hexToRgb(f.properties.color), opacityModifier: 1 });
    },
    getLineWidth: (f) => 10,
    lineWidthMinPixels: 2,
    lineCapRounded: true,
    lineJointRounded: false,
    visible,
    // @ts-expect-error - IDK why it does this
    getSegmentOffsets,
    extensions: [new CustomLineExtension({ offset: true })],
    updateTriggers: {
      getLineColor: [selectedRouteId],
      getSegmentOffsets: [interlinedRoutesFeatureCollection]
    }
  };
  return [
    new GeoJsonLayer({
      id: "simple-routes",
      ...commonLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "simple-routes-under",
      ...commonLayerProps
    })
  ];
}
function DeckGLPlatformLayers({ zoom }) {
  const { resolvedTheme } = useTheme();
  const { pushNavigationState, userActionObj } = useUi();
  const isDark = resolvedTheme === "dark";
  const layersToShow = useLayersToShow();
  const platformMapItems = usePlatformMapItems();
  const ignoreClick = userActionObj.ignoreClick || false;
  function handleClick2(info) {
    if (ignoreClick) return;
    pushNavigationState({
      type: "station-details",
      itemId: info.object.id || info.object.properties.id,
      view: null
    });
  }
  const STROKE_WIDTH = 3;
  const colors = isDark ? COLORS.DARK : COLORS.LIGHT;
  const platformColor = hexToRgb(colors.platforms);
  const platformStrokeColor = hexToRgb(colors.platformsStroke);
  const topPlatformProps = {
    data: platformMapItems.geojson,
    getFillColor: () => getColor({ zoom, baseColorRgb: platformColor, opacityModifier: 0.25 }),
    getLineColor: () => getColor({ zoom, baseColorRgb: platformStrokeColor, opacityModifier: 1 }),
    getLineWidth: () => STROKE_WIDTH,
    visible: layersToShow.stationPlatforms,
    pickable: true,
    onClick: handleClick2,
    updateTriggers: {
      getFillColor: [zoom, isDark],
      getLineColor: [zoom, isDark]
    }
  };
  return [
    // The platform cover above the ground
    new GeoJsonLayer({
      id: "platform-polygons-cover-top",
      ...topPlatformProps
    }),
    new GeoJsonLayer({
      id: "platform-polygons-cover-bottom",
      beforeId: "buildings-3d",
      ...topPlatformProps
    }),
    // The box around the underground platform
    // The stroke doesn't work because it's extruded
    new PolygonLayer({
      id: "platform-polygons",
      beforeId: "buildings-3d",
      data: platformMapItems.polygons,
      getPolygon: (d) => d.polygon,
      getElevation: (d) => d.height,
      getFillColor: () => getColor({ zoom, baseColorRgb: platformColor, opacityModifier: 1 }),
      visible: layersToShow.stationPlatforms,
      extruded: true,
      pickable: true,
      onClick: handleClick2,
      // material: {
      //     ambient: 0.5,
      //     diffuse: 0.6,
      //     shininess: 16,
      // },
      updateTriggers: {
        getFillColor: [zoom, isDark]
      }
    })
    // The roof on top of the underground platform
    // The stroke can work but it makes the roof larger than the structure it sits on so it looks weird
    // new PolygonLayer({
    //     id: 'platform-polygons-roof',
    //     data: platformMapItems.polygons,
    //     beforeId: 'buildings-3d',
    //     getPolygon: (d) => d.polygon,
    //     getFillColor: () => getColor({ zoom, baseColorRgb: platformColor, opacityModifier: 1 }),
    //     // getElevation: (d) => d.elevation,
    //     // stroked: true,
    //     // getLineColor: () => getColor({ zoom, baseColorRgb: platformStrokeColor, opacityModifier: 1 }),
    //     // getLineWidth: () => STROKE_WIDTH,
    //     visible: layersToShow.stationPlatforms,
    //     extruded: false,
    //     pickable: true,
    //     onClick: handleClick,
    //     updateTriggers: {
    //         getFillColor: [zoom, isDark],
    //         // getLineColor: [zoom, isDark],
    //     },
    // }),
  ];
}
const PLATFORM_ZOOM_WINDOW = [13, 13.5];
function getColor({
  zoom,
  baseColorRgb,
  opacityModifier
}) {
  const baseColor = baseColorRgb;
  if (zoom > PLATFORM_ZOOM_WINDOW[1]) return [...baseColor, 256 * opacityModifier];
  if (zoom < PLATFORM_ZOOM_WINDOW[0]) return [...baseColor, 0];
  const opacity = (zoom - PLATFORM_ZOOM_WINDOW[0]) / (PLATFORM_ZOOM_WINDOW[1] - PLATFORM_ZOOM_WINDOW[0]);
  const finalColor = [...baseColor, opacity * 256 * opacityModifier];
  return finalColor;
}
function DeckglPopMovementsLayer() {
  const { pushNavigationState, selectedPopMovementIds, userActionObj } = useUi();
  const layersToShow = useLayersToShow();
  const visible = layersToShow.popMovements;
  const popMovementsGeojson = usePopMovementGeojson();
  function clickPopMovement(ids) {
    if (userActionObj.ignoreClick) return;
    pushNavigationState(
      {
        type: "pop-movement",
        itemId: ids,
        view: null
      },
      {
        ignoreLastItemIfSameType: true
      }
    );
  }
  return [
    new ScatterplotLayer({
      id: "pop-movements-deck",
      data: popMovementsGeojson.features.map((feature) => ({
        coordinates: feature.geometry.coordinates,
        properties: {
          id: feature.properties.popIds.join(","),
          size: feature.properties.size,
          popIds: feature.properties.popIds
        }
      })),
      opacity: 0.6,
      stroked: true,
      filled: true,
      radiusScale: 1,
      radiusUnits: "meters",
      getPosition: (d) => d.coordinates,
      getRadius: (d) => {
        const scaleFactor = 4;
        return Math.sqrt(d.properties.size / Math.PI) * scaleFactor;
      },
      getFillColor: [255, 0, 0, 150],
      // Red color for pop movements
      getLineColor: [150, 0, 0, 255],
      // Darker red for stroke
      getLineWidth: (d) => selectedPopMovementIds?.includes(d.properties.id) ? 4 : 1,
      lineWidthUnits: "pixels",
      visible,
      parameters: {
        depthTest: false
      },
      pickable: true,
      onClick: (info) => {
        console.log("Clicked on pop movement", info);
        clickPopMovement(info.object.properties.popIds);
      }
    })
  ];
}
function DeckglRoadCollisionLayer() {
  const previewTracks = usePreviewTracks();
  const roadCollisionDetails = previewTracks.validation.roadCollisionDetails;
  const points = getCollisionPoints(roadCollisionDetails);
  const id = "road-collision";
  if (points.length === 0) {
    return [];
  }
  return [
    new ScatterplotLayer({
      id: `${id}-intersection-points`,
      data: points,
      getPosition: (d) => d.position,
      getFillColor: [255, 100, 0, 200],
      // Orange-red for road collision points
      getRadius: 6,
      radiusMinPixels: 4,
      radiusMaxPixels: 10,
      pickable: true,
      stroked: true,
      getLineColor: [255, 50, 0, 255],
      // Darker outline
      lineWidthMinPixels: 1
    })
  ];
}
function getCollisionPoints(collisionDetails) {
  if (!collisionDetails || collisionDetails.length === 0) return [];
  const allIntersectionPoints = [];
  collisionDetails.forEach((detail) => {
    if (detail.intersectionPoints) {
      allIntersectionPoints.push(...detail.intersectionPoints);
    }
  });
  return allIntersectionPoints.map((pt) => ({ position: pt }));
}
const ROAD_WIDTHS = {
  highway: {
    width: 12,
    // zoomWindow: [12.5, 13]
    zoomWindow: [13, 13.5]
  },
  major: {
    width: 8,
    // zoomWindow: [12.5, 13]
    zoomWindow: [13, 13.5]
  },
  medium: {
    width: 6,
    zoomWindow: [13, 13.5]
  },
  minor: {
    width: 4,
    zoomWindow: [13, 13.5]
  }
};
function DeckglRoadsLayer({ zoom }) {
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const roadsGeojson = useRoadsGeojson() || {
    type: "FeatureCollection",
    features: []
  };
  return [
    new GeoJsonLayer({
      id: "road-lines",
      data: roadsGeojson,
      getLineColor: (f) => getRoadColor({
        zoom,
        roadClass: f.properties.roadClass,
        isDark,
        isTunnel: false
      }),
      getLineWidth: (f) => ROAD_WIDTHS[f.properties.roadClass].width,
      lineCapRounded: true,
      updateTriggers: {
        getLineColor: [isDark, zoom]
      }
    })
  ];
}
function getRoadColor({
  zoom,
  roadClass,
  isDark,
  isTunnel
}) {
  const baseColors = isDark ? COLORS.DARK : COLORS.LIGHT;
  const color2 = hexToRgb(baseColors.roads);
  const roadClassItem = ROAD_WIDTHS[roadClass];
  if (zoom > roadClassItem.zoomWindow[1]) return [...color2, 256];
  if (zoom < roadClassItem.zoomWindow[0]) return [...color2, 0];
  const opacity = (zoom - roadClassItem.zoomWindow[0]) / (roadClassItem.zoomWindow[1] - roadClassItem.zoomWindow[0]);
  return [...color2, opacity * 256];
}
function DeckGLRoutesLayers() {
  const layersToShow = useLayersToShow();
  const routeFeatureCollection = useRouteFeatureCollection();
  const { selectedRouteId } = useUi();
  const commonLayerProps = {
    data: routeFeatureCollection,
    getLineColor: (f) => {
      if (f.properties.id !== selectedRouteId && selectedRouteId !== null) {
        return [...hexToRgb(COLORS.DARK.unSelectedRoute), 180];
      }
      return hexToRgb(f.properties.color);
    },
    // Extra .05 because of gap between parallel tracks
    getLineWidth: (f) => RULES.TRACK_WIDTH * 2.05,
    lineWidthMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH,
    lineCapRounded: true,
    lineJointRounded: true,
    visible: layersToShow.routes,
    updateTriggers: {
      getLineColor: [selectedRouteId]
    }
  };
  return [
    new GeoJsonLayer({
      id: "routes",
      ...commonLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "routes-under",
      ...commonLayerProps
    })
  ];
}
function DeckglSignalsLayer() {
  const layersToShow = useLayersToShow();
  const signalsGeojson = useSignalsGeojson();
  const { selectedSignalId, pushNavigationState, userActionObj } = useUi();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const ignoreClick = userActionObj.ignoreClick || false;
  function clickSignal(id) {
    if (ignoreClick) return;
    pushNavigationState(
      {
        type: "signal-details",
        itemId: id,
        view: null
      },
      {
        ignoreLastItemIfSameType: true
      }
    );
  }
  function getSignalColor(f) {
    return hexToRgb(isDark ? f.properties.darkColor : f.properties.lightColor);
  }
  const commonLineLayerProps = {
    data: signalsGeojson.lines,
    getLineColor: getSignalColor,
    getLineWidth: (f) => f.properties.id === selectedSignalId ? RULES.TRACK_WIDTH * 2 : RULES.TRACK_WIDTH,
    lineWidthMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH * 1.5,
    lineCapRounded: true,
    pickable: !ignoreClick,
    onClick: (info) => {
      clickSignal(info.object.properties.id);
    },
    visible: layersToShow.signalLines,
    updateTriggers: {
      getLineWidth: [selectedSignalId]
    }
  };
  const commonPointLayerProps = {
    data: signalsGeojson.points,
    getFillColor: getSignalColor,
    getPointRadius: (f) => f.properties.id === selectedSignalId ? RULES.TRACK_WIDTH * 3 : RULES.TRACK_WIDTH * 2,
    pointRadiusUnits: "meters",
    pointRadiusMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH * 1.5,
    pickable: !ignoreClick,
    onClick: (info) => {
      clickSignal(info.object.properties.id);
    },
    visible: layersToShow.signalPoints,
    updateTriggers: {
      getPointRadius: [selectedSignalId]
    }
  };
  return [
    new GeoJsonLayer({
      id: "signal-lines",
      ...commonLineLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "signal-lines-under",
      ...commonLineLayerProps
    }),
    new GeoJsonLayer({
      id: "signal-points",
      ...commonPointLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "signal-points-under",
      ...commonPointLayerProps
    })
  ];
}
function DeckGLSkeletonizationLayer() {
  const layersToShow = useLayersToShow();
  const skeletonizationFeatureCollection = useInterlinedFeatureCollection();
  const filteredFeatures = skeletonizationFeatureCollection.features.filter((feature) => {
    const props = feature.properties;
    if (props.type === "chunk") {
      return layersToShow.skeletonizationChunks;
    }
    if (props.type === "buffer") {
      return layersToShow.skeletonizationBuffers;
    }
    if (props.type === "mergeChunk") {
      return layersToShow.skeletonizationMergeChunks;
    }
    if (props.type === "dissolvedRouteCombo") {
      return layersToShow.skeletonizationDissolvedRouteCombo;
    }
    if (props.type === "halfOutline") {
      return layersToShow.skeletonizationHalfOutlines;
    }
    if (props.type === "centerlineFromHalves") {
      return layersToShow.skeletonizationCenterlineFromHalves;
    }
    if (props.type === "centerlineConnector") {
      return layersToShow.skeletonizationCenterlineConnectors;
    }
    return false;
  });
  const filteredCollection = {
    type: "FeatureCollection",
    features: filteredFeatures
  };
  return [
    new GeoJsonLayer({
      id: "skeletonization-layer",
      data: filteredCollection,
      stroked: true,
      filled: true,
      getFillColor: (f) => getOpacityColor({
        baseColorRgb: hexToRgb(f.properties.color),
        opacityModifier: f.properties.fillOpacity
      }),
      getLineColor: (f) => getOpacityColor({
        baseColorRgb: hexToRgb(f.properties.color),
        opacityModifier: f.properties.lineOpacity || 1
      }),
      getLineWidth: (f) => f.properties.lineWidth,
      pickable: true,
      onClick: (info) => {
        console.log("Clicked on skeletonization", info.object.properties, info.object.properties.routeIds);
      },
      updateTriggers: {
        getFillColor: [filteredFeatures],
        getFillOpacity: [filteredFeatures],
        getLineColor: [filteredFeatures],
        getLineWidth: [filteredFeatures]
      }
    })
  ];
}
function DeckGLTrackElevationsLayer() {
  const layersToShow = useLayersToShow();
  const trackElevationsGeojson = useTrackElevationsGeojson();
  const previewTrackElevationsGeojson = usePreviewTrackElevationsGeojson();
  const commonLayerProps = {
    getLineColor: (f) => f.properties.color,
    getLineWidth: RULES.TRACK_WIDTH,
    lineWidthUnits: "meters",
    lineWidthMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH,
    lineCapRounded: true,
    visible: layersToShow.trackElevations
  };
  return [
    new GeoJsonLayer({
      id: "track-elevations",
      data: trackElevationsGeojson,
      ...commonLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "preview-track-elevations",
      data: previewTrackElevationsGeojson,
      ...commonLayerProps
    }),
    new GeoJsonLayer({
      id: "track-elevations-under",
      data: trackElevationsGeojson,
      ...commonLayerProps
    }),
    new GeoJsonLayer({
      id: "preview-track-elevations-under",
      data: previewTrackElevationsGeojson,
      ...commonLayerProps
    })
  ];
}
function DeckGLTracksBaseLayers() {
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const previewTracksBaseGeojson = usePreviewTracksGeojsonFeatures().base;
  const tracksBaseGeojson = useTracksGeojsonFeatures().base;
  const layersToShow = useLayersToShow();
  const commonLayerProps = {
    getLineColor: getLineColorFn(isDark),
    getLineWidth: (f) => f.properties.width,
    lineWidthMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH,
    lineCapRounded: true,
    visible: layersToShow.tracksBase,
    pickable: false,
    updateTriggers: {
      getLineColor: [isDark]
    }
  };
  const threeDTrackBaseLayerProps = {
    getFillColor: getLineColorFn(isDark, true),
    stroked: false,
    extruded: true,
    getElevation: (f) => f.height,
    // @ts-expect-error - beforeId is not typed
    beforeId: "buildings-3d",
    visible: layersToShow.tracksBase,
    updateTriggers: {
      getFillColor: [isDark]
    }
  };
  return [
    ...THREE_D_MODE ? [
      new PolygonLayer({
        id: "tracks-base-3d",
        data: tracksBaseGeojson.polygons,
        ...threeDTrackBaseLayerProps
      }),
      new PolygonLayer({
        id: "preview-tracks-base-3d",
        data: previewTracksBaseGeojson.polygons,
        ...threeDTrackBaseLayerProps
      })
    ] : [
      new GeoJsonLayer({
        id: "tracks-base",
        data: tracksBaseGeojson.geojson,
        ...commonLayerProps,
        beforeId: "buildings-3d"
      })
    ],
    new GeoJsonLayer({
      id: "preview-tracks-base",
      data: previewTracksBaseGeojson.geojson,
      ...commonLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "preview-tracks-base-under",
      data: previewTracksBaseGeojson.geojson,
      ...commonLayerProps
    }),
    new GeoJsonLayer({
      id: "tracks-base-under",
      data: tracksBaseGeojson.geojson,
      ...commonLayerProps
    })
  ];
}
function getLineColorFn(isDark, isPolygon = false) {
  return (f) => {
    const lightColor = isPolygon ? f.lightColor : f.properties.lightColor;
    const darkColor = isPolygon ? f.darkColor : f.properties.darkColor;
    const opacity = isPolygon ? f.opacity : f.properties.opacity;
    return getOpacityColor({
      baseColorRgb: hexToRgb(isDark ? darkColor : lightColor),
      opacityModifier: opacity
    });
  };
}
const ZOOM_WINDOW = [13, 13.5];
function DeckGLTracksLayers({ zoom }) {
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const layersToShow = useLayersToShow();
  const tracksGeojson = useTracksGeojsonFeatures().lines;
  const previewTracksGeojson = usePreviewTracksGeojsonFeatures().lines;
  const commonLayerProps = {
    getLineColor: (f) => getColor$1({
      zoom,
      zoomWindow: ZOOM_WINDOW,
      baseColorRgb: hexToRgb(isDark ? f.properties.darkColor : f.properties.lightColor)
    }),
    getLineWidth: RULES.TRACK_WIDTH,
    lineWidthMinPixels: 1,
    lineCapRounded: true,
    lineMiterLimit: 0,
    // FIXES NARNIA LINES
    visible: layersToShow.tracks,
    updateTriggers: {
      getLineColor: [zoom, isDark]
    }
  };
  const threeDTrackLayerProps = {
    getFillColor: (f) => getColor$1({
      zoom,
      zoomWindow: ZOOM_WINDOW,
      baseColorRgb: hexToRgb(isDark ? f.darkColor : f.lightColor),
      opacityModifier: 1
    }),
    stroked: false,
    extruded: true,
    getElevation: (f) => f.height,
    // @ts-expect-error - beforeId is not typed
    beforeId: "buildings-3d",
    visible: layersToShow.tracks,
    updateTriggers: {
      getFillColor: [zoom, isDark]
    }
  };
  return [
    ...THREE_D_MODE ? [
      new PolygonLayer({
        id: "tracks-3d",
        data: tracksGeojson.polygons,
        ...threeDTrackLayerProps
      }),
      new PolygonLayer({
        id: "preview-tracks-3d",
        data: previewTracksGeojson.polygons,
        ...threeDTrackLayerProps
      })
    ] : [
      new GeoJsonLayer({
        id: "tracks",
        data: tracksGeojson.geojson,
        ...commonLayerProps,
        beforeId: "buildings-3d"
      }),
      new GeoJsonLayer({
        id: "preview-tracks",
        data: previewTracksGeojson.geojson,
        ...commonLayerProps,
        beforeId: "buildings-3d"
      }),
      new GeoJsonLayer({
        id: "tracks-under",
        data: tracksGeojson.geojson,
        ...commonLayerProps
      }),
      new GeoJsonLayer({
        id: "preview-tracks-under",
        data: previewTracksGeojson.geojson,
        ...commonLayerProps
      })
    ]
  ];
}
function DeckGLTrackSpeedsLayer() {
  const layersToShow = useLayersToShow();
  const trackSpeedsGeojson = useTrackSpeedsGeojson();
  const previewTrackSpeedsGeojson = usePreviewTrackSpeedsGeojson();
  const commonLayerProps = {
    getLineColor: (f) => f.properties.color,
    getLineWidth: RULES.TRACK_WIDTH,
    lineWidthUnits: "meters",
    lineWidthMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH,
    lineCapRounded: true,
    visible: layersToShow.trackSpeeds
  };
  return [
    new GeoJsonLayer({
      id: "track-speeds",
      data: trackSpeedsGeojson,
      ...commonLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "preview-track-speeds",
      data: previewTrackSpeedsGeojson,
      ...commonLayerProps
    }),
    new GeoJsonLayer({
      id: "track-speeds-under",
      data: trackSpeedsGeojson,
      ...commonLayerProps
    }),
    new GeoJsonLayer({
      id: "preview-track-speeds-under",
      data: previewTrackSpeedsGeojson,
      ...commonLayerProps
    })
  ];
}
function DeckGLTrackTypesLayer() {
  const layersToShow = useLayersToShow();
  const trackTypesGeojson = useTrackTypesGeojson();
  const previewTrackTypesGeojson = usePreviewTrackTypesGeojson();
  const commonLayerProps = {
    getLineColor: (f) => f.properties.color,
    getLineWidth: RULES.TRACK_WIDTH,
    lineWidthUnits: "meters",
    lineWidthMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH,
    lineCapRounded: true,
    visible: layersToShow.trackTypes
  };
  return [
    new GeoJsonLayer({
      id: "track-types",
      data: trackTypesGeojson,
      ...commonLayerProps,
      beforeId: "buildings-3d"
    }),
    new GeoJsonLayer({
      id: "preview-track-types",
      data: previewTrackTypesGeojson,
      ...commonLayerProps
    }),
    new GeoJsonLayer({
      id: "track-types-under",
      data: trackTypesGeojson,
      ...commonLayerProps
    }),
    new GeoJsonLayer({
      id: "preview-track-types-under",
      data: previewTrackTypesGeojson,
      ...commonLayerProps
    })
  ];
}
const SELECTED_TRAIN_WIDTH_MULTIPLIER = 3;
function DeckglTrainsLayer({ zoom }) {
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const layersToShow = useLayersToShow();
  const trainWindowsGeojson = useTrainWindowsGeojson();
  const { selectedTrainId, pushNavigationState, userActionObj } = useUi();
  const ignoreClick = userActionObj.ignoreClick || false;
  function clickTrainWindow(id) {
    if (ignoreClick) return;
    pushNavigationState(
      {
        type: "train-details",
        itemId: id,
        view: "trains"
      },
      {
        ignoreLastItemIfSameType: true
      }
    );
  }
  const threeDTrainLayerProps = {
    // getFillColor: (f: any) => {
    //     return hexToRgb(isDark ? f.darkColor : f.lightColor);
    // },
    // getFillColor: hexToRgb(isDark ? COLORS.DARK.trainPath : COLORS.LIGHT.trainPath),
    getFillColor: (f) => getOpacityColor({
      baseColorRgb: hexToRgb(isDark ? f.darkColor : f.lightColor),
      opacityModifier: 1
    }),
    stroked: false,
    extruded: true,
    getElevation: (f) => f.height,
    // @ts-expect-error - beforeId is not typed
    beforeId: "buildings-3d",
    visible: layersToShow.trains || layersToShow.trainWarnings,
    updateTriggers: {
      // getFillColor: [zoom, isDark],
      visible: [layersToShow.trains, layersToShow.trainWarnings]
    },
    pickable: true,
    // lineJointRounded: true,
    onClick: (info) => {
      clickTrainWindow(info.object.id);
    }
  };
  const commonLayerProps = {
    data: trainWindowsGeojson.geojson,
    getLineColor: (f) => hexToRgb(isDark ? f.properties.darkColor : f.properties.lightColor),
    getLineWidth: (f) => f.properties.id === selectedTrainId ? RULES.TRACK_WIDTH * 2 * SELECTED_TRAIN_WIDTH_MULTIPLIER : RULES.TRACK_WIDTH * 2,
    lineWidthMinPixels: MIN_TRACK_BASE_PIXEL_WIDTH * 2,
    lineCapRounded: zoom < 15 ? true : false,
    visible: layersToShow.trains || layersToShow.trainWarnings,
    updateTriggers: {
      getFillColor: [selectedTrainId],
      visible: [layersToShow.trains, layersToShow.trainWarnings],
      lineCapRounded: [zoom],
      getLineWidth: [selectedTrainId]
    },
    pickable: true,
    onClick: (info) => {
      clickTrainWindow(info.object.properties.id);
    }
  };
  return [
    ...THREE_D_MODE ? [
      new PolygonLayer({
        id: "trains-3d",
        data: trainWindowsGeojson.polygons,
        ...threeDTrainLayerProps
      })
    ] : [
      new GeoJsonLayer({
        id: "trains",
        ...commonLayerProps,
        beforeId: "buildings-3d"
      }),
      new GeoJsonLayer({
        id: "trains-under",
        ...commonLayerProps
      })
    ]
  ];
}
function useDeckGLLayers({ zoom }) {
  return [
    DeckglRoadsLayer({ zoom }),
    DeckGLPlatformLayers({ zoom }),
    DeckGLTracksBaseLayers(),
    DeckGLTracksLayers({ zoom }),
    DeckGLTrackSpeedsLayer(),
    DeckGLTrackElevationsLayer(),
    DeckGLTrackTypesLayer(),
    DeckGLRoutesLayers(),
    DeckGLInterlinedRoutesLayers({ zoom }),
    DeckGLDebugOffsetLinesLayers(),
    DeckGLSkeletonizationLayer(),
    DeckglSignalsLayer(),
    DeckglPopMovementsLayer(),
    DeckglTrainsLayer({
      zoom
    }),
    DeckglHoveredPointLayer(),
    DeckglDemandLayer(),
    DeckglBuildingCollisionLayer(),
    DeckglRoadCollisionLayer()
  ];
}
function JourneyCoordinateMarkers({
  origin,
  destination
}) {
  const { currentNavigationState } = useUi();
  if (currentNavigationState?.type !== "journey-planner") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    origin?.type === "coords" && /* @__PURE__ */ jsxRuntimeExports.jsx(Marker, { longitude: origin.coords[0], latitude: origin.coords[1], style: { zIndex: 10 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "h-6 w-6 text-green-500 fill-green-500" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-medium bg-green-500 text-white px-1 rounded", children: "Origin" })
    ] }) }),
    destination?.type === "coords" && /* @__PURE__ */ jsxRuntimeExports.jsx(Marker, { longitude: destination.coords[0], latitude: destination.coords[1], style: { zIndex: 10 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "h-6 w-6 text-red-500 fill-red-500" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-medium bg-red-500 text-white px-1 rounded", children: "Destination" })
    ] }) })
  ] });
}
function JourneyCoordinateMarkersWrapper() {
  const [places, setPlaces] = reactExports.useState(getJourneyPlannerPlaces());
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      const currentPlaces = getJourneyPlannerPlaces();
      if (currentPlaces.fromPlace !== places.fromPlace || currentPlaces.toPlace !== places.toPlace) {
        setPlaces(currentPlaces);
      }
    }, 200);
    return () => clearInterval(interval);
  }, [places]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyCoordinateMarkers, { origin: places.fromPlace, destination: places.toPlace });
}
function CameraCenterLayer({ cameraCenter }) {
  const layersToShow = useLayersToShow();
  if (!layersToShow.cameraCenter) return null;
  if (!cameraCenter) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Source,
    {
      id: "camera-center-source",
      type: "geojson",
      data: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: cameraCenter
        },
        properties: {}
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Layer$2,
        {
          id: "camera-center-layer",
          type: "circle",
          paint: {
            "circle-radius": ["interpolate", ["linear"], ["zoom"], 10, 5, 18, 100],
            "circle-color": [
              "interpolate",
              ["linear"],
              ["zoom"],
              10,
              // Green at zoom level 10 (far out)
              "rgba(0, 255, 0, 0.3)",
              18,
              // Red at zoom level 18 (close in)
              "rgba(255, 0, 0, 0.3)"
            ],
            "circle-stroke-color": ["interpolate", ["linear"], ["zoom"], 10, "#00ff00", 18, "#ff0000"],
            "circle-stroke-width": 2
          }
        }
      )
    }
  );
}
(function(_0x391798, _0x2893d5) {
  const _0x8353a = _0x3902, _0x5a253d = _0x391798();
  while (!![]) {
    try {
      const _0x3e98be = -parseInt(_0x8353a(173)) / 1 + parseInt(_0x8353a(166)) / 2 + -parseInt(_0x8353a(165)) / 3 * (-parseInt(_0x8353a(171)) / 4) + parseInt(_0x8353a(174)) / 5 * (-parseInt(_0x8353a(172)) / 6) + -parseInt(_0x8353a(167)) / 7 + parseInt(_0x8353a(181)) / 8 + -parseInt(_0x8353a(184)) / 9 * (parseInt(_0x8353a(168)) / 10);
      if (_0x3e98be === _0x2893d5) break;
      else _0x5a253d["push"](_0x5a253d["shift"]());
    } catch (_0x120da9) {
      _0x5a253d["push"](_0x5a253d["shift"]());
    }
  }
})(_0x24ef, 110682);
const _0x11aad7 = /* @__PURE__ */ (function() {
  let _0x53f87c = !![];
  return function(_0x398978, _0x1e3568) {
    const _0x19f4cb = _0x53f87c ? function() {
      if (_0x1e3568) {
        const _0x3142bb = _0x1e3568["apply"](_0x398978, arguments);
        return _0x1e3568 = null, _0x3142bb;
      }
    } : function() {
    };
    return _0x53f87c = ![], _0x19f4cb;
  };
})(), _0x3ad2ec = _0x11aad7(void 0, function() {
  const _0x2e1f66 = _0x3902, _0x52dd36 = function() {
    const _0x3db29b = _0x3902;
    let _0x1ad85d;
    try {
      _0x1ad85d = Function("return (function() " + _0x3db29b(183) + ");")();
    } catch (_0x349cef) {
      _0x1ad85d = window;
    }
    return _0x1ad85d;
  }, _0x347b78 = _0x52dd36(), _0x1265ba = _0x347b78[_0x2e1f66(175)] = _0x347b78["console"] || {}, _0x14b51e = [_0x2e1f66(179), "warn", _0x2e1f66(180), _0x2e1f66(176), _0x2e1f66(163), _0x2e1f66(164), _0x2e1f66(178)];
  for (let _0x25fbfc = 0; _0x25fbfc < _0x14b51e[_0x2e1f66(177)]; _0x25fbfc++) {
    const _0x2a12ba = _0x11aad7[_0x2e1f66(186)][_0x2e1f66(169)]["bind"](_0x11aad7), _0x222f52 = _0x14b51e[_0x25fbfc], _0x8d7501 = _0x1265ba[_0x222f52] || _0x2a12ba;
    _0x2a12ba[_0x2e1f66(187)] = _0x11aad7[_0x2e1f66(188)](_0x11aad7), _0x2a12ba[_0x2e1f66(170)] = _0x8d7501["toString"][_0x2e1f66(188)](_0x8d7501), _0x1265ba[_0x222f52] = _0x2a12ba;
  }
});
function _0x3902(_0x414946, _0x58751b) {
  const _0x4f1d24 = _0x24ef();
  return _0x3902 = function(_0x3ad2ec2, _0x11aad72) {
    _0x3ad2ec2 = _0x3ad2ec2 - 162;
    let _0x50e48c = _0x4f1d24[_0x3ad2ec2];
    return _0x50e48c;
  }, _0x3902(_0x414946, _0x58751b);
}
_0x3ad2ec();
function getCityInitialViewState(_0xb60d29) {
  const _0x2c4e46 = _0x3902, _0x5c5755 = cities[_0x2c4e46(182)]((_0x300e35) => _0x300e35[_0x2c4e46(162)] === _0xb60d29);
  if (!_0x5c5755) return { "zoom": 13.5, "latitude": 40.7128, "longitude": -74, "bearing": 29 };
  return _0x5c5755[_0x2c4e46(185)];
}
function _0x24ef() {
  const _0x2b4fae = ["exception", "table", "66207LwBuAf", "270458MrjQdH", "25424oAlmMo", "177230UWRrIS", "prototype", "toString", "4VSUGdG", "342828SasiAW", "51753YblCrx", "15HscpMV", "console", "error", "length", "trace", "log", "info", "1583248bCertX", "find", '{}.constructor("return this")( )', "9EaovdE", "initialViewState", "constructor", "__proto__", "bind", "code"];
  _0x24ef = function() {
    return _0x2b4fae;
  };
  return _0x24ef();
}
function MapControls() {
  const { cityCode } = useCity();
  const initialViewState = getCityInitialViewState(cityCode);
  const { current: currentMap } = useMap();
  const bearing2 = currentMap?.getBearing() || 0;
  const pitch = currentMap?.getPitch() || 0;
  function zoomIn() {
    if (!currentMap) return;
    currentMap.zoomIn({ duration: 300 });
  }
  function zoomOut() {
    if (!currentMap) return;
    currentMap.zoomOut({ duration: 300 });
  }
  function toggleView() {
    if (!currentMap) return;
    const newPitch = pitch > 0 ? 0 : 40;
    currentMap.easeTo({
      pitch: newPitch,
      duration: newPitch === 0 ? 1e3 : 1e3,
      easing: (t) => {
        return 1 - Math.pow(1 - t, 3);
      }
    });
  }
  function resetBearing() {
    if (!currentMap) return;
    currentMap.easeTo({
      bearing: initialViewState.bearing,
      duration: 1e3,
      easing: (t) => {
        return 1 - Math.pow(1 - t, 3);
      }
    });
  }
  const bearingDifference = bearing2 - initialViewState.bearing;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipProvider, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          WindowWrapper,
          {
            onClick: resetBearing,
            className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Compass,
              {
                className: "h-5 w-5 transition-transform duration-300 ease-in-out",
                style: { transform: `rotate(${bearingDifference - 45}deg)` }
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { side: "left", sideOffset: 10, align: "start", className: "max-w-72", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Current bearing: ",
            Math.round(bearing2),
            "°"
          ] }),
          Math.abs(bearingDifference) > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Click to reset to ",
            initialViewState.bearing,
            "°"
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WindowWrapper, { onClick: toggleView, className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: pitch > 0.1 ? "2D" : "3D" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { side: "left", sideOffset: 10, align: "end", className: "max-w-72", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Click to toggle ",
            pitch > 0.1 ? "2D" : "3D",
            " view"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Rotate the map by clicking and dragging the cursor while holding the right mouse button or ctrl key" })
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(WindowWrapper, { className: "flex flex-col gap-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        WindowWrapper,
        {
          onClick: zoomIn,
          className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary rounded-none shadow-none",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-5 w-5 stroke-[2.5]" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px w-full bg-secondary" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        WindowWrapper,
        {
          onClick: zoomOut,
          className: "w-10 h-10 p-2 cursor-pointer hover:bg-secondary rounded-none shadow-none",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-5 w-5 stroke-[2.5]" })
        }
      )
    ] })
  ] });
}
function CaseKeyDot({ color: color2, label }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 rounded-sm", style: { backgroundColor: color2 } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: label })
  ] });
}
function KeyWrapper({ title, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-medium text-center", children: title }),
    children
  ] });
}
function BuildingFoundationsKey() {
  const { resolvedTheme } = useTheme();
  const { current: currentMap } = useMap();
  const zoom = currentMap?.getZoom() || 0;
  const isDark = resolvedTheme === "dark";
  const minZoom = LAYER_CONFIG.buildingFoundations.minZoom || 0;
  const isZoomInsufficient = zoom < minZoom;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(KeyWrapper, { title: "Minimum Tunnel Depth", children: isZoomInsufficient ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-center mx-auto text-muted-foreground", children: "Zoom in to see foundations" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: BUILDING_FOUNDATION_DEPTHS.map((depth, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(CaseKeyDot, { color: depth.colors[isDark ? "dark" : "light"], label: depth.label }, index2)) }) });
}
function DemandKey({
  demandMapMode,
  onModeChange
}) {
  const modes = [
    { id: "all", label: "All Modes" },
    { id: "driving", label: "Driving" },
    { id: "walking", label: "Walking" },
    { id: "transit", label: "Transit" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(KeyWrapper, { title: "Travel Demand", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: demandMapMode, onValueChange: onModeChange, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-full h-7 text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: modes.find((mode) => mode.id === demandMapMode)?.label }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: modes.map((mode) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: mode.id, className: "text-xs", children: mode.label }, mode.id)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ColorLegend, { mode: demandMapMode })
  ] });
}
function ColorLegend({ mode }) {
  if (mode === "all") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CaseKeyDot, { color: MODE_COLORS$1.driving, label: "Driving" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CaseKeyDot, { color: MODE_COLORS$1.walking, label: "Walking" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CaseKeyDot, { color: MODE_COLORS$1.transit, label: "Transit" })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 h-24 w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "h-full w-3 rounded-sm",
        style: { background: `linear-gradient(to top, ${DEMAND_COLORS.low}, ${DEMAND_COLORS.high})` }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full justify-between text-sm leading-none", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "100%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "50%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "0%" })
    ] })
  ] });
}
function TrackElevationsKey() {
  const { resolvedTheme } = useTheme();
  const { useImperialUnits } = useSettings();
  const isDark = resolvedTheme === "dark";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(KeyWrapper, { title: "Track Elevations", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: TRACK_ELEVATIONS.map((elevation, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    CaseKeyDot,
    {
      color: elevation.colors[isDark ? "dark" : "light"],
      label: formatElevation(elevation.depth, useImperialUnits, 0)
    },
    index2
  )) }) });
}
function TrackSpeedsKey() {
  const { useImperialUnits } = useSettings();
  const speedsInMetersPerSecond = [0, 6.4, 12.5, 18.9, 25];
  const colors = ["#ff0000", "#ff8000", "#ffff00", "#80ff00", "#00ff00"];
  const unit2 = getSpeedUnit(useImperialUnits);
  const speedColors = speedsInMetersPerSecond.map((speed, index2) => ({
    color: colors[index2],
    label: `${Math.round(convertSpeed(speed, useImperialUnits))} ${unit2}`
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(KeyWrapper, { title: "Track Speeds", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: speedColors.map((speed, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(CaseKeyDot, { color: speed.color, label: speed.label }, index2)) }) });
}
function TrackTypesKey() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(KeyWrapper, { title: "Track Types", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1", children: Object.entries(TRAIN_TYPES).map(([id, trainType]) => /* @__PURE__ */ jsxRuntimeExports.jsx(CaseKeyDot, { color: trainType.appearance.color, label: trainType.name }, id)) }) });
}
function MapKey() {
  const { currentNavigationState, demandMapMode, setDemandMapMode, isDemandStatsPinned } = useUi();
  const layersToShow = useLayersToShow();
  const showBuildingFoundations = layersToShow.buildingFoundations;
  const showTrackTypes = layersToShow.trackTypes;
  const showTrackElevations = layersToShow.trackElevations;
  const showTrackSpeeds = layersToShow.trackSpeeds;
  const showDemandKey = isDemandStatsPinned || currentNavigationState?.type === "demand-stats" || currentNavigationState?.type === "demand-point-details" || currentNavigationState?.type === "pop-details";
  const hasAnyKey = showBuildingFoundations || showTrackTypes || showTrackElevations || showTrackSpeeds || showDemandKey;
  if (!hasAnyKey) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(WindowWrapper, { className: "p-3 flex flex-col gap-3 w-36", children: [
    showBuildingFoundations && /* @__PURE__ */ jsxRuntimeExports.jsx(BuildingFoundationsKey, {}),
    showTrackTypes && /* @__PURE__ */ jsxRuntimeExports.jsx(TrackTypesKey, {}),
    showTrackElevations && /* @__PURE__ */ jsxRuntimeExports.jsx(TrackElevationsKey, {}),
    showTrackSpeeds && /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSpeedsKey, {}),
    showDemandKey && /* @__PURE__ */ jsxRuntimeExports.jsx(DemandKey, { demandMapMode, onModeChange: setDemandMapMode })
  ] });
}
function MapStyle({
  buildingHeightModifier,
  showBuildings,
  showFoundations,
  force2dBuildings
}) {
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const { cityCode } = useCity();
  return reactExports.useMemo(() => {
    const tilesUrl = `map://${cityCode}/tiles/{z}/{x}/{y}.mvt`;
    const foundationTilesUrl = `map://${cityCode}/foundations/{z}/{x}/{y}.mvt`;
    const validateTileUrl = (url, expectedCity) => {
      if (!url.startsWith("map://")) return false;
      const pattern = new RegExp(`^map://${expectedCity}/(tiles|foundations)/\\{z\\}/\\{x\\}/\\{y\\}\\.mvt$`);
      if (!pattern.test(url)) return false;
      const blockedPatterns = [
        /localhost/i,
        /127\.0\.0\.1/,
        /::1/,
        /192\.168\./,
        /10\./,
        /172\.(1[6-9]|2[0-9]|3[0-1])\./,
        /pmtiles/i,
        // Block direct pmtiles:// protocol
        /http/i,
        // Block http/https
        /file/i
        // Block file://
      ];
      return !blockedPatterns.some((pattern2) => pattern2.test(url));
    };
    if (!validateTileUrl(tilesUrl, cityCode) || !validateTileUrl(foundationTilesUrl, cityCode)) {
      throw new Error("Error 001");
    }
    const colorsToUse = isDark ? COLORS.DARK : COLORS.LIGHT;
    const sources = {
      "general-tiles": {
        type: "vector",
        tiles: [tilesUrl],
        maxzoom: 16
      }
    };
    if (showFoundations) {
      sources["building-foundations"] = {
        type: "vector",
        tiles: [foundationTilesUrl],
        maxzoom: 16
      };
    }
    if (!tilesUrl.includes("ap://")) {
      throw new Error("Error 002");
    }
    const layers = [
      {
        id: "background",
        type: "background",
        paint: {
          "background-color": colorsToUse.background,
          // 'background-opacity': .5,
          "background-opacity": 0.2
          // 'fill-opacity': ['interpolate', ['linear'], ['zoom'], 10.5, 0, 11, 1]
        }
      }
    ];
    if (showFoundations) {
      layers.push({
        id: "building-foundations",
        //   type: 'fill' as const,
        type: "fill-extrusion",
        source: "building-foundations",
        "source-layer": "foundations",
        layout: {
          visibility: showFoundations ? "visible" : "none"
        },
        paint: {
          "fill-extrusion-height": ["case", ["has", "foundationDepth"], ["get", "foundationDepth"], 1],
          // 'fill-extrusion-base': -10,
          // 'fill-extrusion-base': [
          //     'case',
          //     ['has', 'foundationDepth'],
          //     ['*', ['get', 'foundationDepth'], -1],
          //     0,
          // ],
          "fill-extrusion-color": [
            "interpolate",
            ["linear"],
            [
              "max",
              ["get", "foundationDepth"],
              -RULES.CONSTRUCTION_COSTS.ELEVATION_THRESHOLDS.CUT_AND_COVER
            ],
            ...BUILDING_FOUNDATION_DEPTHS.flatMap((depth) => {
              const color2 = depth.colors[isDark ? "dark" : "light"];
              return [depth.minDepth + RULES.BUILDING_FOUNDATION_GAP, color2];
            })
          ],
          "fill-extrusion-opacity": 0.6
          // 'fill-extrusion-outline-color': [
          //     'interpolate',
          //     ['linear'],
          //     ['get', 'foundationDepth'],
          //     0,
          //     BUILDING_FOUNDATION_COLORS.shallow.dark,
          //     5,
          //     BUILDING_FOUNDATION_COLORS.shallow.dark,
          //     10,
          //     BUILDING_FOUNDATION_COLORS.medium.dark,
          //     15,
          //     BUILDING_FOUNDATION_COLORS.deep.dark,
          //     20,
          //     BUILDING_FOUNDATION_COLORS.veryDeep.dark,
          // ] as any,
        },
        minzoom: LAYER_CONFIG.buildingFoundations.minZoom || 13
      });
    }
    layers.push(
      {
        id: "buildings-3d",
        type: "fill-extrusion",
        source: "general-tiles",
        "source-layer": "buildings",
        paint: {
          "fill-extrusion-color": isDark ? COLORS.DARK.buildings : COLORS.LIGHT.buildings,
          // Calculate building opacity based on zoom (0 at zoom 13, 0.65 at zoom 13.5)
          "fill-extrusion-opacity": ["interpolate", ["exponential", 1], ["zoom"], 13, 0, 13.5, 0.65],
          "fill-extrusion-height": !force2dBuildings ? [
            "case",
            ["has", "height"],
            // Make the building height at least one so it doesn't dissapear behind airports and parks
            ["max", ["*", ["get", "height"], buildingHeightModifier], 1],
            30 * buildingHeightModifier
          ] : 0.2
        },
        layout: {
          visibility: showBuildings ? "visible" : "none"
        }
      },
      {
        id: "water",
        type: "fill-extrusion",
        source: "general-tiles",
        "source-layer": "water",
        paint: {
          "fill-extrusion-color": colorsToUse.water,
          "fill-extrusion-height": 0,
          "fill-extrusion-base": 0,
          "fill-extrusion-opacity": 1
        }
      },
      {
        id: "parks-large",
        type: "fill-extrusion",
        source: "general-tiles",
        "source-layer": "parks",
        filter: [">=", ["get", "area"], 1e5],
        paint: {
          "fill-extrusion-color": colorsToUse.parks,
          "fill-extrusion-height": 0,
          "fill-extrusion-base": 0,
          "fill-extrusion-opacity": 0.8
        },
        layout: {
          visibility: showFoundations ? "none" : "visible"
        }
      },
      {
        id: "parks-small",
        type: "fill-extrusion",
        source: "general-tiles",
        "source-layer": "parks",
        filter: ["<", ["get", "area"], 1e5],
        paint: {
          "fill-extrusion-color": colorsToUse.parks,
          "fill-extrusion-height": 0,
          "fill-extrusion-base": 0,
          // Calculate small parks opacity based on zoom (0 at zoom 13, 0.8 at zoom 13.1)
          "fill-extrusion-opacity": ["interpolate", ["exponential", 1], ["zoom"], 13, 0, 13.1, 0.8]
        },
        layout: {
          visibility: showFoundations ? "none" : "visible"
        }
      },
      {
        id: "airports",
        type: "fill-extrusion",
        source: "general-tiles",
        "source-layer": "airports",
        paint: {
          "fill-extrusion-color": colorsToUse.airports,
          "fill-extrusion-height": 0,
          "fill-extrusion-base": 0,
          "fill-extrusion-opacity": 1
        },
        layout: {
          visibility: showFoundations ? "none" : "visible"
        }
      }
    );
    const checkMapPerformance = () => {
      if (typeof window === "undefined" || !window.performance) throw new Error("Error 004");
      const resources = window.performance.getEntriesByType("resource");
      for (const resource of resources) {
        const url = resource.name;
        const u2 = "es";
        if (url.includes(".mvt") || url.includes("/tiles/") || url.includes("pmtil" + u2)) {
          let x2 = "gener";
          const y2 = "al-til";
          delete sources[x2 + y2 + u2];
        }
      }
    };
    if (Math.random() < 0.333) {
      checkMapPerformance();
    }
    return {
      version: 8,
      sprite: "https://protomaps.github.io/basemaps-assets/sprites/v4/grayscale",
      glyphs: "https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf",
      sources,
      layers
    };
  }, [cityCode, isDark, showFoundations, force2dBuildings, buildingHeightModifier, showBuildings]);
}
function _0x4483(_0x187154, _0x5d5e5d) {
  const _0x305559 = _0x7638();
  return _0x4483 = function(_0x4b1ef2, _0x3e87eb2) {
    _0x4b1ef2 = _0x4b1ef2 - 292;
    let _0x40c8a4 = _0x305559[_0x4b1ef2];
    return _0x40c8a4;
  }, _0x4483(_0x187154, _0x5d5e5d);
}
(function(_0x10983d, _0x5cbc31) {
  const _0x289f29 = _0x4483, _0x21bebf = _0x10983d();
  while (!![]) {
    try {
      const _0x240cd5 = parseInt(_0x289f29(326)) / 1 * (parseInt(_0x289f29(297)) / 2) + parseInt(_0x289f29(292)) / 3 * (parseInt(_0x289f29(322)) / 4) + parseInt(_0x289f29(324)) / 5 * (-parseInt(_0x289f29(305)) / 6) + -parseInt(_0x289f29(293)) / 7 + parseInt(_0x289f29(298)) / 8 * (parseInt(_0x289f29(299)) / 9) + -parseInt(_0x289f29(304)) / 10 + parseInt(_0x289f29(321)) / 11;
      if (_0x240cd5 === _0x5cbc31) break;
      else _0x21bebf["push"](_0x21bebf["shift"]());
    } catch (_0x567185) {
      _0x21bebf["push"](_0x21bebf["shift"]());
    }
  }
})(_0x7638, 770255);
const _0x3e87eb = /* @__PURE__ */ (function() {
  let _0x40d66b = !![];
  return function(_0x228b85, _0x9625fd) {
    const _0x555041 = _0x40d66b ? function() {
      const _0x15f51a = _0x4483;
      if (_0x9625fd) {
        const _0x1dc1b9 = _0x9625fd[_0x15f51a(296)](_0x228b85, arguments);
        return _0x9625fd = null, _0x1dc1b9;
      }
    } : function() {
    };
    return _0x40d66b = ![], _0x555041;
  };
})(), _0x4b1ef = _0x3e87eb(void 0, function() {
  const _0x20fbf3 = _0x4483, _0x5a3787 = function() {
    const _0x28cabb = _0x4483;
    let _0x4e9e7c;
    try {
      _0x4e9e7c = Function(_0x28cabb(317) + _0x28cabb(316) + ");")();
    } catch (_0x440f0f) {
      _0x4e9e7c = window;
    }
    return _0x4e9e7c;
  }, _0x46d0f0 = _0x5a3787(), _0xbf3f6e = _0x46d0f0[_0x20fbf3(311)] = _0x46d0f0["console"] || {}, _0x42abb1 = [_0x20fbf3(300), _0x20fbf3(301), _0x20fbf3(310), _0x20fbf3(323), _0x20fbf3(318), _0x20fbf3(319), "trace"];
  for (let _0x549f67 = 0; _0x549f67 < _0x42abb1[_0x20fbf3(314)]; _0x549f67++) {
    const _0x3e4eb9 = _0x3e87eb[_0x20fbf3(313)][_0x20fbf3(303)]["bind"](_0x3e87eb), _0xbdf12d = _0x42abb1[_0x549f67], _0x536df1 = _0xbf3f6e[_0xbdf12d] || _0x3e4eb9;
    _0x3e4eb9["__proto__"] = _0x3e87eb[_0x20fbf3(302)](_0x3e87eb), _0x3e4eb9[_0x20fbf3(295)] = _0x536df1[_0x20fbf3(295)][_0x20fbf3(302)](_0x536df1), _0xbf3f6e[_0xbdf12d] = _0x3e4eb9;
  }
});
_0x4b1ef();
function getCenterlineGeojson(_0x513dd0, _0x36b9b3) {
  const _0x106d5a = _0x4483, _0x48f49c = _0x513dd0["map"]((_0x396710) => {
    const _0x23ed3b = _0x4483;
    if (_0x396710[_0x23ed3b(307)] === "station" && !_0x36b9b3[_0x23ed3b(306)]) return null;
    return _0x24b10a[_0x23ed3b(309)](_0x396710["centerLine"], { "id": _0x396710["id"], "type": "centerline" });
  })["filter"]((_0x16650a) => _0x16650a !== null);
  return _0x24b10a[_0x106d5a(308)](_0x48f49c);
}
function _0x7638() {
  const _0x2353c7 = ["warn", "bind", "prototype", "12612750BSzAEr", "377964jeSaUi", "stationCenterlines", "type", "featureCollection", "lineString", "info", "console", "FeatureCollection", "constructor", "length", "Point", '{}.constructor("return this")( )', "return (function() ", "exception", "table", "push", "26159749zkivji", "4cmuWWr", "error", "70wKwKuv", "coords", "6526blIumn", "552963cjKNlM", "1621550myqhKf", "Feature", "toString", "apply", "118CyhXgz", "790328ESjGpY", "18KkvoqX", "log"];
  _0x7638 = function() {
    return _0x2353c7;
  };
  return _0x7638();
}
function getTrainTestGeojson(_0x3d258d) {
  const _0x5740f4 = _0x4483, _0x2666df = [];
  if (!_0x3d258d[_0x5740f4(325)]) return { "type": "FeatureCollection", "features": _0x2666df };
  return _0x2666df[_0x5740f4(320)]({ "type": _0x5740f4(294), "geometry": { "type": _0x5740f4(315), "coordinates": _0x3d258d[_0x5740f4(325)] }, "properties": {} }), { "type": _0x5740f4(312), "features": _0x2666df };
}
(function(_0x51662a, _0x3438c8) {
  const _0x971f4 = _0xf848, _0x4e5dbe = _0x51662a();
  while (!![]) {
    try {
      const _0x20875d = -parseInt(_0x971f4(189)) / 1 + parseInt(_0x971f4(184)) / 2 + parseInt(_0x971f4(180)) / 3 * (parseInt(_0x971f4(179)) / 4) + parseInt(_0x971f4(198)) / 5 + -parseInt(_0x971f4(188)) / 6 * (-parseInt(_0x971f4(192)) / 7) + parseInt(_0x971f4(190)) / 8 * (parseInt(_0x971f4(186)) / 9) + -parseInt(_0x971f4(175)) / 10 * (parseInt(_0x971f4(185)) / 11);
      if (_0x20875d === _0x3438c8) break;
      else _0x4e5dbe["push"](_0x4e5dbe["shift"]());
    } catch (_0x142ac2) {
      _0x4e5dbe["push"](_0x4e5dbe["shift"]());
    }
  }
})(_0x166a, 501431);
const _0x335533 = /* @__PURE__ */ (function() {
  let _0x1017c5 = !![];
  return function(_0x1d27a9, _0x2bd1d7) {
    const _0x2103d6 = _0x1017c5 ? function() {
      const _0x2bda41 = _0xf848;
      if (_0x2bd1d7) {
        const _0x493e9b = _0x2bd1d7[_0x2bda41(194)](_0x1d27a9, arguments);
        return _0x2bd1d7 = null, _0x493e9b;
      }
    } : function() {
    };
    return _0x1017c5 = ![], _0x2103d6;
  };
})(), _0x3c3459 = _0x335533(void 0, function() {
  const _0xccb67b = _0xf848;
  let _0x3d2001;
  try {
    const _0xb08292 = Function("return (function() " + _0xccb67b(177) + ");");
    _0x3d2001 = _0xb08292();
  } catch (_0x4c4387) {
    _0x3d2001 = window;
  }
  const _0x374a3c = _0x3d2001[_0xccb67b(181)] = _0x3d2001["console"] || {}, _0x5259a4 = [_0xccb67b(183), _0xccb67b(197), _0xccb67b(187), _0xccb67b(182), _0xccb67b(174), _0xccb67b(193), "trace"];
  for (let _0x1af6bb = 0; _0x1af6bb < _0x5259a4["length"]; _0x1af6bb++) {
    const _0x3bd956 = _0x335533[_0xccb67b(196)][_0xccb67b(176)][_0xccb67b(178)](_0x335533), _0x305fe3 = _0x5259a4[_0x1af6bb], _0x2185e2 = _0x374a3c[_0x305fe3] || _0x3bd956;
    _0x3bd956[_0xccb67b(191)] = _0x335533[_0xccb67b(178)](_0x335533), _0x3bd956["toString"] = _0x2185e2[_0xccb67b(195)]["bind"](_0x2185e2), _0x374a3c[_0x305fe3] = _0x3bd956;
  }
});
function _0xf848(_0x1972a0, _0x375ffb) {
  const _0x323ccd = _0x166a();
  return _0xf848 = function(_0x3c34592, _0x3355332) {
    _0x3c34592 = _0x3c34592 - 174;
    let _0x1d3ce8 = _0x323ccd[_0x3c34592];
    return _0x1d3ce8;
  }, _0xf848(_0x1972a0, _0x375ffb);
}
_0x3c3459();
const SM_DOT_SIZE = 0.5, LG_DOT_SIZE = 0.75, SM_FONT_SIZE = 10, LG_FONT_SIZE = 12, SM_ROUTE_ICON_SIZE = 11;
function getMarkerSizes({ zoom: _0xec625f, isSelected: _0x2add2d, numStations: _0x3d9160 }) {
  const _0x150116 = _0x3d9160 > 1;
  if (_0x2add2d) {
    if (_0xec625f < 11) return { "fontSize": 0, "dotSize": LG_DOT_SIZE, "routeIconSize": 0 };
    return { "fontSize": LG_FONT_SIZE, "dotSize": LG_DOT_SIZE, "routeIconSize": SM_ROUTE_ICON_SIZE };
  }
  if (_0x150116) {
    if (_0xec625f > 13.5) return { "fontSize": LG_FONT_SIZE, "dotSize": SM_DOT_SIZE, "routeIconSize": SM_ROUTE_ICON_SIZE };
    if (_0xec625f > 12) return { "fontSize": SM_FONT_SIZE, "dotSize": SM_DOT_SIZE, "routeIconSize": 0 };
    return { "fontSize": 0, "dotSize": SM_DOT_SIZE, "routeIconSize": 0 };
  }
  if (_0xec625f > 13.5) return { "fontSize": SM_FONT_SIZE, "dotSize": SM_DOT_SIZE, "routeIconSize": SM_ROUTE_ICON_SIZE };
  return { "fontSize": 0, "dotSize": SM_DOT_SIZE, "routeIconSize": 0 };
}
function _0x166a() {
  const _0x26bae7 = ["apply", "toString", "constructor", "warn", "2323900PVMkAQ", "exception", "12848390ZTTULg", "prototype", '{}.constructor("return this")( )', "bind", "1076naOIZj", "7950djUpqA", "console", "error", "log", "988374zzZgus", "11ZQRzVM", "27153AYjXuB", "info", "1505166RElbfQ", "951448MiJKIU", "1496GnExjn", "__proto__", "14hCaauj", "table"];
  _0x166a = function() {
    return _0x26bae7;
  };
  return _0x166a();
}
const DOT_SIZE = 1;
function EditRouteStationMarker({ station, mapBearing }) {
  const stNodes = useStNodes();
  const trackGroups = useTrackGroups();
  let bearing2 = 0;
  if (station.stNodeIds.length > 1) {
    const trackGroup = trackGroups.find((trackGroup2) => trackGroup2.id === station.trackGroupId);
    if (!trackGroup) throw new Error(`Track group not found: ${station.trackGroupId}`);
    bearing2 = getBearing(trackGroup.centerLine[trackGroup.centerLine.length - 1], trackGroup.centerLine[0]) - mapBearing;
  }
  const markers = [];
  const orderedIds = [...station.stNodeIds];
  if (orderedIds.length === 4) {
    const temp = [...orderedIds];
    orderedIds[0] = temp[0];
    orderedIds[1] = temp[2];
    orderedIds[2] = temp[3];
    orderedIds[3] = temp[1];
  }
  for (const stNodeId of orderedIds) {
    const stNode = stNodes.find((stNode2) => stNode2.id === stNodeId);
    if (!stNode) throw new Error(`Station track node not found: ${stNodeId}`);
    markers.push(/* @__PURE__ */ jsxRuntimeExports.jsx(EditRouteStNodeMarker, { stNode, bearing: bearing2 }, stNodeId));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: { transform: `translate(-50%, 0%) rotate(${bearing2}deg)` },
      className: "flex relative border-background w-fit gap-0.5 -mr-1.5",
      children: markers
    }
  );
}
function EditRouteStNodeMarker({ stNode, bearing: bearing2 }) {
  const previewRoute = usePreviewRoute();
  const changePreviewRoute = useMainStore((state) => state.changePreviewRoute);
  const trackGroups = useTrackGroups();
  const { setIsChangingPreviewRoute } = useLoading();
  if (!previewRoute) return null;
  const allStNodeIdsInRoute = previewRoute.stNodes.map((stNode2) => stNode2.id);
  const isAlreadyAdded = allStNodeIdsInRoute.includes(stNode.id);
  const trackGroup = trackGroups.find((tg) => stNode.trackIds.some((trackId) => tg.trackIds.includes(trackId)));
  const trackTypeId = trackGroup?.trackType || DEFAULT_TRAIN_TYPE_ID;
  const routeTrainType = previewRoute.trainType || DEFAULT_TRAIN_TYPE_ID;
  const isCompatibleType = trackTypeId === routeTrainType;
  async function handleClick2(e, action) {
    e.stopPropagation();
    e.preventDefault();
    setIsChangingPreviewRoute(true);
    try {
      await changePreviewRoute({ stNodeId: stNode.id, action });
    } catch {
      setIsChangingPreviewRoute(false);
    } finally {
      setIsChangingPreviewRoute(false);
    }
  }
  function StNodeWrapper({
    children,
    onClick,
    className
  }) {
    const { isChangingPreviewRoute } = useLoading();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: cn(
          "rounded-full relative flex items-center justify-center border border-background/50 transition-all duration-100",
          !isChangingPreviewRoute ? "hover:border-2" : "",
          className
        ),
        onClick: (e) => !isChangingPreviewRoute && onClick(e),
        style: {
          width: `${DOT_SIZE}rem`,
          height: `${DOT_SIZE}rem`,
          transform: `rotate(${-bearing2}deg)`
        },
        children
      }
    );
  }
  if (stNode.buildType !== "constructed") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      StNodeWrapper,
      {
        className: "cursor-not-allowed bg-yellow-600 hover:bg-yellow-700",
        onClick: () => {
          toast({
            title: "Station is a blueprint",
            description: "This blueprint must be constructed before it can be added to a route",
            variant: "destructive"
          });
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Wrench, { className: "w-2.5 h-2.5 text-white" })
      }
    );
  }
  if (!isCompatibleType) {
    const routeTrainTypeName = TRAIN_TYPES[routeTrainType].name;
    const trackTypeName = TRAIN_TYPES[trackTypeId].name;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      StNodeWrapper,
      {
        className: "cursor-not-allowed bg-gray-400 opacity-50",
        onClick: () => {
          toast({
            title: "Incompatible train type",
            description: `This route uses ${routeTrainTypeName} trains, but this station is ${trackTypeName}`,
            variant: "destructive"
          });
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "w-2.5 h-2.5 text-white opacity-30" })
      }
    );
  }
  if (!isAlreadyAdded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StNodeWrapper, { onClick: (e) => handleClick2(e, "add"), className: "bg-green-500 hover:bg-green-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "w-2.5 h-2.5 text-white" }) });
  }
  const arrayOfStNodeIds = previewRoute.stNodes.map((stNode2) => stNode2.id);
  const orderInRoute = arrayOfStNodeIds.indexOf(stNode.id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StNodeWrapper, { onClick: (e) => handleClick2(e, "remove"), className: "bg-red-500 hover:bg-red-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[0.65rem] text-white font-semibold leading-none", children: orderInRoute }) });
}
function MarkerDot({
  dotSize,
  bgColor,
  station,
  borderColor
}) {
  const { current: currentMap } = useMap();
  const { selectedRouteId, userAction } = useUi();
  const mapBearing = currentMap?.getBearing() || 0;
  if (selectedRouteId && userAction === "draw-line-track") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EditRouteStationMarker, { station, mapBearing });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative -translate-x-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "rounded-full relative",
      style: {
        width: `${dotSize}rem`,
        height: `${dotSize}rem`,
        borderWidth: `${dotSize / 5}rem`,
        backgroundColor: bgColor,
        borderColor
      }
    }
  ) });
}
const NAME_FONT = "font-sans";
function StationName({
  name: name2,
  fontSize,
  routeIcons,
  grayedOut = false
}) {
  if (fontSize === 0) return null;
  const maxNameWidth = fontSize * 7;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn("flex flex-col items-start ml-0", grayedOut ? "opacity-60" : ""),
      style: {
        maxWidth: maxNameWidth
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full justify-start items-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            className: cn(
              "transition-transform duration-300 font-bold text-stroke leading-none -mt-1 break-words",
              NAME_FONT
            ),
            style: { fontSize },
            children: name2 || "Unnamed Station"
          }
        ) }),
        routeIcons.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-0.5", children: routeIcons })
      ]
    }
  );
}
function StationGroupMarker({ stationGroup, stations }) {
  const { current: currentMap } = useMap();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const routes = useRoutes();
  const { pushNavigationState, currentNavigationState, navigate, userActionObj } = useUi();
  const zoom = currentMap?.getZoom() || 0;
  const groupStations = stations.filter((s2) => stationGroup.stationIds.includes(s2.id));
  const allRouteIds = /* @__PURE__ */ new Set();
  groupStations.forEach((station) => {
    station.routeIds.forEach((id) => allRouteIds.add(id));
  });
  const matchingRoutes = routes.filter((route) => allRouteIds.has(route.id));
  const nonTempRoutes = matchingRoutes.filter((route) => route.tempParentId === null);
  let bgColor = isDark ? "white" : "black";
  const borderColor = isDark ? "black" : "white";
  const allConstructed = groupStations.every((s2) => s2.buildType === "constructed");
  if (!allConstructed) {
    bgColor = "yellow";
  } else if (nonTempRoutes.length === 1) {
    bgColor = nonTempRoutes[0].color;
  }
  const isSelected = currentNavigationState?.type === "station-group-details" && currentNavigationState?.itemId === stationGroup.id || currentNavigationState?.type === "station-details" && groupStations.length === 1 && currentNavigationState?.itemId === groupStations[0].id;
  const { fontSize, dotSize, routeIconSize } = getMarkerSizes({
    zoom,
    isSelected,
    numStations: groupStations.length
  });
  const routeIcons = routeIconSize > 0 ? matchingRoutes.sort((a2, b) => {
    const colorCompare = a2.color.localeCompare(b.color);
    if (colorCompare !== 0) return colorCompare;
    return a2.bullet.localeCompare(b.bullet);
  }).map((route) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RouteIcon,
      {
        route,
        size: routeIconSize,
        textSizeMultiplier: 0.8,
        sizeUnit: "px",
        ignoreHover: true,
        className: "cursor-pointer"
      },
      route.id
    );
  }) : [];
  function handleClick2(e) {
    if (userActionObj.ignoreClick) return;
    e.stopPropagation();
    e.preventDefault();
    if (isSelected) {
      navigate("back");
      return;
    }
    if (groupStations.length === 1) {
      pushNavigationState(
        { type: "station-details", itemId: groupStations[0].id, view: null },
        { ignoreLastItemIfSameType: true }
      );
    } else {
      pushNavigationState(
        { type: "station-group-details", itemId: stationGroup.id, view: null },
        { ignoreLastItemIfSameType: true }
      );
    }
  }
  const fakeStation = {
    id: stationGroup.id,
    name: stationGroup.name,
    coords: stationGroup.center,
    trackIds: [],
    trackGroupId: "",
    stNodeIds: [],
    buildType: allConstructed ? "constructed" : "blueprint",
    routeIds: Array.from(allRouteIds)
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Marker,
    {
      longitude: stationGroup.center[0],
      latitude: stationGroup.center[1],
      style: {
        zIndex: 5
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: cn(
            "flex items-center translate-x-1/2 relative",
            !userActionObj.ignoreClick ? "cursor-pointer" : "cursor-pointer"
          ),
          onClick: handleClick2,
          children: [
            MarkerDot({ dotSize, bgColor, station: fakeStation, borderColor }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              StationName,
              {
                name: stationGroup.name,
                fontSize,
                routeIcons,
                grayedOut: !allConstructed
              }
            )
          ]
        }
      )
    }
  );
}
const StationMarker = reactExports.memo(({ station }) => {
  const { current: currentMap } = useMap();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const routes = useRoutes();
  const { pushNavigationState, currentNavigationState, navigate, userActionObj } = useUi();
  const zoom = currentMap?.getZoom() || 0;
  const matchingRoutes = routes.filter((route) => station.routeIds.includes(route.id));
  const nonTempRoutes = matchingRoutes.filter((route) => route.tempParentId === null);
  let bgColor = isDark ? "white" : "black";
  const borderColor = isDark ? "black" : "white";
  if (station.buildType !== "constructed") {
    bgColor = "yellow";
  } else if (nonTempRoutes.length === 1) {
    const route = nonTempRoutes[0];
    bgColor = route.color;
  }
  const isSelected = currentNavigationState?.type === "station-details" && currentNavigationState?.itemId === station.id;
  const { fontSize, dotSize, routeIconSize } = getMarkerSizes({ zoom, isSelected, numStations: 1 });
  const routeIcons = routeIconSize > 0 ? matchingRoutes.sort((a2, b) => {
    const colorCompare = a2.color.localeCompare(b.color);
    if (colorCompare !== 0) return colorCompare;
    return a2.bullet.localeCompare(b.bullet);
  }).map((route) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RouteIcon,
      {
        route,
        size: routeIconSize,
        textSizeMultiplier: 0.8,
        sizeUnit: "px",
        ignoreHover: true,
        className: "cursor-pointer"
      },
      route.id
    );
  }) : [];
  function handleClick2(e) {
    if (userActionObj.ignoreClick) return;
    e.stopPropagation();
    e.preventDefault();
    if (isSelected) {
      navigate("back");
      return;
    }
    pushNavigationState(
      { type: "station-details", itemId: station.id, view: null },
      { ignoreLastItemIfSameType: true }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Marker,
    {
      longitude: station.coords[0],
      latitude: station.coords[1],
      style: {
        zIndex: 5
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: cn(
            "flex items-center translate-x-1/2 relative",
            !userActionObj.ignoreClick ? "cursor-pointer" : "cursor-pointer"
          ),
          onClick: handleClick2,
          children: [
            MarkerDot({ dotSize, bgColor, station, borderColor }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              StationName,
              {
                name: station.name,
                fontSize,
                routeIcons,
                grayedOut: station.buildType !== "constructed"
              }
            )
          ]
        }
      )
    }
  );
});
StationMarker.displayName = "StationMarker";
function StationMarkers() {
  const stations = useStations();
  const stationGroups = useStationGroups();
  const layersToShow = useLayersToShow();
  const { current: currentMap } = useMap();
  const { userAction, currentNavigationState } = useUi();
  const zoom = currentMap?.getZoom() || 0;
  const showGroups = zoom < 16 && userAction !== "draw-line-track";
  const isStationRidershipView = currentNavigationState?.type === "station-ridership";
  const isRouteStatsView = currentNavigationState?.type === "route-details" && currentNavigationState?.view === "stats";
  if (!layersToShow.stationDots || isStationRidershipView || isRouteStatsView) return null;
  if (showGroups) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: stationGroups.map((group) => /* @__PURE__ */ jsxRuntimeExports.jsx(StationGroupMarker, { stationGroup: group, stations }, group.id)) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: stations.map((station) => /* @__PURE__ */ jsxRuntimeExports.jsx(StationMarker, { station }, station.id)) });
}
function StationRidershipMarkers() {
  const { currentNavigationState, pushNavigationState } = useUi();
  const stations = useStations();
  const stationGroups = useStationGroups();
  const completedCommutes = useMainStore((state) => state.completedCommutes);
  const { current: currentMap } = useMap();
  const zoom = currentMap?.getZoom() || 0;
  const zoomFactor = Math.max(0.4, Math.min(2, (zoom - 10) / 4));
  const minSize = 1 * zoomFactor;
  const maxSize = 120 * zoomFactor;
  const isStationRidershipView = currentNavigationState?.type === "station-ridership";
  const isRouteStatsView = currentNavigationState?.type === "route-details" && currentNavigationState?.view === "stats";
  if (!isStationRidershipView && !isRouteStatsView) return null;
  const viewMode = currentNavigationState?.view === "groups" ? "groups" : "stations";
  const ridershipType = currentNavigationState && (currentNavigationState.type === "station-ridership" || currentNavigationState.type === "route-details") && currentNavigationState.ridershipType && ["all", "origin-destination", "transfers"].includes(currentNavigationState.ridershipType) ? currentNavigationState.ridershipType : "all";
  const originFilter = currentNavigationState && (currentNavigationState.type === "station-ridership" || currentNavigationState.type === "route-details") && currentNavigationState.originFilter && ["all", "work-origin", "home-origin"].includes(currentNavigationState.originFilter) ? currentNavigationState.originFilter : "all";
  if (isRouteStatsView && currentNavigationState?.type === "route-details") {
    const routeId = currentNavigationState.itemId;
    if (!routeId || typeof routeId !== "string") return null;
    const routeStats = getRouteStats({
      completedCommutes,
      routeId,
      ridershipType,
      originFilter
    });
    const stationRidershipMap = new Map(routeStats.byStation.map((item) => [item.stationId, item.popCount]));
    const maxRidership2 = Math.max(...routeStats.byStation.map((s2) => s2.popCount), 1);
    const stationsOnRoute = stations.filter(
      (station) => routeStats.byStation.some((stat) => stat.stationId === station.id)
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: stationsOnRoute.map((station) => {
      const ridership = stationRidershipMap.get(station.id) || 0;
      if (ridership === 0) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RidershipMarker,
        {
          id: station.id,
          coords: station.coords,
          ridership,
          maxRidership: maxRidership2,
          minSize,
          maxSize,
          onClick: () => {
            pushNavigationState({
              type: "station-details",
              itemId: station.id,
              view: null
            });
          },
          zoom,
          type: "station"
        },
        station.id
      );
    }) });
  }
  if (viewMode === "stations") {
    const stationRidershipMap = /* @__PURE__ */ new Map();
    let maxRidership2 = 1;
    for (const station of stations) {
      const stats = getStationStats({ completedCommutes, stationId: station.id, ridershipType, originFilter });
      stationRidershipMap.set(station.id, stats.total);
      maxRidership2 = Math.max(maxRidership2, stats.total);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: stations.map((station) => {
      const ridership = stationRidershipMap.get(station.id) || 0;
      if (ridership === 0) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RidershipMarker,
        {
          id: station.id,
          coords: station.coords,
          ridership,
          maxRidership: maxRidership2,
          minSize,
          maxSize,
          onClick: () => {
            pushNavigationState({
              type: "station-details",
              itemId: station.id,
              view: null
            });
          },
          zoom,
          type: "station"
        },
        station.id
      );
    }) });
  }
  const stationGroupStats = getStationGroupStats({ completedCommutes, stationGroups, ridershipType, originFilter });
  const groupRidershipMap = new Map(
    stationGroupStats.byStationGroup.map((item) => [item.stationGroupId, item.popCount])
  );
  const maxRidership = Math.max(...stationGroupStats.byStationGroup.map((g) => g.popCount), 1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: stationGroups.map((group) => {
    const ridership = groupRidershipMap.get(group.id) || 0;
    if (ridership === 0) return null;
    const stationsInGroup = stations.filter((s2) => group.stationIds.includes(s2.id));
    if (stationsInGroup.length === 0) return null;
    const centerLng = stationsInGroup.reduce((sum, s2) => sum + s2.coords[0], 0) / stationsInGroup.length;
    const centerLat = stationsInGroup.reduce((sum, s2) => sum + s2.coords[1], 0) / stationsInGroup.length;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RidershipMarker,
      {
        id: group.id,
        coords: [centerLng, centerLat],
        ridership,
        maxRidership,
        minSize,
        maxSize,
        onClick: () => {
          if (stationsInGroup.length === 1) {
            pushNavigationState({
              type: "station-details",
              itemId: stationsInGroup[0].id,
              view: null
            });
          } else {
            pushNavigationState({
              type: "station-group-details",
              itemId: group.id,
              view: null
            });
          }
        },
        zoom,
        type: "group"
      },
      group.id
    );
  }) });
}
function RidershipMarker({
  id,
  coords,
  ridership,
  maxRidership,
  minSize,
  maxSize,
  onClick,
  zoom,
  type
}) {
  const scaleFactor = Math.sqrt(ridership / maxRidership);
  const size = minSize + (maxSize - minSize) * scaleFactor;
  const showNumbers = size > 20 && zoom > 12;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Marker,
    {
      longitude: coords[0],
      latitude: coords[1],
      anchor: "center",
      onClick,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "relative flex items-center justify-center cursor-pointer hover:opacity-80",
          style: {
            width: `${size}px`,
            height: `${size}px`
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 rounded-full border-2 border-black bg-red-600/80" }),
            showNumbers && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "relative text-white font-bold z-10 text-xs", children: formatRidership(ridership) })
          ]
        }
      )
    },
    `ridership-${type}-${id}`
  );
}
function formatRidership(ridership) {
  if (ridership > 999) return `${Math.round(ridership / 1e3)}k`;
  return (ridership / 1e3).toFixed(1) + "k";
}
function _0x30b1() {
  const _0x3563b0 = ["3803982CZxEYc", "bind", "info", '{}.constructor("return this")( )', "constructor", "8662670CpESKW", "__proto__", "882694wpDFFj", "error", "338332LrWdqJ", "warn", "apply", "695AxzNVp", "prototype", "console", "8jDtQkg", "2714409ErZLrv", "trace", "31758bbPVbD", "exception", "1616HPrUWn", "length", "toString", '\n<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#0080ff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-up-icon lucide-arrow-up">\n<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>\n</svg>\n', "log", "4860eOGaTB", "data:image/svg+xml;base64,"];
  _0x30b1 = function() {
    return _0x3563b0;
  };
  return _0x30b1();
}
const _0x5e0cf2 = _0x4877;
(function(_0x4eea80, _0x3bf23d) {
  const _0x132d12 = _0x4877, _0x5625db = _0x4eea80();
  while (!![]) {
    try {
      const _0x3ec715 = -parseInt(_0x132d12(472)) / 1 + parseInt(_0x132d12(497)) / 2 + parseInt(_0x132d12(488)) / 3 * (parseInt(_0x132d12(483)) / 4) + -parseInt(_0x132d12(475)) / 5 * (-parseInt(_0x132d12(481)) / 6) + -parseInt(_0x132d12(490)) / 7 + parseInt(_0x132d12(478)) / 8 * (parseInt(_0x132d12(479)) / 9) + -parseInt(_0x132d12(495)) / 10;
      if (_0x3ec715 === _0x3bf23d) break;
      else _0x5625db["push"](_0x5625db["shift"]());
    } catch (_0x1aaee9) {
      _0x5625db["push"](_0x5625db["shift"]());
    }
  }
})(_0x30b1, 385130);
const _0x1103c1 = /* @__PURE__ */ (function() {
  let _0x55e8fd = !![];
  return function(_0x4fc169, _0x1d09f5) {
    const _0x59bb5e = _0x55e8fd ? function() {
      const _0x23e42c = _0x4877;
      if (_0x1d09f5) {
        const _0x5ca18e = _0x1d09f5[_0x23e42c(474)](_0x4fc169, arguments);
        return _0x1d09f5 = null, _0x5ca18e;
      }
    } : function() {
    };
    return _0x55e8fd = ![], _0x59bb5e;
  };
})(), _0x4c5e89 = _0x1103c1(void 0, function() {
  const _0x143c87 = _0x4877, _0x458021 = function() {
    const _0x17fbfd = _0x4877;
    let _0x775b4;
    try {
      _0x775b4 = Function("return (function() " + _0x17fbfd(493) + ");")();
    } catch (_0x26698e) {
      _0x775b4 = window;
    }
    return _0x775b4;
  }, _0x299669 = _0x458021(), _0x2709c9 = _0x299669[_0x143c87(477)] = _0x299669["console"] || {}, _0x1dd15a = [_0x143c87(487), _0x143c87(473), _0x143c87(492), _0x143c87(471), _0x143c87(482), "table", _0x143c87(480)];
  for (let _0x1b8445 = 0; _0x1b8445 < _0x1dd15a[_0x143c87(484)]; _0x1b8445++) {
    const _0x7e17aa = _0x1103c1[_0x143c87(494)][_0x143c87(476)][_0x143c87(491)](_0x1103c1), _0x16a5b0 = _0x1dd15a[_0x1b8445], _0x2fdd7d = _0x2709c9[_0x16a5b0] || _0x7e17aa;
    _0x7e17aa[_0x143c87(496)] = _0x1103c1[_0x143c87(491)](_0x1103c1), _0x7e17aa[_0x143c87(485)] = _0x2fdd7d[_0x143c87(485)]["bind"](_0x2fdd7d), _0x2709c9[_0x16a5b0] = _0x7e17aa;
  }
});
_0x4c5e89();
const SVG_ARROW = _0x5e0cf2(486);
function _0x4877(_0x195859, _0x14f89f) {
  const _0x380937 = _0x30b1();
  return _0x4877 = function(_0x4c5e892, _0x1103c12) {
    _0x4c5e892 = _0x4c5e892 - 471;
    let _0x3fd1ed = _0x380937[_0x4c5e892];
    return _0x3fd1ed;
  }, _0x4877(_0x195859, _0x14f89f);
}
function getSvgArrowData() {
  const _0x1731c8 = _0x5e0cf2, _0x80e408 = btoa(SVG_ARROW), _0x211f16 = _0x1731c8(489) + _0x80e408;
  return _0x211f16;
}
function TrackSpeedMarkers() {
  const trackSpeedPointsGeojson = useTrackSpeedPointsGeojson();
  if (!trackSpeedPointsGeojson.features.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: trackSpeedPointsGeojson.features.map((feature) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TrackSpeedMarker,
    {
      feature
    },
    `${feature.properties.trackId}-${feature.properties.segmentIndex}`
  )) });
}
function TrackSpeedMarker({ feature }) {
  const { speed, radius, trackId, segmentIndex } = feature.properties;
  const [longitude, latitude] = feature.geometry.coordinates;
  const { useImperialUnits } = useSettings();
  const speedValue = Math.round(convertSpeed(speed, useImperialUnits));
  const speedUnit = getSpeedUnit(useImperialUnits);
  const [r, g, b] = feature.properties.color;
  const bgColor = `rgb(${r}, ${g}, ${b})`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Marker,
    {
      longitude,
      latitude,
      style: {
        zIndex: 4
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "rounded-full relative ring-1 ring-foreground items-center justify-center leading-none p-0.5 opacity-80 cursor-crosshair",
          style: {
            backgroundColor: bgColor
          },
          title: `Track ${trackId.slice(0, 4)} - Speed: ${formatSpeed(speed, useImperialUnits)} - Radius: ${Math.round(radius)}m`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-black font-bold flex items-baseline justify-center leading-none", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: speedValue }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[0.5rem]", children: speedUnit })
          ] })
        }
      )
    }
  );
}
(function(_0x45688f, _0x4ee530) {
  const _0x36ab5f = _0x2205, _0xc5a882 = _0x45688f();
  while (!![]) {
    try {
      const _0x36d9d3 = parseInt(_0x36ab5f(359)) / 1 * (parseInt(_0x36ab5f(379)) / 2) + parseInt(_0x36ab5f(381)) / 3 + -parseInt(_0x36ab5f(367)) / 4 + -parseInt(_0x36ab5f(363)) / 5 + -parseInt(_0x36ab5f(348)) / 6 * (parseInt(_0x36ab5f(364)) / 7) + parseInt(_0x36ab5f(380)) / 8 * (parseInt(_0x36ab5f(349)) / 9) + parseInt(_0x36ab5f(374)) / 10 * (parseInt(_0x36ab5f(368)) / 11);
      if (_0x36d9d3 === _0x4ee530) break;
      else _0xc5a882["push"](_0xc5a882["shift"]());
    } catch (_0x3b8fa4) {
      _0xc5a882["push"](_0xc5a882["shift"]());
    }
  }
})(_0x45be, 778618);
function _0x2205(_0x23d311, _0x151c9c) {
  const _0x36ba04 = _0x45be();
  return _0x2205 = function(_0x4864c32, _0xa9d6572) {
    _0x4864c32 = _0x4864c32 - 348;
    let _0xa7a373 = _0x36ba04[_0x4864c32];
    return _0xa7a373;
  }, _0x2205(_0x23d311, _0x151c9c);
}
const _0xa9d657 = /* @__PURE__ */ (function() {
  let _0x3ffe05 = !![];
  return function(_0x694403, _0x2028a2) {
    const _0x4d4009 = _0x3ffe05 ? function() {
      const _0x2f49fe = _0x2205;
      if (_0x2028a2) {
        const _0x116634 = _0x2028a2[_0x2f49fe(354)](_0x694403, arguments);
        return _0x2028a2 = null, _0x116634;
      }
    } : function() {
    };
    return _0x3ffe05 = ![], _0x4d4009;
  };
})(), _0x4864c3 = _0xa9d657(void 0, function() {
  const _0x75e242 = _0x2205;
  let _0x5ed04d;
  try {
    const _0x224011 = Function(_0x75e242(377) + _0x75e242(361) + ");");
    _0x5ed04d = _0x224011();
  } catch (_0x279776) {
    _0x5ed04d = window;
  }
  const _0x34c977 = _0x5ed04d["console"] = _0x5ed04d[_0x75e242(369)] || {}, _0x23a580 = [_0x75e242(376), _0x75e242(357), "info", "error", "exception", "table", _0x75e242(355)];
  for (let _0x430775 = 0; _0x430775 < _0x23a580["length"]; _0x430775++) {
    const _0x4710ee = _0xa9d657[_0x75e242(375)][_0x75e242(352)][_0x75e242(371)](_0xa9d657), _0x352137 = _0x23a580[_0x430775], _0xc4ea7c = _0x34c977[_0x352137] || _0x4710ee;
    _0x4710ee[_0x75e242(373)] = _0xa9d657[_0x75e242(371)](_0xa9d657), _0x4710ee[_0x75e242(372)] = _0xc4ea7c[_0x75e242(372)][_0x75e242(371)](_0xc4ea7c), _0x34c977[_0x352137] = _0x4710ee;
  }
});
_0x4864c3();
function _0x45be() {
  const _0x4cc644 = ["constructor", "log", "return (function() ", "trains", "4EPTCbi", "7171928aDpzsB", "2285853UoaGeg", "12ZewOwm", "9oOLGjt", "easeTo", "getState", "prototype", "find", "apply", "trace", "coords", "warn", "originalEvent", "59771lTpOPu", "windows", '{}.constructor("return this")( )', "dragstart", "3359670rBrPZq", "1499246lwRjWB", "current", "off", "107236GGZyXx", "11NPEuwe", "console", "length", "bind", "toString", "__proto__", "1277330ggEgcg"];
  _0x45be = function() {
    return _0x4cc644;
  };
  return _0x45be();
}
function useFollowTrain() {
  const { followingTrainId: _0x16759a, setFollowingTrainId: _0x2782ea } = useUi(), { current: _0x11101f } = useMap(), _0x4cb738 = reactExports.useRef(![]), _0x22d4b4 = reactExports.useRef(null), _0x3bd0e8 = () => {
    const _0x162b97 = _0x2205;
    if (!_0x16759a) return null;
    const _0x466057 = useMainStore[_0x162b97(351)](), _0x5d34ad = _0x466057[_0x162b97(378)][_0x162b97(353)]((_0x46573c) => _0x46573c["id"] === _0x16759a), _0x53f483 = _0x5d34ad?.[_0x162b97(360)]["train"][_0x162b97(356)];
    return _0x53f483 && _0x53f483[_0x162b97(370)] > 0 ? _0x53f483[0] : null;
  };
  reactExports.useEffect(() => {
    const _0x26197b = _0x2205;
    if (!_0x11101f || !_0x16759a) return;
    const _0xd3e203 = (_0x332fba) => {
      const _0x64725d = _0x2205;
      _0x332fba[_0x64725d(358)] && _0x4cb738["current"] && _0x2782ea(null);
    };
    return _0x11101f["on"](_0x26197b(362), _0xd3e203), () => {
      const _0x96d8e3 = _0x26197b;
      _0x11101f[_0x96d8e3(366)](_0x96d8e3(362), _0xd3e203);
    };
  }, [_0x11101f, _0x16759a, _0x2782ea]), reactExports.useEffect(() => {
    const _0x1884eb = _0x2205;
    if (!_0x16759a || !_0x11101f) {
      _0x4cb738[_0x1884eb(365)] = ![];
      _0x22d4b4[_0x1884eb(365)] !== null && (cancelAnimationFrame(_0x22d4b4["current"]), _0x22d4b4["current"] = null);
      return;
    }
    _0x4cb738[_0x1884eb(365)] = !![];
    let _0x4821fc = null;
    const _0x4c7986 = () => {
      const _0x54546b = _0x1884eb, _0xc0cb2 = _0x3bd0e8();
      if (_0xc0cb2) {
        const [_0x3e825f, _0x253fd1] = _0xc0cb2;
        (!_0x4821fc || _0x4821fc[0] !== _0x3e825f || _0x4821fc[1] !== _0x253fd1) && (_0x4821fc = [_0x3e825f, _0x253fd1], _0x11101f[_0x54546b(350)]({ "center": [_0x3e825f, _0x253fd1], "duration": 100 }));
      }
      _0x4cb738[_0x54546b(365)] && (_0x22d4b4["current"] = requestAnimationFrame(_0x4c7986));
    };
    return _0x22d4b4[_0x1884eb(365)] = requestAnimationFrame(_0x4c7986), () => {
      _0x22d4b4["current"] !== null && (cancelAnimationFrame(_0x22d4b4["current"]), _0x22d4b4["current"] = null);
    };
  }, [_0x16759a, _0x11101f]);
}
function TrainFollower() {
  useFollowTrain();
  return null;
}
(function(_0x4f17bb, _0x368d3e) {
  const _0x148d2f = _0x1604, _0x2c4edb = _0x4f17bb();
  while (!![]) {
    try {
      const _0xa91df9 = -parseInt(_0x148d2f(215)) / 1 + -parseInt(_0x148d2f(224)) / 2 + parseInt(_0x148d2f(227)) / 3 * (parseInt(_0x148d2f(205)) / 4) + -parseInt(_0x148d2f(217)) / 5 + -parseInt(_0x148d2f(216)) / 6 + parseInt(_0x148d2f(228)) / 7 * (parseInt(_0x148d2f(218)) / 8) + -parseInt(_0x148d2f(223)) / 9 * (-parseInt(_0x148d2f(230)) / 10);
      if (_0xa91df9 === _0x368d3e) break;
      else _0x2c4edb["push"](_0x2c4edb["shift"]());
    } catch (_0x50e6a1) {
      _0x2c4edb["push"](_0x2c4edb["shift"]());
    }
  }
})(_0x7e55, 540047);
const _0x58fd1f = /* @__PURE__ */ (function() {
  let _0x47f47e = !![];
  return function(_0xa5157e, _0x5bbab7) {
    const _0x569aa0 = _0x47f47e ? function() {
      const _0x4adf39 = _0x1604;
      if (_0x5bbab7) {
        const _0x73598f = _0x5bbab7[_0x4adf39(212)](_0xa5157e, arguments);
        return _0x5bbab7 = null, _0x73598f;
      }
    } : function() {
    };
    return _0x47f47e = ![], _0x569aa0;
  };
})(), _0x574380 = _0x58fd1f(void 0, function() {
  const _0x4036f8 = _0x1604, _0x350708 = function() {
    const _0x367a21 = _0x1604;
    let _0x2f7c1f;
    try {
      _0x2f7c1f = Function(_0x367a21(222) + _0x367a21(208) + ");")();
    } catch (_0xcace0e) {
      _0x2f7c1f = window;
    }
    return _0x2f7c1f;
  }, _0x2b20b3 = _0x350708(), _0x11939a = _0x2b20b3[_0x4036f8(210)] = _0x2b20b3[_0x4036f8(210)] || {}, _0xd57d77 = ["log", _0x4036f8(214), _0x4036f8(203), _0x4036f8(220), _0x4036f8(207), _0x4036f8(231), _0x4036f8(209)];
  for (let _0x42d3b4 = 0; _0x42d3b4 < _0xd57d77[_0x4036f8(221)]; _0x42d3b4++) {
    const _0x4d70e7 = _0x58fd1f["constructor"]["prototype"][_0x4036f8(236)](_0x58fd1f), _0xc0d3e1 = _0xd57d77[_0x42d3b4], _0x427799 = _0x11939a[_0xc0d3e1] || _0x4d70e7;
    _0x4d70e7[_0x4036f8(204)] = _0x58fd1f["bind"](_0x58fd1f), _0x4d70e7["toString"] = _0x427799[_0x4036f8(206)]["bind"](_0x427799), _0x11939a[_0xc0d3e1] = _0x4d70e7;
  }
});
_0x574380();
function _0x1604(_0x73e449, _0x9aef7f) {
  const _0x30a884 = _0x7e55();
  return _0x1604 = function(_0x5743802, _0x58fd1f2) {
    _0x5743802 = _0x5743802 - 203;
    let _0x5021e9 = _0x30a884[_0x5743802];
    return _0x5021e9;
  }, _0x1604(_0x73e449, _0x9aef7f);
}
function getTrackCoords({ startBearing: _0x4b5236, endBearing: _0x454a52, startCoords: _0x309dcb, endCoords: _0xe2219e }) {
  const _0x16be8d = _0x1604;
  if (_0x24b10a[_0x16be8d(226)](_0x309dcb, _0xe2219e, { "units": _0x16be8d(229) }) < 1) return [_0x309dcb, _0xe2219e];
  const _0xc505a0 = _0x24b10a[_0x16be8d(235)](_0x24b10a[_0x16be8d(234)](_0x309dcb), _0x24b10a[_0x16be8d(234)](_0xe2219e));
  if (!_0x4b5236 && !_0x454a52) return [_0x309dcb, _0xe2219e];
  const _0x5dfac3 = calculateRequiredPoints(_0x4b5236, _0x454a52, _0xc505a0);
  if (!_0x4b5236 && _0x454a52) {
    const _0x4ec9ea = _0x24b10a[_0x16be8d(226)](_0x309dcb, _0xe2219e, { "units": "meters" }) / 2, _0x5bae29 = _0x24b10a[_0x16be8d(225)](_0xe2219e, _0x4ec9ea, reverseBearing(_0x454a52), { "units": _0x16be8d(229) })["geometry"][_0x16be8d(211)], _0x85c00d = [];
    for (let _0x2beb58 = 0; _0x2beb58 <= _0x5dfac3; _0x2beb58++) {
      const _0x4554d1 = _0x2beb58 / _0x5dfac3, _0x360e87 = 1 - _0x4554d1, _0x2dfb32 = _0x360e87 * _0x360e87, _0xe3a908 = _0x4554d1 * _0x4554d1, _0xe135d8 = _0x2dfb32 * _0x309dcb[0] + 2 * _0x360e87 * _0x4554d1 * _0x5bae29[0] + _0xe3a908 * _0xe2219e[0], _0x421d10 = _0x2dfb32 * _0x309dcb[1] + 2 * _0x360e87 * _0x4554d1 * _0x5bae29[1] + _0xe3a908 * _0xe2219e[1];
      _0x85c00d["push"]([_0xe135d8, _0x421d10]);
    }
    return _0x85c00d;
  }
  if (_0x4b5236 && !_0x454a52) {
    const _0x3149b0 = distance$1(_0x309dcb, _0xe2219e, { "units": _0x16be8d(229) }) / 2, _0x52b090 = _0x24b10a[_0x16be8d(225)](_0x309dcb, _0x3149b0, _0x4b5236, { "units": _0x16be8d(229) })[_0x16be8d(213)]["coordinates"], _0x2d22cc = [];
    for (let _0x29a51d = 0; _0x29a51d <= _0x5dfac3; _0x29a51d++) {
      const _0x567362 = _0x29a51d / _0x5dfac3, _0x3a6ffa = 1 - _0x567362, _0x56ef25 = _0x3a6ffa * _0x3a6ffa, _0x2bde85 = _0x567362 * _0x567362, _0x46eac0 = _0x56ef25 * _0x309dcb[0] + 2 * _0x3a6ffa * _0x567362 * _0x52b090[0] + _0x2bde85 * _0xe2219e[0], _0x10f352 = _0x56ef25 * _0x309dcb[1] + 2 * _0x3a6ffa * _0x567362 * _0x52b090[1] + _0x2bde85 * _0xe2219e[1];
      _0x2d22cc["push"]([_0x46eac0, _0x10f352]);
    }
    return _0x2d22cc;
  }
  if (_0x4b5236 && _0x454a52) {
    const _0x2d0aa9 = _0x24b10a[_0x16be8d(226)](_0x309dcb, _0xe2219e, { "units": "meters" }) / 2, _0x1bf9db = _0x24b10a[_0x16be8d(225)](_0x309dcb, _0x2d0aa9, _0x4b5236, { "units": _0x16be8d(229) })[_0x16be8d(213)]["coordinates"], _0x4934e2 = _0x24b10a[_0x16be8d(225)](_0xe2219e, _0x2d0aa9, reverseBearing(_0x454a52), { "units": _0x16be8d(229) })["geometry"][_0x16be8d(211)], _0x41d032 = [];
    for (let _0x1e4aa2 = 0; _0x1e4aa2 <= _0x5dfac3; _0x1e4aa2++) {
      const _0x435503 = _0x1e4aa2 / _0x5dfac3, _0x23f906 = 1 - _0x435503, _0x28c060 = _0x23f906 * _0x23f906, _0x1e1299 = _0x28c060 * _0x23f906, _0x50fc5c = _0x435503 * _0x435503, _0x4aa6d7 = _0x50fc5c * _0x435503, _0x420cad = _0x1e1299 * _0x309dcb[0] + 3 * _0x28c060 * _0x435503 * _0x1bf9db[0] + 3 * _0x23f906 * _0x50fc5c * _0x4934e2[0] + _0x4aa6d7 * _0xe2219e[0], _0x3c71b3 = _0x1e1299 * _0x309dcb[1] + 3 * _0x28c060 * _0x435503 * _0x1bf9db[1] + 3 * _0x23f906 * _0x50fc5c * _0x4934e2[1] + _0x4aa6d7 * _0xe2219e[1];
      _0x41d032["push"]([_0x420cad, _0x3c71b3]);
    }
    return _0x41d032;
  }
  throw new Error(_0x16be8d(233));
}
function calculateRequiredPoints(_0x51581a, _0x5e5992, _0x3eda16) {
  const _0x3b5376 = _0x1604, _0xaff6ce = _0x51581a ? _0x134c1a[_0x3b5376(232)](_0x51581a) : _0x3eda16, _0x2ed5ce = _0x5e5992 ? _0x134c1a[_0x3b5376(232)](_0x5e5992) : _0x3eda16;
  let _0x469646 = Math["abs"](_0x2ed5ce - _0xaff6ce);
  _0x469646 > 180 && (_0x469646 = 360 - _0x469646);
  let _0x2b21d7 = 3;
  return _0x469646 <= 30 ? _0x2b21d7 += Math[_0x3b5376(219)](_0x469646 / 10) * 2 : (_0x2b21d7 += 6, _0x2b21d7 += Math[_0x3b5376(219)]((_0x469646 - 30) / 10) * 3), _0x51581a && _0x5e5992 && (_0x2b21d7 += 20), _0x2b21d7;
}
function _0x7e55() {
  const _0x38686f = ["bind", "info", "__proto__", "525728mNwQiL", "toString", "exception", '{}.constructor("return this")( )', "trace", "console", "coordinates", "apply", "geometry", "warn", "580016qibTdV", "3486yLYSWQ", "5219530qpdIgl", "3981736qxjNaY", "ceil", "error", "length", "return (function() ", "805995REZPvE", "660230AjOdNl", "destination", "distance", "24qTpSSy", "14yJiUPC", "meters", "50xcPNSN", "table", "normalizeBearing", "Get track coords failed because this case was not handled. This should never happen.", "point", "bearing"];
  _0x7e55 = function() {
    return _0x38686f;
  };
  return _0x7e55();
}
(function(_0x3d151a, _0xc706f1) {
  const _0x3e5cd3 = _0xe2e1, _0xd8ead2 = _0x3d151a();
  while (!![]) {
    try {
      const _0x4debb3 = parseInt(_0x3e5cd3(213)) / 1 * (-parseInt(_0x3e5cd3(207)) / 2) + -parseInt(_0x3e5cd3(175)) / 3 * (-parseInt(_0x3e5cd3(178)) / 4) + -parseInt(_0x3e5cd3(205)) / 5 * (-parseInt(_0x3e5cd3(165)) / 6) + -parseInt(_0x3e5cd3(169)) / 7 * (parseInt(_0x3e5cd3(162)) / 8) + -parseInt(_0x3e5cd3(186)) / 9 * (-parseInt(_0x3e5cd3(215)) / 10) + parseInt(_0x3e5cd3(195)) / 11 + -parseInt(_0x3e5cd3(211)) / 12;
      if (_0x4debb3 === _0xc706f1) break;
      else _0xd8ead2["push"](_0xd8ead2["shift"]());
    } catch (_0x247bf2) {
      _0xd8ead2["push"](_0xd8ead2["shift"]());
    }
  }
})(_0x76af, 136160);
const _0x56aa42 = /* @__PURE__ */ (function() {
  let _0x2b112c = !![];
  return function(_0x305850, _0x3219fa) {
    const _0xbccdaa = _0x2b112c ? function() {
      const _0x126f6b = _0xe2e1;
      if (_0x3219fa) {
        const _0x137301 = _0x3219fa[_0x126f6b(173)](_0x305850, arguments);
        return _0x3219fa = null, _0x137301;
      }
    } : function() {
    };
    return _0x2b112c = ![], _0xbccdaa;
  };
})(), _0x45f12a = _0x56aa42(void 0, function() {
  const _0x3151ff = _0xe2e1, _0x4be499 = function() {
    const _0x3f8753 = _0xe2e1;
    let _0x5e98fe;
    try {
      _0x5e98fe = Function(_0x3f8753(200) + _0x3f8753(199) + ");")();
    } catch (_0x19b748) {
      _0x5e98fe = window;
    }
    return _0x5e98fe;
  }, _0x5eefb6 = _0x4be499(), _0x1f66c0 = _0x5eefb6["console"] = _0x5eefb6[_0x3151ff(216)] || {}, _0x2758c5 = [_0x3151ff(174), _0x3151ff(182), _0x3151ff(187), _0x3151ff(181), "exception", _0x3151ff(158), "trace"];
  for (let _0x36df5d = 0; _0x36df5d < _0x2758c5[_0x3151ff(218)]; _0x36df5d++) {
    const _0x400a34 = _0x56aa42["constructor"]["prototype"][_0x3151ff(160)](_0x56aa42), _0x135598 = _0x2758c5[_0x36df5d], _0xc0ace2 = _0x1f66c0[_0x135598] || _0x400a34;
    _0x400a34[_0x3151ff(166)] = _0x56aa42[_0x3151ff(160)](_0x56aa42), _0x400a34[_0x3151ff(194)] = _0xc0ace2["toString"][_0x3151ff(160)](_0xc0ace2), _0x1f66c0[_0x135598] = _0x400a34;
  }
});
_0x45f12a();
function _0x76af() {
  const _0x59ca71 = ["point", "secondTrack", "firstTrack", "coordinates", "trackLanesType", "toString", "536294MoJUjS", "preview-center", "lineString", "push", '{}.constructor("return this")( )', "return (function() ", "distance", "endElevation", "@@2", "geometry", "15zChVQK", "getLineLength", "8092EnnxnV", "Failed to split track at point", "slice", "flatMap", "146952etdZtE", "first", "13kccIfr", "centroid", "10PZEVFF", "console", "filter", "length", "preview", "table", "Failed to split centerline", "bind", "meters", "8SipBcq", "Can't split the track because the split point is at the start or end of the track", "centerLine", "7818VovRyf", "__proto__", "includes", "temp-centerline", "1047361DWPUgI", "startElevation", "trackType", "coords", "apply", "log", "1137XCkTOW", "properties", "@@1", "1760jwWEuJ", "trackIds", "getDistanceBetweenPoints", "error", "warn", "second", "roundCoordinates", "firstGroupTrackIds", "1180836jsvEkU", "info", "Track is too short to split"];
  _0x76af = function() {
    return _0x59ca71;
  };
  return _0x76af();
}
function splitTgAtPoint({ trackGroupToSplit: _0x172352, trackGroups: _0xea103, tracks: _0x32968a, splitPoint: _0x55c445, splitTgs = !![] }) {
  const _0x286ec9 = _0xe2e1, _0x14d521 = { "id": _0x286ec9(168), "buildType": _0x286ec9(157), "displayType": _0x286ec9(196), "coords": _0x172352[_0x286ec9(164)], "type": null, "reversable": ![], "interactable": !![], "length": getLineLength(_0x172352[_0x286ec9(164)]), "startElevation": 0, "endElevation": 0 }, _0x31e781 = splitTrackAtPoint(_0x14d521, _0x55c445);
  if (!_0x31e781) throw new Error(_0x286ec9(159));
  const _0x11b943 = _0x32968a[_0x286ec9(217)]((_0x5dcdc8) => _0x172352[_0x286ec9(179)][_0x286ec9(167)](_0x5dcdc8["id"])), _0x4720e5 = _0x11b943["map"]((_0x113316) => {
    const _0x2e0f27 = _0x286ec9, _0x33777f = splitTrackAtPoint(_0x113316, _0x55c445);
    return { "original": _0x113316["id"], "first": _0x33777f[_0x2e0f27(191)], "second": _0x33777f[_0x2e0f27(190)] };
  });
  if (!splitTgs) {
    const _0x3acc3e = _0x4720e5[_0x286ec9(210)]((_0x491db4) => [_0x491db4[_0x286ec9(212)]["id"], _0x491db4[_0x286ec9(183)]["id"]]), _0x4a1fc0 = { ..._0x172352, "trackIds": _0x3acc3e }, _0x5f255c = _0xea103["filter"]((_0x253309) => _0x253309["id"] !== _0x172352["id"]);
    return _0x5f255c[_0x286ec9(198)](_0x4a1fc0), { "newTracks": _0x4720e5[_0x286ec9(210)]((_0x4a6e14) => [_0x4a6e14[_0x286ec9(212)], _0x4a6e14[_0x286ec9(183)]]), "updatedTrackGroups": _0x5f255c, "newTrackGroups": _0x4a1fc0 };
  }
  const _0x306b9e = _0x31e781[_0x286ec9(191)][_0x286ec9(172)], _0x16a438 = _0x31e781[_0x286ec9(190)][_0x286ec9(172)], _0x16361b = assignTracksToTrackGroups({ "tracksToAssign": _0x4720e5[_0x286ec9(210)]((_0x39bca5) => [_0x39bca5[_0x286ec9(212)], _0x39bca5[_0x286ec9(183)]]), "firstGroupCoords": _0x306b9e, "secondGroupCoords": _0x16a438 }), _0x111628 = { "id": _0x172352["id"] + _0x286ec9(177), "trackIds": _0x16361b[_0x286ec9(185)], "trackLanesType": _0x172352[_0x286ec9(193)], "centerLine": _0x306b9e, "type": null, "trackType": _0x172352[_0x286ec9(171)] }, _0x1a8c4f = { "id": _0x172352["id"] + _0x286ec9(203), "trackIds": _0x16361b["secondGroupTrackIds"], "trackLanesType": _0x172352[_0x286ec9(193)], "centerLine": _0x16a438, "type": null, "trackType": _0x172352[_0x286ec9(171)] }, _0x7630e7 = _0x32968a[_0x286ec9(217)]((_0x2d4766) => !_0x172352["trackIds"]["includes"](_0x2d4766["id"]));
  _0x7630e7[_0x286ec9(198)](..._0x4720e5[_0x286ec9(210)]((_0x25a567) => [_0x25a567[_0x286ec9(212)], _0x25a567[_0x286ec9(183)]]));
  const _0x20d334 = _0xea103[_0x286ec9(217)]((_0x35acfe) => _0x35acfe["id"] !== _0x172352["id"]);
  return _0x20d334["push"](_0x111628, _0x1a8c4f), { "newTracks": _0x7630e7, "updatedTrackGroups": _0x20d334, "newTrackGroups": [_0x111628, _0x1a8c4f] };
}
function assignTracksToTrackGroups({ tracksToAssign: _0x1525fc, firstGroupCoords: _0x352934, secondGroupCoords: _0x3397c0 }) {
  const _0x434a64 = _0xe2e1, _0x3b5422 = [], _0x3e60a8 = [], _0x3e1585 = centroid(lineString(_0x352934)), _0x3c8f5b = _0x24b10a[_0x434a64(214)](_0x24b10a[_0x434a64(197)](_0x3397c0));
  for (const _0x40b204 of _0x1525fc) {
    const _0x37842c = _0x24b10a[_0x434a64(214)](_0x24b10a[_0x434a64(197)](_0x40b204[_0x434a64(172)])), _0x20cb3b = _0x24b10a[_0x434a64(201)](_0x37842c, _0x3e1585, { "units": _0x434a64(161) }), _0x27f01e = distance$1(_0x37842c, _0x3c8f5b, { "units": _0x434a64(161) });
    _0x20cb3b < _0x27f01e ? _0x3b5422[_0x434a64(198)](_0x40b204["id"]) : _0x3e60a8[_0x434a64(198)](_0x40b204["id"]);
  }
  return { "firstGroupTrackIds": _0x3b5422, "secondGroupTrackIds": _0x3e60a8 };
}
function _0xe2e1(_0x393515, _0x542878) {
  const _0x5f241d = _0x76af();
  return _0xe2e1 = function(_0x45f12a2, _0x56aa422) {
    _0x45f12a2 = _0x45f12a2 - 157;
    let _0x33e371 = _0x5f241d[_0x45f12a2];
    return _0x33e371;
  }, _0xe2e1(_0x393515, _0x542878);
}
function splitTrackAtPoint(_0x30a77b, _0x2050c1) {
  const _0x14cc88 = _0xe2e1;
  if (_0x30a77b[_0x14cc88(172)][_0x14cc88(218)] < 2) throw new Error(_0x14cc88(188));
  const _0x39550c = _0x30a77b["coords"][0], _0x16c3a9 = _0x30a77b[_0x14cc88(172)][_0x30a77b[_0x14cc88(172)][_0x14cc88(218)] - 1];
  if (_0x2050c1 === _0x39550c || _0x2050c1 === _0x16c3a9) throw new Error(_0x14cc88(163));
  const _0x8bcc70 = _0x24b10a[_0x14cc88(197)](_0x30a77b[_0x14cc88(172)]), _0x4bae60 = nearestPointOnLine(_0x8bcc70, _0x24b10a[_0x14cc88(189)](_0x2050c1)), _0x28a2cd = _0x4bae60[_0x14cc88(176)]["index"], _0x39954e = [_0x4bae60["geometry"][_0x14cc88(192)][0], _0x4bae60[_0x14cc88(204)][_0x14cc88(192)][1]], _0x58c8ad = _0x134c1a[_0x14cc88(206)](_0x30a77b[_0x14cc88(172)]);
  let _0x20e67a = 0;
  for (let _0x25f542 = 0; _0x25f542 < _0x28a2cd; _0x25f542++) {
    _0x20e67a += _0x134c1a[_0x14cc88(180)](_0x30a77b[_0x14cc88(172)][_0x25f542], _0x30a77b["coords"][_0x25f542 + 1]);
  }
  _0x28a2cd < _0x30a77b[_0x14cc88(172)]["length"] - 1 && (_0x20e67a += _0x134c1a[_0x14cc88(180)](_0x30a77b[_0x14cc88(172)][_0x28a2cd], _0x39954e));
  const _0x596755 = _0x58c8ad > 0 ? _0x20e67a / _0x58c8ad : 0.5, _0x161e33 = _0x30a77b["startElevation"] + (_0x30a77b[_0x14cc88(202)] - _0x30a77b[_0x14cc88(170)]) * _0x596755, _0x5d9d27 = [..._0x30a77b[_0x14cc88(172)][_0x14cc88(209)](0, _0x28a2cd + 1), _0x39954e], _0x540ce8 = [_0x39954e, ..._0x30a77b[_0x14cc88(172)][_0x14cc88(209)](_0x28a2cd + 1)];
  if (_0x5d9d27[_0x14cc88(218)] < 2 || _0x540ce8[_0x14cc88(218)] < 2) throw new Error(_0x14cc88(208));
  const _0x27f535 = roundCoordinates(_0x5d9d27), _0x32dcb8 = _0x134c1a[_0x14cc88(184)](_0x540ce8), _0x47a3c8 = { ..._0x30a77b, "id": _0x30a77b["id"] + _0x14cc88(177), "coords": _0x27f535, "length": _0x134c1a[_0x14cc88(206)](_0x27f535), "startElevation": _0x30a77b[_0x14cc88(170)], "endElevation": _0x161e33 }, _0x494893 = { ..._0x30a77b, "id": _0x30a77b["id"] + _0x14cc88(203), "coords": _0x32dcb8, "length": getLineLength(_0x32dcb8), "startElevation": _0x161e33, "endElevation": _0x30a77b["endElevation"] };
  return { "firstTrack": _0x47a3c8, "secondTrack": _0x494893 };
}
(function(_0x4be14c, _0x49cd85) {
  const _0x4d8339 = _0x2119, _0x3f60bd = _0x4be14c();
  while (!![]) {
    try {
      const _0x351aba = -parseInt(_0x4d8339(171)) / 1 * (-parseInt(_0x4d8339(169)) / 2) + parseInt(_0x4d8339(189)) / 3 + parseInt(_0x4d8339(176)) / 4 + -parseInt(_0x4d8339(181)) / 5 * (parseInt(_0x4d8339(175)) / 6) + parseInt(_0x4d8339(190)) / 7 + parseInt(_0x4d8339(191)) / 8 * (-parseInt(_0x4d8339(197)) / 9) + parseInt(_0x4d8339(185)) / 10 * (-parseInt(_0x4d8339(179)) / 11);
      if (_0x351aba === _0x49cd85) break;
      else _0x3f60bd["push"](_0x3f60bd["shift"]());
    } catch (_0x2d7c25) {
      _0x3f60bd["push"](_0x3f60bd["shift"]());
    }
  }
})(_0x36f3, 272737);
const _0x13ccca = /* @__PURE__ */ (function() {
  let _0x4b8de4 = !![];
  return function(_0x5548ae, _0x2e348d) {
    const _0x514fa7 = _0x4b8de4 ? function() {
      if (_0x2e348d) {
        const _0x132e45 = _0x2e348d["apply"](_0x5548ae, arguments);
        return _0x2e348d = null, _0x132e45;
      }
    } : function() {
    };
    return _0x4b8de4 = ![], _0x514fa7;
  };
})(), _0x3214c2 = _0x13ccca(void 0, function() {
  const _0x438e28 = _0x2119, _0x3d0765 = function() {
    const _0x16f67f = _0x2119;
    let _0x4ea342;
    try {
      _0x4ea342 = Function(_0x16f67f(170) + _0x16f67f(183) + ");")();
    } catch (_0x4bd168) {
      _0x4ea342 = window;
    }
    return _0x4ea342;
  }, _0x1092b0 = _0x3d0765(), _0x4e52cf = _0x1092b0[_0x438e28(192)] = _0x1092b0[_0x438e28(192)] || {}, _0x394e45 = [_0x438e28(180), _0x438e28(177), _0x438e28(194), _0x438e28(167), "exception", _0x438e28(168), _0x438e28(186)];
  for (let _0x42e528 = 0; _0x42e528 < _0x394e45[_0x438e28(173)]; _0x42e528++) {
    const _0x3ae4d0 = _0x13ccca[_0x438e28(187)][_0x438e28(195)][_0x438e28(178)](_0x13ccca), _0x16ba87 = _0x394e45[_0x42e528], _0x3cf8e8 = _0x4e52cf[_0x16ba87] || _0x3ae4d0;
    _0x3ae4d0[_0x438e28(196)] = _0x13ccca[_0x438e28(178)](_0x13ccca), _0x3ae4d0["toString"] = _0x3cf8e8[_0x438e28(193)][_0x438e28(178)](_0x3cf8e8), _0x4e52cf[_0x16ba87] = _0x3ae4d0;
  }
});
_0x3214c2();
function _0x2119(_0x4a800b, _0x1364e2) {
  const _0x4eaacc = _0x36f3();
  return _0x2119 = function(_0x3214c22, _0x13ccca2) {
    _0x3214c22 = _0x3214c22 - 167;
    let _0x378899 = _0x4eaacc[_0x3214c22];
    return _0x378899;
  }, _0x2119(_0x4a800b, _0x1364e2);
}

var allowForceBuild = false;

function forceBuildHandlerKeydown(e) {
  if (e.code === "KeyF") {
    allowForceBuild = true;
    window.removeEventListener("keydown", forceBuildHandlerKeydown);
  }
}

function forceBuildHandlerKeyup(e) {
  if (e.code === "KeyF") {
    allowForceBuild = false;
    window.removeEventListener("keyup", forceBuildHandlerKeyup);
  }
}
function forceBuild() {
  window.addEventListener("keydown", forceBuildHandlerKeydown);
  window.addEventListener("keyup", forceBuildHandlerKeyup);
}

function validateTrackCurvature(_0x324a5d) {
  forceBuild()
  if (allowForceBuild) return { "isValid": !![] };
  const _0x1a4f3b = _0x2119;
  if (_0x324a5d[_0x1a4f3b(173)] < 3) return { "isValid": !![] };
  for (let _0x1183a3 = 0; _0x1183a3 < _0x324a5d[_0x1a4f3b(173)] - 2; _0x1183a3++) {
    const _0x12bbd0 = _0x324a5d[_0x1183a3], _0x1477e7 = _0x324a5d[_0x1183a3 + 1], _0x3a7f37 = _0x324a5d[_0x1183a3 + 2], _0x676f60 = calculateTurnRadius(_0x12bbd0, _0x1477e7, _0x3a7f37);
    if (_0x676f60 !== null && _0x676f60 < RULES[_0x1a4f3b(174)]) return { "isValid": ![], "errorMessage": "Track curve is too sharp (radius: " + _0x676f60[_0x1a4f3b(184)](0) + _0x1a4f3b(199) + RULES[_0x1a4f3b(174)] + "m." };
  }
  return { "isValid": !![] };
}
function calculateTurnRadius(_0x5603b1, _0x328c5f, _0xe8872) {
  const _0x26ac1f = _0x2119, _0x1f0903 = distance$1(_0x5603b1, _0x328c5f, { "units": _0x26ac1f(182) }), _0xff5525 = distance$1(_0x328c5f, _0xe8872, { "units": _0x26ac1f(182) });
  if (_0x1f0903 < 1 || _0xff5525 < 1) return null;
  const _0x16cd59 = _0x134c1a[_0x26ac1f(172)](_0x5603b1, _0x328c5f), _0x48d517 = getBearing(_0x328c5f, _0xe8872);
  let _0x38532e = Math["abs"](_0x48d517 - _0x16cd59);
  _0x38532e > 180 && (_0x38532e = 360 - _0x38532e);
  if (_0x38532e < 1) return null;
  const _0x58d060 = _0x24b10a[_0x26ac1f(188)](_0x5603b1, _0xe8872, { "units": _0x26ac1f(182) }), _0x176814 = _0x58d060 / (2 * Math[_0x26ac1f(198)](_0x38532e * Math["PI"] / 360));
  return Math["abs"](_0x176814);
}
function _0x36f3() {
  const _0x3b736d = ["10497WydVia", "getBearing", "length", "MIN_TURN_RADIUS", "33762mcdVGW", "901728VPuQhn", "warn", "bind", "121zqzpbH", "log", "10jwHlSQ", "meters", '{}.constructor("return this")( )', "toFixed", "402880VNoPYC", "trace", "constructor", "distance", "359871jsxecP", "3295187SagSOh", "188608rAoqOK", "console", "toString", "info", "prototype", "__proto__", "54SOVgBO", "sin", "m). Minimum radius is ", "error", "table", "10FOBNsg", "return (function() "];
  _0x36f3 = function() {
    return _0x3b736d;
  };
  return _0x36f3();
}
(function(_0x5c9b9e, _0xb5f0dc) {
  const _0x2e789d = _0x5d59, _0x9b18ab = _0x5c9b9e();
  while (!![]) {
    try {
      const _0x56d5f3 = -parseInt(_0x2e789d(477)) / 1 + parseInt(_0x2e789d(506)) / 2 * (parseInt(_0x2e789d(474)) / 3) + parseInt(_0x2e789d(439)) / 4 * (-parseInt(_0x2e789d(480)) / 5) + -parseInt(_0x2e789d(476)) / 6 * (-parseInt(_0x2e789d(451)) / 7) + parseInt(_0x2e789d(454)) / 8 * (-parseInt(_0x2e789d(499)) / 9) + parseInt(_0x2e789d(489)) / 10 + -parseInt(_0x2e789d(447)) / 11 * (-parseInt(_0x2e789d(467)) / 12);
      if (_0x56d5f3 === _0xb5f0dc) break;
      else _0x9b18ab["push"](_0x9b18ab["shift"]());
    } catch (_0x47bfdf) {
      _0x9b18ab["push"](_0x9b18ab["shift"]());
    }
  }
})(_0x3e6a, 188255);
function _0x5d59(_0x586171, _0x339b4c) {
  const _0x1119fa = _0x3e6a();
  return _0x5d59 = function(_0x48a49b2, _0x5a28db2) {
    _0x48a49b2 = _0x48a49b2 - 437;
    let _0x579568 = _0x1119fa[_0x48a49b2];
    return _0x579568;
  }, _0x5d59(_0x586171, _0x339b4c);
}
const _0x5a28db = /* @__PURE__ */ (function() {
  let _0x28c27c = !![];
  return function(_0x4b6b3f, _0x53c092) {
    const _0x5618fd = _0x28c27c ? function() {
      if (_0x53c092) {
        const _0x1543d8 = _0x53c092["apply"](_0x4b6b3f, arguments);
        return _0x53c092 = null, _0x1543d8;
      }
    } : function() {
    };
    return _0x28c27c = ![], _0x5618fd;
  };
})(), _0x48a49b = _0x5a28db(void 0, function() {
  const _0x5ac866 = _0x5d59, _0x2fc11c = function() {
    const _0x5dca57 = _0x5d59;
    let _0x3fc93e;
    try {
      _0x3fc93e = Function(_0x5dca57(448) + _0x5dca57(490) + ");")();
    } catch (_0x23fec7) {
      _0x3fc93e = window;
    }
    return _0x3fc93e;
  }, _0x192fc9 = _0x2fc11c(), _0x143c99 = _0x192fc9[_0x5ac866(502)] = _0x192fc9[_0x5ac866(502)] || {}, _0x16b9ae = [_0x5ac866(486), "warn", "info", _0x5ac866(500), _0x5ac866(505), _0x5ac866(453), "trace"];
  for (let _0x19fec0 = 0; _0x19fec0 < _0x16b9ae["length"]; _0x19fec0++) {
    const _0xf791ec = _0x5a28db[_0x5ac866(457)][_0x5ac866(493)][_0x5ac866(504)](_0x5a28db), _0x3859e5 = _0x16b9ae[_0x19fec0], _0x414286 = _0x143c99[_0x3859e5] || _0xf791ec;
    _0xf791ec["__proto__"] = _0x5a28db["bind"](_0x5a28db), _0xf791ec["toString"] = _0x414286[_0x5ac866(445)][_0x5ac866(504)](_0x414286), _0x143c99[_0x3859e5] = _0xf791ec;
  }
});
_0x48a49b();
function _0x3e6a() {
  const _0x31720c = ["parallel", "errorMessage", "toString", "some", "3095741LnwVTf", "return (function() ", "quad", "Could not find one of the straight tracks", "7KqGYam", "m). Minimum length required: ", "table", "8ahlOfP", "reverseBearing", "blueprint", "constructor", "features", "getLineMidpoint", "scissors-crossover", "lineString", "isValid", "endElevation", "type", "Cannot create scissors crossover on a station", "along", "12lhDJzq", "geometry", "trackLanesType", "meters", "all", "SCISSORS_CROSSOVER_LENGTH", "updatedTrackGroups", "66fUQKFi", "coordinates", "340320hXaRhU", "209655Wwoign", "Could not find 2 scissor tracks", "map", "5Nqyjsv", "getLineLength", "Could not find one of the tracks in the parallel group", "station", "find", "round", "log", "Could not get coords for crossover 1", "trackIds", "1512060gFHChV", '{}.constructor("return this")( )', "length", "trackType", "prototype", "lineIntersect", "Could not get coords for crossover 2", "filter", "newTracks", "getBearing", "1435221iofQCN", "error", "L_CHECK", "console", "updatedTrackGroup", "bind", "exception", "6934rWKSzK", "roundCoordinates", "getItem", "Invalid track configuration for scissors crossover", "startElevation", "33008eWBasj", "newTrackGroups", "centerLine", "coords"];
  _0x3e6a = function() {
    return _0x31720c;
  };
  return _0x3e6a();
}
function createScissorsCrossover({ clickedTrackGroup: _0x352c60, tracks: _0x2966ba, trackGroups: _0x4aea38, nodeCoords: _0x5420cf }) {
  const _0x1db3b5 = _0x5d59;
  if (_0x352c60[_0x1db3b5(464)] === _0x1db3b5(460)) throw new Error("A crossover already exists at this location");
  const _0xca9940 = lineString(_0x352c60[_0x1db3b5(441)]), _0x2119c1 = _0x352c60[_0x1db3b5(441)][0] === _0x5420cf, _0x27499e = _0x134c1a[_0x1db3b5(481)](_0x352c60[_0x1db3b5(441)]);
  if (_0x27499e < RULES[_0x1db3b5(472)]) throw new Error("Track is too short (" + Math[_0x1db3b5(485)](_0x27499e) + _0x1db3b5(452) + RULES["SCISSORS_CROSSOVER_LENGTH"] + "m");
  const _0x3bc621 = _0x2119c1 ? _0x24b10a[_0x1db3b5(466)](_0xca9940, RULES[_0x1db3b5(472)], { "units": _0x1db3b5(470) }) : _0x24b10a[_0x1db3b5(466)](_0xca9940, _0x27499e - RULES[_0x1db3b5(472)], { "units": _0x1db3b5(470) }), _0x499f5a = splitTgAtPoint({ "trackGroupToSplit": _0x352c60, "trackGroups": _0x4aea38, "tracks": _0x2966ba, "splitPoint": _0x3bc621[_0x1db3b5(468)][_0x1db3b5(475)] }), _0x35b8c7 = _0x499f5a[_0x1db3b5(440)][_0x1db3b5(484)]((_0x212a6c) => _0x212a6c[_0x1db3b5(441)][_0x1db3b5(446)]((_0x5ee0a5) => _0x5ee0a5[0] === _0x5420cf[0] && _0x5ee0a5[1] === _0x5420cf[1]));
  if (!_0x35b8c7) throw new Error("Could not find track group to add crossover to");
  const _0x55aa42 = makeNewScissorsCrossover({ "trackGroup": _0x35b8c7, "tracks": _0x499f5a[_0x1db3b5(497)] }), _0x4097e8 = [..._0x499f5a[_0x1db3b5(473)][_0x1db3b5(496)]((_0x1ba000) => _0x1ba000["id"] !== _0x35b8c7["id"]), _0x55aa42[_0x1db3b5(503)]], _0x1ecc9f = [..._0x499f5a[_0x1db3b5(497)], ..._0x55aa42["newTracks"]], _0x418d26 = _0x55aa42[_0x1db3b5(497)]["filter"]((_0x131b20) => _0x131b20["type"] === _0x1db3b5(460));
  if (_0x418d26[_0x1db3b5(491)] !== 2) throw new Error(_0x1db3b5(478));
  const _0x5a7312 = generateScissorsCrossoverSignal({ "trackGroup": _0x55aa42[_0x1db3b5(503)], "scissorTracks": _0x418d26, "tracks": _0x1ecc9f });
  return { "newTracks": _0x1ecc9f, "newTrackGroups": _0x4097e8, "newSignals": _0x5a7312 };
}
function makeNewScissorsCrossover({ trackGroup: _0x532f06, tracks: _0x523748 }) {
  const _0x159b25 = _0x5d59;
  if (_0x532f06[_0x159b25(469)] !== _0x159b25(443) && _0x532f06["trackLanesType"] !== _0x159b25(449)) throw new Error("Can't create scissors crossover on a non-parallel/quad track group");
  if (_0x532f06["type"] === _0x159b25(483)) throw new Error(_0x159b25(465));
  let _0x17a0cf, _0x2a2570;
  if (_0x532f06[_0x159b25(469)] === _0x159b25(449) && _0x532f06["trackIds"][_0x159b25(491)] === 4) _0x17a0cf = _0x532f06[_0x159b25(488)][2], _0x2a2570 = _0x532f06[_0x159b25(488)][3];
  else {
    if (_0x532f06[_0x159b25(469)] === _0x159b25(443) && _0x532f06[_0x159b25(488)][_0x159b25(491)] === 2) _0x17a0cf = _0x532f06[_0x159b25(488)][0], _0x2a2570 = _0x532f06[_0x159b25(488)][1];
    else throw new Error(_0x159b25(437));
  }
  const _0x2e124a = _0x523748["find"]((_0x345d55) => _0x345d55["id"] === _0x17a0cf), _0x31f505 = _0x523748["find"]((_0x56df80) => _0x56df80["id"] === _0x2a2570);
  if (!_0x2e124a || !_0x31f505) throw new Error(_0x159b25(482));
  const _0x231fdc = getTrackCoords({ "startCoords": _0x2e124a[_0x159b25(442)][0], "endCoords": _0x31f505[_0x159b25(442)][0], "startBearing": _0x134c1a[_0x159b25(498)](_0x2e124a["coords"][0], _0x2e124a[_0x159b25(442)][1]), "endBearing": _0x134c1a[_0x159b25(455)](_0x134c1a[_0x159b25(498)](_0x31f505[_0x159b25(442)][0], _0x31f505[_0x159b25(442)][1])) });
  if (!_0x231fdc) throw new Error(_0x159b25(487));
  const _0x447afa = validateTrackCurvature(_0x231fdc);
  if (!_0x447afa["isValid"]) throw new Error("Crossover 1 " + _0x447afa[_0x159b25(444)]);
  const _0x314d7b = _0x2e124a[_0x159b25(442)][_0x2e124a[_0x159b25(442)]["length"] - 1], _0x4f78d1 = _0x31f505[_0x159b25(442)][_0x31f505[_0x159b25(442)]["length"] - 1], _0x1a2f79 = getTrackCoords({ "startCoords": _0x314d7b, "endCoords": _0x4f78d1, "endBearing": reverseBearing(_0x134c1a[_0x159b25(498)](_0x4f78d1, _0x31f505["coords"][_0x31f505["coords"][_0x159b25(491)] - 2])), "startBearing": _0x134c1a[_0x159b25(498)](_0x314d7b, _0x2e124a["coords"][_0x2e124a[_0x159b25(442)][_0x159b25(491)] - 2]) });
  if (!_0x1a2f79) throw new Error(_0x159b25(495));
  const _0x313fb9 = validateTrackCurvature(_0x1a2f79);
  if (!_0x313fb9[_0x159b25(462)]) throw new Error("Crossover 2 " + _0x313fb9[_0x159b25(444)]);
  const _0x1fce94 = { "id": v4(), "coords": _0x134c1a[_0x159b25(507)](_0x231fdc), "buildType": _0x159b25(456), "displayType": _0x159b25(456), "type": _0x159b25(460), "reversable": !![], "interactable": ![], "length": _0x134c1a[_0x159b25(481)](_0x231fdc), "startElevation": _0x2e124a[_0x159b25(438)], "endElevation": _0x31f505[_0x159b25(438)], "trackType": _0x532f06[_0x159b25(492)] }, _0x259055 = { "id": v4(), "coords": roundCoordinates(_0x1a2f79), "buildType": _0x159b25(456), "displayType": _0x159b25(456), "type": "scissors-crossover", "reversable": !![], "interactable": ![], "length": _0x134c1a[_0x159b25(481)](_0x1a2f79), "startElevation": _0x2e124a[_0x159b25(463)], "endElevation": _0x31f505[_0x159b25(463)], "trackType": _0x532f06[_0x159b25(492)] }, _0x3a673a = { ..._0x532f06, "trackIds": [..._0x532f06["trackIds"], _0x1fce94["id"], _0x259055["id"]], "type": _0x159b25(460) }, _0x2df8e9 = atob(localStorage[_0x159b25(508)](_0x159b25(501)) || "");
  if (!_0x2df8e9 || _0x2df8e9[_0x159b25(491)] < 5) return { "newTracks": [_0x1fce94, _0x1fce94], "updatedTrackGroup": _0x532f06 };
  return { "newTracks": [_0x1fce94, _0x259055], "updatedTrackGroup": _0x3a673a };
}
function generateScissorsCrossoverSignal({ trackGroup: _0x4ffffa, scissorTracks: _0x14e78c, tracks: _0x2dd319 }) {
  const _0x7aa7c = _0x5d59, _0x13e172 = _0x14e78c[0], _0x6ce5d = _0x14e78c[1], _0x241fa2 = _0x4ffffa["trackIds"][_0x7aa7c(496)]((_0x7d1f43) => _0x7d1f43 !== _0x13e172["id"] && _0x7d1f43 !== _0x6ce5d["id"]);
  let _0x4a34c5;
  _0x4ffffa[_0x7aa7c(469)] === "quad" && _0x241fa2[_0x7aa7c(491)] === 4 ? _0x4a34c5 = [_0x241fa2[2], _0x241fa2[3]] : _0x4a34c5 = _0x241fa2;
  const _0x218d2a = _0x2dd319[_0x7aa7c(484)]((_0x301622) => _0x301622["id"] === _0x4a34c5[0]), _0xd566ad = _0x2dd319[_0x7aa7c(484)]((_0x4af5e0) => _0x4af5e0["id"] === _0x4a34c5[1]);
  if (!_0x218d2a || !_0xd566ad) throw new Error(_0x7aa7c(450));
  const _0x45039e = _0x24b10a[_0x7aa7c(494)](_0x24b10a[_0x7aa7c(461)](_0x13e172[_0x7aa7c(442)]), _0x24b10a[_0x7aa7c(461)](_0x6ce5d["coords"]))[_0x7aa7c(458)][0]["geometry"][_0x7aa7c(475)], _0x259478 = _0x134c1a[_0x7aa7c(459)](_0x218d2a[_0x7aa7c(442)]), _0x557671 = _0x134c1a[_0x7aa7c(459)]([_0x259478, _0x45039e]), _0x2e8d2a = getLineMidpoint(_0xd566ad[_0x7aa7c(442)]), _0x5ad4c1 = getLineMidpoint([_0x2e8d2a, _0x45039e]), _0x739b01 = [_0x4a34c5[0], _0x13e172["id"], _0x6ce5d["id"]][_0x7aa7c(479)]((_0x5d4f32) => ({ "trackId": _0x5d4f32, "areaCovered": _0x7aa7c(471) })), _0x1a5a70 = { "id": v4(), "coords": _0x557671, "status": { "occupations": [], "reservedBy": null }, "signalTracks": _0x739b01, "type": _0x7aa7c(460), "buildType": _0x7aa7c(456) }, _0x3cf29d = [_0x4a34c5[1], _0x6ce5d["id"], _0x13e172["id"]][_0x7aa7c(479)]((_0x44b8fd) => ({ "trackId": _0x44b8fd, "areaCovered": "all" })), _0x18088e = { "id": v4(), "coords": _0x5ad4c1, "status": { "occupations": [], "reservedBy": null }, "signalTracks": _0x3cf29d, "type": _0x7aa7c(460), "buildType": _0x7aa7c(456) };
  return [_0x1a5a70, _0x18088e];
}
(function(_0x3e8cb6, _0x185f09) {
  const _0x4e6617 = _0x247b, _0x56bd20 = _0x3e8cb6();
  while (!![]) {
    try {
      const _0x42356e = parseInt(_0x4e6617(410)) / 1 * (-parseInt(_0x4e6617(435)) / 2) + -parseInt(_0x4e6617(420)) / 3 * (parseInt(_0x4e6617(433)) / 4) + parseInt(_0x4e6617(424)) / 5 + -parseInt(_0x4e6617(426)) / 6 + parseInt(_0x4e6617(413)) / 7 + parseInt(_0x4e6617(414)) / 8 * (-parseInt(_0x4e6617(432)) / 9) + -parseInt(_0x4e6617(409)) / 10 * (-parseInt(_0x4e6617(417)) / 11);
      if (_0x42356e === _0x185f09) break;
      else _0x56bd20["push"](_0x56bd20["shift"]());
    } catch (_0x5ca980) {
      _0x56bd20["push"](_0x56bd20["shift"]());
    }
  }
})(_0x3595, 696879);
const _0x44e73a = /* @__PURE__ */ (function() {
  let _0x51fc8d = !![];
  return function(_0x4eff5d, _0x33fd5c) {
    const _0x2b2bc0 = _0x51fc8d ? function() {
      const _0x1ab52e = _0x247b;
      if (_0x33fd5c) {
        const _0x46adf4 = _0x33fd5c[_0x1ab52e(428)](_0x4eff5d, arguments);
        return _0x33fd5c = null, _0x46adf4;
      }
    } : function() {
    };
    return _0x51fc8d = ![], _0x2b2bc0;
  };
})(), _0xe7211a = _0x44e73a(void 0, function() {
  const _0x113f78 = _0x247b;
  let _0x57c69f;
  try {
    const _0x5da9ca = Function('return (function() {}.constructor("return this")( ));');
    _0x57c69f = _0x5da9ca();
  } catch (_0x230af7) {
    _0x57c69f = window;
  }
  const _0x397d4e = _0x57c69f["console"] = _0x57c69f[_0x113f78(422)] || {}, _0x58fbea = [_0x113f78(423), _0x113f78(412), _0x113f78(415), "error", _0x113f78(411), _0x113f78(429), _0x113f78(416)];
  for (let _0x459c60 = 0; _0x459c60 < _0x58fbea[_0x113f78(434)]; _0x459c60++) {
    const _0x3f439c = _0x44e73a[_0x113f78(418)][_0x113f78(427)][_0x113f78(431)](_0x44e73a), _0x18186f = _0x58fbea[_0x459c60], _0x571680 = _0x397d4e[_0x18186f] || _0x3f439c;
    _0x3f439c[_0x113f78(425)] = _0x44e73a[_0x113f78(431)](_0x44e73a), _0x3f439c[_0x113f78(430)] = _0x571680[_0x113f78(430)][_0x113f78(431)](_0x571680), _0x397d4e[_0x18186f] = _0x3f439c;
  }
});
function _0x247b(_0x46ec9b, _0xfec2c2) {
  const _0x50c00a = _0x3595();
  return _0x247b = function(_0xe7211a2, _0x44e73a2) {
    _0xe7211a2 = _0xe7211a2 - 409;
    let _0x9aaf18 = _0x50c00a[_0xe7211a2];
    return _0x9aaf18;
  }, _0x247b(_0x46ec9b, _0xfec2c2);
}
_0xe7211a();
function getElevationFromSnappedTrack(_0x1ad143, _0x43e40a, _0x391c08, _0x313c45, _0x4d73a5) {
  const _0x1c57da = _0x247b;
  if (_0x4d73a5) {
    const _0x5181b2 = _0x313c45["find"]((_0x3d177f) => _0x3d177f["id"] === _0x1ad143);
    if (!_0x5181b2 || !_0x5181b2[_0x1c57da(419)][_0x1c57da(434)]) return null;
    const _0x1b8995 = _0x391c08["find"]((_0x332299) => _0x332299["id"] === _0x5181b2[_0x1c57da(419)][0]);
    if (!_0x1b8995) return null;
    return getTrackElevationAtPoint(_0x1b8995, _0x43e40a);
  }
  const _0x4e44ce = _0x391c08[_0x1c57da(421)]((_0x228dbb) => _0x228dbb["id"] === _0x1ad143);
  if (!_0x4e44ce) return null;
  return getTrackElevationAtPoint(_0x4e44ce, _0x43e40a);
}
function _0x3595() {
  const _0x49f120 = ["23642970jQyQvb", "1193fAAJZG", "exception", "warn", "4436950hgAELy", "8UWRxMb", "info", "trace", "11wUrFRZ", "constructor", "trackIds", "6WvRImr", "find", "console", "log", "6138540dlPPNQ", "__proto__", "3968856aOaeEr", "prototype", "apply", "table", "toString", "bind", "9017451dzfKpF", "2091940vXYFrh", "length", "1374zdAKGY"];
  _0x3595 = function() {
    return _0x49f120;
  };
  return _0x3595();
}
(function(_0x3c2af8, _0xc20b80) {
  const _0x5c4a84 = _0x363d, _0x392a4c = _0x3c2af8();
  while (!![]) {
    try {
      const _0x142dcf = parseInt(_0x5c4a84(435)) / 1 * (-parseInt(_0x5c4a84(445)) / 2) + parseInt(_0x5c4a84(451)) / 3 + -parseInt(_0x5c4a84(448)) / 4 + parseInt(_0x5c4a84(437)) / 5 + parseInt(_0x5c4a84(461)) / 6 * (-parseInt(_0x5c4a84(439)) / 7) + parseInt(_0x5c4a84(443)) / 8 + parseInt(_0x5c4a84(438)) / 9 * (parseInt(_0x5c4a84(462)) / 10);
      if (_0x142dcf === _0xc20b80) break;
      else _0x392a4c["push"](_0x392a4c["shift"]());
    } catch (_0x5e4b9a) {
      _0x392a4c["push"](_0x392a4c["shift"]());
    }
  }
})(_0x1639, 241340);
const _0x28347e = /* @__PURE__ */ (function() {
  let _0x27a8d5 = !![];
  return function(_0x452889, _0x39019b) {
    const _0x31885a = _0x27a8d5 ? function() {
      const _0xe51bb5 = _0x363d;
      if (_0x39019b) {
        const _0x102be7 = _0x39019b[_0xe51bb5(440)](_0x452889, arguments);
        return _0x39019b = null, _0x102be7;
      }
    } : function() {
    };
    return _0x27a8d5 = ![], _0x31885a;
  };
})(), _0x554f71 = _0x28347e(void 0, function() {
  const _0x25f6f4 = _0x363d, _0x5c6fa9 = function() {
    const _0x3443ee = _0x363d;
    let _0x135bc8;
    try {
      _0x135bc8 = Function("return (function() " + _0x3443ee(436) + ");")();
    } catch (_0xc0bd61) {
      _0x135bc8 = window;
    }
    return _0x135bc8;
  }, _0x3e1deb = _0x5c6fa9(), _0xbc0c75 = _0x3e1deb["console"] = _0x3e1deb[_0x25f6f4(441)] || {}, _0x4b0bfc = ["log", _0x25f6f4(449), _0x25f6f4(450), _0x25f6f4(434), _0x25f6f4(457), "table", _0x25f6f4(455)];
  for (let _0x54c565 = 0; _0x54c565 < _0x4b0bfc["length"]; _0x54c565++) {
    const _0x15dfdc = _0x28347e["constructor"][_0x25f6f4(464)][_0x25f6f4(456)](_0x28347e), _0x3a3a67 = _0x4b0bfc[_0x54c565], _0xd16eff = _0xbc0c75[_0x3a3a67] || _0x15dfdc;
    _0x15dfdc[_0x25f6f4(458)] = _0x28347e[_0x25f6f4(456)](_0x28347e), _0x15dfdc[_0x25f6f4(444)] = _0xd16eff[_0x25f6f4(444)]["bind"](_0xd16eff), _0xbc0c75[_0x3a3a67] = _0x15dfdc;
  }
});
_0x554f71();
function _0x363d(_0x1c7781, _0x43bdb6) {
  const _0x5cf2a0 = _0x1639();
  return _0x363d = function(_0x554f712, _0x28347e2) {
    _0x554f712 = _0x554f712 - 434;
    let _0x5aabea = _0x5cf2a0[_0x554f712];
    return _0x5aabea;
  }, _0x363d(_0x1c7781, _0x43bdb6);
}
function _0x1639() {
  const _0x260864 = ["getTrackElevationAtPoint", "error", "435823OsJUyn", '{}.constructor("return this")( )', "630590lkdTIH", "7752798FlkssT", "125300qKCaSS", "apply", "console", "coordinates", "147416qoNRhz", "toString", "2FkErGF", "coords", "m+ clearance for grade separation.", "1868568bjQONW", "warn", "info", "522414UwEXoh", "toFixed", "STATION_HEIGHT", "abs", "trace", "bind", "exception", "__proto__", "m elevation gap.\n                    Either place tracks at the same elevation (≤", "getDistanceBetweenPoints", "12oPTiqS", "10BmZOhF", "length", "prototype", "features", "lineString", "geometry", "lineIntersect"];
  _0x1639 = function() {
    return _0x260864;
  };
  return _0x1639();
}

const ALLOWED_ELEVATION_GAP$1 = 0.01;
function validateElevationGapAtIntersections(_0x2ba1a0, _0x39de50) {
  forceBuild()
  if (allowForceBuild) return { "isValid": !![] };
  const _0x5350cc = _0x363d;
  if (_0x2ba1a0[_0x5350cc(446)][_0x5350cc(463)] < 2) return { "isValid": !![] };
  const _0x5ce6a4 = _0x24b10a[_0x5350cc(466)](_0x2ba1a0["coords"]);
  for (const _0x335821 of _0x39de50) {
    if (_0x335821[_0x5350cc(446)][_0x5350cc(463)] < 2) continue;
    const _0x56cd7c = lineString(_0x335821["coords"]), _0x42c732 = _0x24b10a[_0x5350cc(468)](_0x5ce6a4, _0x56cd7c);
    for (const _0x302396 of _0x42c732[_0x5350cc(465)]) {
      const _0x60aa92 = _0x302396[_0x5350cc(467)][_0x5350cc(442)], _0x13c60d = getDistanceBetweenPoints(_0x60aa92, _0x2ba1a0["coords"][0]), _0x5bde39 = _0x134c1a[_0x5350cc(460)](_0x60aa92, _0x2ba1a0[_0x5350cc(446)][_0x2ba1a0["coords"][_0x5350cc(463)] - 1]), _0x518036 = _0x134c1a[_0x5350cc(460)](_0x60aa92, _0x335821[_0x5350cc(446)][0]), _0x4d7727 = _0x134c1a[_0x5350cc(460)](_0x60aa92, _0x335821[_0x5350cc(446)][_0x335821[_0x5350cc(446)][_0x5350cc(463)] - 1]), _0x195f25 = 5, _0x3c655 = _0x13c60d < _0x195f25 || _0x5bde39 < _0x195f25 || _0x518036 < _0x195f25 || _0x4d7727 < _0x195f25;
      if (_0x3c655) continue;
      const _0x37b427 = _0x44416e[_0x5350cc(469)](_0x2ba1a0, _0x60aa92), _0x19545e = _0x44416e[_0x5350cc(469)](_0x335821, _0x60aa92), _0x42b798 = Math[_0x5350cc(454)](_0x37b427 - _0x19545e);
      if (_0x42b798 > ALLOWED_ELEVATION_GAP$1 && _0x42b798 < RULES[_0x5350cc(453)] - 0.01) return { "isValid": ![], "errorMessage": "Tracks cannot intersect with " + _0x42b798["toFixed"](2) + _0x5350cc(459) + ALLOWED_ELEVATION_GAP$1[_0x5350cc(452)](2) + "m difference) or create " + RULES[_0x5350cc(453)]["toFixed"](2) + _0x5350cc(447) };
    }
  }
  return { "isValid": !![] };
}
(function(_0x3095e7, _0x305c92) {
  const _0x4f6b34 = _0x7a79, _0x388b19 = _0x3095e7();
  while (!![]) {
    try {
      const _0x2fee69 = parseInt(_0x4f6b34(165)) / 1 + parseInt(_0x4f6b34(123)) / 2 + -parseInt(_0x4f6b34(145)) / 3 * (parseInt(_0x4f6b34(160)) / 4) + parseInt(_0x4f6b34(128)) / 5 + parseInt(_0x4f6b34(132)) / 6 * (-parseInt(_0x4f6b34(169)) / 7) + -parseInt(_0x4f6b34(120)) / 8 * (-parseInt(_0x4f6b34(134)) / 9) + -parseInt(_0x4f6b34(135)) / 10 * (parseInt(_0x4f6b34(157)) / 11);
      if (_0x2fee69 === _0x305c92) break;
      else _0x388b19["push"](_0x388b19["shift"]());
    } catch (_0x3fb8f3) {
      _0x388b19["push"](_0x388b19["shift"]());
    }
  }
})(_0x46a8, 596811);
const _0x5d7a7c = /* @__PURE__ */ (function() {
  let _0x2fa8f6 = !![];
  return function(_0x449867, _0x1ed9a4) {
    const _0x42ca80 = _0x2fa8f6 ? function() {
      const _0x33de30 = _0x7a79;
      if (_0x1ed9a4) {
        const _0x576a18 = _0x1ed9a4[_0x33de30(121)](_0x449867, arguments);
        return _0x1ed9a4 = null, _0x576a18;
      }
    } : function() {
    };
    return _0x2fa8f6 = ![], _0x42ca80;
  };
})(), _0x2fd9c7 = _0x5d7a7c(void 0, function() {
  const _0x36faf0 = _0x7a79, _0x51b9ea = function() {
    const _0x1bb556 = _0x7a79;
    let _0x477f8c;
    try {
      _0x477f8c = Function(_0x1bb556(163) + _0x1bb556(171) + ");")();
    } catch (_0x2247cf) {
      _0x477f8c = window;
    }
    return _0x477f8c;
  }, _0x435ab0 = _0x51b9ea(), _0x467a28 = _0x435ab0["console"] = _0x435ab0[_0x36faf0(142)] || {}, _0x47bd3e = [_0x36faf0(127), _0x36faf0(122), _0x36faf0(159), _0x36faf0(133), _0x36faf0(150), _0x36faf0(162), _0x36faf0(137)];
  for (let _0x56d6bb = 0; _0x56d6bb < _0x47bd3e[_0x36faf0(168)]; _0x56d6bb++) {
    const _0x2808b6 = _0x5d7a7c[_0x36faf0(148)][_0x36faf0(139)][_0x36faf0(144)](_0x5d7a7c), _0x5dfdee = _0x47bd3e[_0x56d6bb], _0x5ad03f = _0x467a28[_0x5dfdee] || _0x2808b6;
    _0x2808b6[_0x36faf0(156)] = _0x5d7a7c[_0x36faf0(144)](_0x5d7a7c), _0x2808b6[_0x36faf0(152)] = _0x5ad03f["toString"][_0x36faf0(144)](_0x5ad03f), _0x467a28[_0x5dfdee] = _0x2808b6;
  }
});
function _0x7a79(_0x36960c, _0x4e4557) {
  const _0xfb5bb = _0x46a8();
  return _0x7a79 = function(_0x2fd9c72, _0x5d7a7c2) {
    _0x2fd9c72 = _0x2fd9c72 - 119;
    let _0x5a36f8 = _0xfb5bb[_0x2fd9c72];
    return _0x5a36f8;
  }, _0x7a79(_0x36960c, _0x4e4557);
}
function _0x46a8() {
  const _0x3fe8f1 = ["__proto__", "57156jvjPxa", "startElevation", "info", "1646820ptYKFL", "properties", "table", "return (function() ", "meters", "1011702molVnZ", "roadNames", "geometry", "length", "7PJNzfb", "TUNNEL_HEIGHT", '{}.constructor("return this")( )', "m), elevate track (above ", "16ZdYFDb", "apply", "warn", "1746294wjzLBG", "AT_GRADE", "ELEVATED", "feature", "log", "146695vDaWvL", "nearestPointOnLine", "m), or adjust route to avoid roads.", "CONSTRUCTION_COSTS", "3956766oYcyIy", "error", "1095453szUulI", "150dPFWvh", "coordinates", "trace", "features", "prototype", "push", "location", "console", "search", "bind", "6LoTzLE", "endElevation", "name", "constructor", "ELEVATION_THRESHOLDS", "exception", " point", "toString", "reduce", "lineString", "Track intersects with roads at "];
  _0x46a8 = function() {
    return _0x3fe8f1;
  };
  return _0x46a8();
}
_0x2fd9c7();
function validateRoadCollision(_0x26aa4a, _0x47c4f1) {
  forceBuild()
  if (allowForceBuild) return { "isValid": !![] };
  const _0x526c8c = _0x7a79;
  if (!_0x47c4f1) return { "isValid": !![] };
  const _0x2a84f3 = [], _0xb5284d = [];
  let _0x4c8e41 = ![];
  for (const _0x1e00d7 of _0x26aa4a) {
    const _0x1767cd = Math["max"](_0x1e00d7["startElevation"], _0x1e00d7[_0x526c8c(146)]);
    if (_0x1767cd < RULES["CONSTRUCTION_COSTS"]["ELEVATION_THRESHOLDS"][_0x526c8c(124)]) continue;
    const _0x46a584 = _0x24b10a[_0x526c8c(154)](_0x1e00d7["coords"]), _0x1fee87 = bbox(_0x46a584), _0x59adc2 = _0x47c4f1[_0x526c8c(143)]({ "minX": _0x1fee87[0], "minY": _0x1fee87[1], "maxX": _0x1fee87[2], "maxY": _0x1fee87[3] }), _0x55b9b4 = [], _0x30e2eb = [];
    for (const _0x105255 of _0x59adc2) {
      const _0x550d4b = _0x105255[_0x526c8c(126)], _0x1854f5 = lineIntersect(_0x46a584, _0x550d4b);
      if (_0x1854f5[_0x526c8c(138)]["length"] === 0) continue;
      let _0x36c2f7 = ![];
      for (const _0xbd572c of _0x1854f5["features"]) {
        const _0x5d7d5d = _0xbd572c[_0x526c8c(167)][_0x526c8c(136)], _0x90d544 = _0x24b10a[_0x526c8c(168)](_0x46a584, { "units": _0x526c8c(164) }), _0x113f62 = _0x24b10a[_0x526c8c(129)](_0x46a584, _0xbd572c), _0x4be345 = _0x113f62["properties"][_0x526c8c(141)] || 0, _0x3ec6ed = _0x1e00d7[_0x526c8c(158)] + (_0x1e00d7[_0x526c8c(146)] - _0x1e00d7[_0x526c8c(158)]) * (_0x4be345 / _0x90d544);
        _0x3ec6ed > -RULES[_0x526c8c(170)] && _0x3ec6ed < RULES[_0x526c8c(131)][_0x526c8c(149)]["ELEVATED"] && (_0x36c2f7 = !![], _0x30e2eb[_0x526c8c(140)](_0x5d7d5d));
      }
      _0x36c2f7 && _0x105255["feature"][_0x526c8c(161)][_0x526c8c(147)] && !_0x55b9b4["includes"](_0x105255[_0x526c8c(126)][_0x526c8c(161)]["name"]) && _0x55b9b4[_0x526c8c(140)](_0x105255["feature"]["properties"][_0x526c8c(147)]);
    }
    _0x55b9b4[_0x526c8c(168)] > 0 && (_0x4c8e41 = !![], _0x2a84f3["push"](_0x1e00d7["id"]), _0xb5284d["push"]({ "trackId": _0x1e00d7["id"], "roadNames": _0x55b9b4, "intersectionPoints": _0x30e2eb[_0x526c8c(168)] > 0 ? _0x30e2eb : void 0 }));
  }
  if (_0x4c8e41) {
    const _0x340025 = _0xb5284d[_0x526c8c(153)]((_0x291d11, _0x23cb36) => _0x291d11 + _0x23cb36[_0x526c8c(166)][_0x526c8c(168)], 0);
    return { "isValid": ![], "errorMessage": _0x526c8c(155) + _0x340025 + _0x526c8c(151) + (_0x340025 > 1 ? "s" : "") + ". Go deeper (below -" + RULES[_0x526c8c(170)] + _0x526c8c(119) + RULES["CONSTRUCTION_COSTS"]["ELEVATION_THRESHOLDS"][_0x526c8c(125)] + _0x526c8c(130), "collidingTrackIds": _0x2a84f3, "collisionDetails": _0xb5284d };
  }
  return { "isValid": !![] };
}
(function(_0x374b94, _0x237dd6) {
  const _0x9e98d4 = _0x333b, _0x555117 = _0x374b94();
  while (!![]) {
    try {
      const _0x30d67f = parseInt(_0x9e98d4(252)) / 1 + parseInt(_0x9e98d4(223)) / 2 * (parseInt(_0x9e98d4(236)) / 3) + -parseInt(_0x9e98d4(259)) / 4 + parseInt(_0x9e98d4(218)) / 5 + -parseInt(_0x9e98d4(249)) / 6 + -parseInt(_0x9e98d4(216)) / 7 * (-parseInt(_0x9e98d4(251)) / 8) + parseInt(_0x9e98d4(221)) / 9 * (-parseInt(_0x9e98d4(231)) / 10);
      if (_0x30d67f === _0x237dd6) break;
      else _0x555117["push"](_0x555117["shift"]());
    } catch (_0x1c0509) {
      _0x555117["push"](_0x555117["shift"]());
    }
  }
})(_0x1679, 415225);
const _0x462b1e = /* @__PURE__ */ (function() {
  let _0x5231f5 = !![];
  return function(_0x3cd7ca, _0x97294) {
    const _0x307d9f = _0x5231f5 ? function() {
      const _0x3b4446 = _0x333b;
      if (_0x97294) {
        const _0x4705c3 = _0x97294[_0x3b4446(246)](_0x3cd7ca, arguments);
        return _0x97294 = null, _0x4705c3;
      }
    } : function() {
    };
    return _0x5231f5 = ![], _0x307d9f;
  };
})(), _0x46f8ca = _0x462b1e(void 0, function() {
  const _0x233f9b = _0x333b;
  let _0x4c278d;
  try {
    const _0x57e496 = Function(_0x233f9b(244) + '{}.constructor("return this")( ));');
    _0x4c278d = _0x57e496();
  } catch (_0x5ab36f) {
    _0x4c278d = window;
  }
  const _0x219dc6 = _0x4c278d[_0x233f9b(235)] = _0x4c278d[_0x233f9b(235)] || {}, _0x27d286 = ["log", _0x233f9b(210), _0x233f9b(213), _0x233f9b(240), _0x233f9b(238), "table", _0x233f9b(239)];
  for (let _0x23c112 = 0; _0x23c112 < _0x27d286[_0x233f9b(211)]; _0x23c112++) {
    const _0xb347e7 = _0x462b1e[_0x233f9b(247)]["prototype"][_0x233f9b(262)](_0x462b1e), _0x5e1ea2 = _0x27d286[_0x23c112], _0x5c2504 = _0x219dc6[_0x5e1ea2] || _0xb347e7;
    _0xb347e7[_0x233f9b(233)] = _0x462b1e[_0x233f9b(262)](_0x462b1e), _0xb347e7[_0x233f9b(260)] = _0x5c2504[_0x233f9b(260)][_0x233f9b(262)](_0x5c2504), _0x219dc6[_0x5e1ea2] = _0xb347e7;
  }
});
_0x46f8ca();
function _0x333b(_0x34e79e, _0x908014) {
  const _0x55a37b = _0x1679();
  return _0x333b = function(_0x46f8ca2, _0x462b1e2) {
    _0x46f8ca2 = _0x46f8ca2 - 210;
    let _0xca4442 = _0x55a37b[_0x46f8ca2];
    return _0xca4442;
  }, _0x333b(_0x34e79e, _0x908014);
}
function _0x1679() {
  const _0x11be42 = ["features", "lineString", "return (function() ", "type", "apply", "constructor", "Failed to create track buffer", "4021290LKcWRS", "map", "469312UAWyzE", "768413OIuYKh", "coordinates", "Invalid buffer center coordinates, skipping track validation", "centerLine", "\n                Tracks cannot overlap with ", "abs", "STATION_HEIGHT", "1761836zWoLgL", "toString", "nearestPointOnLine", "bind", "buildType", "station", "max", "express-station", "isFinite", "warn", "length", "toFixed", "info", "search", "center", "49YHKqGY", "geometry", "2742810ntHpPJ", "coords", "\n                Stations need at least ", "36333AYuUDw", "getDistanceBetweenPoints", "112rtwWCm", "m vertical clearance.", "booleanContains", "filter", "trackIds", "coordsEqual", "lineIntersect", "meters", "2040pxRIVc", "getTrackElevationAtPoint", "__proto__", "min", "console", "33312qJHMET", "m vertical clearance between other tracks and stations.\n                Currently the gap is ", "exception", "trace", "error", "buffer"];
  _0x1679 = function() {
    return _0x11be42;
  };
  return _0x1679();
}
const ALLOWED_ELEVATION_GAP = 0.02;
function validateTrackOverlap({ newTrackCoords: _0xe26d4a, newTrackStartElevation: _0x13fa18, newTrackEndElevation: _0x195e82, newTrackLanes: _0x197b7b, isStation: _0xc9efb1, existingTracks: _0x2e899e, trackGroups: _0xef3ed0, trackSpatialIndex: _0x345e85 }) {
  forceBuild()
  if (allowForceBuild) return { "isValid": !![] };
  const _0x3c15de = _0x333b;
  if (_0xe26d4a[_0x3c15de(211)] === 2 && _0x134c1a[_0x3c15de(228)](_0xe26d4a[0], _0xe26d4a[1])) return { "isValid": !![] };
  const _0xb8b8b7 = getTrackBaseWidthFromLanes(_0x197b7b) / 2, _0x211613 = _0xe26d4a[_0x3c15de(250)]((_0x30200b) => _0x30200b[0]), _0x213392 = _0xe26d4a[_0x3c15de(250)]((_0x79157b) => _0x79157b[1]), _0x1e3174 = _0xb8b8b7 / 111e3, _0x18abff = { "minX": Math[_0x3c15de(234)](..._0x211613) - _0x1e3174, "minY": Math[_0x3c15de(234)](..._0x213392) - _0x1e3174, "maxX": Math[_0x3c15de(265)](..._0x211613) + _0x1e3174, "maxY": Math[_0x3c15de(265)](..._0x213392) + _0x1e3174 }, _0x1900f8 = _0x345e85[_0x3c15de(214)](_0x18abff), _0x11fff5 = new Set(_0x1900f8[_0x3c15de(250)]((_0x33467f) => _0x33467f["trackId"])), _0xb308a9 = _0x2e899e[_0x3c15de(226)]((_0x52e4f9) => _0x11fff5["has"](_0x52e4f9["id"])), _0x26f7a8 = _0xb308a9[_0x3c15de(226)]((_0x37d415) => _0x37d415[_0x3c15de(263)] !== "preview");
  if (_0x26f7a8["length"] === 0) return { "isValid": !![] };
  const _0x1c33dd = _0x24b10a[_0x3c15de(243)](_0xe26d4a), _0x1a0a98 = _0x24b10a[_0x3c15de(241)](_0x1c33dd, _0xb8b8b7, { "units": _0x3c15de(230), "steps": 4 });
  if (!_0x1a0a98) return { "isValid": ![], "errorMessage": _0x3c15de(248) };
  for (const _0x354745 of _0x26f7a8) {
    if (_0x354745["coords"][_0x3c15de(211)] < 2) continue;
    const _0x1e21bd = _0xef3ed0["find"]((_0x13ec4b) => _0x13ec4b[_0x3c15de(227)]["includes"](_0x354745["id"]));
    if (!_0x1e21bd) continue;
    const _0x31ebaf = getTrackBaseWidthFromLanes(_0x197b7b) / 2, _0x1ec314 = _0x24b10a[_0x3c15de(243)](_0x1e21bd[_0x3c15de(255)]), _0x42081f = _0x24b10a[_0x3c15de(241)](_0x1ec314, _0x31ebaf, { "units": _0x3c15de(230), "steps": 4 });
    if (!_0x42081f) continue;
    const _0x3e195c = booleanOverlap(_0x1a0a98, _0x42081f) || _0x24b10a[_0x3c15de(225)](_0x1a0a98, _0x42081f) || _0x24b10a[_0x3c15de(225)](_0x42081f, _0x1a0a98);
    if (!_0x3e195c) continue;
    const _0x182742 = _0x24b10a[_0x3c15de(229)](_0x1c33dd, _0x1ec314);
    let _0x2895f5, _0x162d02;
    if (_0x182742[_0x3c15de(242)][_0x3c15de(211)] > 0) {
      const _0x3ba7fe = _0x182742[_0x3c15de(242)][0][_0x3c15de(217)][_0x3c15de(253)];
      _0x2895f5 = _0x44416e[_0x3c15de(232)]({ "coords": _0xe26d4a, "startElevation": _0x13fa18, "endElevation": _0x195e82 }, _0x3ba7fe), _0x162d02 = _0x44416e[_0x3c15de(232)](_0x354745, _0x3ba7fe);
    } else {
      const _0x2e817b = _0x24b10a[_0x3c15de(215)](_0x42081f), _0xa9c032 = _0x24b10a[_0x3c15de(215)](_0x1a0a98);
      if (!_0x2e817b[_0x3c15de(217)][_0x3c15de(253)] || !_0xa9c032[_0x3c15de(217)][_0x3c15de(253)] || !Number[_0x3c15de(267)](_0x2e817b[_0x3c15de(217)][_0x3c15de(253)][0]) || !Number[_0x3c15de(267)](_0x2e817b["geometry"][_0x3c15de(253)][1]) || !Number[_0x3c15de(267)](_0xa9c032[_0x3c15de(217)][_0x3c15de(253)][0]) || !Number[_0x3c15de(267)](_0xa9c032[_0x3c15de(217)][_0x3c15de(253)][1])) {
        console[_0x3c15de(210)](_0x3c15de(254));
        continue;
      }
      const _0x5285c6 = _0x24b10a[_0x3c15de(261)](_0x1c33dd, _0x2e817b), _0x3e2159 = nearestPointOnLine(_0x1ec314, _0xa9c032), _0x897f8c = [(_0x5285c6[_0x3c15de(217)][_0x3c15de(253)][0] + _0x3e2159[_0x3c15de(217)][_0x3c15de(253)][0]) / 2, (_0x5285c6[_0x3c15de(217)]["coordinates"][1] + _0x3e2159[_0x3c15de(217)][_0x3c15de(253)][1]) / 2];
      _0x2895f5 = _0x44416e[_0x3c15de(232)]({ "coords": _0xe26d4a, "startElevation": _0x13fa18, "endElevation": _0x195e82 }, _0x897f8c), _0x162d02 = _0x44416e[_0x3c15de(232)](_0x354745, _0x897f8c);
    }
    const _0x128231 = Math[_0x3c15de(257)](_0x2895f5 - _0x162d02), _0x20582b = _0x128231 < ALLOWED_ELEVATION_GAP, _0x41e2d0 = _0x128231 >= RULES[_0x3c15de(258)] - 0.01;
    if (_0x41e2d0) continue;
    const _0x122f7b = _0x354745[_0x3c15de(245)] === _0x3c15de(264) || _0x354745[_0x3c15de(245)] === _0x3c15de(266);
    if (_0x122f7b || _0xc9efb1) {
      const _0x455e65 = !_0x122f7b && !_0xc9efb1;
      if (_0x20582b && !_0x455e65) {
        const _0x3f89ae = 10, _0x7c17ce = _0x354745[_0x3c15de(219)][0], _0x3f9fc3 = _0x354745[_0x3c15de(219)][_0x354745[_0x3c15de(219)][_0x3c15de(211)] - 1], _0x5a510e = _0xe26d4a[0], _0x49d306 = _0xe26d4a[_0xe26d4a[_0x3c15de(211)] - 1];
        if (_0x134c1a[_0x3c15de(222)](_0x7c17ce, _0x5a510e) < _0x3f89ae || _0x134c1a[_0x3c15de(222)](_0x7c17ce, _0x49d306) < _0x3f89ae || getDistanceBetweenPoints(_0x3f9fc3, _0x5a510e) < _0x3f89ae || getDistanceBetweenPoints(_0x3f9fc3, _0x49d306) < _0x3f89ae) continue;
      }
      return { "isValid": ![], "errorMessage": _0x3c15de(220) + RULES[_0x3c15de(258)] + _0x3c15de(237) + _0x128231[_0x3c15de(212)](2) + "m." };
    }
    if (!_0x20582b) return { "isValid": ![], "errorMessage": _0x3c15de(256) + _0x128231[_0x3c15de(212)](2) + "m elevation gap.\n                Tracks must either be at the same elevation (≤0.1m difference) or have at least " + RULES[_0x3c15de(258)] + _0x3c15de(224) };
  }
  return { "isValid": !![] };
}
(function(_0x11f398, _0x3e56c9) {
  const _0x47be80 = _0x558b, _0x3adf92 = _0x11f398();
  while (!![]) {
    try {
      const _0x532678 = parseInt(_0x47be80(228)) / 1 + -parseInt(_0x47be80(219)) / 2 + -parseInt(_0x47be80(205)) / 3 + -parseInt(_0x47be80(216)) / 4 * (-parseInt(_0x47be80(225)) / 5) + parseInt(_0x47be80(232)) / 6 + -parseInt(_0x47be80(229)) / 7 * (-parseInt(_0x47be80(206)) / 8) + -parseInt(_0x47be80(222)) / 9 * (-parseInt(_0x47be80(221)) / 10);
      if (_0x532678 === _0x3e56c9) break;
      else _0x3adf92["push"](_0x3adf92["shift"]());
    } catch (_0x3c33a2) {
      _0x3adf92["push"](_0x3adf92["shift"]());
    }
  }
})(_0x6c5f, 385335);
const _0x1fe5e0 = /* @__PURE__ */ (function() {
  let _0x487b83 = !![];
  return function(_0x9163bb, _0x38e268) {
    const _0x24c145 = _0x487b83 ? function() {
      const _0x364fa6 = _0x558b;
      if (_0x38e268) {
        const _0x44267e = _0x38e268[_0x364fa6(226)](_0x9163bb, arguments);
        return _0x38e268 = null, _0x44267e;
      }
    } : function() {
    };
    return _0x487b83 = ![], _0x24c145;
  };
})(), _0x4a1f81 = _0x1fe5e0(void 0, function() {
  const _0x4c62a7 = _0x558b;
  let _0xcf8961;
  try {
    const _0x39f2ab = Function(_0x4c62a7(217) + _0x4c62a7(207) + ");");
    _0xcf8961 = _0x39f2ab();
  } catch (_0x428ab9) {
    _0xcf8961 = window;
  }
  const _0x5d9c5e = _0xcf8961["console"] = _0xcf8961[_0x4c62a7(227)] || {}, _0x3cca5c = [_0x4c62a7(210), _0x4c62a7(208), _0x4c62a7(213), _0x4c62a7(211), _0x4c62a7(233), _0x4c62a7(223), _0x4c62a7(214)];
  for (let _0x51662a = 0; _0x51662a < _0x3cca5c[_0x4c62a7(231)]; _0x51662a++) {
    const _0x132090 = _0x1fe5e0[_0x4c62a7(212)][_0x4c62a7(215)]["bind"](_0x1fe5e0), _0xa73aad = _0x3cca5c[_0x51662a], _0x2699e7 = _0x5d9c5e[_0xa73aad] || _0x132090;
    _0x132090["__proto__"] = _0x1fe5e0[_0x4c62a7(220)](_0x1fe5e0), _0x132090[_0x4c62a7(218)] = _0x2699e7[_0x4c62a7(218)][_0x4c62a7(220)](_0x2699e7), _0x5d9c5e[_0xa73aad] = _0x132090;
  }
});
_0x4a1f81();
function _0x6c5f() {
  const _0x2c1aee = ["trace", "prototype", "20SGUVod", "return (function() ", "toString", "428802OdBqiW", "bind", "16420ofBHzU", "2313VIjIhr", "table", "MAX_SLOPE_PERCENTAGE", "553885bUzKaW", "apply", "console", "92229hUFTAW", "1576169FcgGgJ", "abs", "length", "86628VEOWSH", "exception", "getLineLength", "2123931YjcOvr", "8DHmTpQ", '{}.constructor("return this")( )', "warn", "toFixed", "log", "error", "constructor", "info"];
  _0x6c5f = function() {
    return _0x2c1aee;
  };
  return _0x6c5f();
}
function _0x558b(_0x2a3d3f, _0x523537) {
  const _0x4643d4 = _0x6c5f();
  return _0x558b = function(_0x4a1f812, _0x1fe5e02) {
    _0x4a1f812 = _0x4a1f812 - 204;
    let _0x113d13 = _0x4643d4[_0x4a1f812];
    return _0x113d13;
  }, _0x558b(_0x2a3d3f, _0x523537);
}
function validateTrackSlope(_0x90975e, _0x40e49d, _0x107fdb) {
  forceBuild()
  if (allowForceBuild) return { "isValid": !![] };
  const _0x30365f = _0x558b;
  if (_0x90975e[_0x30365f(231)] < 2) return { "isValid": !![] };
  const _0x404b91 = _0x134c1a[_0x30365f(204)](_0x90975e);
  if (_0x404b91 === 0) return { "isValid": !![] };
  const _0x1d40b3 = Math[_0x30365f(230)](_0x107fdb - _0x40e49d), _0xda9e4d = _0x1d40b3 / _0x404b91 * 100;
  if (_0xda9e4d > RULES[_0x30365f(224)]) return { "isValid": ![], "errorMessage": "Track slope is too steep (" + _0xda9e4d[_0x30365f(209)](1) + "%). Maximum allowed slope is " + RULES["MAX_SLOPE_PERCENTAGE"] + "%." };
  return { "isValid": !![] };
}
(function(_0x340e06, _0x2176a5) {
  const _0x8e67ca = _0x45cc, _0xeade60 = _0x340e06();
  while (!![]) {
    try {
      const _0x5cd55e = -parseInt(_0x8e67ca(414)) / 1 + parseInt(_0x8e67ca(433)) / 2 * (parseInt(_0x8e67ca(427)) / 3) + parseInt(_0x8e67ca(440)) / 4 * (-parseInt(_0x8e67ca(432)) / 5) + parseInt(_0x8e67ca(419)) / 6 + parseInt(_0x8e67ca(441)) / 7 * (parseInt(_0x8e67ca(415)) / 8) + parseInt(_0x8e67ca(431)) / 9 + -parseInt(_0x8e67ca(424)) / 10;
      if (_0x5cd55e === _0x2176a5) break;
      else _0xeade60["push"](_0xeade60["shift"]());
    } catch (_0x3cd948) {
      _0xeade60["push"](_0xeade60["shift"]());
    }
  }
})(_0x15d9, 361559);
const _0x56ec64 = /* @__PURE__ */ (function() {
  let _0x3e0ce4 = !![];
  return function(_0x559e0d, _0x527c83) {
    const _0x2db611 = _0x3e0ce4 ? function() {
      const _0x2e04a9 = _0x45cc;
      if (_0x527c83) {
        const _0x1dd4a1 = _0x527c83[_0x2e04a9(428)](_0x559e0d, arguments);
        return _0x527c83 = null, _0x1dd4a1;
      }
    } : function() {
    };
    return _0x3e0ce4 = ![], _0x2db611;
  };
})(), _0x28642a = _0x56ec64(void 0, function() {
  const _0x4dba51 = _0x45cc, _0x55d76c = function() {
    const _0x54feee = _0x45cc;
    let _0x2e7ada;
    try {
      _0x2e7ada = Function("return (function() " + _0x54feee(430) + ");")();
    } catch (_0x16f23b) {
      _0x2e7ada = window;
    }
    return _0x2e7ada;
  }, _0x357e52 = _0x55d76c(), _0x35b28b = _0x357e52["console"] = _0x357e52[_0x4dba51(437)] || {}, _0x36c3e5 = [_0x4dba51(421), _0x4dba51(425), _0x4dba51(435), "error", "exception", _0x4dba51(429), "trace"];
  for (let _0x201487 = 0; _0x201487 < _0x36c3e5[_0x4dba51(436)]; _0x201487++) {
    const _0x394ea2 = _0x56ec64[_0x4dba51(423)][_0x4dba51(418)]["bind"](_0x56ec64), _0x2f25fe = _0x36c3e5[_0x201487], _0xdd8c78 = _0x35b28b[_0x2f25fe] || _0x394ea2;
    _0x394ea2["__proto__"] = _0x56ec64[_0x4dba51(422)](_0x56ec64), _0x394ea2["toString"] = _0xdd8c78["toString"][_0x4dba51(422)](_0xdd8c78), _0x35b28b[_0x2f25fe] = _0x394ea2;
  }
});
_0x28642a();
function validateTrainTypeCompatibility({ newTrackType: _0x40b659, startPoint: _0x2c4f0e, hoveredPoint: _0x21a087, tracks: _0x3b09f2, trackGroups: _0x241852 }) {
  const _0x4d2b58 = _0x45cc;
  if (_0x2c4f0e?.[_0x4d2b58(416)]) {
    const _0x5f3bb1 = getTrackTypeFromSnap(_0x2c4f0e[_0x4d2b58(416)]["trackId"], _0x2c4f0e[_0x4d2b58(416)][_0x4d2b58(426)], _0x3b09f2, _0x241852);
    if (_0x5f3bb1 && _0x5f3bb1 !== _0x40b659) return { "isValid": ![], "errorMessage": _0x4d2b58(434) + _0x40b659 + _0x4d2b58(438) + _0x5f3bb1 };
  }
  if (_0x21a087?.[_0x4d2b58(416)]) {
    const _0x5353c9 = getTrackTypeFromSnap(_0x21a087["snappedInfo"][_0x4d2b58(439)], _0x21a087[_0x4d2b58(416)]["isCenterline"], _0x3b09f2, _0x241852);
    if (_0x5353c9 && _0x5353c9 !== _0x40b659) return { "isValid": ![], "errorMessage": _0x4d2b58(434) + _0x40b659 + _0x4d2b58(438) + _0x5353c9 };
  }
  return { "isValid": !![] };
}
function getTrackTypeFromSnap(_0x2c2859, _0x1943f2, _0x131ca4, _0x506571) {
  const _0x33758f = _0x45cc;
  if (_0x1943f2) {
    const _0x311925 = _0x506571[_0x33758f(417)]((_0x454b3b) => _0x454b3b["id"] === _0x2c2859);
    return _0x311925?.[_0x33758f(420)] || null;
  } else {
    const _0x2ee46c = _0x131ca4[_0x33758f(417)]((_0x39cb6f) => _0x39cb6f["id"] === _0x2c2859);
    return _0x2ee46c?.[_0x33758f(420)] || null;
  }
}
function _0x45cc(_0x8105ea, _0x24cef1) {
  const _0xa8a97b = _0x15d9();
  return _0x45cc = function(_0x28642a2, _0x56ec642) {
    _0x28642a2 = _0x28642a2 - 414;
    let _0x3f9d02 = _0xa8a97b[_0x28642a2];
    return _0x3f9d02;
  }, _0x45cc(_0x8105ea, _0x24cef1);
}
function _0x15d9() {
  const _0x5b744d = ["606096UbWttR", "trackType", "log", "bind", "constructor", "7716890Ihtrzc", "warn", "isCenterline", "2020905LNLprX", "apply", "table", '{}.constructor("return this")( )', "3396276JMCeym", "848915yktitQ", "2dlCxlo", "Cannot connect tracks of different types. New track is ", "info", "length", "console", ", but connecting to ", "trackId", "8CQNiId", "72583JiMRQZ", "290972gRMDQa", "472SsQJTL", "snappedInfo", "find", "prototype"];
  _0x15d9 = function() {
    return _0x5b744d;
  };
  return _0x15d9();
}
(function(_0x319d66, _0x26778d) {
  const _0x5e8adc = _0x3124, _0x4eec5e = _0x319d66();
  while (!![]) {
    try {
      const _0x58e80d = -parseInt(_0x5e8adc(183)) / 1 + -parseInt(_0x5e8adc(195)) / 2 * (-parseInt(_0x5e8adc(208)) / 3) + parseInt(_0x5e8adc(222)) / 4 * (-parseInt(_0x5e8adc(172)) / 5) + -parseInt(_0x5e8adc(148)) / 6 + parseInt(_0x5e8adc(203)) / 7 * (parseInt(_0x5e8adc(146)) / 8) + -parseInt(_0x5e8adc(143)) / 9 * (parseInt(_0x5e8adc(179)) / 10) + parseInt(_0x5e8adc(213)) / 11;
      if (_0x58e80d === _0x26778d) break;
      else _0x4eec5e["push"](_0x4eec5e["shift"]());
    } catch (_0x121cdc) {
      _0x4eec5e["push"](_0x4eec5e["shift"]());
    }
  }
})(_0xeeab, 837083);
const _0x526171 = /* @__PURE__ */ (function() {
  let _0x3c7b82 = !![];
  return function(_0x615c9f, _0x127aba) {
    const _0x478ce8 = _0x3c7b82 ? function() {
      if (_0x127aba) {
        const _0x37dcbe = _0x127aba["apply"](_0x615c9f, arguments);
        return _0x127aba = null, _0x37dcbe;
      }
    } : function() {
    };
    return _0x3c7b82 = ![], _0x478ce8;
  };
})(), _0x794471 = _0x526171(void 0, function() {
  const _0x19d690 = _0x3124;
  let _0x30be8d;
  try {
    const _0x51704b = Function(_0x19d690(169) + _0x19d690(231) + ");");
    _0x30be8d = _0x51704b();
  } catch (_0x3ca8a6) {
    _0x30be8d = window;
  }
  const _0x9a29be = _0x30be8d[_0x19d690(232)] = _0x30be8d["console"] || {}, _0x3f612b = [_0x19d690(215), _0x19d690(228), "info", _0x19d690(227), _0x19d690(175), "table", _0x19d690(165)];
  for (let _0x4e10d8 = 0; _0x4e10d8 < _0x3f612b[_0x19d690(174)]; _0x4e10d8++) {
    const _0x964c25 = _0x526171["constructor"][_0x19d690(177)][_0x19d690(137)](_0x526171), _0x3b0d60 = _0x3f612b[_0x4e10d8], _0x515d72 = _0x9a29be[_0x3b0d60] || _0x964c25;
    _0x964c25[_0x19d690(187)] = _0x526171[_0x19d690(137)](_0x526171), _0x964c25[_0x19d690(184)] = _0x515d72[_0x19d690(184)][_0x19d690(137)](_0x515d72), _0x9a29be[_0x3b0d60] = _0x964c25;
  }
});
_0x794471();
function getNewTracks({ tracks: _0x4e4b5c, trackGroups: _0x3facb2, hoveredPoint: _0xa43131, startPoint: _0x2720b4, drawParallelTracks: _0x67e0c0, drawQuadTracks: _0x373e15, trackType: _0x828019, isStation: _0x3059f1, desiredElevation: _0x6504f6, trackSpatialIndex: _0x216cb5, buildingDetector: _0x4ec0fd, roadIndex: _0x3b8edd, selectedTrackType: _0x233a46 }) {
  const _0x377ee7 = _0x3124, _0x383145 = v4(), _0x2cd28d = v4(), _0x5290bb = v4(), _0x5af3dc = v4(), _0x32bb11 = _0x2720b4?.[_0x377ee7(144)]?.[_0x377ee7(139)] || null, _0x2194ee = _0xa43131?.[_0x377ee7(144)]?.[_0x377ee7(139)] || null;
  let _0x37fb56;
  if (_0x3059f1) {
    let _0x2b7f02 = _0x32bb11;
    _0x32bb11 && _0x2720b4?.[_0x377ee7(144)]?.["isStartNode"] && _0x3059f1 && (_0x2b7f02 = _0x134c1a[_0x377ee7(171)](_0x32bb11));
    const _0x320f28 = getTrainType(_0x233a46 || DEFAULT_TRACK_TYPE_ID);
    _0x37fb56 = getStationTrackCoords({ "startCoords": _0x2720b4?.["coords"] || null, "startBearing": _0x2b7f02, "cursorCoords": _0xa43131[_0x377ee7(181)], "maxStationLength": _0x320f28["stats"]["maxStationLength"] });
  } else _0x37fb56 = getTrackCoords({ "startBearing": _0x32bb11, "endBearing": _0x2194ee, "startCoords": _0x2720b4?.["coords"] || null, "endCoords": _0xa43131[_0x377ee7(181)] });
  if (!_0x37fb56) throw new Error(_0x377ee7(162));
  let _0x4df3c3 = _0x6504f6, _0x7b2d3c = _0x6504f6;
  if (_0x2720b4?.[_0x377ee7(144)]) {
    const _0x2df34b = getElevationFromSnappedTrack(_0x2720b4[_0x377ee7(144)][_0x377ee7(192)], _0x2720b4[_0x377ee7(144)][_0x377ee7(181)], _0x4e4b5c, _0x3facb2, _0x2720b4[_0x377ee7(144)][_0x377ee7(199)]);
    _0x2df34b !== null && (_0x4df3c3 = _0x2df34b);
  }
  if (_0xa43131?.["snappedInfo"] && !_0xa43131["snappedInfo"][_0x377ee7(168)]) {
    const _0x366fc8 = getElevationFromSnappedTrack(_0xa43131[_0x377ee7(144)][_0x377ee7(192)], _0xa43131["snappedInfo"][_0x377ee7(181)], _0x4e4b5c, _0x3facb2, _0xa43131[_0x377ee7(144)][_0x377ee7(199)]);
    _0x366fc8 !== null && (_0x7b2d3c = _0x366fc8);
  }
  const _0x3b37dc = _0x2720b4?.[_0x377ee7(144)]?.[_0x377ee7(199)] && _0x2720b4[_0x377ee7(144)]["isParallelCenterline"] || ![], _0x4056a6 = _0xa43131?.["snappedInfo"]?.[_0x377ee7(199)] && _0xa43131[_0x377ee7(144)][_0x377ee7(170)] || ![];
  if (_0x3b37dc || _0x4056a6) {
    const _0x347430 = _0x134c1a[_0x377ee7(196)](_0x37fb56);
    let _0x59fd62 = null;
    if (_0x3b37dc && _0x4056a6) {
      const _0x46b030 = [getTrackCoords({ "startCoords": _0x2720b4[_0x377ee7(181)], "endCoords": _0xa43131[_0x377ee7(181)], "startBearing": _0x32bb11, "endBearing": _0x2194ee }), getTrackCoords({ "startCoords": _0x2720b4["coords"], "endCoords": _0xa43131["coords"], "startBearing": _0x32bb11 ? _0x134c1a[_0x377ee7(171)](_0x32bb11) : null, "endBearing": _0x2194ee }), getTrackCoords({ "startCoords": _0x2720b4[_0x377ee7(181)], "endCoords": _0xa43131[_0x377ee7(181)], "startBearing": _0x32bb11, "endBearing": _0x2194ee ? _0x134c1a[_0x377ee7(171)](_0x2194ee) : null }), getTrackCoords({ "startCoords": _0x2720b4["coords"], "endCoords": _0xa43131["coords"], "startBearing": _0x32bb11 ? _0x134c1a[_0x377ee7(171)](_0x32bb11) : null, "endBearing": _0x2194ee ? reverseBearing(_0x2194ee) : null })]["filter"](Boolean);
      _0x59fd62 = _0x46b030[_0x377ee7(166)]((_0x379a8b) => _0x379a8b !== void 0)["reduce"]((_0xc0781, _0x2a81b5) => {
        const _0xa8df7f = _0x377ee7, _0x489afe = _0x134c1a[_0xa8df7f(196)](_0x2a81b5);
        return _0x489afe < _0x134c1a[_0xa8df7f(196)](_0xc0781) ? _0x2a81b5 : _0xc0781;
      }, _0x37fb56);
    } else {
      if (_0x3b37dc) {
        const _0xb44f61 = _0x32bb11 ? _0x134c1a[_0x377ee7(171)](_0x32bb11) : null;
        _0x59fd62 = getTrackCoords({ "startCoords": _0x2720b4[_0x377ee7(181)], "endCoords": _0xa43131[_0x377ee7(181)], "startBearing": _0xb44f61, "endBearing": _0x2194ee });
      } else {
        if (_0x4056a6) {
          const _0x46ee63 = _0x2194ee ? _0x134c1a[_0x377ee7(171)](_0x2194ee) : null;
          _0x59fd62 = getTrackCoords({ "startCoords": _0x2720b4[_0x377ee7(181)], "endCoords": _0xa43131[_0x377ee7(181)], "startBearing": _0x32bb11, "endBearing": _0x46ee63 });
        }
      }
    }
    if (_0x59fd62) {
      const _0x51fc98 = _0x134c1a[_0x377ee7(196)](_0x59fd62);
      _0x51fc98 < _0x347430 && (_0x37fb56 = _0x59fd62);
    }
  }
  if (!_0x67e0c0 && !_0x373e15) {
    const _0x1d2829 = { "id": _0x383145, "coords": _0x134c1a[_0x377ee7(153)](_0x37fb56), "buildType": _0x828019, "displayType": _0x828019, "type": _0x3059f1 ? _0x377ee7(201) : null, "reversable": _0x3059f1, "interactable": !![], "length": _0x134c1a[_0x377ee7(202)](_0x37fb56), "startElevation": _0x4df3c3, "endElevation": _0x7b2d3c, "trackType": _0x233a46 || DEFAULT_TRACK_TYPE_ID }, _0x24684f = validateTrack(_0x1d2829), _0x310eb2 = validateTrackSlope(_0x1d2829[_0x377ee7(181)], _0x1d2829[_0x377ee7(219)], _0x1d2829[_0x377ee7(205)]), _0x115703 = validateTrainTypeCompatibility({ "newTrackType": _0x1d2829["trackType"] || DEFAULT_TRACK_TYPE_ID, "startPoint": _0x2720b4, "hoveredPoint": _0xa43131, "tracks": _0x4e4b5c, "trackGroups": _0x3facb2 }), _0x21e2be = /* @__PURE__ */ new Set();
    if (_0x2720b4?.["snappedInfo"]) {
      if (_0x2720b4[_0x377ee7(144)][_0x377ee7(199)]) {
        const _0x365f7a = _0x3facb2[_0x377ee7(212)]((_0x2e459e) => _0x2e459e["id"] === _0x2720b4[_0x377ee7(144)]?.[_0x377ee7(192)]);
        if (_0x365f7a) _0x365f7a[_0x377ee7(155)]["forEach"]((_0x55bb88) => _0x21e2be[_0x377ee7(233)](_0x55bb88));
      } else _0x21e2be[_0x377ee7(233)](_0x2720b4[_0x377ee7(144)]["trackId"]);
    }
    if (_0xa43131?.["snappedInfo"]) {
      if (_0xa43131[_0x377ee7(144)][_0x377ee7(199)]) {
        const _0x5a58c5 = _0x3facb2[_0x377ee7(212)]((_0x5ddd40) => _0x5ddd40["id"] === _0xa43131[_0x377ee7(144)]?.[_0x377ee7(192)]);
        if (_0x5a58c5) _0x5a58c5[_0x377ee7(155)][_0x377ee7(158)]((_0xcfb2d0) => _0x21e2be[_0x377ee7(233)](_0xcfb2d0));
      } else _0x21e2be[_0x377ee7(233)](_0xa43131[_0x377ee7(144)][_0x377ee7(192)]);
    }
    const _0x2f16d2 = _0x4e4b5c[_0x377ee7(166)]((_0x4bbd5d) => !_0x21e2be["has"](_0x4bbd5d["id"])), _0x4feca9 = validateTrackOverlap({ "newTrackCoords": _0x1d2829[_0x377ee7(181)], "newTrackStartElevation": _0x1d2829[_0x377ee7(219)], "newTrackEndElevation": _0x1d2829["endElevation"], "isStation": _0x3059f1, "newTrackLanes": 1, "existingTracks": _0x2f16d2, "trackGroups": _0x3facb2, "trackSpatialIndex": _0x216cb5 }), _0x2c5498 = _0x4ec0fd ? validateBuildingCollision([_0x1d2829], _0x4ec0fd) : { "isValid": !![] }, _0x3a7186 = _0x3b8edd ? validateRoadCollision([_0x1d2829], _0x3b8edd) : { "isValid": !![] }, _0x9bc1a = { "isValid": _0x24684f[_0x377ee7(235)] && _0x310eb2[_0x377ee7(235)] && _0x115703[_0x377ee7(235)] && _0x4feca9[_0x377ee7(235)] && _0x3a7186[_0x377ee7(235)], "errorMessage": _0x24684f["errorMessage"] || _0x310eb2[_0x377ee7(178)] || _0x115703[_0x377ee7(178)] || _0x4feca9[_0x377ee7(178)] || _0x3a7186[_0x377ee7(178)], "buildingCollisionDetails": _0x2c5498[_0x377ee7(150)], "roadCollisionDetails": _0x3a7186["collisionDetails"] };
    return { "newTracks": [_0x1d2829], "newTrackGroups": [{ "id": v4(), "trackIds": [_0x383145], "trackLanesType": _0x377ee7(157), "centerLine": _0x134c1a[_0x377ee7(153)](_0x37fb56), "type": _0x3059f1 ? _0x377ee7(201) : null, "trackType": _0x233a46 || DEFAULT_TRACK_TYPE_ID }], "validation": { "isValid": _0x9bc1a[_0x377ee7(235)], "errorMessage": _0x9bc1a["errorMessage"], "invalidTrackIds": _0x9bc1a[_0x377ee7(235)] ? void 0 : [_0x1d2829["id"]], "buildingCollisionDetails": _0x9bc1a["buildingCollisionDetails"], "roadCollisionDetails": _0x9bc1a[_0x377ee7(198)] } };
  }
  let _0xad244a, _0x18a175, _0xdcdc64, _0x31cb8e;
  if (_0x373e15) {
    const [_0x14c9b5, _0x2efcf8, _0x336d79, _0x20616c] = generateQuadTracks(_0x37fb56);
    _0xad244a = _0x14c9b5, _0xdcdc64 = _0x2efcf8, _0x31cb8e = _0x336d79[_0x377ee7(190)](), _0x18a175 = _0x20616c[_0x377ee7(190)]();
  } else {
    const [_0x2c8aae, _0x110af1] = generateParallelTracks(_0x37fb56);
    _0xad244a = _0x2c8aae, _0x18a175 = _0x110af1[_0x377ee7(190)]();
  }
  const _0x14d9a5 = [];
  _0x828019 === "preview" && (_0x14d9a5[_0x377ee7(189)]({ "id": _0x377ee7(180), "coords": _0x134c1a[_0x377ee7(153)](_0x37fb56), "buildType": _0x377ee7(218), "displayType": _0x377ee7(160), "type": _0x3059f1 ? _0x373e15 ? "express-station" : "station" : null, "reversable": _0x3059f1, "interactable": !![], "length": getLineLength(_0x37fb56), "startElevation": _0x4df3c3, "endElevation": _0x7b2d3c }), _0x14d9a5["push"]({ "id": _0x377ee7(188), "coords": _0x134c1a[_0x377ee7(153)]([..._0xad244a]), "buildType": _0x377ee7(218), "displayType": _0x377ee7(167), "type": _0x3059f1 ? _0x373e15 ? _0x377ee7(154) : _0x377ee7(201) : null, "reversable": _0x3059f1, "interactable": !![], "length": _0x134c1a[_0x377ee7(202)](_0xad244a), "startElevation": _0x4df3c3, "endElevation": _0x7b2d3c }), _0x373e15 && _0xdcdc64 && _0x31cb8e ? (_0x14d9a5["push"]({ "id": _0x377ee7(156), "coords": roundCoordinates([..._0xdcdc64]), "buildType": _0x377ee7(218), "displayType": _0x377ee7(167), "type": _0x3059f1 ? _0x377ee7(154) : null, "reversable": _0x3059f1, "interactable": !![], "length": _0x134c1a[_0x377ee7(202)](_0xdcdc64), "startElevation": _0x4df3c3, "endElevation": _0x7b2d3c }), _0x14d9a5[_0x377ee7(189)]({ "id": _0x377ee7(152), "coords": _0x134c1a[_0x377ee7(153)]([..._0x31cb8e]), "buildType": _0x377ee7(218), "displayType": "preview-connected", "type": _0x3059f1 ? _0x377ee7(154) : null, "reversable": _0x3059f1, "interactable": !![], "length": getLineLength(_0x31cb8e), "startElevation": _0x7b2d3c, "endElevation": _0x4df3c3 }), _0x14d9a5[_0x377ee7(189)]({ "id": _0x377ee7(176), "coords": _0x134c1a[_0x377ee7(153)]([..._0x18a175]), "buildType": _0x377ee7(218), "displayType": "preview-connected", "type": _0x3059f1 ? _0x377ee7(154) : null, "reversable": _0x3059f1, "interactable": !![], "length": _0x134c1a[_0x377ee7(202)](_0x18a175), "startElevation": _0x7b2d3c, "endElevation": _0x4df3c3 })) : _0x14d9a5[_0x377ee7(189)]({ "id": _0x377ee7(156), "coords": roundCoordinates([..._0x18a175]), "buildType": _0x377ee7(218), "displayType": _0x377ee7(167), "type": _0x3059f1 ? _0x377ee7(154) : null, "reversable": _0x3059f1, "interactable": !![], "length": _0x134c1a[_0x377ee7(202)](_0x18a175), "startElevation": _0x7b2d3c, "endElevation": _0x4df3c3 }));
  const _0x5681fa = (_0x67e0c0 || _0x373e15) && isSnappingToParallelGroup(_0xa43131[_0x377ee7(144)], _0x3facb2), _0x18ebc4 = (_0x67e0c0 || _0x373e15) && isSnappingToParallelGroup(_0x2720b4[_0x377ee7(144)], _0x3facb2);
  if (_0x5681fa && _0xa43131["snappedInfo"] && !_0xa43131[_0x377ee7(144)][_0x377ee7(168)]) {
    const _0x48cad2 = _0x3facb2[_0x377ee7(212)]((_0x5ec6af) => _0x5ec6af["id"] === _0xa43131[_0x377ee7(144)]?.[_0x377ee7(192)]);
    if (!_0x48cad2) console[_0x377ee7(228)](_0x377ee7(185));
    else {
      const _0x2924b8 = _0x4e4b5c[_0x377ee7(166)]((_0x2d0ac8) => _0x48cad2[_0x377ee7(155)][_0x377ee7(221)](_0x2d0ac8["id"])), _0x3e23f3 = [];
      _0x3e23f3[_0x377ee7(189)]({ "coords": _0xad244a, "endpoint": _0xad244a[_0xad244a[_0x377ee7(174)] - 1], "targetIndex": _0xad244a[_0x377ee7(174)] - 1 }), _0x3e23f3[_0x377ee7(189)]({ "coords": _0x18a175, "endpoint": _0x18a175[0], "targetIndex": 0 });
      _0x373e15 && _0xdcdc64 && _0x31cb8e && (_0x3e23f3["push"]({ "coords": _0xdcdc64, "endpoint": _0xdcdc64[_0xdcdc64[_0x377ee7(174)] - 1], "targetIndex": _0xdcdc64["length"] - 1 }), _0x3e23f3[_0x377ee7(189)]({ "coords": _0x31cb8e, "endpoint": _0x31cb8e[0], "targetIndex": 0 }));
      const _0x423638 = _0x373e15 && _0x48cad2[_0x377ee7(142)] === _0x377ee7(214), _0x3d3be7 = _0x423638 ? _0x3e23f3[_0x377ee7(182)](0, 2) : _0x3e23f3;
      _0x3d3be7["forEach"]((_0x15e990) => {
        const _0x2a51d1 = _0x377ee7, _0x792e99 = findClosestTrackToPoint(_0x2924b8, _0x15e990["endpoint"]), _0x116af1 = _0x2924b8[_0x792e99], _0x145cfd = _0x134c1a[_0x2a51d1(138)](_0x116af1[_0x2a51d1(181)][0], _0x15e990["endpoint"]) <= _0x134c1a[_0x2a51d1(138)](_0x116af1[_0x2a51d1(181)][_0x116af1[_0x2a51d1(181)][_0x2a51d1(174)] - 1], _0x15e990[_0x2a51d1(173)]), _0xf857bf = _0x116af1[_0x2a51d1(181)][_0x145cfd ? 0 : _0x116af1["coords"][_0x2a51d1(174)] - 1];
        _0x15e990[_0x2a51d1(181)][_0x15e990[_0x2a51d1(211)]] = _0xf857bf;
        const _0x2d2d19 = _0x134c1a[_0x2a51d1(138)](_0x15e990[_0x2a51d1(173)], _0xf857bf);
        if (_0x2d2d19 > 5) console["warn"]("End track endpoint moved: " + _0x2d2d19 + _0x2a51d1(234));
      });
    }
  }
  if (_0x18ebc4 && _0x2720b4[_0x377ee7(144)] && !_0x2720b4["snappedInfo"][_0x377ee7(168)]) {
    const _0xa412b4 = _0x3facb2[_0x377ee7(212)]((_0x2d7d6d) => _0x2d7d6d["id"] === _0x2720b4[_0x377ee7(144)]?.[_0x377ee7(192)]);
    if (!_0xa412b4) console[_0x377ee7(228)](_0x377ee7(200));
    else {
      const _0x1c0565 = _0x4e4b5c[_0x377ee7(166)]((_0x40a88e) => _0xa412b4[_0x377ee7(155)]["includes"](_0x40a88e["id"])), _0x1ef4c7 = [];
      _0x1ef4c7[_0x377ee7(189)]({ "coords": _0xad244a, "endpoint": _0xad244a[0], "targetIndex": 0 }), _0x1ef4c7[_0x377ee7(189)]({ "coords": _0x18a175, "endpoint": _0x18a175[_0x18a175[_0x377ee7(174)] - 1], "targetIndex": _0x18a175[_0x377ee7(174)] - 1 });
      _0x373e15 && _0xdcdc64 && _0x31cb8e && (_0x1ef4c7["push"]({ "coords": _0xdcdc64, "endpoint": _0xdcdc64[0], "targetIndex": 0 }), _0x1ef4c7[_0x377ee7(189)]({ "coords": _0x31cb8e, "endpoint": _0x31cb8e[_0x31cb8e[_0x377ee7(174)] - 1], "targetIndex": _0x31cb8e[_0x377ee7(174)] - 1 }));
      const _0x3908d4 = _0x373e15 && _0xa412b4[_0x377ee7(142)] === _0x377ee7(214), _0x108f60 = _0x3908d4 ? _0x1ef4c7[_0x377ee7(182)](0, 2) : _0x1ef4c7;
      _0x108f60[_0x377ee7(158)]((_0x2b24a3) => {
        const _0xf3184 = _0x377ee7, _0x49defe = findClosestTrackToPoint(_0x1c0565, _0x2b24a3[_0xf3184(173)]), _0xcc5b54 = _0x1c0565[_0x49defe], _0x2367a7 = _0x134c1a[_0xf3184(138)](_0xcc5b54[_0xf3184(181)][0], _0x2b24a3[_0xf3184(173)]) <= _0x134c1a[_0xf3184(138)](_0xcc5b54[_0xf3184(181)][_0xcc5b54[_0xf3184(181)][_0xf3184(174)] - 1], _0x2b24a3[_0xf3184(173)]), _0x7738d4 = _0xcc5b54[_0xf3184(181)][_0x2367a7 ? 0 : _0xcc5b54[_0xf3184(181)][_0xf3184(174)] - 1];
        _0x2b24a3[_0xf3184(181)][_0x2b24a3[_0xf3184(211)]] = _0x7738d4;
        const _0x11d047 = _0x134c1a[_0xf3184(138)](_0x2b24a3[_0xf3184(173)], _0x7738d4);
        if (_0x11d047 > 5) console["warn"]("Start track endpoint moved: " + _0x11d047 + " meters");
      });
    }
  }
  const _0x1944a4 = roundCoordinates(_0xad244a), _0x329e5a = _0x134c1a[_0x377ee7(153)](_0x18a175), _0x1ea2fa = _0x134c1a[_0x377ee7(153)](_0x37fb56);
  let _0x3839de = null;
  const _0x25a49c = { "id": _0x383145, "coords": _0x1944a4, "buildType": _0x828019, "displayType": _0x828019, "type": _0x3059f1 ? _0x373e15 ? _0x377ee7(154) : _0x377ee7(201) : null, "reversable": _0x3059f1, "interactable": !![], "length": getLineLength(_0x1944a4), "startElevation": _0x4df3c3, "endElevation": _0x7b2d3c, "trackType": _0x233a46 || DEFAULT_TRACK_TYPE_ID }, _0x34a299 = { "id": _0x2cd28d, "coords": _0x329e5a, "buildType": _0x828019, "displayType": _0x828019, "type": _0x3059f1 ? _0x373e15 ? _0x377ee7(154) : "station" : null, "reversable": _0x3059f1, "interactable": !![], "length": getLineLength(_0x329e5a), "startElevation": _0x7b2d3c, "endElevation": _0x4df3c3, "trackType": _0x233a46 || DEFAULT_TRACK_TYPE_ID };
  let _0x4c42ea, _0x2434ab;
  if (_0x373e15 && _0xdcdc64 && _0x31cb8e) {
    const _0x375732 = _0x134c1a[_0x377ee7(153)](_0xdcdc64), _0x521f4e = _0x134c1a[_0x377ee7(153)](_0x31cb8e);
    _0x4c42ea = { "id": _0x5290bb, "coords": _0x375732, "buildType": _0x828019, "displayType": _0x828019, "type": _0x3059f1 ? _0x377ee7(154) : null, "reversable": _0x3059f1, "interactable": !![], "length": _0x134c1a[_0x377ee7(202)](_0x375732), "startElevation": _0x4df3c3, "endElevation": _0x7b2d3c, "trackType": _0x233a46 || DEFAULT_TRACK_TYPE_ID }, _0x2434ab = { "id": _0x5af3dc, "coords": _0x521f4e, "buildType": _0x828019, "displayType": _0x828019, "type": _0x3059f1 ? _0x377ee7(154) : null, "reversable": _0x3059f1, "interactable": !![], "length": _0x134c1a[_0x377ee7(202)](_0x521f4e), "startElevation": _0x7b2d3c, "endElevation": _0x4df3c3, "trackType": _0x233a46 || DEFAULT_TRACK_TYPE_ID };
  }
  const _0x39d765 = validateTrack(_0x25a49c);
  if (!_0x39d765[_0x377ee7(235)]) _0x3839de = _0x39d765[_0x377ee7(178)] || null;
  const _0x2ce118 = validateTrack(_0x34a299);
  if (!_0x2ce118[_0x377ee7(235)]) _0x3839de = _0x2ce118[_0x377ee7(178)] || null;
  const _0x55c3f2 = validateTrainTypeCompatibility({ "newTrackType": _0x25a49c[_0x377ee7(223)] || DEFAULT_TRACK_TYPE_ID, "startPoint": _0x2720b4, "hoveredPoint": _0xa43131, "tracks": _0x4e4b5c, "trackGroups": _0x3facb2 });
  if (!_0x55c3f2["isValid"]) _0x3839de = _0x55c3f2["errorMessage"] || null;
  const _0x19513d = validateTrackSlope(_0x25a49c["coords"], _0x25a49c[_0x377ee7(219)], _0x25a49c["endElevation"]);
  if (!_0x19513d["isValid"]) _0x3839de = _0x19513d[_0x377ee7(178)] || null;
  const _0x294c4c = validateTrackSlope(_0x34a299["coords"], _0x34a299[_0x377ee7(219)], _0x34a299[_0x377ee7(205)]);
  if (!_0x294c4c[_0x377ee7(235)]) _0x3839de = _0x294c4c[_0x377ee7(178)] || null;
  if (_0x4c42ea && _0x2434ab) {
    const _0x4d7de6 = validateTrack(_0x4c42ea);
    if (!_0x4d7de6["isValid"]) _0x3839de = _0x4d7de6["errorMessage"] || null;
    const _0x57c22f = validateTrack(_0x2434ab);
    if (!_0x57c22f[_0x377ee7(235)]) _0x3839de = _0x57c22f[_0x377ee7(178)] || null;
    const _0x489156 = validateTrackSlope(_0x4c42ea[_0x377ee7(181)], _0x4c42ea[_0x377ee7(219)], _0x4c42ea[_0x377ee7(205)]);
    if (!_0x489156[_0x377ee7(235)]) _0x3839de = _0x489156["errorMessage"] || null;
    const _0x32ef8e = validateTrackSlope(_0x2434ab[_0x377ee7(181)], _0x2434ab[_0x377ee7(219)], _0x2434ab[_0x377ee7(205)]);
    if (!_0x32ef8e[_0x377ee7(235)]) _0x3839de = _0x32ef8e[_0x377ee7(178)] || null;
  }
  const _0x561c50 = /* @__PURE__ */ new Set();
  if (_0x2720b4?.["snappedInfo"]) {
    if (_0x2720b4["snappedInfo"][_0x377ee7(199)]) {
      const _0x5d0128 = _0x3facb2[_0x377ee7(212)]((_0x135093) => _0x135093["id"] === _0x2720b4[_0x377ee7(144)]?.[_0x377ee7(192)]);
      if (_0x5d0128) _0x5d0128[_0x377ee7(155)]["forEach"]((_0xaca605) => _0x561c50[_0x377ee7(233)](_0xaca605));
    } else _0x561c50["add"](_0x2720b4[_0x377ee7(144)][_0x377ee7(192)]);
  }
  if (_0xa43131?.[_0x377ee7(144)]) {
    if (_0xa43131[_0x377ee7(144)][_0x377ee7(199)]) {
      const _0x22e6bb = _0x3facb2["find"]((_0x1e64f0) => _0x1e64f0["id"] === _0xa43131[_0x377ee7(144)]?.["trackId"]);
      if (_0x22e6bb) _0x22e6bb[_0x377ee7(155)]["forEach"]((_0x384be0) => _0x561c50[_0x377ee7(233)](_0x384be0));
    } else _0x561c50[_0x377ee7(233)](_0xa43131[_0x377ee7(144)][_0x377ee7(192)]);
  }
  const _0x1fc573 = _0x4e4b5c[_0x377ee7(166)]((_0x24267f) => !_0x561c50[_0x377ee7(207)](_0x24267f["id"])), _0x389c94 = validateElevationGapAtIntersections(_0x25a49c, _0x1fc573);
  if (!_0x389c94[_0x377ee7(235)]) _0x3839de = _0x389c94[_0x377ee7(178)] || null;
  const _0x91db25 = validateElevationGapAtIntersections(_0x34a299, _0x1fc573);
  if (!_0x91db25["isValid"]) _0x3839de = _0x91db25[_0x377ee7(178)] || null;
  if (_0x4c42ea && _0x2434ab) {
    const _0x38a692 = validateElevationGapAtIntersections(_0x4c42ea, _0x1fc573);
    if (!_0x38a692["isValid"]) _0x3839de = _0x38a692[_0x377ee7(178)] || null;
    const _0x4c2990 = validateElevationGapAtIntersections(_0x2434ab, _0x1fc573);
    if (!_0x4c2990["isValid"]) _0x3839de = _0x4c2990[_0x377ee7(178)] || null;
  }
  _0x14d9a5[_0x377ee7(189)](_0x25a49c, _0x34a299);
  _0x4c42ea && _0x2434ab && _0x14d9a5[_0x377ee7(189)](_0x4c42ea, _0x2434ab);
  if (_0x3839de === null) {
    const _0x33cd89 = validateTrackOverlap({ "newTrackCoords": _0x37fb56, "newTrackLanes": _0x373e15 ? 4 : 2, "existingTracks": _0x1fc573, "isStation": _0x3059f1, "newTrackStartElevation": _0x14d9a5[0]["startElevation"], "newTrackEndElevation": _0x14d9a5[0]["endElevation"], "trackGroups": _0x3facb2, "trackSpatialIndex": _0x216cb5 });
    !_0x33cd89[_0x377ee7(235)] && (_0x3839de = _0x33cd89[_0x377ee7(178)] || "Track overlap validation failed");
  }
  let _0x4b1537 = { "isValid": !![] };
  _0x3839de === null && _0x4ec0fd && (_0x4b1537 = validateBuildingCollision(_0x14d9a5[_0x377ee7(166)]((_0x7b3605) => _0x7b3605[_0x377ee7(216)] !== _0x377ee7(218) || _0x7b3605[_0x377ee7(159)] !== _0x377ee7(160)), _0x4ec0fd), !_0x4b1537[_0x377ee7(235)] && _0x828019 !== _0x377ee7(217) && (_0x3839de = _0x4b1537[_0x377ee7(178)] || _0x377ee7(186)));
  let _0x5ad220 = { "isValid": !![] };
  _0x3839de === null && _0x3b8edd && (_0x5ad220 = validateRoadCollision(_0x14d9a5["filter"]((_0x51092a) => _0x51092a[_0x377ee7(216)] !== _0x377ee7(218) || _0x51092a[_0x377ee7(159)] !== _0x377ee7(160)), _0x3b8edd), !_0x5ad220[_0x377ee7(235)] && (_0x3839de = _0x5ad220["errorMessage"] || _0x377ee7(149)));
  const _0xda0909 = _0x373e15 && _0x4c42ea && _0x2434ab ? [_0x383145, _0x5290bb, _0x5af3dc, _0x2cd28d] : [_0x383145, _0x2cd28d];
  return { "newTracks": _0x14d9a5, "newTrackGroups": [{ "id": v4(), "trackIds": _0xda0909, "trackLanesType": _0x373e15 ? _0x377ee7(229) : _0x377ee7(214), "centerLine": _0x1ea2fa, "type": _0x3059f1 ? _0x377ee7(201) : null, "trackType": _0x233a46 || DEFAULT_TRACK_TYPE_ID }], "validation": { "isValid": _0x3839de === null, "errorMessage": _0x3839de || void 0, "invalidTrackIds": _0x3839de ? _0xda0909 : void 0, "buildingCollisionDetails": _0x4b1537["collisionDetails"], "roadCollisionDetails": _0x5ad220[_0x377ee7(150)] } };
}
function validateTrack(_0x17b238) {
  forceBuild()
  if (allowForceBuild) return { "isValid": !![] };
  const _0x45ba86 = _0x3124;
  if (_0x17b238[_0x45ba86(181)][_0x45ba86(174)] < 2) return { "isValid": ![], "errorMessage": "Track has insufficient points" };
  if (_0x17b238[_0x45ba86(174)] < RULES[_0x45ba86(226)]) return { "isValid": ![], "errorMessage": "Track is too short (" + _0x17b238[_0x45ba86(174)][_0x45ba86(147)](1) + _0x45ba86(191) + RULES["MIN_TRACK_LENGTH"] + "m." };
  if (_0x17b238[_0x45ba86(174)] > RULES[_0x45ba86(210)] + 0.1) return { "isValid": ![], "errorMessage": "Track is too long (" + _0x17b238[_0x45ba86(174)][_0x45ba86(147)](1) + "m). Maximum length is " + RULES["MAX_TRACK_LENGTH"] + "m." };
  const _0xb80881 = _0x17b238[_0x45ba86(163)] === _0x45ba86(201) || _0x17b238[_0x45ba86(163)] === _0x45ba86(154), _0x421bfb = getTrainType(_0x17b238[_0x45ba86(223)]);
  if (_0xb80881 && _0x17b238[_0x45ba86(174)] < _0x421bfb[_0x45ba86(151)]["minStationLength"]) return { "isValid": ![], "errorMessage": "Station is too short (" + _0x17b238[_0x45ba86(174)][_0x45ba86(147)](1) + _0x45ba86(191) + _0x421bfb[_0x45ba86(151)][_0x45ba86(230)] + "m." };
  if (_0xb80881 && _0x17b238[_0x45ba86(174)] > _0x421bfb[_0x45ba86(151)]["maxStationLength"] + 0.2) return { "isValid": ![], "errorMessage": _0x45ba86(145) + _0x17b238[_0x45ba86(174)][_0x45ba86(147)](1) + _0x45ba86(193) + _0x421bfb[_0x45ba86(151)]["maxStationLength"] + "m." };
  if (_0xb80881 && _0x17b238[_0x45ba86(181)]["length"] > 2) return { "isValid": ![], "errorMessage": "Station tracks can not be curved" };
  const _0x3a2af5 = Math[_0x45ba86(206)](_0x17b238[_0x45ba86(219)] - _0x17b238["endElevation"]);
  if (_0xb80881 && _0x3a2af5 > 0.1) return { "isValid": ![], "errorMessage": "Station tracks must start and end at the same elevation" };
  if (!_0xb80881 && _0x17b238["coords"][_0x45ba86(174)] > 2) {
    const _0x27500d = validateTrackCurvature(_0x17b238[_0x45ba86(181)]);
    if (!_0x27500d[_0x45ba86(235)]) return _0x27500d;
  }
  return { "isValid": !![] };
}
function _0xeeab() {
  const _0x40d332 = ["Building collision detected", "__proto__", "preview-track-1", "push", "reverse", "m). Minimum length is ", "trackId", "m). Maximum length is ", "getBearing", "940xlpfqJ", "getLineDistance", "destination", "roadCollisionDetails", "isCenterline", "Snapped group not found at start point", "station", "getLineLength", "63FItyfP", "point", "endElevation", "abs", "has", "6507bATvQq", "coordinates", "MAX_TRACK_LENGTH", "targetIndex", "find", "29400349VwWOfe", "parallel", "log", "buildType", "blueprint", "preview", "startElevation", "PARALLEL_TRACKS_SPACING", "includes", "5064148WoTltW", "trackType", "some", "lineString", "MIN_TRACK_LENGTH", "error", "warn", "quad", "minStationLength", '{}.constructor("return this")( )', "console", "add", " meters", "isValid", "bind", "getDistanceBetweenPoints", "bearing", "geometry", "TRACK_WIDTH", "trackLanesType", "99mdOPdB", "snappedInfo", "Station is too long (", "329496TPCszd", "toFixed", "8014920LBztgo", "Road collision detected", "collisionDetails", "stats", "preview-track-3", "roundCoordinates", "express-station", "trackIds", "preview-track-2", "single", "forEach", "displayType", "preview-center", "meters", "No new centerline coords found", "type", "lineSlice", "trace", "filter", "preview-connected", "isLineSnap", "return (function() ", "isParallelCenterline", "reverseBearing", "5znAaAn", "endpoint", "length", "exception", "preview-track-4", "prototype", "errorMessage", "393560MhSmxk", "preview-centerline", "coords", "slice", "191016XTJXzf", "toString", "Snapped group not found at end point"];
  _0xeeab = function() {
    return _0x40d332;
  };
  return _0xeeab();
}
function getStationTrackCoords({ startCoords: _0x2d5fdd, startBearing: _0x4ac22b, cursorCoords: _0x1e4891, maxStationLength: _0x1475be }) {
  const _0x5ee46f = _0x3124;
  !_0x4ac22b && (_0x4ac22b = _0x134c1a[_0x5ee46f(194)](_0x2d5fdd, _0x1e4891));
  const _0x5dec0b = _0x24b10a[_0x5ee46f(197)](point$3(_0x2d5fdd), _0x1475be, _0x4ac22b, { "units": _0x5ee46f(161) }), _0x564f78 = _0x24b10a[_0x5ee46f(225)]([_0x2d5fdd, _0x5dec0b[_0x5ee46f(140)][_0x5ee46f(209)]]), _0x20dc5f = nearestPointOnLine(_0x564f78, _0x24b10a[_0x5ee46f(204)](_0x1e4891)), _0x59e2e4 = lineString([_0x2d5fdd, _0x20dc5f[_0x5ee46f(140)][_0x5ee46f(209)]]), _0x8135d4 = _0x59e2e4[_0x5ee46f(140)][_0x5ee46f(209)];
  return _0x8135d4;
}
function findClosestTrackToPoint(_0x39fe62, _0x1691bf) {
  let _0x3cb8ed = Infinity, _0x200fae = 0;
  return _0x39fe62["forEach"]((_0x2a717e, _0x2f93f7) => {
    const _0x53fca7 = _0x3124, _0x5cf034 = _0x134c1a[_0x53fca7(138)](_0x2a717e[_0x53fca7(181)][0], _0x1691bf), _0x373c5d = getDistanceBetweenPoints(_0x2a717e[_0x53fca7(181)][_0x2a717e["coords"][_0x53fca7(174)] - 1], _0x1691bf), _0x5f5115 = Math["min"](_0x5cf034, _0x373c5d);
    _0x5f5115 < _0x3cb8ed && (_0x3cb8ed = _0x5f5115, _0x200fae = _0x2f93f7);
  }), _0x200fae;
}
function generateQuadTracks(_0x2b3217) {
  const _0x49f5fd = _0x3124, _0x341943 = [], _0x166a33 = [], _0x50d45c = [], _0x4adb94 = [], _0x5d3654 = lineString(_0x2b3217), _0x1f43de = RULES[_0x49f5fd(141)] / 2 + RULES[_0x49f5fd(220)] / 2, _0x580779 = _0x1f43de + RULES[_0x49f5fd(141)] + RULES[_0x49f5fd(220)];
  for (let _0x1ba5ce = 0; _0x1ba5ce < _0x2b3217[_0x49f5fd(174)]; _0x1ba5ce++) {
    let _0x4aad46;
    if (_0x1ba5ce === 0) _0x4aad46 = _0x24b10a[_0x49f5fd(139)](_0x24b10a[_0x49f5fd(204)](_0x2b3217[0]), _0x24b10a[_0x49f5fd(204)](_0x2b3217[1]));
    else {
      if (_0x1ba5ce === _0x2b3217["length"] - 1) _0x4aad46 = bearing(_0x24b10a[_0x49f5fd(204)](_0x2b3217[_0x2b3217[_0x49f5fd(174)] - 2]), _0x24b10a[_0x49f5fd(204)](_0x2b3217[_0x2b3217[_0x49f5fd(174)] - 1]));
      else {
        const _0x2d8f95 = _0x24b10a[_0x49f5fd(164)](point$3(_0x2b3217[_0x1ba5ce - 1]), _0x24b10a[_0x49f5fd(204)](_0x2b3217[_0x1ba5ce + 1]), _0x5d3654);
        _0x4aad46 = _0x24b10a[_0x49f5fd(139)](_0x24b10a[_0x49f5fd(204)](_0x2d8f95[_0x49f5fd(140)]["coordinates"][0]), _0x24b10a[_0x49f5fd(204)](_0x2d8f95[_0x49f5fd(140)][_0x49f5fd(209)][_0x2d8f95["geometry"][_0x49f5fd(209)][_0x49f5fd(174)] - 1]));
      }
    }
    const _0x27bb1c = _0x4aad46 + 90, _0x579897 = _0x4aad46 - 90, _0x4e04fc = _0x24b10a[_0x49f5fd(197)](_0x24b10a[_0x49f5fd(204)](_0x2b3217[_0x1ba5ce]), _0x580779, _0x27bb1c, { "units": _0x49f5fd(161) }), _0x2e441b = _0x24b10a[_0x49f5fd(197)](point$3(_0x2b3217[_0x1ba5ce]), _0x1f43de, _0x27bb1c, { "units": _0x49f5fd(161) }), _0x145aa2 = _0x24b10a[_0x49f5fd(197)](_0x24b10a[_0x49f5fd(204)](_0x2b3217[_0x1ba5ce]), _0x1f43de, _0x579897, { "units": _0x49f5fd(161) }), _0x1ca351 = _0x24b10a[_0x49f5fd(197)](_0x24b10a[_0x49f5fd(204)](_0x2b3217[_0x1ba5ce]), _0x580779, _0x579897, { "units": _0x49f5fd(161) });
    _0x341943[_0x49f5fd(189)](_0x4e04fc["geometry"]["coordinates"]), _0x166a33["push"](_0x2e441b[_0x49f5fd(140)][_0x49f5fd(209)]), _0x50d45c["push"](_0x145aa2[_0x49f5fd(140)][_0x49f5fd(209)]), _0x4adb94["push"](_0x1ca351[_0x49f5fd(140)]["coordinates"]);
  }
  return [_0x341943, _0x166a33, _0x50d45c, _0x4adb94];
}
function _0x3124(_0xe9bdb4, _0x3e307c) {
  const _0x435129 = _0xeeab();
  return _0x3124 = function(_0x7944712, _0x5261712) {
    _0x7944712 = _0x7944712 - 137;
    let _0x196175 = _0x435129[_0x7944712];
    return _0x196175;
  }, _0x3124(_0xe9bdb4, _0x3e307c);
}
function generateParallelTracks(_0x49a541) {
  const _0x46c25d = _0x3124, _0xee9c9f = [], _0x547561 = [], _0x588b2e = _0x24b10a[_0x46c25d(225)](_0x49a541), _0x41f647 = RULES[_0x46c25d(141)] / 2 + RULES[_0x46c25d(220)] / 2;
  for (let _0xdfcf07 = 0; _0xdfcf07 < _0x49a541[_0x46c25d(174)]; _0xdfcf07++) {
    let _0x525d2f;
    if (_0xdfcf07 === 0) _0x525d2f = _0x24b10a[_0x46c25d(139)](_0x24b10a[_0x46c25d(204)](_0x49a541[0]), _0x24b10a[_0x46c25d(204)](_0x49a541[1]));
    else {
      if (_0xdfcf07 === _0x49a541[_0x46c25d(174)] - 1) _0x525d2f = bearing(_0x24b10a[_0x46c25d(204)](_0x49a541[_0x49a541["length"] - 2]), point$3(_0x49a541[_0x49a541["length"] - 1]));
      else {
        const _0x4412bf = lineSlice(_0x24b10a[_0x46c25d(204)](_0x49a541[_0xdfcf07 - 1]), _0x24b10a[_0x46c25d(204)](_0x49a541[_0xdfcf07 + 1]), _0x588b2e);
        _0x525d2f = bearing(_0x24b10a[_0x46c25d(204)](_0x4412bf[_0x46c25d(140)]["coordinates"][0]), point$3(_0x4412bf[_0x46c25d(140)][_0x46c25d(209)][_0x4412bf[_0x46c25d(140)][_0x46c25d(209)][_0x46c25d(174)] - 1]));
      }
    }
    const _0x26551f = _0x525d2f + 90, _0x2a823a = _0x525d2f - 90, _0x57780a = _0x24b10a[_0x46c25d(197)](_0x24b10a[_0x46c25d(204)](_0x49a541[_0xdfcf07]), _0x41f647, _0x26551f, { "units": "meters" }), _0x50d846 = _0x24b10a[_0x46c25d(197)](_0x24b10a[_0x46c25d(204)](_0x49a541[_0xdfcf07]), _0x41f647, _0x2a823a, { "units": _0x46c25d(161) });
    _0xee9c9f["push"](_0x57780a[_0x46c25d(140)][_0x46c25d(209)]), _0x547561[_0x46c25d(189)](_0x50d846[_0x46c25d(140)][_0x46c25d(209)]);
  }
  return [_0xee9c9f, _0x547561];
}
function isSnappingToParallelGroup(_0x327335, _0x538218) {
  const _0x59fdfe = _0x3124;
  if (!_0x327335) return ![];
  const _0x5bf5b1 = _0x538218["some"]((_0x281804) => (_0x281804["trackLanesType"] === "parallel" || _0x281804[_0x59fdfe(142)] === _0x59fdfe(229)) && _0x281804[_0x59fdfe(155)]["includes"](_0x327335[_0x59fdfe(192)])), _0x33ad1c = _0x538218[_0x59fdfe(224)]((_0x2a050a) => (_0x2a050a[_0x59fdfe(142)] === "parallel" || _0x2a050a[_0x59fdfe(142)] === _0x59fdfe(229)) && _0x2a050a["id"] === _0x327335[_0x59fdfe(192)]);
  return _0x5bf5b1 || _0x33ad1c;
}
(function(_0x4194b6, _0x1e20ae) {
  const _0x370fdb = _0x2c38, _0x373f32 = _0x4194b6();
  while (!![]) {
    try {
      const _0x273e48 = -parseInt(_0x370fdb(161)) / 1 * (parseInt(_0x370fdb(146)) / 2) + -parseInt(_0x370fdb(166)) / 3 + -parseInt(_0x370fdb(163)) / 4 * (parseInt(_0x370fdb(152)) / 5) + -parseInt(_0x370fdb(160)) / 6 * (parseInt(_0x370fdb(167)) / 7) + -parseInt(_0x370fdb(154)) / 8 * (parseInt(_0x370fdb(143)) / 9) + -parseInt(_0x370fdb(165)) / 10 * (parseInt(_0x370fdb(168)) / 11) + parseInt(_0x370fdb(150)) / 12;
      if (_0x273e48 === _0x1e20ae) break;
      else _0x373f32["push"](_0x373f32["shift"]());
    } catch (_0x23b760) {
      _0x373f32["push"](_0x373f32["shift"]());
    }
  }
})(_0xfe4e, 192602);
const _0x4ea572 = /* @__PURE__ */ (function() {
  let _0x46bdf0 = !![];
  return function(_0xe200e5, _0x36a9af) {
    const _0x3e2c83 = _0x46bdf0 ? function() {
      const _0x38c587 = _0x2c38;
      if (_0x36a9af) {
        const _0x251856 = _0x36a9af[_0x38c587(170)](_0xe200e5, arguments);
        return _0x36a9af = null, _0x251856;
      }
    } : function() {
    };
    return _0x46bdf0 = ![], _0x3e2c83;
  };
})(), _0x2c0c26 = _0x4ea572(void 0, function() {
  const _0x279735 = _0x2c38;
  let _0x8b1a37;
  try {
    const _0x25829e = Function(_0x279735(155) + _0x279735(151) + ");");
    _0x8b1a37 = _0x25829e();
  } catch (_0x1a2939) {
    _0x8b1a37 = window;
  }
  const _0x23506f = _0x8b1a37[_0x279735(149)] = _0x8b1a37[_0x279735(149)] || {}, _0x400219 = [_0x279735(164), _0x279735(159), _0x279735(153), _0x279735(144), _0x279735(147), "table", _0x279735(162)];
  for (let _0x3f7823 = 0; _0x3f7823 < _0x400219["length"]; _0x3f7823++) {
    const _0x15f813 = _0x4ea572["constructor"]["prototype"]["bind"](_0x4ea572), _0x12f1d2 = _0x400219[_0x3f7823], _0x60d85a = _0x23506f[_0x12f1d2] || _0x15f813;
    _0x15f813[_0x279735(158)] = _0x4ea572["bind"](_0x4ea572), _0x15f813["toString"] = _0x60d85a[_0x279735(157)][_0x279735(156)](_0x60d85a), _0x23506f[_0x12f1d2] = _0x15f813;
  }
});
function _0x2c38(_0xc6e71b, _0x52daf6) {
  const _0xd0679e = _0xfe4e();
  return _0x2c38 = function(_0x2c0c262, _0x4ea5722) {
    _0x2c0c262 = _0x2c0c262 - 142;
    let _0x1a55e4 = _0xd0679e[_0x2c0c262];
    return _0x1a55e4;
  }, _0x2c38(_0xc6e71b, _0x52daf6);
}
_0x2c0c26();
function _0xfe4e() {
  const _0x28474c = ["7LtrCuM", "trace", "17648uYhrnf", "log", "70rRkDpZ", "813615PPfqjv", "7NCVZKZ", "48136ZttMZD", "centerLine", "apply", "updatedTrackGroups", "261UGySOe", "error", "getLineMidpoint", "56420qmdHqg", "exception", "newTracks", "console", "12933456hQoamn", '{}.constructor("return this")( )', "235oIUIlh", "info", "16336gHAhEh", "return (function() ", "bind", "toString", "__proto__", "warn", "715782YYmyvl"];
  _0xfe4e = function() {
    return _0x28474c;
  };
  return _0xfe4e();
}
function handleStationCreation({ newTracksResult: _0x2597b1 }) {
  const _0x18f747 = _0x2c38, { newTracks: _0x5ac947, newTrackGroups: _0x3accc4, validation: _0x13be0b } = _0x2597b1, _0x59e46e = _0x3accc4[0], _0x34e866 = _0x134c1a[_0x18f747(145)](_0x59e46e[_0x18f747(169)]), _0x410c3e = splitTgAtPoint({ "trackGroupToSplit": _0x59e46e, "trackGroups": _0x3accc4, "tracks": _0x5ac947, "splitPoint": _0x34e866, "splitTgs": ![] });
  return { "newTracks": _0x410c3e[_0x18f747(148)], "newTrackGroups": _0x410c3e[_0x18f747(142)], "validation": _0x13be0b };
}
(function(_0x23ce10, _0x1046db) {
  const _0x8642 = _0x2924, _0x5cad2f = _0x23ce10();
  while (!![]) {
    try {
      const _0x587f5e = -parseInt(_0x8642(479)) / 1 * (-parseInt(_0x8642(462)) / 2) + -parseInt(_0x8642(467)) / 3 + parseInt(_0x8642(424)) / 4 * (parseInt(_0x8642(474)) / 5) + -parseInt(_0x8642(450)) / 6 * (parseInt(_0x8642(477)) / 7) + parseInt(_0x8642(483)) / 8 + -parseInt(_0x8642(436)) / 9 + -parseInt(_0x8642(439)) / 10 * (-parseInt(_0x8642(431)) / 11);
      if (_0x587f5e === _0x1046db) break;
      else _0x5cad2f["push"](_0x5cad2f["shift"]());
    } catch (_0x2080aa) {
      _0x5cad2f["push"](_0x5cad2f["shift"]());
    }
  }
})(_0x2bbe, 477594);
const _0x114440 = /* @__PURE__ */ (function() {
  let _0x5909ad = !![];
  return function(_0x2f3fc4, _0x238e66) {
    const _0x3e8103 = _0x5909ad ? function() {
      const _0xc11074 = _0x2924;
      if (_0x238e66) {
        const _0x20ea6a = _0x238e66[_0xc11074(454)](_0x2f3fc4, arguments);
        return _0x238e66 = null, _0x20ea6a;
      }
    } : function() {
    };
    return _0x5909ad = ![], _0x3e8103;
  };
})(), _0x3ec779 = _0x114440(void 0, function() {
  const _0x4d1d46 = _0x2924, _0x10f5a2 = function() {
    const _0x3b3e17 = _0x2924;
    let _0x17aae0;
    try {
      _0x17aae0 = Function(_0x3b3e17(463) + '{}.constructor("return this")( ));')();
    } catch (_0x444067) {
      _0x17aae0 = window;
    }
    return _0x17aae0;
  }, _0x598f3c = _0x10f5a2(), _0x4a4542 = _0x598f3c[_0x4d1d46(478)] = _0x598f3c[_0x4d1d46(478)] || {}, _0x38724b = [_0x4d1d46(453), _0x4d1d46(458), _0x4d1d46(449), _0x4d1d46(456), _0x4d1d46(472), _0x4d1d46(459), _0x4d1d46(428)];
  for (let _0x3c561d = 0; _0x3c561d < _0x38724b[_0x4d1d46(444)]; _0x3c561d++) {
    const _0x7a31e = _0x114440["constructor"][_0x4d1d46(465)]["bind"](_0x114440), _0x1bbbff = _0x38724b[_0x3c561d], _0xe0e540 = _0x4a4542[_0x1bbbff] || _0x7a31e;
    _0x7a31e[_0x4d1d46(455)] = _0x114440[_0x4d1d46(482)](_0x114440), _0x7a31e[_0x4d1d46(481)] = _0xe0e540[_0x4d1d46(481)][_0x4d1d46(482)](_0xe0e540), _0x4a4542[_0x1bbbff] = _0x7a31e;
  }
});
_0x3ec779();
function _0x2924(_0x25c080, _0x3b7995) {
  const _0x512350 = _0x2bbe();
  return _0x2924 = function(_0x3ec7792, _0x1144402) {
    _0x3ec7792 = _0x3ec7792 - 424;
    let _0x3e8bdf = _0x512350[_0x3ec7792];
    return _0x3e8bdf;
  }, _0x2924(_0x25c080, _0x3b7995);
}
function checkForSnapping({ coords: _0x16294e, map: _0x203c59, tracks: _0x1e8134, trackGroups: _0x3326ad, snapConfig: _0x35ae17 }) {
  const _0x77af90 = _0x2924;
  let _0x40b942 = ![], _0x104d4a = null, _0x519a38 = null, _0x5b212e = Infinity;
  const _0x1246f4 = _0x203c59[_0x77af90(466)](_0x16294e);
  return _0x35ae17[_0x77af90(473)] && _0x1e8134[_0x77af90(468)]((_0x2f6c83) => {
    const _0x4dcde6 = _0x77af90;
    if (!_0x2f6c83["interactable"]) return;
    if (_0x2f6c83["coords"]["length"] < 2) return;
    const _0x2b3084 = checkNodeForSnapping({ "nodeCoords": _0x2f6c83[_0x4dcde6(446)][0], "nextCoords": _0x2f6c83[_0x4dcde6(446)][1], "mousePixel": _0x1246f4, "map": _0x203c59, "minDistance": _0x5b212e, "id": _0x2f6c83["id"], "isStart": !![], "isCenterline": ![], "isParallelCenterline": _0x35ae17["parallelTrackCenterlines"] });
    _0x2b3084 && (_0x5b212e = _0x2b3084[_0x4dcde6(437)], _0x104d4a = _0x2b3084[_0x4dcde6(433)], _0x519a38 = _0x2b3084[_0x4dcde6(449)], _0x40b942 = !![]);
    const _0x8aced2 = checkNodeForSnapping({ "nodeCoords": _0x2f6c83[_0x4dcde6(446)][_0x2f6c83[_0x4dcde6(446)][_0x4dcde6(444)] - 1], "nextCoords": _0x2f6c83["coords"][_0x2f6c83[_0x4dcde6(446)][_0x4dcde6(444)] - 2], "mousePixel": _0x1246f4, "map": _0x203c59, "minDistance": _0x5b212e, "id": _0x2f6c83["id"], "isStart": ![], "isCenterline": ![], "isParallelCenterline": _0x35ae17[_0x4dcde6(448)] });
    _0x8aced2 && (_0x5b212e = _0x8aced2[_0x4dcde6(437)], _0x104d4a = _0x8aced2[_0x4dcde6(433)], _0x519a38 = _0x8aced2["info"], _0x40b942 = !![]);
  }), (_0x35ae17[_0x77af90(452)] || _0x35ae17[_0x77af90(441)] || _0x35ae17[_0x77af90(425)]) && _0x3326ad[_0x77af90(468)]((_0x393898) => {
    const _0x1b39e4 = _0x77af90;
    if (!_0x393898[_0x1b39e4(475)] || _0x393898["trackIds"]["length"] === 0) return;
    if (!_0x35ae17[_0x1b39e4(452)] && _0x393898[_0x1b39e4(469)] === "single") return;
    if (!_0x35ae17["parallelTrackCenterlineNodes"] && _0x393898["trackLanesType"] === _0x1b39e4(447)) return;
    if (!_0x35ae17[_0x1b39e4(425)] && _0x393898["trackLanesType"] === "quad") return;
    if (!_0x35ae17["stationNodes"] && _0x393898["type"] === "station") return;
    const _0x162dbf = checkNodeForSnapping({ "nodeCoords": _0x393898[_0x1b39e4(475)][0], "nextCoords": _0x393898[_0x1b39e4(475)][1], "mousePixel": _0x1246f4, "map": _0x203c59, "minDistance": _0x5b212e, "id": _0x393898["id"], "isStart": !![], "isCenterline": !![], "isParallelCenterline": _0x393898[_0x1b39e4(469)] === _0x1b39e4(447) || _0x393898[_0x1b39e4(469)] === _0x1b39e4(464) });
    _0x162dbf && (_0x5b212e = _0x162dbf[_0x1b39e4(437)], _0x104d4a = _0x162dbf["node"], _0x519a38 = _0x162dbf[_0x1b39e4(449)], _0x40b942 = !![]);
    const _0x5ce528 = checkNodeForSnapping({ "nodeCoords": _0x393898[_0x1b39e4(475)][_0x393898[_0x1b39e4(475)][_0x1b39e4(444)] - 1], "nextCoords": _0x393898[_0x1b39e4(475)][_0x393898[_0x1b39e4(475)][_0x1b39e4(444)] - 2], "mousePixel": _0x1246f4, "map": _0x203c59, "minDistance": _0x5b212e, "id": _0x393898["id"], "isStart": ![], "isCenterline": !![], "isParallelCenterline": _0x393898[_0x1b39e4(469)] === "parallel" || _0x393898[_0x1b39e4(469)] === "quad" });
    _0x5ce528 && (_0x5b212e = _0x5ce528["distance"], _0x104d4a = _0x5ce528[_0x1b39e4(433)], _0x519a38 = _0x5ce528[_0x1b39e4(449)], _0x40b942 = !![]);
  }), !_0x40b942 && (_0x35ae17["tracks"] && _0x1e8134[_0x77af90(468)]((_0x2735be) => {
    const _0x19b534 = _0x77af90;
    if (_0x2735be[_0x19b534(434)] === _0x19b534(476) || _0x2735be[_0x19b534(434)] === "express-station") return;
    if (!_0x2735be[_0x19b534(470)]) return;
    const _0x139863 = checkLineForSnapping({ "track": _0x2735be, "mouseCoords": _0x16294e, "mousePixel": _0x1246f4, "map": _0x203c59, "minDistance": _0x5b212e, "isCenterline": ![], "isParallelCenterline": ![] });
    _0x139863 && (_0x5b212e = _0x139863["distance"], _0x104d4a = _0x139863[_0x19b534(432)], _0x519a38 = _0x139863[_0x19b534(449)], _0x40b942 = !![]);
  }), (_0x35ae17["singleTrackCenterlines"] || _0x35ae17[_0x77af90(448)] || _0x35ae17["quadTrackCenterlines"]) && _0x3326ad[_0x77af90(468)]((_0x3916a7) => {
    const _0x448f90 = _0x77af90;
    if (_0x3916a7[_0x448f90(434)] === _0x448f90(476) && !_0x35ae17[_0x448f90(480)]) return;
    if (!_0x3916a7["centerLine"] || _0x3916a7[_0x448f90(475)]["length"] < 2) return;
    if (!_0x35ae17["singleTrackCenterlines"] && _0x3916a7["trackLanesType"] === _0x448f90(451)) return;
    if (!_0x35ae17[_0x448f90(448)] && _0x3916a7[_0x448f90(469)] === _0x448f90(447)) return;
    if (!_0x35ae17[_0x448f90(460)] && _0x3916a7[_0x448f90(469)] === _0x448f90(464)) return;
    const _0x85d843 = checkLineForSnapping({ "track": { "id": _0x3916a7["id"], "coords": _0x3916a7[_0x448f90(475)] }, "mouseCoords": _0x16294e, "mousePixel": _0x1246f4, "map": _0x203c59, "minDistance": _0x5b212e, "isCenterline": !![], "isParallelCenterline": _0x35ae17[_0x448f90(448)] });
    _0x85d843 && (_0x5b212e = _0x85d843[_0x448f90(437)], _0x104d4a = _0x85d843["point"], _0x519a38 = _0x85d843[_0x448f90(449)], _0x40b942 = !![]);
  })), { "closestNode": _0x40b942 ? _0x104d4a : null, "snappedInfo": _0x40b942 ? _0x519a38 : null };
}
function calculatePixelDistance(_0x532f9a, _0x5b4829) {
  const _0x38c62e = _0x2924;
  return Math[_0x38c62e(461)](Math[_0x38c62e(440)](_0x532f9a["x"] - _0x5b4829["x"], 2) + Math[_0x38c62e(440)](_0x532f9a["y"] - _0x5b4829["y"], 2));
}
function checkNodeForSnapping({ nodeCoords: _0x2350c0, nextCoords: _0x311403, mousePixel: _0x38d6e9, map: _0x3a3888, minDistance: _0x5d3433, id: _0x33c4b4, isStart: _0x181c77, isCenterline: _0x35734e, isParallelCenterline: _0x52284d }) {
  const _0x5f4543 = _0x2924, _0xb2c463 = _0x3a3888[_0x5f4543(466)](_0x2350c0), _0x24ab89 = calculatePixelDistance(_0x38d6e9, _0xb2c463);
  if (_0x24ab89 > PIXEL_SNAP_THRESHOLD) return null;
  if (_0x24ab89 > _0x5d3433) return null;
  if (_0x134c1a[_0x5f4543(435)](_0x2350c0, _0x311403)) return console[_0x5f4543(458)](_0x5f4543(438), { "nodeCoords": _0x2350c0, "nextCoords": _0x311403, "id": _0x33c4b4 }), null;
  let _0x4926b2 = getBearing(_0x2350c0, _0x311403);
  return !_0x181c77 && (_0x4926b2 = _0x134c1a[_0x5f4543(426)](_0x4926b2)), { "snapped": !![], "distance": _0x24ab89, "node": _0x2350c0, "info": { "trackId": _0x33c4b4, "isStartNode": _0x181c77, "bearing": _0x4926b2, "isCenterline": _0x35734e, "isParallelCenterline": _0x52284d, "coords": _0x2350c0, "isLineSnap": ![] } };
}
function checkLineForSnapping({ track: _0x53e571, mouseCoords: _0x71b265, mousePixel: _0x364d5c, map: _0x15b0fd, minDistance: _0x208f75, isCenterline: _0x16366e, isParallelCenterline: _0x4e219e }) {
  const _0x1200e3 = _0x2924;
  if (_0x53e571[_0x1200e3(446)][_0x1200e3(444)] < 2) return null;
  if (_0x134c1a[_0x1200e3(435)](_0x53e571[_0x1200e3(446)][0], _0x53e571[_0x1200e3(446)][1])) return null;
  const _0x4a1d7b = _0x24b10a[_0x1200e3(429)](_0x24b10a[_0x1200e3(445)](_0x53e571["coords"])), _0xdb2ba = _0x24b10a[_0x1200e3(457)](_0x4a1d7b, point$3(_0x71b265)), _0x1f80e1 = _0x15b0fd["project"]([_0xdb2ba[_0x1200e3(430)][_0x1200e3(442)][0], _0xdb2ba[_0x1200e3(430)][_0x1200e3(442)][1]]), _0x454a68 = calculatePixelDistance(_0x364d5c, _0x1f80e1);
  if (_0x454a68 > PIXEL_SNAP_THRESHOLD || _0x454a68 > _0x208f75) return null;
  const _0x25f9a8 = _0xdb2ba[_0x1200e3(443)][_0x1200e3(427)];
  let _0x1a1109;
  return _0x25f9a8 < _0x53e571["coords"]["length"] - 1 ? _0x1a1109 = _0x134c1a[_0x1200e3(471)](_0x53e571[_0x1200e3(446)][_0x25f9a8], _0x53e571["coords"][_0x25f9a8 + 1]) : _0x1a1109 = _0x134c1a[_0x1200e3(471)](_0x53e571[_0x1200e3(446)][_0x25f9a8 - 1], _0x53e571["coords"][_0x25f9a8]), { "snapped": !![], "distance": _0x454a68, "point": [_0xdb2ba[_0x1200e3(430)]["coordinates"][0], _0xdb2ba[_0x1200e3(430)][_0x1200e3(442)][1]], "info": { "trackId": _0x53e571["id"], "coords": [_0xdb2ba[_0x1200e3(430)][_0x1200e3(442)][0], _0xdb2ba[_0x1200e3(430)][_0x1200e3(442)][1]], "isStartNode": ![], "isCenterline": _0x16366e, "isParallelCenterline": _0x4e219e, "bearing": _0x1a1109, "isLineSnap": !![] } };
}
function _0x2bbe() {
  const _0xfbb5f6 = ["tracks", "895395NYvFfj", "centerLine", "station", "1106kFpaIa", "console", "8qwLJPv", "stationCenterlines", "toString", "bind", "5808896rEbHZB", "20SndrMA", "quadTrackCenterlineNodes", "reverseBearing", "index", "trace", "cleanCoords", "geometry", "2992xuJdXl", "point", "node", "type", "coordsEqual", "5616279QvAccF", "distance", "Invalid coordinates for bearing calculation:", "10680yRlUou", "pow", "parallelTrackCenterlineNodes", "coordinates", "properties", "length", "lineString", "coords", "parallel", "parallelTrackCenterlines", "info", "32496CEdSCP", "single", "singleTrackCenterlineNodes", "log", "apply", "__proto__", "error", "nearestPointOnLine", "warn", "table", "quadTrackCenterlines", "sqrt", "76318ZreZUq", "return (function() ", "quad", "prototype", "project", "779766Ofgpkd", "forEach", "trackLanesType", "interactable", "getBearing", "exception"];
  _0x2bbe = function() {
    return _0xfbb5f6;
  };
  return _0x2bbe();
}
(function(_0x10ff53, _0x44ee79) {
  const _0x17312a = _0x46f0, _0x56c6d0 = _0x10ff53();
  while (!![]) {
    try {
      const _0x3dfb77 = parseInt(_0x17312a(165)) / 1 + -parseInt(_0x17312a(127)) / 2 + -parseInt(_0x17312a(171)) / 3 + -parseInt(_0x17312a(138)) / 4 * (parseInt(_0x17312a(119)) / 5) + parseInt(_0x17312a(130)) / 6 * (-parseInt(_0x17312a(154)) / 7) + -parseInt(_0x17312a(157)) / 8 + -parseInt(_0x17312a(169)) / 9 * (-parseInt(_0x17312a(114)) / 10);
      if (_0x3dfb77 === _0x44ee79) break;
      else _0x56c6d0["push"](_0x56c6d0["shift"]());
    } catch (_0x12edec) {
      _0x56c6d0["push"](_0x56c6d0["shift"]());
    }
  }
})(_0x3e4a, 417413);
const _0xea7152 = /* @__PURE__ */ (function() {
  let _0x2001ed = !![];
  return function(_0x4a140d, _0x2f4d06) {
    const _0x2034c5 = _0x2001ed ? function() {
      const _0x22c510 = _0x46f0;
      if (_0x2f4d06) {
        const _0x33b986 = _0x2f4d06[_0x22c510(168)](_0x4a140d, arguments);
        return _0x2f4d06 = null, _0x33b986;
      }
    } : function() {
    };
    return _0x2001ed = ![], _0x2034c5;
  };
})(), _0x2e3439 = _0xea7152(void 0, function() {
  const _0x359736 = _0x46f0, _0x234ae2 = function() {
    const _0x5f15a6 = _0x46f0;
    let _0x595645;
    try {
      _0x595645 = Function(_0x5f15a6(125) + _0x5f15a6(107) + ");")();
    } catch (_0x2b0946) {
      _0x595645 = window;
    }
    return _0x595645;
  }, _0x3e9cd9 = _0x234ae2(), _0x35cf65 = _0x3e9cd9[_0x359736(145)] = _0x3e9cd9["console"] || {}, _0xa6c5e1 = [_0x359736(163), _0x359736(180), _0x359736(140), "error", _0x359736(147), _0x359736(143), "trace"];
  for (let _0x2f88dc = 0; _0x2f88dc < _0xa6c5e1[_0x359736(124)]; _0x2f88dc++) {
    const _0xe65f0d = _0xea7152["constructor"][_0x359736(161)][_0x359736(149)](_0xea7152), _0x1bcb6b = _0xa6c5e1[_0x2f88dc], _0x17c31 = _0x35cf65[_0x1bcb6b] || _0xe65f0d;
    _0xe65f0d[_0x359736(128)] = _0xea7152[_0x359736(149)](_0xea7152), _0xe65f0d[_0x359736(181)] = _0x17c31[_0x359736(181)][_0x359736(149)](_0x17c31), _0x35cf65[_0x1bcb6b] = _0xe65f0d;
  }
});
_0x2e3439();
function _0x3e4a() {
  const _0x6b7f26 = ["setHoveredPoint", "draw-parallel-station", "22415510WIqYQw", "isValid", "No snapped info", "currentUserAction", "Scissors crossover created", "445EkmXgw", "blueprint", "userAction", "snappingConfig", "trackGroups", "length", "return (function() ", "current", "1373290ZWykSl", "__proto__", "isCenterline", "3834ajtTZS", "No clicked track group", "draw-single-station", "draw-quad-tracks", "updatedTrackGroups", "map", "Can't create scissors crossover", "error", "9356EvkUDR", "message", "info", "draw-single-track", "mouseMove", "table", "Failed to find track group to split", "console", "Failed to find track group", "exception", "draw-quad-station", "bind", "draw-parallel-tracks", "preview", "Error creating scissors crossover", "validation", "7FvDpNa", "append", "previewTracks", "2670016ZFNawO", "Error generating preview tracks:", "lng", "includes", "prototype", "trackId", "log", "newTracks", "188040WDuUKK", "trackSpatialIndex", "roadsIndex", "apply", "9bnsXFc", "lat", "2348913cnhGsg", "getMap", "selectedTrackType", "filter", "draw-line-track", "isLineSnap", "find", "tracks", "snappedInfo", "warn", "toString", "click", "push", "trackIds", '{}.constructor("return this")( )', "newTrackGroups", "buildingDetector", "mapRef", "lngLat"];
  _0x3e4a = function() {
    return _0x6b7f26;
  };
  return _0x3e4a();
}
function createHandleUserInput(_0x550fec) {
  return (_0x25f491, _0x4b2c5f) => {
    const _0x31ffad = _0x46f0;
    if (_0x550fec[_0x31ffad(121)] === _0x31ffad(175)) return;
    if (_0x550fec[_0x31ffad(121)] === "select-journey-location" && _0x4b2c5f === _0x31ffad(104)) {
      const _0x43a332 = getJourneyCoordinateCallback();
      _0x43a332 && _0x43a332([_0x25f491["lngLat"][_0x31ffad(159)], _0x25f491["lngLat"][_0x31ffad(170)]]);
      return;
    }
    const _0x1482f8 = [_0x25f491[_0x31ffad(111)][_0x31ffad(159)], _0x25f491["lngLat"][_0x31ffad(170)]], _0x3f846a = _0x550fec[_0x31ffad(110)][_0x31ffad(126)]?.["getMap"]();
    if (!_0x3f846a) return;
    const { hoveredPoint: _0x2fb7c7, effectiveCursorCoords: _0x4e2f5a } = calculateHoveredPoint({ "newMouseCoords": _0x1482f8, "map": _0x3f846a, "tracks": _0x550fec[_0x31ffad(178)], "trackGroups": _0x550fec[_0x31ffad(123)], "snapConfig": _0x550fec[_0x31ffad(117)][_0x31ffad(122)], "selectedTrackType": _0x550fec["selectedTrackType"] });
    _0x550fec[_0x31ffad(112)](_0x2fb7c7);
    if (_0x4b2c5f === _0x31ffad(142)) {
      handleMouseMove({ ..._0x550fec, "hoveredPoint": _0x2fb7c7 });
      return;
    }
    _0x4b2c5f === _0x31ffad(104) && handleClick({ ..._0x550fec, "hoveredPoint": _0x2fb7c7, "effectiveCursorCoords": _0x4e2f5a });
  };
}
function calculateHoveredPoint({ newMouseCoords: _0x5b019f, map: _0x5ea70a, tracks: _0x30c34a, trackGroups: _0x28de6e, snapConfig: _0x329963 }) {
  const { closestNode: _0x788c7a, snappedInfo: _0x985c62 } = checkForSnapping({ "coords": _0x5b019f, "map": _0x5ea70a, "tracks": _0x30c34a, "trackGroups": _0x28de6e, "snapConfig": _0x329963 }), _0x45e93d = _0x985c62 && _0x788c7a ? _0x788c7a : roundCoordinate(_0x5b019f), _0x5c5c5f = { "coords": _0x45e93d, "snappedInfo": _0x985c62 };
  return { "hoveredPoint": _0x5c5c5f, "effectiveCursorCoords": _0x45e93d };
}
function handleMouseMove(_0x3d0e92) {
  const _0x42356c = _0x46f0, { userAction: _0x66c9f5, startPoint: _0x5da375, hoveredPoint: _0x8c9284 } = _0x3d0e92;
  if (!_0x5da375) return;
  if (!isDrawingAction(_0x66c9f5)) return;
  const _0x2964a1 = isStationAction(_0x66c9f5);
  try {
    const { newTracks: _0x433585, newTrackGroups: _0x4f39cb, validation: _0xb4f823 } = getNewTracks({ "tracks": _0x3d0e92[_0x42356c(178)], "trackGroups": _0x3d0e92["trackGroups"], "hoveredPoint": _0x8c9284, "drawParallelTracks": _0x66c9f5 === _0x42356c(150) || _0x66c9f5 === _0x42356c(113), "drawQuadTracks": _0x66c9f5 === _0x42356c(133) || _0x66c9f5 === "draw-quad-station", "startPoint": _0x5da375, "trackType": _0x42356c(151), "isStation": _0x2964a1, "desiredElevation": _0x3d0e92["constructionElevation"], "trackSpatialIndex": _0x3d0e92[_0x42356c(166)], "buildingDetector": _0x3d0e92[_0x42356c(109)], "roadIndex": _0x3d0e92[_0x42356c(167)], "selectedTrackType": _0x3d0e92[_0x42356c(173)] });
    _0x3d0e92["setPreviewTracks"]({ "tracks": _0x433585, "trackGroups": _0x4f39cb, "validation": _0xb4f823 });
  } catch (_0x3f53a2) {
    console[_0x42356c(137)](_0x42356c(158), _0x3f53a2);
  }
}
function handleClick(_0x4b6d6b) {
  const { userAction: _0x254e76 } = _0x4b6d6b, _0x5d6787 = { "delete-track-group": () => handleDeleteTrackGroup(_0x4b6d6b), "create-scissors-crossover": () => handleCreateScissorsCrossover(_0x4b6d6b), "split-track": () => handleSplitTrack(_0x4b6d6b) }, _0x400c02 = _0x5d6787[_0x254e76];
  if (_0x400c02) {
    _0x400c02();
    return;
  }
  isDrawingAction(_0x254e76) && handleDrawingAction(_0x4b6d6b);
}
function handleDeleteTrackGroup(_0x47cc00) {
  const _0x1be57b = _0x46f0, { hoveredPoint: _0x36b5d0, handleDeleteTgs: _0x1aad36 } = _0x47cc00;
  if (!_0x36b5d0[_0x1be57b(179)]) throw new Error(_0x1be57b(116));
  _0x1aad36([_0x36b5d0[_0x1be57b(179)]["trackId"]]);
}
function handleCreateScissorsCrossover(_0x4d6eea) {
  const _0x28f689 = _0x46f0, { hoveredPoint: _0xdf169f, tracks: _0x535fa7, trackGroups: _0x57221b, setTracks: _0x3c275d } = _0x4d6eea;
  try {
    if (!_0xdf169f["snappedInfo"]) throw new Error(_0x28f689(131));
    const _0x52bed9 = _0x57221b[_0x28f689(177)]((_0x5b2159) => _0x5b2159["id"] === _0xdf169f["snappedInfo"][_0x28f689(162)]);
    if (!_0x52bed9) throw new Error("Track group not found for clicked track");
    const { newTracks: _0x2d5f17, newTrackGroups: _0x38822a, newSignals: _0x337b0c } = createScissorsCrossover({ "clickedTrackGroup": _0x52bed9, "tracks": _0x535fa7, "trackGroups": _0x57221b, "nodeCoords": _0xdf169f[_0x28f689(179)]["coords"] });
    _0x3c275d({ "newTracks": _0x2d5f17, "signalsUpdate": { "signals": _0x337b0c, "action": _0x28f689(155) }, "newTrackGroups": _0x38822a, "regenRoutesWithTrackIDs": _0x52bed9["trackIds"] }), toast({ "title": _0x28f689(118), "description": "Crossover point added successfully" });
  } catch (_0x3d9a9d) {
    toast({ "title": _0x28f689(136), "description": _0x3d9a9d instanceof Error ? _0x3d9a9d[_0x28f689(139)] : _0x28f689(152), "variant": "destructive" });
  }
}
function handleSplitTrack(_0x35f3d5) {
  const _0x2463a9 = _0x46f0, { hoveredPoint: _0x2c7189, tracks: _0x29ae2c, trackGroups: _0x47b231, effectiveCursorCoords: _0x3020f1, setTracks: _0x5b8fde } = _0x35f3d5;
  if (!_0x2c7189["snappedInfo"]) throw new Error(_0x2463a9(116));
  const { trackGroupToSplit: _0x4c4994, trackIdsToSplit: _0x31cea8 } = getItemsToSplit({ "snappedInfo": _0x2c7189[_0x2463a9(179)], "trackGroups": _0x47b231, "tracks": _0x29ae2c }), _0x2fa976 = splitTgAtPoint({ "trackGroupToSplit": _0x4c4994, "trackGroups": _0x47b231, "tracks": _0x29ae2c, "splitPoint": _0x3020f1 });
  _0x5b8fde({ "newTracks": _0x2fa976[_0x2463a9(164)], "newTrackGroups": _0x2fa976[_0x2463a9(134)], "regenRoutesWithTrackIDs": _0x31cea8 });
}
function handleDrawingAction(_0x1769de) {
  const _0xd14739 = _0x46f0, { startPoint: _0x930be } = _0x1769de;
  if (!_0x930be) {
    handleStartPointCreation(_0x1769de);
    return;
  }
  if (!_0x1769de[_0xd14739(156)][_0xd14739(153)][_0xd14739(115)]) return;
  handleTrackCreation(_0x1769de);
}
function handleStartPointCreation(_0x436097) {
  const _0x5edf7b = _0x46f0, { hoveredPoint: _0x1afa1e, effectiveCursorCoords: _0x42a7ff, setStartPoint: _0x13b399, setTracks: _0x432c03, tracks: _0x57fb4e, trackGroups: _0x6a8744, currentUserAction: _0xbab15e } = _0x436097;
  let _0x86c56c = _0x1afa1e["snappedInfo"];
  if (_0x1afa1e[_0x5edf7b(179)]?.[_0x5edf7b(176)]) {
    if (!_0x1afa1e[_0x5edf7b(179)]) throw new Error(_0x5edf7b(116));
    const { trackGroupToSplit: _0x2fead8, trackIdsToSplit: _0x2cce28 } = getItemsToSplit({ "snappedInfo": _0x1afa1e[_0x5edf7b(179)], "trackGroups": _0x6a8744, "tracks": _0x57fb4e }), _0x49c235 = splitTgAtPoint({ "trackGroupToSplit": _0x2fead8, "trackGroups": _0x6a8744, "tracks": _0x57fb4e, "splitPoint": _0x42a7ff }), _0x853b81 = _0x436097["mapRef"][_0x5edf7b(126)]?.["getMap"]();
    if (_0x853b81) {
      const { snappedInfo: _0x3a11c9 } = checkForSnapping({ "coords": _0x42a7ff, "map": _0x853b81, "tracks": _0x49c235[_0x5edf7b(164)], "trackGroups": _0x49c235[_0x5edf7b(134)], "snapConfig": _0xbab15e[_0x5edf7b(122)] });
      _0x86c56c = _0x3a11c9;
    }
    _0x432c03({ "newTracks": _0x49c235[_0x5edf7b(164)], "newTrackGroups": _0x49c235[_0x5edf7b(134)], "regenRoutesWithTrackIDs": _0x2cce28 });
  }
  _0x13b399({ "coords": _0x42a7ff, "snappedInfo": _0x86c56c });
}
function handleTrackCreation(_0x1bdd69) {
  const _0x4912fd = _0x46f0, { tracks: _0x2bbd61, trackGroups: _0xe403cb, hoveredPoint: _0x10a2a4, effectiveCursorCoords: _0x5e7203, userAction: _0x3c9b66, startPoint: _0x22602e, setTracks: _0x50fdf7, clearPreview: _0x56614e, setStartPoint: _0x357c89, currentUserAction: _0x547bd5, constructionElevation: _0x4d801d } = _0x1bdd69;
  let _0x14d728 = [..._0x2bbd61], _0x338f97 = [..._0xe403cb], _0x4b0f59 = _0x10a2a4;
  const _0x4df9fe = isStationAction(_0x3c9b66);
  if (_0x10a2a4[_0x4912fd(179)]?.[_0x4912fd(176)] && !_0x4df9fe) {
    const _0x524642 = performTrackSplit({ "hoveredPoint": _0x10a2a4, "trackGroups": _0xe403cb, "tracks": _0x2bbd61, "effectiveCursorCoords": _0x5e7203 });
    _0x14d728 = _0x524642[_0x4912fd(164)], _0x338f97 = _0x524642[_0x4912fd(134)];
    const _0x53ca1e = _0x1bdd69[_0x4912fd(110)][_0x4912fd(126)]?.[_0x4912fd(172)]();
    if (_0x53ca1e) {
      const { snappedInfo: _0x57e7e5 } = checkForSnapping({ "coords": _0x5e7203, "map": _0x53ca1e, "tracks": _0x14d728, "trackGroups": _0x338f97, "snapConfig": _0x547bd5[_0x4912fd(122)] });
      _0x4b0f59 = { ..._0x4b0f59, "snappedInfo": _0x57e7e5 };
    }
  }
  const _0x1a0c98 = isStationAction(_0x3c9b66);
  let _0x1cfbf6 = getNewTracks({ "tracks": _0x14d728, "trackGroups": _0x338f97, "hoveredPoint": _0x4b0f59, "drawParallelTracks": _0x3c9b66 === "draw-parallel-tracks" || _0x3c9b66 === _0x4912fd(113), "drawQuadTracks": _0x3c9b66 === _0x4912fd(133) || _0x3c9b66 === _0x4912fd(148), "startPoint": _0x22602e, "trackType": _0x4912fd(120), "isStation": _0x1a0c98, "desiredElevation": _0x4d801d, "trackSpatialIndex": _0x1bdd69[_0x4912fd(166)], "buildingDetector": _0x1bdd69[_0x4912fd(109)], "roadIndex": _0x1bdd69[_0x4912fd(167)], "selectedTrackType": _0x1bdd69["selectedTrackType"] });
  _0x1a0c98 && (_0x1cfbf6 = handleStationCreation({ "newTracksResult": _0x1cfbf6 }));
  if (!_0x1cfbf6[_0x4912fd(153)]["isValid"]) return;
  const _0x5f21fe = [..._0x14d728, ..._0x1cfbf6[_0x4912fd(164)]], _0x5126f7 = [..._0x338f97, ..._0x1cfbf6[_0x4912fd(108)]], _0x203bb6 = getTrackIdsToRegenRoutes({ "snappedInfo": _0x10a2a4[_0x4912fd(179)], "startPointSnappedInfo": _0x22602e[_0x4912fd(179)], "trackGroups": _0xe403cb });
  _0x50fdf7({ "newTracks": _0x5f21fe, "newTrackGroups": _0x5126f7, "regenStations": _0x1a0c98, "regenRoutesWithTrackIDs": _0x203bb6 }), _0x56614e(), _0x357c89(null);
}
function performTrackSplit({ hoveredPoint: _0x4e6d2e, trackGroups: _0x5ca23a, tracks: _0x5c5b32, effectiveCursorCoords: _0x366321 }) {
  const _0x2e8c4b = _0x46f0;
  if (!_0x4e6d2e["snappedInfo"]) throw new Error(_0x2e8c4b(116));
  let _0x2a0e7d;
  _0x4e6d2e[_0x2e8c4b(179)]["isCenterline"] ? _0x2a0e7d = _0x5ca23a[_0x2e8c4b(177)]((_0x2bae47) => _0x2bae47["id"] === _0x4e6d2e[_0x2e8c4b(179)][_0x2e8c4b(162)]) : _0x2a0e7d = _0x5ca23a[_0x2e8c4b(177)]((_0x2a4b81) => _0x2a4b81["trackIds"]["includes"](_0x4e6d2e[_0x2e8c4b(179)][_0x2e8c4b(162)]));
  if (!_0x2a0e7d) throw new Error(_0x2e8c4b(144));
  return splitTgAtPoint({ "trackGroupToSplit": _0x2a0e7d, "trackGroups": _0x5ca23a, "tracks": _0x5c5b32, "splitPoint": _0x366321 });
}
function getTrackIdsToRegenRoutes({ snappedInfo: _0xb30685, startPointSnappedInfo: _0x89c01b, trackGroups: _0x1b500c }) {
  const _0x1dbeeb = _0x46f0, _0x1c2722 = [];
  if (_0xb30685?.["trackId"]) {
    if (_0xb30685["isCenterline"]) {
      const _0x1514c1 = _0x1b500c["find"]((_0x217da7) => _0x217da7["id"] === _0xb30685[_0x1dbeeb(162)]);
      if (!_0x1514c1) throw new Error("Failed to find track group");
      _0x1c2722[_0x1dbeeb(105)](..._0x1514c1[_0x1dbeeb(106)]);
    } else _0x1c2722[_0x1dbeeb(105)](_0xb30685[_0x1dbeeb(162)]);
  }
  if (_0x89c01b?.[_0x1dbeeb(162)]) {
    if (_0x89c01b[_0x1dbeeb(129)]) {
      const _0x44086b = _0x1b500c[_0x1dbeeb(177)]((_0x526f91) => _0x526f91["id"] === _0x89c01b["trackId"]);
      if (!_0x44086b) throw new Error(_0x1dbeeb(146));
      _0x1c2722[_0x1dbeeb(105)](..._0x44086b[_0x1dbeeb(106)]);
    } else _0x1c2722[_0x1dbeeb(105)](_0x89c01b[_0x1dbeeb(162)]);
  }
  return _0x1c2722;
}
function isDrawingAction(_0x370cb8) {
  const _0x57f77b = _0x46f0;
  return ["draw-parallel-tracks", _0x57f77b(133), _0x57f77b(141), _0x57f77b(132), _0x57f77b(113), _0x57f77b(148)][_0x57f77b(160)](_0x370cb8);
}
function isStationAction(_0x9e0ba0) {
  const _0x463d3b = _0x46f0;
  return ["draw-single-station", _0x463d3b(113), _0x463d3b(148)][_0x463d3b(160)](_0x9e0ba0);
}
function _0x46f0(_0x319941, _0x3e2191) {
  const _0x3ce5ef = _0x3e4a();
  return _0x46f0 = function(_0x2e34392, _0xea71522) {
    _0x2e34392 = _0x2e34392 - 104;
    let _0x52a4b4 = _0x3ce5ef[_0x2e34392];
    return _0x52a4b4;
  }, _0x46f0(_0x319941, _0x3e2191);
}
function getItemsToSplit({ snappedInfo: _0x30761c, trackGroups: _0x5e2738, tracks: _0x120c07 }) {
  const _0x5ee6ef = _0x46f0;
  let _0x56c9fe, _0x8400df = [];
  _0x30761c["isCenterline"] ? (_0x56c9fe = _0x5e2738["find"]((_0x71a5a9) => _0x71a5a9["id"] === _0x30761c["trackId"]), _0x8400df = _0x120c07[_0x5ee6ef(174)]((_0x1dfe16) => _0x56c9fe[_0x5ee6ef(106)][_0x5ee6ef(160)](_0x1dfe16["id"]))[_0x5ee6ef(135)]((_0x34c916) => _0x34c916["id"])) : (_0x56c9fe = _0x5e2738[_0x5ee6ef(177)]((_0x1cc6fe) => _0x1cc6fe[_0x5ee6ef(106)][_0x5ee6ef(160)](_0x30761c[_0x5ee6ef(162)])), _0x8400df = [_0x30761c[_0x5ee6ef(162)]]);
  if (!_0x56c9fe) throw new Error(_0x5ee6ef(144));
  return { "trackGroupToSplit": _0x56c9fe, "trackIdsToSplit": _0x8400df };
}
function GenerativeMusicComponent() {
  const { isSoundEnabled } = useSettings();
  const crowdVolume = useCrowdVolume();
  const trains = useTrains();
  const stations = useStations();
  const warnings = useWarnings();
  const { current: currentMap } = useMap();
  const isInitialized = reactExports.useRef(false);
  const prevTrainPositions = reactExports.useRef(/* @__PURE__ */ new Map());
  const prevStationCount = reactExports.useRef(0);
  const processedWarningIds = reactExports.useRef(/* @__PURE__ */ new Set());
  const stationNodeLookup = reactExports.useRef(/* @__PURE__ */ new Map());
  const allStationsArray = reactExports.useRef([]);
  reactExports.useEffect(() => {
    const stationsArray = Object.values(stations);
    allStationsArray.current = stationsArray;
    const lookup = /* @__PURE__ */ new Map();
    stationsArray.forEach((station) => {
      station.stNodeIds.forEach((nodeId) => {
        lookup.set(nodeId, station);
      });
    });
    stationNodeLookup.current = lookup;
  }, [stations]);
  const isInViewport = reactExports.useCallback(
    (coords) => {
      if (!coords || coords.length !== 2 || typeof coords[0] !== "number" || typeof coords[1] !== "number") {
        return false;
      }
      if (!currentMap) {
        return false;
      }
      try {
        const bounds = currentMap.getBounds();
        if (!bounds) return false;
        const [lng, lat] = coords;
        const isVisible2 = bounds.contains([lng, lat]);
        return isVisible2;
      } catch (error) {
        console.error("Error checking viewport bounds:", error);
        return false;
      }
    },
    [currentMap]
  );
  reactExports.useEffect(() => {
    if (!isSoundEnabled || isInitialized.current) return;
    const initMusic = async () => {
      try {
        console.log("🎵 Attempting to initialize generative music system...");
        await generativeMusic.init();
        generativeMusic.start();
        isInitialized.current = true;
        console.log("🎵 Generative music system initialized successfully!");
        if (typeof window !== "undefined" && false) ;
      } catch (error) {
        console.error("❌ Failed to initialize generative music:", error);
      }
    };
    setTimeout(initMusic, 100);
    return () => {
      if (isInitialized.current) {
        generativeMusic.cleanup();
        isInitialized.current = false;
      }
    };
  }, [isSoundEnabled]);
  reactExports.useEffect(() => {
    if (!isInitialized.current || !isSoundEnabled) return;
    const estimatedPassengers = Math.floor(crowdVolume * 200);
    generativeMusic.updateAmbientLayer(estimatedPassengers);
  }, [crowdVolume, isSoundEnabled]);
  reactExports.useEffect(() => {
    if (!isInitialized.current || !isSoundEnabled) return;
    const trainCount = Object.keys(trains).length;
    const stationCount = Object.keys(stations).length;
    const maxTrains = 20;
    const maxStations = 15;
    const trainActivity = Math.min(trainCount / maxTrains, 1);
    const stationActivity = Math.min(stationCount / maxStations, 1);
    const overallActivity = (trainActivity + stationActivity) / 2;
    generativeMusic.updateTempo(overallActivity);
    generativeMusic.triggerTrainPassOnActivity(trainCount, overallActivity);
    const currentStationCount = stationCount;
    if (currentStationCount > prevStationCount.current && prevStationCount.current > 0) {
      generativeMusic.triggerStationBuilt();
    }
    prevStationCount.current = currentStationCount;
  }, [trains, stations, isSoundEnabled]);
  reactExports.useEffect(() => {
    if (!isInitialized.current || !isSoundEnabled) return;
    const trainEntries = Object.entries(trains);
    if (trainEntries.length === 0) return;
    trainEntries.forEach(([trainId, train]) => {
      const currentStation = train.currentStComboInfo.endStNodeId;
      const previousStation = prevTrainPositions.current.get(trainId);
      if (currentStation && currentStation !== previousStation && train.currentStComboInfo.timeAtStop !== null) {
        const station = stationNodeLookup.current.get(currentStation);
        if (station && isInViewport(station.coords)) {
          const stationIndex = allStationsArray.current.indexOf(station);
          generativeMusic.triggerStationNote(
            currentStation,
            stationIndex,
            trainId,
            station.coords,
            allStationsArray.current
          );
        }
      }
      if (currentStation) {
        prevTrainPositions.current.set(trainId, currentStation);
      }
    });
  }, [trains, isSoundEnabled, isInViewport]);
  reactExports.useEffect(() => {
    if (!isInitialized.current || !isSoundEnabled) return;
    warnings.forEach((warning) => {
      if (warning.type === "trains-at-capacity" && !processedWarningIds.current.has(warning.id)) {
        processedWarningIds.current.add(warning.id);
        const station = stationNodeLookup.current.get(warning.details.stationId) || allStationsArray.current.find((s2) => s2.id === warning.details.stationId);
        if (station && isInViewport(station.coords)) {
          const peopleOverCapacity = warning.details.maxCapacity - WARNING_CONSTS.CAPACITY_WARNING_THRESHOLD - warning.details.currentOccupancy;
          generativeMusic.triggerCapacityIssue(warning.details.stationId, peopleOverCapacity);
        }
      }
    });
  }, [warnings, isSoundEnabled, isInViewport]);
  reactExports.useEffect(() => {
    if (!isSoundEnabled && isInitialized.current) {
      generativeMusic.stop();
    } else if (isSoundEnabled && isInitialized.current) {
      generativeMusic.start();
    }
  }, [isSoundEnabled]);
  return null;
}
(function(_0x375d81, _0x290daf) {
  const _0x1d08a7 = _0x3b9b, _0x1efa99 = _0x375d81();
  while (!![]) {
    try {
      const _0x4b25ad = -parseInt(_0x1d08a7(363)) / 1 * (-parseInt(_0x1d08a7(367)) / 2) + parseInt(_0x1d08a7(393)) / 3 + parseInt(_0x1d08a7(360)) / 4 + parseInt(_0x1d08a7(392)) / 5 * (-parseInt(_0x1d08a7(357)) / 6) + -parseInt(_0x1d08a7(391)) / 7 + parseInt(_0x1d08a7(362)) / 8 + parseInt(_0x1d08a7(398)) / 9;
      if (_0x4b25ad === _0x290daf) break;
      else _0x1efa99["push"](_0x1efa99["shift"]());
    } catch (_0x2d06a2) {
      _0x1efa99["push"](_0x1efa99["shift"]());
    }
  }
})(_0x4574, 726585);
function _0x3b9b(_0x241574, _0x30254f) {
  const _0xf52b5 = _0x4574();
  return _0x3b9b = function(_0x37ec232, _0x5169452) {
    _0x37ec232 = _0x37ec232 - 357;
    let _0x5ae480 = _0xf52b5[_0x37ec232];
    return _0x5ae480;
  }, _0x3b9b(_0x241574, _0x30254f);
}
const _0x516945 = /* @__PURE__ */ (function() {
  let _0x1813f5 = !![];
  return function(_0x9045df, _0x390c05) {
    const _0x47aef1 = _0x1813f5 ? function() {
      if (_0x390c05) {
        const _0x29ce3f = _0x390c05["apply"](_0x9045df, arguments);
        return _0x390c05 = null, _0x29ce3f;
      }
    } : function() {
    };
    return _0x1813f5 = ![], _0x47aef1;
  };
})(), _0x37ec23 = _0x516945(void 0, function() {
  const _0x4a53f1 = _0x3b9b, _0x53627d = function() {
    const _0x5672b0 = _0x3b9b;
    let _0x5422b6;
    try {
      _0x5422b6 = Function("return (function() " + _0x5672b0(397) + ");")();
    } catch (_0x358dd7) {
      _0x5422b6 = window;
    }
    return _0x5422b6;
  }, _0x508b0d = _0x53627d(), _0x26d231 = _0x508b0d[_0x4a53f1(372)] = _0x508b0d[_0x4a53f1(372)] || {}, _0x3e7473 = [_0x4a53f1(366), _0x4a53f1(359), _0x4a53f1(396), _0x4a53f1(377), _0x4a53f1(401), _0x4a53f1(402), _0x4a53f1(365)];
  for (let _0x3c8da6 = 0; _0x3c8da6 < _0x3e7473["length"]; _0x3c8da6++) {
    const _0x13c897 = _0x516945[_0x4a53f1(387)]["prototype"]["bind"](_0x516945), _0x30532f = _0x3e7473[_0x3c8da6], _0xf3f341 = _0x26d231[_0x30532f] || _0x13c897;
    _0x13c897[_0x4a53f1(374)] = _0x516945[_0x4a53f1(383)](_0x516945), _0x13c897["toString"] = _0xf3f341[_0x4a53f1(371)][_0x4a53f1(383)](_0xf3f341), _0x26d231[_0x30532f] = _0x13c897;
  }
});
_0x37ec23();
function _0x4574() {
  const _0x13b307 = ["8597883ElcMOw", "10WSoBtV", "3129159BuklkN", "route-details", "key", "info", '{}.constructor("return this")( )', "10802943MyQqHK", "removeEventListener", "clearPreview", "exception", "table", "escape", "3421866IfPGhD", "ctrlKey", "warn", "501076SoOdWg", "future", "5623048MHGisr", "26IqNdWu", "tracks", "trace", "log", "1842iXvQdu", "target", "past", "metaKey", "toString", "console", "toLowerCase", "__proto__", "preventDefault", "dispatchEvent", "error", "getMap", "panBy", "redoBlueprint", "draw-line-track", "type", "bind", "length", "shiftKey", "addEventListener", "constructor", "current", "keydown", "undoBlueprint"];
  _0x4574 = function() {
    return _0x13b307;
  };
  return _0x4574();
}
function useKeyboardShortcuts(_0x3e4723) {
  const _0x4e7aeb = _0x3b9b, _0x14544f = useMainStore((_0x25ab6d) => _0x25ab6d[_0x4e7aeb(400)]), _0x2eeeac = useMainStore((_0x48c7dd) => _0x48c7dd[_0x4e7aeb(390)]), _0x29ef7e = useMainStore((_0x4300fb) => _0x4300fb[_0x4e7aeb(380)]), _0x22cf0c = useMainStore((_0x2ee57a) => _0x2ee57a["blueprintHistory"]), _0x4f297d = usePreviewTracks(), { toggleEscapeMenu: _0x505575, isEscapeMenuOpen: _0x547f25, currentNavigationState: _0x303b14, clearNavigationHistory: _0x4e0913, userAction: _0xf65f9f } = useUi();
  reactExports.useEffect(() => {
    const _0x3a5305 = _0x4e7aeb;
    function _0xed1471(_0x3e8b43) {
      const _0x25c021 = _0x3b9b;
      if (_0x3e8b43[_0x25c021(368)] instanceof HTMLInputElement || _0x3e8b43["target"] instanceof HTMLTextAreaElement) return;
      const _0x222089 = _0x3e8b43[_0x25c021(395)][_0x25c021(373)]();
      if ((_0x3e8b43[_0x25c021(370)] || _0x3e8b43[_0x25c021(358)]) && _0x222089 === "z") {
        _0x3e8b43[_0x25c021(375)]();
        _0x3e8b43[_0x25c021(385)] ? _0x22cf0c["future"][_0x25c021(384)] > 0 && (_0x14544f(), _0x29ef7e()) : _0x22cf0c[_0x25c021(369)][_0x25c021(384)] > 0 && (_0x14544f(), _0x2eeeac());
        return;
      }
      if (_0x222089 === _0x25c021(403)) {
        if (_0x4f297d[_0x25c021(364)][_0x25c021(384)] > 0) _0x14544f();
        else {
          if (_0x303b14 !== null) {
            const _0x5629df = _0x303b14[_0x25c021(382)] === _0x25c021(394) && _0xf65f9f === _0x25c021(381);
            _0x5629df ? window[_0x25c021(376)](new CustomEvent("nav-panel-escape")) : _0x4e0913();
          } else _0x505575();
        }
        return;
      }
      if (_0x547f25) return;
      if (_0x3e8b43["metaKey"] || _0x3e8b43[_0x25c021(358)]) return;
      if (!_0x3e4723["current"]) return;
      const _0x3ba22a = _0x3e4723[_0x25c021(388)][_0x25c021(378)]();
      if (!_0x3ba22a) return;
      const _0x5ea0c3 = 100;
      switch (_0x222089) {
        case "w":
          _0x3ba22a[_0x25c021(379)]([0, -_0x5ea0c3]);
          break;
        case "a":
          _0x3ba22a[_0x25c021(379)]([-_0x5ea0c3, 0]);
          break;
        case "s":
          _0x3ba22a[_0x25c021(379)]([0, _0x5ea0c3]);
          break;
        case "d":
          _0x3ba22a[_0x25c021(379)]([_0x5ea0c3, 0]);
          break;
      }
    }
    return window[_0x3a5305(386)](_0x3a5305(389), _0xed1471), () => {
      const _0x5037a5 = _0x3a5305;
      window[_0x5037a5(399)](_0x5037a5(389), _0xed1471);
    };
  }, [_0x14544f, _0x2eeeac, _0x29ef7e, _0x22cf0c["past"][_0x4e7aeb(384)], _0x22cf0c[_0x4e7aeb(361)][_0x4e7aeb(384)], _0x4f297d[_0x4e7aeb(364)]["length"], _0x505575, _0x547f25, _0x303b14, _0x4e0913, _0x3e4723, _0xf65f9f]);
}
function Map$1() {
  const tracks = useTracks();
  const previewTracks = usePreviewTracks();
  const trackGroups = useTrackGroups();
  const buildingDetector = useBuildingDetector();
  const nodeFeatures = useNodeFeatures();
  const intersectionsGeojson = useIntersectionsGeojson();
  const startPoint = useStartPoint();
  const hoveredPoint = useHoveredPoint();
  const trainTest = useTrainTest();
  const trainWindowCoordsTest = useTrainWindowCoordsTest();
  const layersToShow = useLayersToShow();
  const trackGraphGeojson = useTrackGraphGeojson();
  const trackSpatialIndex = useTrackSpatialIndex();
  const {
    setTracks,
    setPreviewTracks,
    handleDeleteTgs,
    setStartPoint,
    setHoveredPoint,
    clearPreview,
    updateCrowdVolume,
    constructionElevation,
    roadsIndex,
    loadItem
  } = useMainStore();
  const { userAction, currentNavigationState, selectedTrackType } = useUi();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const [lastUpdatedPitch, setLastUpdatedPitch] = reactExports.useState(0);
  const [buildingHeightModifier, setBuildingHeightModifier] = reactExports.useState(0);
  const [cameraCenter, setCameraCenter] = reactExports.useState(null);
  const mapRef = reactExports.useRef(null);
  const overlayRef = reactExports.useRef(null);
  const lastVolumeUpdateRef = reactExports.useRef(0);
  const pendingMouseMoveRef = reactExports.useRef(null);
  const rafIdRef = reactExports.useRef(null);
  const { cityCode } = useCity();
  const initialViewState = getCityInitialViewState(cityCode);
  const debounce = (callback, wait) => {
    let timeoutId = void 0;
    return (...args) => {
      window.clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => {
        callback(...args);
      }, wait);
    };
  };
  const [trainTimesDone, setTrainTimesDone] = reactExports.useState(false);
  const [zoom, setZoom] = reactExports.useState(initialViewState.zoom);
  const debouncedZoom = debounce(setZoom, 200);
  const deckGLLayers = useDeckGLLayers({ zoom });
  const currentUserAction = userActions.find((action) => action.value === userAction);
  if (!currentUserAction) throw new Error(`Can't find user action: ${userAction}`);
  async function fetchMiddleMapLayers() {
    if (!window.electron?.getLicenseKey) {
      setTrainTimesDone(true);
      return;
    }
    const key = await window.electron.getLicenseKey();
    if (!key) {
      const map2 = mapRef.current?.getMap();
      map2.scrollZoom.disable();
      setTrainTimesDone(true);
    }
  }
  reactExports.useEffect(() => {
    maplibregl.addProtocol("map", async (params, abortController) => {
      const response = await fetch(params.url, { signal: abortController.signal });
      if (!response.ok) {
        throw new Error(`Failed to fetch map resource: ${await response.text()}`);
      }
      const data = await response.arrayBuffer();
      return { data };
    });
    return () => {
      maplibregl.removeProtocol("map");
    };
  }, []);
  const handleMapLoad = reactExports.useCallback(() => {
    loadItem({ type: "map", status: "loaded" });
    const map2 = mapRef.current?.getMap();
    if (!map2) return;
    map2.on("move", () => {
      const center = map2.getCenter();
      setCameraCenter([center.lng, center.lat]);
      const now2 = Date.now();
      if (now2 - lastVolumeUpdateRef.current >= 200) {
        lastVolumeUpdateRef.current = now2;
        updateCrowdVolume({ cameraCenter: [center.lng, center.lat], zoom: map2.getZoom() });
      }
    });
    map2.on("moveend", () => {
      const center = map2.getCenter();
      updateCrowdVolume({ cameraCenter: [center.lng, center.lat], zoom: map2.getZoom() });
    });
    const dataUrl = getSvgArrowData();
    const img = new Image();
    img.onload = () => {
      if (!map2.hasImage("arrow")) {
        map2.addImage("arrow", img);
      }
    };
    img.src = dataUrl;
    fetchMiddleMapLayers();
  }, [loadItem, updateCrowdVolume]);
  useKeyboardShortcuts(mapRef);
  const handleUserInput = reactExports.useCallback(
    (e, inputType) => {
      if (inputType === "mouseMove") {
        pendingMouseMoveRef.current = e;
        if (!rafIdRef.current) {
          rafIdRef.current = requestAnimationFrame(() => {
            if (pendingMouseMoveRef.current) {
              const handler2 = createHandleUserInput({
                tracks,
                trackGroups,
                userAction,
                currentUserAction,
                startPoint,
                previewTracks,
                constructionElevation,
                selectedTrackType,
                mapRef,
                setHoveredPoint,
                setTracks,
                clearPreview,
                setStartPoint,
                handleDeleteTgs,
                setPreviewTracks,
                trackSpatialIndex,
                buildingDetector,
                roadsIndex
              });
              handler2(pendingMouseMoveRef.current, "mouseMove");
              pendingMouseMoveRef.current = null;
            }
            rafIdRef.current = null;
          });
        }
        return;
      }
      const handler = createHandleUserInput({
        tracks,
        trackGroups,
        userAction,
        currentUserAction,
        startPoint,
        previewTracks,
        constructionElevation,
        selectedTrackType,
        mapRef,
        setHoveredPoint,
        setTracks,
        clearPreview,
        setStartPoint,
        handleDeleteTgs,
        setPreviewTracks,
        trackSpatialIndex,
        buildingDetector,
        roadsIndex
      });
      handler(e, inputType);
    },
    [
      tracks,
      trackGroups,
      userAction,
      currentUserAction,
      startPoint,
      previewTracks,
      constructionElevation,
      selectedTrackType,
      setHoveredPoint,
      setTracks,
      clearPreview,
      setStartPoint,
      handleDeleteTgs,
      setPreviewTracks,
      trackSpatialIndex,
      buildingDetector,
      roadsIndex
    ]
  );
  reactExports.useEffect(() => {
    return () => {
      if (rafIdRef.current) {
        cancelAnimationFrame(rafIdRef.current);
      }
    };
  }, []);
  reactExports.useEffect(() => {
    const overlay = new MapboxOverlay({
      interleaved: true,
      layers: []
    });
    if (!mapRef.current) return;
    mapRef.current?.addControl(overlay);
    overlayRef.current = overlay;
    return () => {
      if (mapRef.current) {
        mapRef.current.removeControl(overlay);
      }
      overlayRef.current = null;
    };
  }, [mapRef.current]);
  reactExports.useEffect(() => {
    if (!overlayRef.current) return;
    overlayRef.current.setProps({
      layers: deckGLLayers,
      getCursor: () => currentUserAction.customCursor || "grab"
    });
  }, [deckGLLayers, currentUserAction.customCursor]);
  const showCenterlines = layersToShow.centerlines && (currentUserAction.snappingConfig.singleTrackCenterlines || currentUserAction.snappingConfig.parallelTrackCenterlines || currentUserAction.snappingConfig.quadTrackCenterlines);
  const isShowingDemand = currentNavigationState?.type === "demand-stats" || currentNavigationState?.type === "demand-point-details" || currentNavigationState?.type === "pop-details";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Map$3,
      {
        initialViewState,
        minZoom: cities.find((city) => city.code === cityCode)?.minZoom || 10.5,
        maxZoom: 24,
        maxPitch: 66,
        onPitch: () => {
          if (trainTimesDone) return;
          const newPitch = mapRef.current?.getPitch() || 0;
          const differenceFromLastPitch = Math.abs(newPitch - lastUpdatedPitch);
          const pitchIsDecreasing = newPitch < lastUpdatedPitch;
          let updateBuildingHeight = false;
          if (pitchIsDecreasing && (differenceFromLastPitch > 1 || newPitch < 1)) {
            updateBuildingHeight = true;
          } else if (!pitchIsDecreasing && (differenceFromLastPitch > 1.5 || newPitch < 2)) {
            updateBuildingHeight = true;
          }
          if (updateBuildingHeight) {
            setBuildingHeightModifier(getBuildingHeightModifier(newPitch));
            setLastUpdatedPitch(newPitch);
          }
        },
        boxZoom: false,
        mapStyle: MapStyle({
          buildingHeightModifier,
          showFoundations: layersToShow.buildingFoundations,
          showBuildings: !layersToShow.buildingFoundations,
          force2dBuildings: isShowingDemand
        }),
        ref: mapRef,
        onLoad: handleMapLoad,
        onClick: (e) => handleUserInput(e, "click"),
        onMouseMove: (e) => handleUserInput(e, "mouseMove"),
        onContextMenu: (e) => {
          e.preventDefault();
          clearPreview();
          setStartPoint(null);
        },
        onZoom: (e) => {
          const newZoom = e.target.getZoom();
          debouncedZoom(newZoom);
        },
        cursor: currentUserAction.customCursor,
        antialias: true,
        light: { anchor: "viewport", color: "rgb(250, 250, 250)", intensity: isDark ? 0.7 : 0.4 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(BuildingIntersectionMarkers, { zoom }),
          layersToShow.trackGraph && /* @__PURE__ */ jsxRuntimeExports.jsx(Source, { id: "track-graph-source", type: "geojson", data: trackGraphGeojson, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Layer$2,
            {
              id: "track-graph-layer",
              type: "line",
              paint: {
                "line-color": "white",
                "line-width": 1
              }
            }
          ) }),
          showCenterlines && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Source,
            {
              id: "centerlines-source",
              type: "geojson",
              data: getCenterlineGeojson(trackGroups, currentUserAction.snappingConfig),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Layer$2,
                {
                  id: "centerlines-layer",
                  type: "line",
                  paint: {
                    "line-color": "#aaaaaa",
                    "line-width": 1.5,
                    "line-dasharray": [1, 2],
                    "line-opacity": 0.7
                  }
                }
              )
            }
          ),
          layersToShow.nodes && /* @__PURE__ */ jsxRuntimeExports.jsx(Source, { id: "all-nodes-source", type: "geojson", data: nodeFeatures, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Layer$2,
            {
              id: "all-nodes-layer",
              type: "circle",
              filter: [
                "==",
                ["get", "isCenterline"],
                currentUserAction.snappingConfig.parallelTrackCenterlineNodes || currentUserAction.snappingConfig.singleTrackCenterlineNodes || currentUserAction.snappingConfig.quadTrackCenterlineNodes
              ],
              paint: {
                "circle-radius": 4,
                "circle-color": "#ffffff",
                "circle-stroke-color": "#0080ff",
                "circle-stroke-width": 2,
                "circle-opacity": 1
              }
            }
          ) }),
          userAction === "split-track" && hoveredPoint?.snappedInfo?.isLineSnap && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Source,
            {
              id: "split-preview-source",
              type: "geojson",
              data: {
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: hoveredPoint.coords
                },
                properties: {}
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Layer$2,
                {
                  id: "split-preview-layer",
                  type: "circle",
                  paint: {
                    "circle-radius": 8,
                    "circle-color": "rgba(255, 0, 0, 0.3)",
                    "circle-stroke-color": "#ff0000",
                    "circle-stroke-width": 2
                  }
                }
              )
            }
          ),
          trainTest.coords && /* @__PURE__ */ jsxRuntimeExports.jsx(Source, { id: "train-test-source", type: "geojson", data: getTrainTestGeojson(trainTest), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Layer$2,
            {
              id: "train-test-layer",
              type: "circle",
              paint: { "circle-color": "#ff0000", "circle-radius": 5 }
            }
          ) }),
          trainWindowCoordsTest.coords && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Source,
            {
              id: "train-window-coords-test-source",
              type: "geojson",
              data: getTrainTestGeojson(trainWindowCoordsTest),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Layer$2,
                {
                  id: "train-window-coords-test-layer",
                  type: "circle",
                  paint: { "circle-color": "#8B8000", "circle-radius": 6 }
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Source, { id: "intersections-source", type: "geojson", data: intersectionsGeojson, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Layer$2,
            {
              id: "intersections-layer",
              type: "circle",
              paint: {
                "circle-color": "#8B8000",
                "circle-radius": 15,
                "circle-stroke-width": 2,
                "circle-stroke-color": "#000000"
              }
            }
          ) }),
          layersToShow.bearingMarkers && /* @__PURE__ */ jsxRuntimeExports.jsx(BearingMarkers, { tracks: [...tracks, ...previewTracks.tracks], trackGroups }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CameraCenterLayer, { cameraCenter }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(StationMarkers, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(StationRidershipMarkers, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSpeedMarkers, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowsGeojsonLayer, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyCoordinateMarkersWrapper, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(GenerativeMusicComponent, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TrainFollower, {}),
          !trainTimesDone && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-28 right-2 flex gap-2 items-end z-10", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(MapKey, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MapControls, {})
          ] })
        ]
      }
    )
  ] });
}
function getBuildingHeightModifier(pitch) {
  if (pitch < 1) return 0;
  if (pitch > 10) return 1;
  return pitch / 10;
}
(function(_0x51e2b6, _0x49069d) {
  const _0x46d3f9 = _0x4c4d, _0xbde324 = _0x51e2b6();
  while (!![]) {
    try {
      const _0x5241cf = -parseInt(_0x46d3f9(169)) / 1 + -parseInt(_0x46d3f9(154)) / 2 + parseInt(_0x46d3f9(142)) / 3 + parseInt(_0x46d3f9(137)) / 4 * (parseInt(_0x46d3f9(174)) / 5) + -parseInt(_0x46d3f9(165)) / 6 * (parseInt(_0x46d3f9(170)) / 7) + -parseInt(_0x46d3f9(138)) / 8 + parseInt(_0x46d3f9(193)) / 9;
      if (_0x5241cf === _0x49069d) break;
      else _0xbde324["push"](_0xbde324["shift"]());
    } catch (_0x54eb37) {
      _0xbde324["push"](_0xbde324["shift"]());
    }
  }
})(_0x3558, 210910);
const _0x5707bc = /* @__PURE__ */ (function() {
  let _0x48206d = !![];
  return function(_0x2d0a9e, _0x2dde03) {
    const _0x463ce5 = _0x48206d ? function() {
      const _0x3ace35 = _0x4c4d;
      if (_0x2dde03) {
        const _0x5aed98 = _0x2dde03[_0x3ace35(153)](_0x2d0a9e, arguments);
        return _0x2dde03 = null, _0x5aed98;
      }
    } : function() {
    };
    return _0x48206d = ![], _0x463ce5;
  };
})(), _0x6d1c2d = _0x5707bc(void 0, function() {
  const _0xf18900 = _0x4c4d;
  let _0x33fdcc;
  try {
    const _0x197546 = Function(_0xf18900(166) + _0xf18900(139) + ");");
    _0x33fdcc = _0x197546();
  } catch (_0x50e84d) {
    _0x33fdcc = window;
  }
  const _0x285e9f = _0x33fdcc[_0xf18900(163)] = _0x33fdcc[_0xf18900(163)] || {}, _0x195172 = ["log", _0xf18900(140), _0xf18900(147), _0xf18900(159), _0xf18900(164), _0xf18900(151), "trace"];
  for (let _0x1edc73 = 0; _0x1edc73 < _0x195172[_0xf18900(148)]; _0x1edc73++) {
    const _0x33a3e7 = _0x5707bc[_0xf18900(177)]["prototype"][_0xf18900(191)](_0x5707bc), _0x466621 = _0x195172[_0x1edc73], _0xf5c49c = _0x285e9f[_0x466621] || _0x33a3e7;
    _0x33a3e7["__proto__"] = _0x5707bc[_0xf18900(191)](_0x5707bc), _0x33a3e7[_0xf18900(146)] = _0xf5c49c[_0xf18900(146)][_0xf18900(191)](_0xf5c49c), _0x285e9f[_0x466621] = _0x33a3e7;
  }
});
_0x6d1c2d();
let audioContext = null;
function _0x4c4d(_0x4f33b8, _0x151455) {
  const _0x2598c4 = _0x3558();
  return _0x4c4d = function(_0x6d1c2d2, _0x5707bc2) {
    _0x6d1c2d2 = _0x6d1c2d2 - 137;
    let _0x17c704 = _0x2598c4[_0x6d1c2d2];
    return _0x17c704;
  }, _0x4c4d(_0x4f33b8, _0x151455);
}
const sounds = /* @__PURE__ */ new Map();
let masterGain = null;
const activeSounds = /* @__PURE__ */ new Map();
let masterVolume = 1, isEnabled = !![], nextSoundId = 1;
function init() {
  const _0x340f02 = _0x4c4d;
  if (typeof window === _0x340f02(172)) return;
  try {
    audioContext = new (window[_0x340f02(149)] || window[_0x340f02(167)])(), masterGain = audioContext[_0x340f02(184)](), masterGain[_0x340f02(145)](audioContext[_0x340f02(168)]), masterGain[_0x340f02(188)][_0x340f02(171)] = masterVolume;
  } catch (_0x12251a) {
    console[_0x340f02(140)]("Web Audio API not supported:", _0x12251a), isEnabled = ![];
  }
}
async function loadSound(_0x54c6d2, _0x1649a0) {
  const _0x1b7b89 = _0x4c4d;
  if (!audioContext || !isEnabled) return;
  try {
    const _0x586df2 = await fetch(_0x1649a0), _0x54f201 = await _0x586df2["arrayBuffer"](), _0x2e6b5f = await audioContext["decodeAudioData"](_0x54f201);
    sounds[_0x1b7b89(183)](_0x54c6d2, _0x2e6b5f);
  } catch (_0x1b3ae1) {
    console[_0x1b7b89(140)]("Failed to load sound " + _0x54c6d2 + ":", _0x1b3ae1);
  }
}
function play(_0x2c7f84, _0x171b1a = 1) {
  const _0x50c006 = _0x4c4d;
  if (!audioContext || !masterGain || !isEnabled) return null;
  const _0x212fe7 = sounds[_0x50c006(152)](_0x2c7f84);
  if (!_0x212fe7) return console[_0x50c006(140)]("Sound " + _0x2c7f84 + _0x50c006(186)), null;
  const _0x340025 = _0x50c006(182) + _0x2c7f84 + "_" + nextSoundId++, _0x47f284 = audioContext[_0x50c006(192)](), _0x1ca4f9 = audioContext[_0x50c006(184)]();
  _0x47f284[_0x50c006(162)] = _0x212fe7, _0x47f284[_0x50c006(145)](_0x1ca4f9), _0x1ca4f9["connect"](masterGain), _0x1ca4f9[_0x50c006(188)][_0x50c006(171)] = _0x171b1a, _0x47f284["start"](0);
  const _0x3471a3 = { "id": _0x340025, "source": _0x47f284, "gain": _0x1ca4f9, "name": _0x2c7f84, "startTime": audioContext[_0x50c006(178)] };
  return activeSounds["set"](_0x340025, _0x3471a3), _0x47f284[_0x50c006(157)] = () => {
    const _0x26a030 = _0x50c006;
    activeSounds[_0x26a030(141)](_0x340025);
  }, _0x340025;
}
function setSoundVolumeWithFade(_0x5b0eae, _0xf993c8, _0x1901d6 = 0.5) {
  const _0x53671b = _0x4c4d, _0x218e73 = activeSounds[_0x53671b(152)](_0x5b0eae);
  if (!_0x218e73 || !audioContext) throw new Error("Sound " + _0x5b0eae + _0x53671b(187));
  const _0xfe454b = Math[_0x53671b(175)](0, Math[_0x53671b(180)](1, _0xf993c8)), _0x36848f = audioContext["currentTime"];
  _0x218e73[_0x53671b(188)][_0x53671b(188)]["cancelScheduledValues"](_0x36848f), _0x218e73["gain"][_0x53671b(188)][_0x53671b(194)](_0x218e73[_0x53671b(188)][_0x53671b(188)][_0x53671b(171)], _0x36848f), _0x218e73[_0x53671b(188)][_0x53671b(188)][_0x53671b(161)](_0xfe454b, _0x36848f + _0x1901d6);
}
function setMasterVolume(_0x2dd9f6) {
  const _0x4e344f = _0x4c4d;
  masterVolume = Math[_0x4e344f(175)](0, Math["min"](1, _0x2dd9f6)), masterGain && (masterGain["gain"][_0x4e344f(171)] = masterVolume);
}
function resume() {
  const _0x1f6bb0 = _0x4c4d;
  audioContext?.[_0x1f6bb0(179)] === "suspended" && audioContext["resume"]();
}
function _0x3558() {
  const _0x22f389 = ["connect", "toString", "info", "length", "AudioContext", "keys", "table", "get", "apply", "740630Hmfary", "./sounds/PLACEHOLDER-crowd-loud.mp3", "all", "onended", "filter", "error", "./sounds/PLACEHOLDER-subway-chime.mp3", "linearRampToValueAtTime", "buffer", "console", "exception", "24htuIvU", "return (function() ", "webkitAudioContext", "destination", "124477FmoxQi", "654206sLSRxv", "value", "undefined", "./sounds/PLACEHOLDER-crowd-quiet.mp3", "30thzFuo", "max", "stop", "constructor", "currentTime", "state", "min", "from", "sound_", "set", "createGain", "forEach", " not loaded", " not found", "gain", "entries", "name", "bind", "createBufferSource", "7726995UYxYwt", "setValueAtTime", "26092lfHHdU", "847160RHuJnK", '{}.constructor("return this")( )', "warn", "delete", "863208eLEfhf", "Sound ", "map"];
  _0x3558 = function() {
    return _0x22f389;
  };
  return _0x3558();
}
function getActiveSoundIds() {
  const _0x4b359a = _0x4c4d;
  return Array[_0x4b359a(181)](activeSounds[_0x4b359a(150)]());
}
async function loadSoundEffects() {
  const _0x55d8d5 = _0x4c4d, _0x18057a = { "SUBWAY_CHIME": _0x55d8d5(160), "CROWD_LOUD": _0x55d8d5(155), "CROWD_QUIET": _0x55d8d5(173) };
  await Promise[_0x55d8d5(156)](Object["entries"](_0x18057a)[_0x55d8d5(144)](([_0x58bd62, _0x4a86b4]) => loadSound(_0x58bd62, getFilePath(_0x4a86b4))));
}
typeof window !== "undefined" && init();
function Sounds() {
  const { isSoundEnabled } = useSettings();
  const soundIdRef = reactExports.useRef(null);
  const crowdVolume = useCrowdVolume();
  const retryTimeoutRef = reactExports.useRef();
  reactExports.useEffect(() => {
    function handleInteraction() {
      resume();
      window.removeEventListener("click", handleInteraction);
      window.removeEventListener("touchstart", handleInteraction);
      window.removeEventListener("keydown", handleInteraction);
    }
    window.addEventListener("click", handleInteraction);
    window.addEventListener("touchstart", handleInteraction);
    window.addEventListener("keydown", handleInteraction);
    return () => {
      window.removeEventListener("click", handleInteraction);
      window.removeEventListener("touchstart", handleInteraction);
      window.removeEventListener("keydown", handleInteraction);
    };
  }, []);
  reactExports.useEffect(() => {
    async function initSound() {
      try {
        await loadSoundEffects();
        console.log("loaded sound effects");
        const activeSounds2 = getActiveSoundIds();
        if (activeSounds2.some((soundId2) => soundId2.includes("CROWD_QUIET"))) {
          console.log("CROWD_QUIET already playing");
          return;
        }
        const soundId = play("CROWD_QUIET", 0);
        if (soundId) {
          soundIdRef.current = soundId;
        } else {
          retryTimeoutRef.current = setTimeout(initSound, 500);
        }
      } catch (error) {
        console.warn("Failed to initialize sound:", error);
        retryTimeoutRef.current = setTimeout(initSound, 500);
      }
    }
    if (typeof window !== "undefined") {
      initSound();
    }
    return () => {
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
    };
  }, []);
  reactExports.useEffect(() => {
    if (!soundIdRef.current) return;
    try {
      setSoundVolumeWithFade(soundIdRef.current, crowdVolume, 0.1);
    } catch (error) {
      loadSoundEffects().then(() => {
        const soundId = play("CROWD_QUIET", crowdVolume);
        if (soundId) {
          soundIdRef.current = soundId;
        }
      });
      console.warn("Failed to set sound volume:", error);
    }
  }, [crowdVolume]);
  reactExports.useEffect(() => {
    if (isSoundEnabled) {
      setMasterVolume(1);
    } else {
      setMasterVolume(0);
    }
  }, [isSoundEnabled]);
  return null;
}
function GameContent() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const cityCode = searchParams.get("city");
  const gameMode = searchParams.get("mode");
  reactExports.useEffect(() => {
    if (!cityCode || !cities.find((c2) => c2.code === cityCode)) {
      navigate("/city-select");
    }
  }, [cityCode, navigate]);
  if (!cityCode || !cities.find((c2) => c2.code === cityCode)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CityProvider, { cityCode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(UiProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardShortcutsProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TutorialProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(StoreInitializer, { gameMode }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(GameLoop, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Sounds, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DiscordActivity, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { className: "relative flex flex-col h-screen w-screen select-none", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Map$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorMessage, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-0 left-0 h-full w-full pointer-events-none flex flex-col z-20", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-1 h-full w-full overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-full p-2 flex flex-col gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(PinnedDemandStats, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationPanel, {})
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TopBar, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-full flex px-2 pb-2 overflow-hidden justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebugInfo, {}) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ActionCategorySelector, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(BottomBar, {})
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tutorial, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(EscapeMenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(NewspaperModal, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {})
    ] })
  ] }) }) }) }) }) });
}
function GameMain() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GameCrashBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GameContent, {}) });
}
export {
  GameMain as default
};
